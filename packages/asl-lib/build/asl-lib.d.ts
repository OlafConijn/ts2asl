declare module '@ts2asl/asl-lib/asl' {

export type While = {
  condition: () => boolean;
  block: Function;
  name?: string;
};
export interface Foreach<T> {
  items: T[] | undefined | (() => T[]);
  iterator: <U>(item: T, objectContext: StateMachineContext<U>) => void;
  comment?: string;
  name?: string;
}
export type DoWhile = {
  condition: () => boolean;
  block: Function;
  name?: string;
};
export type If = {
  condition: boolean | (() => boolean);
  then: Function;
  else?: Function;
  comment?: string;
  name?: string;
};

export interface Succeed {
  comment?: string;
  name?: string;
}
export interface Try {
  try: Function;
  catch?: CatchConfiguration;
  finally?: Function;
  comment?: string;
  name?: string;
}
export interface Switch<T> {
  expression: () => T;
  cases: ({} | {
      label: T;
      block: Function
  })[]        
  comment?: string;
  name?: string;
}

export  const typescriptSwitch: <T>(args: Switch<T>) => Promise<void>;
export  const typescriptTry: (args: Try) => Promise<void>;
export  const typescriptDoWhile: (args: DoWhile) => Promise<void>;
export  const typescriptWhile: (args: While) => Promise<void>;
export  const typescriptForeach: <T>(args: Foreach<T>) => Promise<void>;
export  const typescriptIf: (args: If) => Promise<void>;

}// Generated by dts-bundle v0.7.3

declare module '@ts2asl/asl-lib' {
    export type ClientConfig = {
        region: string;
    };
    export * from "@ts2asl/asl-lib/asl";
    export * from "@ts2asl/asl-lib/sdk";
    export * from "@ts2asl/asl-lib/deploy";
    export * from "@ts2asl/asl-lib/runtime";
    export * from "@ts2asl/asl-lib/optimized";
    export * from "@ts2asl/asl-lib/testing";
    export const clientConfig: ClientConfig;
}

declare module '@ts2asl/asl-lib/asl' {
    export type AslError = {
        Cause: string;
        Error: string;
    };
    export type CatchConfiguration = Array<{
        errorEquals: string[];
        block: (error?: AslError) => unknown;
    }>;
    export type RetryConfiguration = Array<{
        errorEquals: string[];
        intervalSeconds?: number;
        maxAttempts?: number;
        backoffRate?: number;
    }>;
    export interface Wait {
        seconds?: number | (() => number);
        timestamp?: string | (() => string);
        comment?: string;
        name?: string;
    }
    export interface Try {
        try: Function;
        catch?: CatchConfiguration;
        finally?: Function;
        comment?: string;
        name?: string;
    }
    export interface Task {
        name?: string;
        resource: string;
        parameters?: unknown | (() => unknown) | (<U>(objectContext: StateMachineContext<U>) => unknown);
        catch?: CatchConfiguration;
        retry?: RetryConfiguration;
        timeoutSeconds?: number;
        heartbeatSeconds?: number;
    }
    export interface SdkIntegrationTask<TInput> {
        name?: string;
        parameters: TInput;
        catch?: CatchConfiguration;
        retry?: RetryConfiguration;
        timeoutSeconds?: number;
        heartbeatSeconds?: number;
    }
    export interface Pass<T> {
        parameters: T | (() => T) | (<U>(objectContext: StateMachineContext<U>) => T);
        comment?: string;
        name?: string;
    }
    export interface Fail {
        error?: string;
        cause?: string;
        comment?: string;
        name?: string;
    }
    export interface Map<T, O> {
        parameters?: unknown | (() => unknown) | (<U>(objectContext: StateMachineContext<U>) => unknown);
        items: T[] | undefined | (() => T[]);
        iterator: <U>(item: T, objectContext: StateMachineContext<U>) => O;
        maxConcurrency?: number;
        comment?: string;
        name?: string;
    }
    export interface Succeed {
        comment?: string;
        name?: string;
    }
    export interface Parallel<T> {
        branches: (() => void | {})[];
        catch?: CatchConfiguration;
        retry?: RetryConfiguration;
        comment?: string;
        name?: string;
    }
    export type TypescriptInvoke<P, R> = {
        catch?: CatchConfiguration;
        retry?: RetryConfiguration;
        timeoutSeconds?: number;
        heartbeatSeconds?: number;
        comment?: string;
        name?: string;
    } & ({
        resource: ((parameters: P) => Promise<R>) | ((parameters: P) => R);
        parameters: P | (() => P);
    } | {
        resource: () => (R | Promise<R>);
    });
    export interface Choice {
        choices: Array<{
            condition: () => boolean;
            block: Function;
        }>;
        default?: Function;
        comment?: string;
        name?: string;
    }
    export interface StateMachineContext<TInput> {
        readonly execution: {
            readonly id: string;
            readonly input: TInput;
            readonly name: string;
            readonly roleArn: string;
            readonly startTime: string;
        };
        readonly stateMachine: {
            readonly id: string;
            readonly name: string;
        };
        readonly state: {
            readonly name: string;
            readonly enteredTime: string;
        };
        readonly task: {
            readonly name: string;
            readonly token?: string;
        };
    }
    export const typescriptInvoke: <P, R>(args: TypescriptInvoke<P, R>) => Promise<R>;
    export const task: <TResult>(args: Task) => Promise<TResult>;
    export const wait: (args: Wait) => Promise<void>;
    export const parallel: <Item>(args: Parallel<Item>) => Promise<unknown[]>;
    export const choice: (args: Choice) => Promise<void>;
    export const map: <Input, Output>(args: Map<Input, Output>) => Promise<Output[]>;
    export const pass: <T>(args: Pass<T>) => T;
    export const succeed: (x: Succeed) => {};
    export const fail: (x: Fail) => never;
    export const jsonPathLength: <T>(items: T[]) => number;
    export const jsonPathFilter: <T>(items: T[], predicate: (x: T) => boolean) => T[];
    export const jsonPathSlice: <T>(items: T[], start: number, end?: number, step?: number) => T[];
    export const jsonPathExpression: (items: unknown, expression: string) => unknown;
    export const jsonPathMap: (items: unknown[], expression: string) => unknown[];
    export namespace convert {
        function booleanToString(arg: boolean | undefined): string;
        function numberToString(arg: number | undefined): string;
        function stringToBoolean(arg: string | undefined): boolean;
        function stringToNumber(arg: string | undefined): number;
    }
    export namespace states {
        function format(format: string, ...args: unknown[]): string;
        function stringToJson(arg: string | undefined): unknown;
        function jsonToString(arg: unknown): string;
        function array(...args: unknown[]): unknown[];
    }
}

declare module '@ts2asl/asl-lib/sdk' {
    import { CatchConfiguration, RetryConfiguration } from '@ts2asl/asl-lib/asl';
    type ClassType<T> = {
        prototype: T;
    };
    type SdkIntegration<T> = {
        parameters: T;
        name?: string;
        catch?: CatchConfiguration;
        retry?: RetryConfiguration;
        timeoutSeconds?: number;
        heartbeatSeconds?: number;
    };
    type SdkIntegrationClient<T> = {
        [K in keyof T]: T[K] extends (input: infer Input, options: any, cb: (err: any, data?: infer TOutput) => void) => Promise<infer _X> ? (input: SdkIntegration<Input>) => Promise<TOutput> : never;
    };
    export const sdk: <TClient>(client: ClassType<TClient> & (new (config: {}) => TClient)) => SdkIntegrationClient<TClient>;
    export {};
}

declare module '@ts2asl/asl-lib/deploy' {
    export namespace deploy {
        const asStateMachine: <T>(fn: T) => T;
        const asLambda: <T>(fn: T) => T;
        const getParameter: (parameterName: string) => string;
        const setParameter: (parameterName: string, value: string) => void;
        const getLambdaName: (functionName: string | Function) => string;
        const getLambdaArn: (functionName: string | Function) => string;
        const getStateMachineName: (functionName: string | Function) => string;
        const getStateMachineArn: (functionName: string | Function) => string;
        const evalConst: <T>(identifier: T) => T;
    }
}

declare module '@ts2asl/asl-lib/runtime' {
    import { AslError } from "@ts2asl/asl-lib/asl";
    export namespace runtime {
        const createError: (error: string, cause: string) => AslError & Error & {
            name: string;
        };
    }
}

declare module '@ts2asl/asl-lib/optimized' {
    import { CatchConfiguration, RetryConfiguration } from "@ts2asl/asl-lib/asl";
    export namespace optimized {
        const apiGatewayInvoke: (_input: OptimizedIntegration<ApiGatewayInvokeInput, IntegrationType>) => Promise<ApiGatewayInvokeOutput>;
        const lambdaInvoke: (_input: OptimizedIntegration<LambdaInvokeInput, IntegrationType>) => Promise<LambdaInvokeOutput>;
        const snsPublish: (_input: OptimizedIntegration<SNSPublishInput, IntegrationType>) => Promise<SNSPublishOutput>;
        const sqsSend: (_input: OptimizedIntegration<SQSSendInput, IntegrationType>) => Promise<SQSSendOutput>;
    }
    interface ApiGatewayInvokeInput {
        ApiEndpoint: string;
        Method: "GET" | "POST" | "PUT" | "DELETE" | "PATCH" | "HEAD" | "OPTION";
        Headers?: Record<string, string>;
        QueryParameters?: Record<string, string>;
        RequestBody?: {} | string;
        Stage?: string;
        Path?: string;
        AllowNullValues?: boolean;
        AuthType?: "NO_AUTH" | "IAM_ROLE" | "RESOURCE_POLICY";
    }
    interface ApiGatewayInvokeOutput {
        ResponseBody: {};
        Headers: Record<string, string>;
        StatusCode: number;
        StatusText: string;
    }
    interface LambdaInvokeInput {
        ClientContext?: string;
        FunctionName: string;
        InvocationType?: "Event" | "RequestResponse" | "DryRun";
        Qualifier?: string;
        Payload?: Record<string, unknown>;
    }
    interface LambdaInvokeOutput {
        ExecutedVersion: string;
        Payload: string;
        SdkHttpMetadata: {
            HttpHeaders: Record<string, string>;
            HttpStatusCode: number;
        };
        SdkResponseMetadata: {
            RequestId: string;
        };
        StatusCode: number;
    }
    interface SNSPublishInput {
        Message?: string;
        MessageAttributes?: Record<string, string>;
        MessageStructure?: string;
        PhoneNumber?: string;
        Subject?: string;
        TargetArn?: string;
        TopicArn?: string;
    }
    interface SNSPublishOutput {
        MessageId: string;
        SequenceNumber: string;
    }
    interface SQSSendInput {
        DelaySeconds?: number;
        MessageAttribute?: Record<string, string>;
        MessageBody: string;
        MessageDeduplicationId?: string;
        MessageGroupId?: string;
        QueueUrl?: string;
    }
    interface SQSSendOutput {
        MessageId: string;
        SequenceNumber: string;
    }
    type OptimizedIntegration<T, TInvocationType> = {
        parameters: T;
        integrationType?: TInvocationType;
        name?: string;
        catch?: CatchConfiguration;
        retry?: RetryConfiguration;
        timeoutSeconds?: number;
        heartbeatSeconds?: number;
    };
    type IntegrationType = "RequestResponse" | "WaitForTaskToken";
    export {};
}

declare module '@ts2asl/asl-lib/testing' {
    import { StateMachineContext } from "@ts2asl/asl-lib/asl";
    export namespace testing {
        const createTestContext: <TInput>(input: TInput, context?: Partial<StateMachineContext<TInput>>) => StateMachineContext<TInput>;
    }
}

