// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/smithy-client
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http

declare module '@aws-sdk/client-ivs' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { BatchGetChannelCommandInput, BatchGetChannelCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/BatchGetChannelCommand";
    import { BatchGetStreamKeyCommandInput, BatchGetStreamKeyCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/BatchGetStreamKeyCommand";
    import { CreateChannelCommandInput, CreateChannelCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/CreateChannelCommand";
    import { CreateRecordingConfigurationCommandInput, CreateRecordingConfigurationCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/CreateRecordingConfigurationCommand";
    import { CreateStreamKeyCommandInput, CreateStreamKeyCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/CreateStreamKeyCommand";
    import { DeleteChannelCommandInput, DeleteChannelCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/DeleteChannelCommand";
    import { DeletePlaybackKeyPairCommandInput, DeletePlaybackKeyPairCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/DeletePlaybackKeyPairCommand";
    import { DeleteRecordingConfigurationCommandInput, DeleteRecordingConfigurationCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/DeleteRecordingConfigurationCommand";
    import { DeleteStreamKeyCommandInput, DeleteStreamKeyCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/DeleteStreamKeyCommand";
    import { GetChannelCommandInput, GetChannelCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/GetChannelCommand";
    import { GetPlaybackKeyPairCommandInput, GetPlaybackKeyPairCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/GetPlaybackKeyPairCommand";
    import { GetRecordingConfigurationCommandInput, GetRecordingConfigurationCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/GetRecordingConfigurationCommand";
    import { GetStreamCommandInput, GetStreamCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/GetStreamCommand";
    import { GetStreamKeyCommandInput, GetStreamKeyCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/GetStreamKeyCommand";
    import { GetStreamSessionCommandInput, GetStreamSessionCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/GetStreamSessionCommand";
    import { ImportPlaybackKeyPairCommandInput, ImportPlaybackKeyPairCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ImportPlaybackKeyPairCommand";
    import { ListChannelsCommandInput, ListChannelsCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ListChannelsCommand";
    import { ListPlaybackKeyPairsCommandInput, ListPlaybackKeyPairsCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ListPlaybackKeyPairsCommand";
    import { ListRecordingConfigurationsCommandInput, ListRecordingConfigurationsCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ListRecordingConfigurationsCommand";
    import { ListStreamKeysCommandInput, ListStreamKeysCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ListStreamKeysCommand";
    import { ListStreamsCommandInput, ListStreamsCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ListStreamsCommand";
    import { ListStreamSessionsCommandInput, ListStreamSessionsCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ListStreamSessionsCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ListTagsForResourceCommand";
    import { PutMetadataCommandInput, PutMetadataCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/PutMetadataCommand";
    import { StopStreamCommandInput, StopStreamCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/StopStreamCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/UntagResourceCommand";
    import { UpdateChannelCommandInput, UpdateChannelCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/UpdateChannelCommand";
    import { IvsClient } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    /**
        * <p>
        *             <b>Introduction</b>
        *          </p>
        *          <p>The Amazon Interactive Video Service (IVS) API is REST compatible, using a standard HTTP
        *       API and an Amazon Web Services EventBridge event stream for responses. JSON is used for both
        *       requests and responses, including errors.</p>
        *          <p>The API is an Amazon Web Services regional service. For a list of supported regions and
        *       Amazon IVS HTTPS service endpoints, see the <a href="https://docs.aws.amazon.com/general/latest/gr/ivs.html">Amazon IVS page</a> in the
        *           <i>Amazon Web Services General Reference</i>.</p>
        *          <p>
        *             <i>
        *                <b>All API request parameters and URLs are case sensitive.
        *         </b>
        *             </i>
        *          </p>
        *          <p>For a summary of notable documentation changes in each release, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/doc-history.html"> Document
        *       History</a>.</p>
        *          <p>
        *             <b>Allowed Header Values</b>
        *          </p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <code>
        *                      <b>Accept:</b>
        *                   </code> application/json</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <code>
        *                      <b>Accept-Encoding:</b>
        *                   </code> gzip, deflate</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <code>
        *                      <b>Content-Type:</b>
        *                   </code>application/json</p>
        *             </li>
        *          </ul>
        *          <p>
        *             <b>Resources</b>
        *          </p>
        *          <p>The following resources contain information about your IVS live stream (see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/getting-started.html"> Getting Started with
        *         Amazon IVS</a>):</p>
        *          <ul>
        *             <li>
        *                <p>Channel — Stores configuration data related to your live stream. You first create a
        *           channel and then use the channel’s stream key to start your live stream. See the Channel
        *           endpoints for more information. </p>
        *             </li>
        *             <li>
        *                <p>Stream key — An identifier assigned by Amazon IVS when you create a channel, which is
        *           then used to authorize streaming. See the StreamKey endpoints for more information.
        *               <i>
        *                      <b>Treat the stream key like a secret, since it allows
        *               anyone to stream to the channel.</b>
        *                   </i>
        *                </p>
        *             </li>
        *             <li>
        *                <p>Playback key pair — Video playback may be restricted using playback-authorization
        *           tokens, which use public-key encryption. A playback key pair is the public-private pair of
        *           keys used to sign and validate the playback-authorization token. See the PlaybackKeyPair
        *           endpoints for more information.</p>
        *             </li>
        *             <li>
        *                <p>Recording configuration — Stores configuration related to recording a live stream and
        *           where to store the recorded content. Multiple channels can reference the same recording
        *           configuration. See the Recording Configuration endpoints for more information.</p>
        *             </li>
        *          </ul>
        *          <p>
        *             <b>Tagging</b>
        *          </p>
        *          <p>A <i>tag</i> is a metadata label that you assign to an Amazon Web Services
        *       resource. A tag comprises a <i>key</i> and a <i>value</i>, both
        *       set by you. For example, you might set a tag as <code>topic:nature</code> to label a
        *       particular video category. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services Resources</a> for
        *       more information, including restrictions that apply to tags.</p>
        *          <p>Tags can help you identify and organize your Amazon Web Services resources. For example,
        *       you can use the same tag for different resources to indicate that they are related. You can
        *       also use tags to manage access (see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_tags.html"> Access Tags</a>). </p>
        *          <p>The Amazon IVS API has these tag-related endpoints: <a>TagResource</a>, <a>UntagResource</a>, and <a>ListTagsForResource</a>. The following
        *       resources support tagging: Channels, Stream Keys, Playback Key Pairs, and Recording
        *       Configurations.</p>
        *          <p>At most 50 tags can be applied to a resource. </p>
        *          <p>
        *             <b>Authentication versus Authorization</b>
        *          </p>
        *          <p>Note the differences between these concepts:</p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <i>Authentication</i> is about verifying identity. You need to be
        *           authenticated to sign Amazon IVS API requests.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <i>Authorization</i> is about granting permissions. You need to be
        *           authorized to view <a href="https://docs.aws.amazon.com/ivs/latest/userguide/private-channels.html">Amazon IVS private channels</a>.
        *           (Private channels are channels that are enabled for "playback authorization.")</p>
        *             </li>
        *          </ul>
        *          <p>
        *             <b>Authentication</b>
        *          </p>
        *          <p>All Amazon IVS API requests must be authenticated with a signature. The Amazon Web Services
        *       Command-Line Interface (CLI) and Amazon IVS Player SDKs take care of signing the underlying
        *       API calls for you. However, if your application calls the Amazon IVS API directly, it’s your
        *       responsibility to sign the requests.</p>
        *          <p>You generate a signature using valid Amazon Web Services credentials that have permission
        *       to perform the requested action. For example, you must sign PutMetadata requests with a
        *       signature generated from an IAM user account that has the <code>ivs:PutMetadata</code>
        *       permission.</p>
        *          <p>For more information:</p>
        *          <ul>
        *             <li>
        *                <p>Authentication and generating signatures — See <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-authenticating-requests.html">Authenticating Requests
        *               (Amazon Web Services Signature Version 4)</a> in the <i>Amazon Web Services
        *             General Reference</i>.</p>
        *             </li>
        *             <li>
        *                <p>Managing Amazon IVS permissions — See <a href="https://docs.aws.amazon.com/ivs/latest/userguide/security-iam.html">Identity and Access Management</a> on
        *           the Security page of the <i>Amazon IVS User Guide</i>.</p>
        *             </li>
        *          </ul>
        *          <p>
        *             <b>Channel Endpoints</b>
        *          </p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <a>CreateChannel</a> — Creates a new channel and an associated stream
        *           key to start streaming.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>GetChannel</a> — Gets the channel configuration for the specified
        *           channel ARN (Amazon Resource Name).</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>BatchGetChannel</a> — Performs <a>GetChannel</a> on
        *           multiple ARNs simultaneously.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>ListChannels</a> — Gets summary information about all channels in
        *           your account, in the Amazon Web Services region where the API request is processed. This
        *           list can be filtered to match a specified name or recording-configuration ARN. Filters are
        *           mutually exclusive and cannot be used together. If you try to use both filters, you will
        *           get an error (409 Conflict Exception).</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>UpdateChannel</a> — Updates a channel's configuration. This does
        *           not affect an ongoing stream of this channel. You must stop and restart the stream for the
        *           changes to take effect.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>DeleteChannel</a> — Deletes the specified channel.</p>
        *             </li>
        *          </ul>
        *          <p>
        *             <b>StreamKey Endpoints</b>
        *          </p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <a>CreateStreamKey</a> — Creates a stream key, used to initiate a
        *           stream, for the specified channel ARN.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>GetStreamKey</a> — Gets stream key information for the specified
        *           ARN.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>BatchGetStreamKey</a> — Performs <a>GetStreamKey</a> on
        *           multiple ARNs simultaneously.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>ListStreamKeys</a> — Gets summary information about stream keys
        *           for the specified channel.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>DeleteStreamKey</a> — Deletes the stream key for the specified
        *           ARN, so it can no longer be used to stream.</p>
        *             </li>
        *          </ul>
        *          <p>
        *             <b>Stream Endpoints</b>
        *          </p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <a>GetStream</a> — Gets information about the active (live) stream on
        *           a specified channel.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>GetStreamSession</a> — Gets metadata on a specified stream.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>ListStreams</a> — Gets summary information about live streams in
        *           your account, in the Amazon Web Services region where the API request is processed.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>ListStreamSessions</a> — Gets a summary of current and previous
        *           streams for a specified channel in your account, in the AWS region where the API request
        *           is processed.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>StopStream</a> — Disconnects the incoming RTMPS stream for the
        *           specified channel. Can be used in conjunction with <a>DeleteStreamKey</a> to
        *           prevent further streaming to a channel.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>PutMetadata</a> — Inserts metadata into the active stream of the
        *           specified channel. At most 5 requests per second per channel are allowed, each with a
        *           maximum 1 KB payload. (If 5 TPS is not sufficient for your needs, we recommend batching
        *           your data into a single PutMetadata call.) At most 155 requests per second per account are
        *           allowed.</p>
        *             </li>
        *          </ul>
        *          <p>
        *             <b>PlaybackKeyPair Endpoints</b>
        *          </p>
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/private-channels.html">Setting Up Private Channels</a> in the
        *         <i>Amazon IVS User Guide</i>.</p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <a>ImportPlaybackKeyPair</a> — Imports the public portion of a new
        *           key pair and returns its <code>arn</code> and <code>fingerprint</code>. The
        *             <code>privateKey</code> can then be used to generate viewer authorization tokens, to
        *           grant viewers access to private channels (channels enabled for playback
        *           authorization).</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>GetPlaybackKeyPair</a> — Gets a specified playback authorization
        *           key pair and returns the <code>arn</code> and <code>fingerprint</code>. The
        *             <code>privateKey</code> held by the caller can be used to generate viewer authorization
        *           tokens, to grant viewers access to private channels.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>ListPlaybackKeyPairs</a> — Gets summary information about playback
        *           key pairs.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>DeletePlaybackKeyPair</a> — Deletes a specified authorization key
        *           pair. This invalidates future viewer tokens generated using the key pair’s
        *             <code>privateKey</code>.</p>
        *             </li>
        *          </ul>
        *          <p>
        *             <b>RecordingConfiguration Endpoints</b>
        *          </p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <a>CreateRecordingConfiguration</a> — Creates a new recording
        *           configuration, used to enable recording to Amazon S3.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>GetRecordingConfiguration</a> — Gets the recording-configuration
        *           metadata for the specified ARN.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>ListRecordingConfigurations</a> — Gets summary information about
        *           all recording configurations in your account, in the Amazon Web Services region where the
        *           API request is processed.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>DeleteRecordingConfiguration</a> — Deletes the recording
        *           configuration for the specified ARN.</p>
        *             </li>
        *          </ul>
        *          <p>
        *             <b>Amazon Web Services Tags Endpoints</b>
        *          </p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <a>TagResource</a> — Adds or updates tags for the Amazon Web Services
        *           resource with the specified ARN.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>UntagResource</a> — Removes tags from the resource with the
        *           specified ARN.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>ListTagsForResource</a> — Gets information about Amazon Web Services tags for the specified ARN.</p>
        *             </li>
        *          </ul>
        */
    export class Ivs extends IvsClient {
            /**
                * <p>Performs <a>GetChannel</a> on multiple ARNs simultaneously.</p>
                */
            batchGetChannel(args: BatchGetChannelCommandInput, options?: __HttpHandlerOptions): Promise<BatchGetChannelCommandOutput>;
            batchGetChannel(args: BatchGetChannelCommandInput, cb: (err: any, data?: BatchGetChannelCommandOutput) => void): void;
            batchGetChannel(args: BatchGetChannelCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchGetChannelCommandOutput) => void): void;
            /**
                * <p>Performs <a>GetStreamKey</a> on multiple ARNs simultaneously.</p>
                */
            batchGetStreamKey(args: BatchGetStreamKeyCommandInput, options?: __HttpHandlerOptions): Promise<BatchGetStreamKeyCommandOutput>;
            batchGetStreamKey(args: BatchGetStreamKeyCommandInput, cb: (err: any, data?: BatchGetStreamKeyCommandOutput) => void): void;
            batchGetStreamKey(args: BatchGetStreamKeyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchGetStreamKeyCommandOutput) => void): void;
            /**
                * <p>Creates a new channel and an associated stream key to start streaming.</p>
                */
            createChannel(args: CreateChannelCommandInput, options?: __HttpHandlerOptions): Promise<CreateChannelCommandOutput>;
            createChannel(args: CreateChannelCommandInput, cb: (err: any, data?: CreateChannelCommandOutput) => void): void;
            createChannel(args: CreateChannelCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateChannelCommandOutput) => void): void;
            /**
                * <p>Creates a new recording configuration, used to enable recording to Amazon S3.</p>
                *          <p>
                *             <b>Known issue:</b> In the us-east-1 region, if you use the
                *         Amazon Web Services CLI to create a recording configuration, it returns success even if the
                *       S3 bucket is in a different region. In this case, the <code>state</code> of the recording
                *       configuration is <code>CREATE_FAILED</code> (instead of <code>ACTIVE</code>). (In other
                *       regions, the CLI correctly returns failure if the bucket is in a different region.)</p>
                *          <p>
                *             <b>Workaround:</b> Ensure that your S3 bucket is in the same
                *       region as the recording configuration. If you create a recording configuration in a different
                *       region as your S3 bucket, delete that recording configuration and create a new one with an S3
                *       bucket from the correct region.</p>
                */
            createRecordingConfiguration(args: CreateRecordingConfigurationCommandInput, options?: __HttpHandlerOptions): Promise<CreateRecordingConfigurationCommandOutput>;
            createRecordingConfiguration(args: CreateRecordingConfigurationCommandInput, cb: (err: any, data?: CreateRecordingConfigurationCommandOutput) => void): void;
            createRecordingConfiguration(args: CreateRecordingConfigurationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateRecordingConfigurationCommandOutput) => void): void;
            /**
                * <p>Creates a stream key, used to initiate a stream, for the specified channel ARN.</p>
                *          <p>Note that <a>CreateChannel</a> creates a stream key. If you subsequently use
                *       CreateStreamKey on the same channel, it will fail because a stream key already exists and
                *       there is a limit of 1 stream key per channel. To reset the stream key on a channel, use <a>DeleteStreamKey</a> and then CreateStreamKey.</p>
                */
            createStreamKey(args: CreateStreamKeyCommandInput, options?: __HttpHandlerOptions): Promise<CreateStreamKeyCommandOutput>;
            createStreamKey(args: CreateStreamKeyCommandInput, cb: (err: any, data?: CreateStreamKeyCommandOutput) => void): void;
            createStreamKey(args: CreateStreamKeyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateStreamKeyCommandOutput) => void): void;
            /**
                * <p>Deletes the specified channel and its associated stream keys.</p>
                *          <p>If you try to delete a live channel, you will get an error (409 ConflictException). To
                *       delete a channel that is live, call <a>StopStream</a>, wait for the Amazon
                *       EventBridge "Stream End" event (to verify that the stream's state was changed from Live to
                *       Offline), then call DeleteChannel. (See <a href="https://docs.aws.amazon.com/ivs/latest/userguide/eventbridge.html"> Using EventBridge with Amazon IVS</a>.)
                *     </p>
                */
            deleteChannel(args: DeleteChannelCommandInput, options?: __HttpHandlerOptions): Promise<DeleteChannelCommandOutput>;
            deleteChannel(args: DeleteChannelCommandInput, cb: (err: any, data?: DeleteChannelCommandOutput) => void): void;
            deleteChannel(args: DeleteChannelCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteChannelCommandOutput) => void): void;
            /**
                * <p>Deletes a specified authorization key pair. This invalidates future viewer tokens
                *       generated using the key pair’s <code>privateKey</code>. For more information, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/private-channels.html">Setting Up Private
                *         Channels</a> in the <i>Amazon IVS User Guide</i>.</p>
                */
            deletePlaybackKeyPair(args: DeletePlaybackKeyPairCommandInput, options?: __HttpHandlerOptions): Promise<DeletePlaybackKeyPairCommandOutput>;
            deletePlaybackKeyPair(args: DeletePlaybackKeyPairCommandInput, cb: (err: any, data?: DeletePlaybackKeyPairCommandOutput) => void): void;
            deletePlaybackKeyPair(args: DeletePlaybackKeyPairCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeletePlaybackKeyPairCommandOutput) => void): void;
            /**
                * <p>Deletes the recording configuration for the specified ARN.</p>
                *          <p>If you try to delete a recording configuration that is associated with a channel, you will
                *       get an error (409 ConflictException). To avoid this, for all channels that reference the
                *       recording configuration, first use <a>UpdateChannel</a> to set the
                *         <code>recordingConfigurationArn</code> field to an empty string, then use
                *       DeleteRecordingConfiguration.</p>
                */
            deleteRecordingConfiguration(args: DeleteRecordingConfigurationCommandInput, options?: __HttpHandlerOptions): Promise<DeleteRecordingConfigurationCommandOutput>;
            deleteRecordingConfiguration(args: DeleteRecordingConfigurationCommandInput, cb: (err: any, data?: DeleteRecordingConfigurationCommandOutput) => void): void;
            deleteRecordingConfiguration(args: DeleteRecordingConfigurationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteRecordingConfigurationCommandOutput) => void): void;
            /**
                * <p>Deletes the stream key for the specified ARN, so it can no longer be used to
                *       stream.</p>
                */
            deleteStreamKey(args: DeleteStreamKeyCommandInput, options?: __HttpHandlerOptions): Promise<DeleteStreamKeyCommandOutput>;
            deleteStreamKey(args: DeleteStreamKeyCommandInput, cb: (err: any, data?: DeleteStreamKeyCommandOutput) => void): void;
            deleteStreamKey(args: DeleteStreamKeyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteStreamKeyCommandOutput) => void): void;
            /**
                * <p>Gets the channel configuration for the specified channel ARN. See also <a>BatchGetChannel</a>.</p>
                */
            getChannel(args: GetChannelCommandInput, options?: __HttpHandlerOptions): Promise<GetChannelCommandOutput>;
            getChannel(args: GetChannelCommandInput, cb: (err: any, data?: GetChannelCommandOutput) => void): void;
            getChannel(args: GetChannelCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetChannelCommandOutput) => void): void;
            /**
                * <p>Gets a specified playback authorization key pair and returns the <code>arn</code> and
                *         <code>fingerprint</code>. The <code>privateKey</code> held by the caller can be used to
                *       generate viewer authorization tokens, to grant viewers access to private channels. For more
                *       information, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/private-channels.html">Setting Up Private Channels</a> in the <i>Amazon IVS User
                *       Guide</i>.</p>
                */
            getPlaybackKeyPair(args: GetPlaybackKeyPairCommandInput, options?: __HttpHandlerOptions): Promise<GetPlaybackKeyPairCommandOutput>;
            getPlaybackKeyPair(args: GetPlaybackKeyPairCommandInput, cb: (err: any, data?: GetPlaybackKeyPairCommandOutput) => void): void;
            getPlaybackKeyPair(args: GetPlaybackKeyPairCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetPlaybackKeyPairCommandOutput) => void): void;
            /**
                * <p>Gets the recording configuration for the specified ARN.</p>
                */
            getRecordingConfiguration(args: GetRecordingConfigurationCommandInput, options?: __HttpHandlerOptions): Promise<GetRecordingConfigurationCommandOutput>;
            getRecordingConfiguration(args: GetRecordingConfigurationCommandInput, cb: (err: any, data?: GetRecordingConfigurationCommandOutput) => void): void;
            getRecordingConfiguration(args: GetRecordingConfigurationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetRecordingConfigurationCommandOutput) => void): void;
            /**
                * <p>Gets information about the active (live) stream on a specified channel.</p>
                */
            getStream(args: GetStreamCommandInput, options?: __HttpHandlerOptions): Promise<GetStreamCommandOutput>;
            getStream(args: GetStreamCommandInput, cb: (err: any, data?: GetStreamCommandOutput) => void): void;
            getStream(args: GetStreamCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetStreamCommandOutput) => void): void;
            /**
                * <p>Gets stream-key information for a specified ARN.</p>
                */
            getStreamKey(args: GetStreamKeyCommandInput, options?: __HttpHandlerOptions): Promise<GetStreamKeyCommandOutput>;
            getStreamKey(args: GetStreamKeyCommandInput, cb: (err: any, data?: GetStreamKeyCommandOutput) => void): void;
            getStreamKey(args: GetStreamKeyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetStreamKeyCommandOutput) => void): void;
            /**
                * <p>Gets metadata on a specified stream.</p>
                */
            getStreamSession(args: GetStreamSessionCommandInput, options?: __HttpHandlerOptions): Promise<GetStreamSessionCommandOutput>;
            getStreamSession(args: GetStreamSessionCommandInput, cb: (err: any, data?: GetStreamSessionCommandOutput) => void): void;
            getStreamSession(args: GetStreamSessionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetStreamSessionCommandOutput) => void): void;
            /**
                * <p>Imports the public portion of a new key pair and returns its <code>arn</code> and
                *         <code>fingerprint</code>. The <code>privateKey</code> can then be used to generate viewer
                *       authorization tokens, to grant viewers access to private channels. For more information, see
                *         <a href="https://docs.aws.amazon.com/ivs/latest/userguide/private-channels.html">Setting Up
                *         Private Channels</a> in the <i>Amazon IVS User Guide</i>.</p>
                */
            importPlaybackKeyPair(args: ImportPlaybackKeyPairCommandInput, options?: __HttpHandlerOptions): Promise<ImportPlaybackKeyPairCommandOutput>;
            importPlaybackKeyPair(args: ImportPlaybackKeyPairCommandInput, cb: (err: any, data?: ImportPlaybackKeyPairCommandOutput) => void): void;
            importPlaybackKeyPair(args: ImportPlaybackKeyPairCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ImportPlaybackKeyPairCommandOutput) => void): void;
            /**
                * <p>Gets summary information about all channels in your account, in the Amazon Web Services
                *       region where the API request is processed. This list can be filtered to match a specified name
                *       or recording-configuration ARN. Filters are mutually exclusive and cannot be used together. If
                *       you try to use both filters, you will get an error (409 ConflictException).</p>
                */
            listChannels(args: ListChannelsCommandInput, options?: __HttpHandlerOptions): Promise<ListChannelsCommandOutput>;
            listChannels(args: ListChannelsCommandInput, cb: (err: any, data?: ListChannelsCommandOutput) => void): void;
            listChannels(args: ListChannelsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListChannelsCommandOutput) => void): void;
            /**
                * <p>Gets summary information about playback key pairs. For more information, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/private-channels.html">Setting Up Private
                *         Channels</a> in the <i>Amazon IVS User Guide</i>.</p>
                */
            listPlaybackKeyPairs(args: ListPlaybackKeyPairsCommandInput, options?: __HttpHandlerOptions): Promise<ListPlaybackKeyPairsCommandOutput>;
            listPlaybackKeyPairs(args: ListPlaybackKeyPairsCommandInput, cb: (err: any, data?: ListPlaybackKeyPairsCommandOutput) => void): void;
            listPlaybackKeyPairs(args: ListPlaybackKeyPairsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListPlaybackKeyPairsCommandOutput) => void): void;
            /**
                * <p>Gets summary information about all recording configurations in your account, in the
                *         Amazon Web Services region where the API request is processed.</p>
                */
            listRecordingConfigurations(args: ListRecordingConfigurationsCommandInput, options?: __HttpHandlerOptions): Promise<ListRecordingConfigurationsCommandOutput>;
            listRecordingConfigurations(args: ListRecordingConfigurationsCommandInput, cb: (err: any, data?: ListRecordingConfigurationsCommandOutput) => void): void;
            listRecordingConfigurations(args: ListRecordingConfigurationsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListRecordingConfigurationsCommandOutput) => void): void;
            /**
                * <p>Gets summary information about stream keys for the specified channel.</p>
                */
            listStreamKeys(args: ListStreamKeysCommandInput, options?: __HttpHandlerOptions): Promise<ListStreamKeysCommandOutput>;
            listStreamKeys(args: ListStreamKeysCommandInput, cb: (err: any, data?: ListStreamKeysCommandOutput) => void): void;
            listStreamKeys(args: ListStreamKeysCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListStreamKeysCommandOutput) => void): void;
            /**
                * <p>Gets summary information about live streams in your account, in the Amazon Web Services
                *       region where the API request is processed.</p>
                */
            listStreams(args: ListStreamsCommandInput, options?: __HttpHandlerOptions): Promise<ListStreamsCommandOutput>;
            listStreams(args: ListStreamsCommandInput, cb: (err: any, data?: ListStreamsCommandOutput) => void): void;
            listStreams(args: ListStreamsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListStreamsCommandOutput) => void): void;
            /**
                * <p>Gets a summary of current and previous streams for a specified channel in your account, in
                *       the AWS region where the API request is processed.</p>
                */
            listStreamSessions(args: ListStreamSessionsCommandInput, options?: __HttpHandlerOptions): Promise<ListStreamSessionsCommandOutput>;
            listStreamSessions(args: ListStreamSessionsCommandInput, cb: (err: any, data?: ListStreamSessionsCommandOutput) => void): void;
            listStreamSessions(args: ListStreamSessionsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListStreamSessionsCommandOutput) => void): void;
            /**
                * <p>Gets information about Amazon Web Services tags for the specified ARN.</p>
                */
            listTagsForResource(args: ListTagsForResourceCommandInput, options?: __HttpHandlerOptions): Promise<ListTagsForResourceCommandOutput>;
            listTagsForResource(args: ListTagsForResourceCommandInput, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            listTagsForResource(args: ListTagsForResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            /**
                * <p>Inserts metadata into the active stream of the specified channel. At most 5 requests per
                *       second per channel are allowed, each with a maximum 1 KB payload. (If 5 TPS is not sufficient
                *       for your needs, we recommend batching your data into a single PutMetadata call.) At most 155
                *       requests per second per account are allowed. Also see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/metadata.html">Embedding Metadata within a Video Stream</a> in
                *       the <i>Amazon IVS User Guide</i>.</p>
                */
            putMetadata(args: PutMetadataCommandInput, options?: __HttpHandlerOptions): Promise<PutMetadataCommandOutput>;
            putMetadata(args: PutMetadataCommandInput, cb: (err: any, data?: PutMetadataCommandOutput) => void): void;
            putMetadata(args: PutMetadataCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutMetadataCommandOutput) => void): void;
            /**
                * <p>Disconnects the incoming RTMPS stream for the specified channel. Can be used in
                *       conjunction with <a>DeleteStreamKey</a> to prevent further streaming to a
                *       channel.</p>
                *          <note>
                *             <p>Many streaming client-software libraries automatically reconnect a dropped RTMPS
                *         session, so to stop the stream permanently, you may want to first revoke the
                *           <code>streamKey</code> attached to the channel.</p>
                *          </note>
                */
            stopStream(args: StopStreamCommandInput, options?: __HttpHandlerOptions): Promise<StopStreamCommandOutput>;
            stopStream(args: StopStreamCommandInput, cb: (err: any, data?: StopStreamCommandOutput) => void): void;
            stopStream(args: StopStreamCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: StopStreamCommandOutput) => void): void;
            /**
                * <p>Adds or updates tags for the Amazon Web Services resource with the specified ARN.</p>
                */
            tagResource(args: TagResourceCommandInput, options?: __HttpHandlerOptions): Promise<TagResourceCommandOutput>;
            tagResource(args: TagResourceCommandInput, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            tagResource(args: TagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            /**
                * <p>Removes tags from the resource with the specified ARN.</p>
                */
            untagResource(args: UntagResourceCommandInput, options?: __HttpHandlerOptions): Promise<UntagResourceCommandOutput>;
            untagResource(args: UntagResourceCommandInput, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            untagResource(args: UntagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            /**
                * <p>Updates a channel's configuration. This does not affect an ongoing stream of this channel.
                *       You must stop and restart the stream for the changes to take effect.</p>
                */
            updateChannel(args: UpdateChannelCommandInput, options?: __HttpHandlerOptions): Promise<UpdateChannelCommandOutput>;
            updateChannel(args: UpdateChannelCommandInput, cb: (err: any, data?: UpdateChannelCommandOutput) => void): void;
            updateChannel(args: UpdateChannelCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateChannelCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/BatchGetChannelCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { BatchGetChannelRequest, BatchGetChannelResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface BatchGetChannelCommandInput extends BatchGetChannelRequest {
    }
    export interface BatchGetChannelCommandOutput extends BatchGetChannelResponse, __MetadataBearer {
    }
    /**
        * <p>Performs <a>GetChannel</a> on multiple ARNs simultaneously.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, BatchGetChannelCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, BatchGetChannelCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new BatchGetChannelCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchGetChannelCommandInput} for command's `input` shape.
        * @see {@link BatchGetChannelCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class BatchGetChannelCommand extends $Command<BatchGetChannelCommandInput, BatchGetChannelCommandOutput, IvsClientResolvedConfig> {
            readonly input: BatchGetChannelCommandInput;
            constructor(input: BatchGetChannelCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchGetChannelCommandInput, BatchGetChannelCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/BatchGetStreamKeyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { BatchGetStreamKeyRequest, BatchGetStreamKeyResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface BatchGetStreamKeyCommandInput extends BatchGetStreamKeyRequest {
    }
    export interface BatchGetStreamKeyCommandOutput extends BatchGetStreamKeyResponse, __MetadataBearer {
    }
    /**
        * <p>Performs <a>GetStreamKey</a> on multiple ARNs simultaneously.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, BatchGetStreamKeyCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, BatchGetStreamKeyCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new BatchGetStreamKeyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchGetStreamKeyCommandInput} for command's `input` shape.
        * @see {@link BatchGetStreamKeyCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class BatchGetStreamKeyCommand extends $Command<BatchGetStreamKeyCommandInput, BatchGetStreamKeyCommandOutput, IvsClientResolvedConfig> {
            readonly input: BatchGetStreamKeyCommandInput;
            constructor(input: BatchGetStreamKeyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchGetStreamKeyCommandInput, BatchGetStreamKeyCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/CreateChannelCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { CreateChannelRequest, CreateChannelResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface CreateChannelCommandInput extends CreateChannelRequest {
    }
    export interface CreateChannelCommandOutput extends CreateChannelResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a new channel and an associated stream key to start streaming.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, CreateChannelCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, CreateChannelCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new CreateChannelCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateChannelCommandInput} for command's `input` shape.
        * @see {@link CreateChannelCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class CreateChannelCommand extends $Command<CreateChannelCommandInput, CreateChannelCommandOutput, IvsClientResolvedConfig> {
            readonly input: CreateChannelCommandInput;
            constructor(input: CreateChannelCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateChannelCommandInput, CreateChannelCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/CreateRecordingConfigurationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { CreateRecordingConfigurationRequest, CreateRecordingConfigurationResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface CreateRecordingConfigurationCommandInput extends CreateRecordingConfigurationRequest {
    }
    export interface CreateRecordingConfigurationCommandOutput extends CreateRecordingConfigurationResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a new recording configuration, used to enable recording to Amazon S3.</p>
        *          <p>
        *             <b>Known issue:</b> In the us-east-1 region, if you use the
        *         Amazon Web Services CLI to create a recording configuration, it returns success even if the
        *       S3 bucket is in a different region. In this case, the <code>state</code> of the recording
        *       configuration is <code>CREATE_FAILED</code> (instead of <code>ACTIVE</code>). (In other
        *       regions, the CLI correctly returns failure if the bucket is in a different region.)</p>
        *          <p>
        *             <b>Workaround:</b> Ensure that your S3 bucket is in the same
        *       region as the recording configuration. If you create a recording configuration in a different
        *       region as your S3 bucket, delete that recording configuration and create a new one with an S3
        *       bucket from the correct region.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, CreateRecordingConfigurationCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, CreateRecordingConfigurationCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new CreateRecordingConfigurationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateRecordingConfigurationCommandInput} for command's `input` shape.
        * @see {@link CreateRecordingConfigurationCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class CreateRecordingConfigurationCommand extends $Command<CreateRecordingConfigurationCommandInput, CreateRecordingConfigurationCommandOutput, IvsClientResolvedConfig> {
            readonly input: CreateRecordingConfigurationCommandInput;
            constructor(input: CreateRecordingConfigurationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateRecordingConfigurationCommandInput, CreateRecordingConfigurationCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/CreateStreamKeyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { CreateStreamKeyRequest, CreateStreamKeyResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface CreateStreamKeyCommandInput extends CreateStreamKeyRequest {
    }
    export interface CreateStreamKeyCommandOutput extends CreateStreamKeyResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a stream key, used to initiate a stream, for the specified channel ARN.</p>
        *          <p>Note that <a>CreateChannel</a> creates a stream key. If you subsequently use
        *       CreateStreamKey on the same channel, it will fail because a stream key already exists and
        *       there is a limit of 1 stream key per channel. To reset the stream key on a channel, use <a>DeleteStreamKey</a> and then CreateStreamKey.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, CreateStreamKeyCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, CreateStreamKeyCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new CreateStreamKeyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateStreamKeyCommandInput} for command's `input` shape.
        * @see {@link CreateStreamKeyCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class CreateStreamKeyCommand extends $Command<CreateStreamKeyCommandInput, CreateStreamKeyCommandOutput, IvsClientResolvedConfig> {
            readonly input: CreateStreamKeyCommandInput;
            constructor(input: CreateStreamKeyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateStreamKeyCommandInput, CreateStreamKeyCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/DeleteChannelCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { DeleteChannelRequest } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface DeleteChannelCommandInput extends DeleteChannelRequest {
    }
    export interface DeleteChannelCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes the specified channel and its associated stream keys.</p>
        *          <p>If you try to delete a live channel, you will get an error (409 ConflictException). To
        *       delete a channel that is live, call <a>StopStream</a>, wait for the Amazon
        *       EventBridge "Stream End" event (to verify that the stream's state was changed from Live to
        *       Offline), then call DeleteChannel. (See <a href="https://docs.aws.amazon.com/ivs/latest/userguide/eventbridge.html"> Using EventBridge with Amazon IVS</a>.)
        *     </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, DeleteChannelCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, DeleteChannelCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new DeleteChannelCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteChannelCommandInput} for command's `input` shape.
        * @see {@link DeleteChannelCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class DeleteChannelCommand extends $Command<DeleteChannelCommandInput, DeleteChannelCommandOutput, IvsClientResolvedConfig> {
            readonly input: DeleteChannelCommandInput;
            constructor(input: DeleteChannelCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteChannelCommandInput, DeleteChannelCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/DeletePlaybackKeyPairCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { DeletePlaybackKeyPairRequest, DeletePlaybackKeyPairResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface DeletePlaybackKeyPairCommandInput extends DeletePlaybackKeyPairRequest {
    }
    export interface DeletePlaybackKeyPairCommandOutput extends DeletePlaybackKeyPairResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes a specified authorization key pair. This invalidates future viewer tokens
        *       generated using the key pair’s <code>privateKey</code>. For more information, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/private-channels.html">Setting Up Private
        *         Channels</a> in the <i>Amazon IVS User Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, DeletePlaybackKeyPairCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, DeletePlaybackKeyPairCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new DeletePlaybackKeyPairCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeletePlaybackKeyPairCommandInput} for command's `input` shape.
        * @see {@link DeletePlaybackKeyPairCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class DeletePlaybackKeyPairCommand extends $Command<DeletePlaybackKeyPairCommandInput, DeletePlaybackKeyPairCommandOutput, IvsClientResolvedConfig> {
            readonly input: DeletePlaybackKeyPairCommandInput;
            constructor(input: DeletePlaybackKeyPairCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeletePlaybackKeyPairCommandInput, DeletePlaybackKeyPairCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/DeleteRecordingConfigurationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { DeleteRecordingConfigurationRequest } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface DeleteRecordingConfigurationCommandInput extends DeleteRecordingConfigurationRequest {
    }
    export interface DeleteRecordingConfigurationCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes the recording configuration for the specified ARN.</p>
        *          <p>If you try to delete a recording configuration that is associated with a channel, you will
        *       get an error (409 ConflictException). To avoid this, for all channels that reference the
        *       recording configuration, first use <a>UpdateChannel</a> to set the
        *         <code>recordingConfigurationArn</code> field to an empty string, then use
        *       DeleteRecordingConfiguration.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, DeleteRecordingConfigurationCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, DeleteRecordingConfigurationCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new DeleteRecordingConfigurationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteRecordingConfigurationCommandInput} for command's `input` shape.
        * @see {@link DeleteRecordingConfigurationCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class DeleteRecordingConfigurationCommand extends $Command<DeleteRecordingConfigurationCommandInput, DeleteRecordingConfigurationCommandOutput, IvsClientResolvedConfig> {
            readonly input: DeleteRecordingConfigurationCommandInput;
            constructor(input: DeleteRecordingConfigurationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteRecordingConfigurationCommandInput, DeleteRecordingConfigurationCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/DeleteStreamKeyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { DeleteStreamKeyRequest } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface DeleteStreamKeyCommandInput extends DeleteStreamKeyRequest {
    }
    export interface DeleteStreamKeyCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes the stream key for the specified ARN, so it can no longer be used to
        *       stream.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, DeleteStreamKeyCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, DeleteStreamKeyCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new DeleteStreamKeyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteStreamKeyCommandInput} for command's `input` shape.
        * @see {@link DeleteStreamKeyCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class DeleteStreamKeyCommand extends $Command<DeleteStreamKeyCommandInput, DeleteStreamKeyCommandOutput, IvsClientResolvedConfig> {
            readonly input: DeleteStreamKeyCommandInput;
            constructor(input: DeleteStreamKeyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteStreamKeyCommandInput, DeleteStreamKeyCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/GetChannelCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { GetChannelRequest, GetChannelResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface GetChannelCommandInput extends GetChannelRequest {
    }
    export interface GetChannelCommandOutput extends GetChannelResponse, __MetadataBearer {
    }
    /**
        * <p>Gets the channel configuration for the specified channel ARN. See also <a>BatchGetChannel</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, GetChannelCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, GetChannelCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new GetChannelCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetChannelCommandInput} for command's `input` shape.
        * @see {@link GetChannelCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class GetChannelCommand extends $Command<GetChannelCommandInput, GetChannelCommandOutput, IvsClientResolvedConfig> {
            readonly input: GetChannelCommandInput;
            constructor(input: GetChannelCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetChannelCommandInput, GetChannelCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/GetPlaybackKeyPairCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { GetPlaybackKeyPairRequest, GetPlaybackKeyPairResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface GetPlaybackKeyPairCommandInput extends GetPlaybackKeyPairRequest {
    }
    export interface GetPlaybackKeyPairCommandOutput extends GetPlaybackKeyPairResponse, __MetadataBearer {
    }
    /**
        * <p>Gets a specified playback authorization key pair and returns the <code>arn</code> and
        *         <code>fingerprint</code>. The <code>privateKey</code> held by the caller can be used to
        *       generate viewer authorization tokens, to grant viewers access to private channels. For more
        *       information, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/private-channels.html">Setting Up Private Channels</a> in the <i>Amazon IVS User
        *       Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, GetPlaybackKeyPairCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, GetPlaybackKeyPairCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new GetPlaybackKeyPairCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetPlaybackKeyPairCommandInput} for command's `input` shape.
        * @see {@link GetPlaybackKeyPairCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class GetPlaybackKeyPairCommand extends $Command<GetPlaybackKeyPairCommandInput, GetPlaybackKeyPairCommandOutput, IvsClientResolvedConfig> {
            readonly input: GetPlaybackKeyPairCommandInput;
            constructor(input: GetPlaybackKeyPairCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetPlaybackKeyPairCommandInput, GetPlaybackKeyPairCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/GetRecordingConfigurationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { GetRecordingConfigurationRequest, GetRecordingConfigurationResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface GetRecordingConfigurationCommandInput extends GetRecordingConfigurationRequest {
    }
    export interface GetRecordingConfigurationCommandOutput extends GetRecordingConfigurationResponse, __MetadataBearer {
    }
    /**
        * <p>Gets the recording configuration for the specified ARN.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, GetRecordingConfigurationCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, GetRecordingConfigurationCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new GetRecordingConfigurationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetRecordingConfigurationCommandInput} for command's `input` shape.
        * @see {@link GetRecordingConfigurationCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class GetRecordingConfigurationCommand extends $Command<GetRecordingConfigurationCommandInput, GetRecordingConfigurationCommandOutput, IvsClientResolvedConfig> {
            readonly input: GetRecordingConfigurationCommandInput;
            constructor(input: GetRecordingConfigurationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetRecordingConfigurationCommandInput, GetRecordingConfigurationCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/GetStreamCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { GetStreamRequest, GetStreamResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface GetStreamCommandInput extends GetStreamRequest {
    }
    export interface GetStreamCommandOutput extends GetStreamResponse, __MetadataBearer {
    }
    /**
        * <p>Gets information about the active (live) stream on a specified channel.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, GetStreamCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, GetStreamCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new GetStreamCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetStreamCommandInput} for command's `input` shape.
        * @see {@link GetStreamCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class GetStreamCommand extends $Command<GetStreamCommandInput, GetStreamCommandOutput, IvsClientResolvedConfig> {
            readonly input: GetStreamCommandInput;
            constructor(input: GetStreamCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetStreamCommandInput, GetStreamCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/GetStreamKeyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { GetStreamKeyRequest, GetStreamKeyResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface GetStreamKeyCommandInput extends GetStreamKeyRequest {
    }
    export interface GetStreamKeyCommandOutput extends GetStreamKeyResponse, __MetadataBearer {
    }
    /**
        * <p>Gets stream-key information for a specified ARN.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, GetStreamKeyCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, GetStreamKeyCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new GetStreamKeyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetStreamKeyCommandInput} for command's `input` shape.
        * @see {@link GetStreamKeyCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class GetStreamKeyCommand extends $Command<GetStreamKeyCommandInput, GetStreamKeyCommandOutput, IvsClientResolvedConfig> {
            readonly input: GetStreamKeyCommandInput;
            constructor(input: GetStreamKeyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetStreamKeyCommandInput, GetStreamKeyCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/GetStreamSessionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { GetStreamSessionRequest, GetStreamSessionResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface GetStreamSessionCommandInput extends GetStreamSessionRequest {
    }
    export interface GetStreamSessionCommandOutput extends GetStreamSessionResponse, __MetadataBearer {
    }
    /**
        * <p>Gets metadata on a specified stream.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, GetStreamSessionCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, GetStreamSessionCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new GetStreamSessionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetStreamSessionCommandInput} for command's `input` shape.
        * @see {@link GetStreamSessionCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class GetStreamSessionCommand extends $Command<GetStreamSessionCommandInput, GetStreamSessionCommandOutput, IvsClientResolvedConfig> {
            readonly input: GetStreamSessionCommandInput;
            constructor(input: GetStreamSessionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetStreamSessionCommandInput, GetStreamSessionCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ImportPlaybackKeyPairCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { ImportPlaybackKeyPairRequest, ImportPlaybackKeyPairResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface ImportPlaybackKeyPairCommandInput extends ImportPlaybackKeyPairRequest {
    }
    export interface ImportPlaybackKeyPairCommandOutput extends ImportPlaybackKeyPairResponse, __MetadataBearer {
    }
    /**
        * <p>Imports the public portion of a new key pair and returns its <code>arn</code> and
        *         <code>fingerprint</code>. The <code>privateKey</code> can then be used to generate viewer
        *       authorization tokens, to grant viewers access to private channels. For more information, see
        *         <a href="https://docs.aws.amazon.com/ivs/latest/userguide/private-channels.html">Setting Up
        *         Private Channels</a> in the <i>Amazon IVS User Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, ImportPlaybackKeyPairCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, ImportPlaybackKeyPairCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new ImportPlaybackKeyPairCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ImportPlaybackKeyPairCommandInput} for command's `input` shape.
        * @see {@link ImportPlaybackKeyPairCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class ImportPlaybackKeyPairCommand extends $Command<ImportPlaybackKeyPairCommandInput, ImportPlaybackKeyPairCommandOutput, IvsClientResolvedConfig> {
            readonly input: ImportPlaybackKeyPairCommandInput;
            constructor(input: ImportPlaybackKeyPairCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ImportPlaybackKeyPairCommandInput, ImportPlaybackKeyPairCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ListChannelsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { ListChannelsRequest, ListChannelsResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface ListChannelsCommandInput extends ListChannelsRequest {
    }
    export interface ListChannelsCommandOutput extends ListChannelsResponse, __MetadataBearer {
    }
    /**
        * <p>Gets summary information about all channels in your account, in the Amazon Web Services
        *       region where the API request is processed. This list can be filtered to match a specified name
        *       or recording-configuration ARN. Filters are mutually exclusive and cannot be used together. If
        *       you try to use both filters, you will get an error (409 ConflictException).</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, ListChannelsCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, ListChannelsCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new ListChannelsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListChannelsCommandInput} for command's `input` shape.
        * @see {@link ListChannelsCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class ListChannelsCommand extends $Command<ListChannelsCommandInput, ListChannelsCommandOutput, IvsClientResolvedConfig> {
            readonly input: ListChannelsCommandInput;
            constructor(input: ListChannelsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListChannelsCommandInput, ListChannelsCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ListPlaybackKeyPairsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { ListPlaybackKeyPairsRequest, ListPlaybackKeyPairsResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface ListPlaybackKeyPairsCommandInput extends ListPlaybackKeyPairsRequest {
    }
    export interface ListPlaybackKeyPairsCommandOutput extends ListPlaybackKeyPairsResponse, __MetadataBearer {
    }
    /**
        * <p>Gets summary information about playback key pairs. For more information, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/private-channels.html">Setting Up Private
        *         Channels</a> in the <i>Amazon IVS User Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, ListPlaybackKeyPairsCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, ListPlaybackKeyPairsCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new ListPlaybackKeyPairsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListPlaybackKeyPairsCommandInput} for command's `input` shape.
        * @see {@link ListPlaybackKeyPairsCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class ListPlaybackKeyPairsCommand extends $Command<ListPlaybackKeyPairsCommandInput, ListPlaybackKeyPairsCommandOutput, IvsClientResolvedConfig> {
            readonly input: ListPlaybackKeyPairsCommandInput;
            constructor(input: ListPlaybackKeyPairsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListPlaybackKeyPairsCommandInput, ListPlaybackKeyPairsCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ListRecordingConfigurationsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { ListRecordingConfigurationsRequest, ListRecordingConfigurationsResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface ListRecordingConfigurationsCommandInput extends ListRecordingConfigurationsRequest {
    }
    export interface ListRecordingConfigurationsCommandOutput extends ListRecordingConfigurationsResponse, __MetadataBearer {
    }
    /**
        * <p>Gets summary information about all recording configurations in your account, in the
        *         Amazon Web Services region where the API request is processed.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, ListRecordingConfigurationsCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, ListRecordingConfigurationsCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new ListRecordingConfigurationsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListRecordingConfigurationsCommandInput} for command's `input` shape.
        * @see {@link ListRecordingConfigurationsCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class ListRecordingConfigurationsCommand extends $Command<ListRecordingConfigurationsCommandInput, ListRecordingConfigurationsCommandOutput, IvsClientResolvedConfig> {
            readonly input: ListRecordingConfigurationsCommandInput;
            constructor(input: ListRecordingConfigurationsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListRecordingConfigurationsCommandInput, ListRecordingConfigurationsCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ListStreamKeysCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { ListStreamKeysRequest, ListStreamKeysResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface ListStreamKeysCommandInput extends ListStreamKeysRequest {
    }
    export interface ListStreamKeysCommandOutput extends ListStreamKeysResponse, __MetadataBearer {
    }
    /**
        * <p>Gets summary information about stream keys for the specified channel.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, ListStreamKeysCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, ListStreamKeysCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new ListStreamKeysCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListStreamKeysCommandInput} for command's `input` shape.
        * @see {@link ListStreamKeysCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class ListStreamKeysCommand extends $Command<ListStreamKeysCommandInput, ListStreamKeysCommandOutput, IvsClientResolvedConfig> {
            readonly input: ListStreamKeysCommandInput;
            constructor(input: ListStreamKeysCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListStreamKeysCommandInput, ListStreamKeysCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ListStreamsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { ListStreamsRequest, ListStreamsResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface ListStreamsCommandInput extends ListStreamsRequest {
    }
    export interface ListStreamsCommandOutput extends ListStreamsResponse, __MetadataBearer {
    }
    /**
        * <p>Gets summary information about live streams in your account, in the Amazon Web Services
        *       region where the API request is processed.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, ListStreamsCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, ListStreamsCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new ListStreamsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListStreamsCommandInput} for command's `input` shape.
        * @see {@link ListStreamsCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class ListStreamsCommand extends $Command<ListStreamsCommandInput, ListStreamsCommandOutput, IvsClientResolvedConfig> {
            readonly input: ListStreamsCommandInput;
            constructor(input: ListStreamsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListStreamsCommandInput, ListStreamsCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ListStreamSessionsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { ListStreamSessionsRequest, ListStreamSessionsResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface ListStreamSessionsCommandInput extends ListStreamSessionsRequest {
    }
    export interface ListStreamSessionsCommandOutput extends ListStreamSessionsResponse, __MetadataBearer {
    }
    /**
        * <p>Gets a summary of current and previous streams for a specified channel in your account, in
        *       the AWS region where the API request is processed.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, ListStreamSessionsCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, ListStreamSessionsCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new ListStreamSessionsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListStreamSessionsCommandInput} for command's `input` shape.
        * @see {@link ListStreamSessionsCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class ListStreamSessionsCommand extends $Command<ListStreamSessionsCommandInput, ListStreamSessionsCommandOutput, IvsClientResolvedConfig> {
            readonly input: ListStreamSessionsCommandInput;
            constructor(input: ListStreamSessionsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListStreamSessionsCommandInput, ListStreamSessionsCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ListTagsForResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { ListTagsForResourceRequest, ListTagsForResourceResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface ListTagsForResourceCommandInput extends ListTagsForResourceRequest {
    }
    export interface ListTagsForResourceCommandOutput extends ListTagsForResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Gets information about Amazon Web Services tags for the specified ARN.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, ListTagsForResourceCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, ListTagsForResourceCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new ListTagsForResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTagsForResourceCommandInput} for command's `input` shape.
        * @see {@link ListTagsForResourceCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class ListTagsForResourceCommand extends $Command<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput, IvsClientResolvedConfig> {
            readonly input: ListTagsForResourceCommandInput;
            constructor(input: ListTagsForResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/PutMetadataCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { PutMetadataRequest } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface PutMetadataCommandInput extends PutMetadataRequest {
    }
    export interface PutMetadataCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Inserts metadata into the active stream of the specified channel. At most 5 requests per
        *       second per channel are allowed, each with a maximum 1 KB payload. (If 5 TPS is not sufficient
        *       for your needs, we recommend batching your data into a single PutMetadata call.) At most 155
        *       requests per second per account are allowed. Also see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/metadata.html">Embedding Metadata within a Video Stream</a> in
        *       the <i>Amazon IVS User Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, PutMetadataCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, PutMetadataCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new PutMetadataCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutMetadataCommandInput} for command's `input` shape.
        * @see {@link PutMetadataCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class PutMetadataCommand extends $Command<PutMetadataCommandInput, PutMetadataCommandOutput, IvsClientResolvedConfig> {
            readonly input: PutMetadataCommandInput;
            constructor(input: PutMetadataCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutMetadataCommandInput, PutMetadataCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/StopStreamCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { StopStreamRequest, StopStreamResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface StopStreamCommandInput extends StopStreamRequest {
    }
    export interface StopStreamCommandOutput extends StopStreamResponse, __MetadataBearer {
    }
    /**
        * <p>Disconnects the incoming RTMPS stream for the specified channel. Can be used in
        *       conjunction with <a>DeleteStreamKey</a> to prevent further streaming to a
        *       channel.</p>
        *          <note>
        *             <p>Many streaming client-software libraries automatically reconnect a dropped RTMPS
        *         session, so to stop the stream permanently, you may want to first revoke the
        *           <code>streamKey</code> attached to the channel.</p>
        *          </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, StopStreamCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, StopStreamCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new StopStreamCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link StopStreamCommandInput} for command's `input` shape.
        * @see {@link StopStreamCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class StopStreamCommand extends $Command<StopStreamCommandInput, StopStreamCommandOutput, IvsClientResolvedConfig> {
            readonly input: StopStreamCommandInput;
            constructor(input: StopStreamCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<StopStreamCommandInput, StopStreamCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/TagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { TagResourceRequest, TagResourceResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface TagResourceCommandInput extends TagResourceRequest {
    }
    export interface TagResourceCommandOutput extends TagResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Adds or updates tags for the Amazon Web Services resource with the specified ARN.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, TagResourceCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, TagResourceCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new TagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TagResourceCommandInput} for command's `input` shape.
        * @see {@link TagResourceCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class TagResourceCommand extends $Command<TagResourceCommandInput, TagResourceCommandOutput, IvsClientResolvedConfig> {
            readonly input: TagResourceCommandInput;
            constructor(input: TagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TagResourceCommandInput, TagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/UntagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { UntagResourceRequest, UntagResourceResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface UntagResourceCommandInput extends UntagResourceRequest {
    }
    export interface UntagResourceCommandOutput extends UntagResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Removes tags from the resource with the specified ARN.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, UntagResourceCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, UntagResourceCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new UntagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UntagResourceCommandInput} for command's `input` shape.
        * @see {@link UntagResourceCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class UntagResourceCommand extends $Command<UntagResourceCommandInput, UntagResourceCommandOutput, IvsClientResolvedConfig> {
            readonly input: UntagResourceCommandInput;
            constructor(input: UntagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UntagResourceCommandInput, UntagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/UpdateChannelCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { IvsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient";
    import { UpdateChannelRequest, UpdateChannelResponse } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0";
    export interface UpdateChannelCommandInput extends UpdateChannelRequest {
    }
    export interface UpdateChannelCommandOutput extends UpdateChannelResponse, __MetadataBearer {
    }
    /**
        * <p>Updates a channel's configuration. This does not affect an ongoing stream of this channel.
        *       You must stop and restart the stream for the changes to take effect.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { IvsClient, UpdateChannelCommand } from "@aws-sdk/client-ivs"; // ES Modules import
        * // const { IvsClient, UpdateChannelCommand } = require("@aws-sdk/client-ivs"); // CommonJS import
        * const client = new IvsClient(config);
        * const command = new UpdateChannelCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateChannelCommandInput} for command's `input` shape.
        * @see {@link UpdateChannelCommandOutput} for command's `response` shape.
        * @see {@link IvsClientResolvedConfig | config} for IvsClient's `config` shape.
        *
        */
    export class UpdateChannelCommand extends $Command<UpdateChannelCommandInput, UpdateChannelCommandOutput, IvsClientResolvedConfig> {
            readonly input: UpdateChannelCommandInput;
            constructor(input: UpdateChannelCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: IvsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateChannelCommandInput, UpdateChannelCommandOutput>;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/IvsClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { BatchGetChannelCommandInput, BatchGetChannelCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/BatchGetChannelCommand";
    import { BatchGetStreamKeyCommandInput, BatchGetStreamKeyCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/BatchGetStreamKeyCommand";
    import { CreateChannelCommandInput, CreateChannelCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/CreateChannelCommand";
    import { CreateRecordingConfigurationCommandInput, CreateRecordingConfigurationCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/CreateRecordingConfigurationCommand";
    import { CreateStreamKeyCommandInput, CreateStreamKeyCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/CreateStreamKeyCommand";
    import { DeleteChannelCommandInput, DeleteChannelCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/DeleteChannelCommand";
    import { DeletePlaybackKeyPairCommandInput, DeletePlaybackKeyPairCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/DeletePlaybackKeyPairCommand";
    import { DeleteRecordingConfigurationCommandInput, DeleteRecordingConfigurationCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/DeleteRecordingConfigurationCommand";
    import { DeleteStreamKeyCommandInput, DeleteStreamKeyCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/DeleteStreamKeyCommand";
    import { GetChannelCommandInput, GetChannelCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/GetChannelCommand";
    import { GetPlaybackKeyPairCommandInput, GetPlaybackKeyPairCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/GetPlaybackKeyPairCommand";
    import { GetRecordingConfigurationCommandInput, GetRecordingConfigurationCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/GetRecordingConfigurationCommand";
    import { GetStreamCommandInput, GetStreamCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/GetStreamCommand";
    import { GetStreamKeyCommandInput, GetStreamKeyCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/GetStreamKeyCommand";
    import { GetStreamSessionCommandInput, GetStreamSessionCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/GetStreamSessionCommand";
    import { ImportPlaybackKeyPairCommandInput, ImportPlaybackKeyPairCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ImportPlaybackKeyPairCommand";
    import { ListChannelsCommandInput, ListChannelsCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ListChannelsCommand";
    import { ListPlaybackKeyPairsCommandInput, ListPlaybackKeyPairsCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ListPlaybackKeyPairsCommand";
    import { ListRecordingConfigurationsCommandInput, ListRecordingConfigurationsCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ListRecordingConfigurationsCommand";
    import { ListStreamKeysCommandInput, ListStreamKeysCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ListStreamKeysCommand";
    import { ListStreamsCommandInput, ListStreamsCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ListStreamsCommand";
    import { ListStreamSessionsCommandInput, ListStreamSessionsCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ListStreamSessionsCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/ListTagsForResourceCommand";
    import { PutMetadataCommandInput, PutMetadataCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/PutMetadataCommand";
    import { StopStreamCommandInput, StopStreamCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/StopStreamCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/UntagResourceCommand";
    import { UpdateChannelCommandInput, UpdateChannelCommandOutput } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/commands/UpdateChannelCommand";
    export type ServiceInputTypes = BatchGetChannelCommandInput | BatchGetStreamKeyCommandInput | CreateChannelCommandInput | CreateRecordingConfigurationCommandInput | CreateStreamKeyCommandInput | DeleteChannelCommandInput | DeletePlaybackKeyPairCommandInput | DeleteRecordingConfigurationCommandInput | DeleteStreamKeyCommandInput | GetChannelCommandInput | GetPlaybackKeyPairCommandInput | GetRecordingConfigurationCommandInput | GetStreamCommandInput | GetStreamKeyCommandInput | GetStreamSessionCommandInput | ImportPlaybackKeyPairCommandInput | ListChannelsCommandInput | ListPlaybackKeyPairsCommandInput | ListRecordingConfigurationsCommandInput | ListStreamKeysCommandInput | ListStreamSessionsCommandInput | ListStreamsCommandInput | ListTagsForResourceCommandInput | PutMetadataCommandInput | StopStreamCommandInput | TagResourceCommandInput | UntagResourceCommandInput | UpdateChannelCommandInput;
    export type ServiceOutputTypes = BatchGetChannelCommandOutput | BatchGetStreamKeyCommandOutput | CreateChannelCommandOutput | CreateRecordingConfigurationCommandOutput | CreateStreamKeyCommandOutput | DeleteChannelCommandOutput | DeletePlaybackKeyPairCommandOutput | DeleteRecordingConfigurationCommandOutput | DeleteStreamKeyCommandOutput | GetChannelCommandOutput | GetPlaybackKeyPairCommandOutput | GetRecordingConfigurationCommandOutput | GetStreamCommandOutput | GetStreamKeyCommandOutput | GetStreamSessionCommandOutput | ImportPlaybackKeyPairCommandOutput | ListChannelsCommandOutput | ListPlaybackKeyPairsCommandOutput | ListRecordingConfigurationsCommandOutput | ListStreamKeysCommandOutput | ListStreamSessionsCommandOutput | ListStreamsCommandOutput | ListTagsForResourceCommandOutput | PutMetadataCommandOutput | StopStreamCommandOutput | TagResourceCommandOutput | UntagResourceCommandOutput | UpdateChannelCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type IvsClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of IvsClient class constructor that set the region, credentials and other options.
        */
    export interface IvsClientConfig extends IvsClientConfigType {
    }
    type IvsClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of IvsClient class. This is resolved and normalized from the {@link IvsClientConfig | constructor configuration interface}.
        */
    export interface IvsClientResolvedConfig extends IvsClientResolvedConfigType {
    }
    /**
        * <p>
        *             <b>Introduction</b>
        *          </p>
        *          <p>The Amazon Interactive Video Service (IVS) API is REST compatible, using a standard HTTP
        *       API and an Amazon Web Services EventBridge event stream for responses. JSON is used for both
        *       requests and responses, including errors.</p>
        *          <p>The API is an Amazon Web Services regional service. For a list of supported regions and
        *       Amazon IVS HTTPS service endpoints, see the <a href="https://docs.aws.amazon.com/general/latest/gr/ivs.html">Amazon IVS page</a> in the
        *           <i>Amazon Web Services General Reference</i>.</p>
        *          <p>
        *             <i>
        *                <b>All API request parameters and URLs are case sensitive.
        *         </b>
        *             </i>
        *          </p>
        *          <p>For a summary of notable documentation changes in each release, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/doc-history.html"> Document
        *       History</a>.</p>
        *          <p>
        *             <b>Allowed Header Values</b>
        *          </p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <code>
        *                      <b>Accept:</b>
        *                   </code> application/json</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <code>
        *                      <b>Accept-Encoding:</b>
        *                   </code> gzip, deflate</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <code>
        *                      <b>Content-Type:</b>
        *                   </code>application/json</p>
        *             </li>
        *          </ul>
        *          <p>
        *             <b>Resources</b>
        *          </p>
        *          <p>The following resources contain information about your IVS live stream (see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/getting-started.html"> Getting Started with
        *         Amazon IVS</a>):</p>
        *          <ul>
        *             <li>
        *                <p>Channel — Stores configuration data related to your live stream. You first create a
        *           channel and then use the channel’s stream key to start your live stream. See the Channel
        *           endpoints for more information. </p>
        *             </li>
        *             <li>
        *                <p>Stream key — An identifier assigned by Amazon IVS when you create a channel, which is
        *           then used to authorize streaming. See the StreamKey endpoints for more information.
        *               <i>
        *                      <b>Treat the stream key like a secret, since it allows
        *               anyone to stream to the channel.</b>
        *                   </i>
        *                </p>
        *             </li>
        *             <li>
        *                <p>Playback key pair — Video playback may be restricted using playback-authorization
        *           tokens, which use public-key encryption. A playback key pair is the public-private pair of
        *           keys used to sign and validate the playback-authorization token. See the PlaybackKeyPair
        *           endpoints for more information.</p>
        *             </li>
        *             <li>
        *                <p>Recording configuration — Stores configuration related to recording a live stream and
        *           where to store the recorded content. Multiple channels can reference the same recording
        *           configuration. See the Recording Configuration endpoints for more information.</p>
        *             </li>
        *          </ul>
        *          <p>
        *             <b>Tagging</b>
        *          </p>
        *          <p>A <i>tag</i> is a metadata label that you assign to an Amazon Web Services
        *       resource. A tag comprises a <i>key</i> and a <i>value</i>, both
        *       set by you. For example, you might set a tag as <code>topic:nature</code> to label a
        *       particular video category. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services Resources</a> for
        *       more information, including restrictions that apply to tags.</p>
        *          <p>Tags can help you identify and organize your Amazon Web Services resources. For example,
        *       you can use the same tag for different resources to indicate that they are related. You can
        *       also use tags to manage access (see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_tags.html"> Access Tags</a>). </p>
        *          <p>The Amazon IVS API has these tag-related endpoints: <a>TagResource</a>, <a>UntagResource</a>, and <a>ListTagsForResource</a>. The following
        *       resources support tagging: Channels, Stream Keys, Playback Key Pairs, and Recording
        *       Configurations.</p>
        *          <p>At most 50 tags can be applied to a resource. </p>
        *          <p>
        *             <b>Authentication versus Authorization</b>
        *          </p>
        *          <p>Note the differences between these concepts:</p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <i>Authentication</i> is about verifying identity. You need to be
        *           authenticated to sign Amazon IVS API requests.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <i>Authorization</i> is about granting permissions. You need to be
        *           authorized to view <a href="https://docs.aws.amazon.com/ivs/latest/userguide/private-channels.html">Amazon IVS private channels</a>.
        *           (Private channels are channels that are enabled for "playback authorization.")</p>
        *             </li>
        *          </ul>
        *          <p>
        *             <b>Authentication</b>
        *          </p>
        *          <p>All Amazon IVS API requests must be authenticated with a signature. The Amazon Web Services
        *       Command-Line Interface (CLI) and Amazon IVS Player SDKs take care of signing the underlying
        *       API calls for you. However, if your application calls the Amazon IVS API directly, it’s your
        *       responsibility to sign the requests.</p>
        *          <p>You generate a signature using valid Amazon Web Services credentials that have permission
        *       to perform the requested action. For example, you must sign PutMetadata requests with a
        *       signature generated from an IAM user account that has the <code>ivs:PutMetadata</code>
        *       permission.</p>
        *          <p>For more information:</p>
        *          <ul>
        *             <li>
        *                <p>Authentication and generating signatures — See <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-authenticating-requests.html">Authenticating Requests
        *               (Amazon Web Services Signature Version 4)</a> in the <i>Amazon Web Services
        *             General Reference</i>.</p>
        *             </li>
        *             <li>
        *                <p>Managing Amazon IVS permissions — See <a href="https://docs.aws.amazon.com/ivs/latest/userguide/security-iam.html">Identity and Access Management</a> on
        *           the Security page of the <i>Amazon IVS User Guide</i>.</p>
        *             </li>
        *          </ul>
        *          <p>
        *             <b>Channel Endpoints</b>
        *          </p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <a>CreateChannel</a> — Creates a new channel and an associated stream
        *           key to start streaming.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>GetChannel</a> — Gets the channel configuration for the specified
        *           channel ARN (Amazon Resource Name).</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>BatchGetChannel</a> — Performs <a>GetChannel</a> on
        *           multiple ARNs simultaneously.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>ListChannels</a> — Gets summary information about all channels in
        *           your account, in the Amazon Web Services region where the API request is processed. This
        *           list can be filtered to match a specified name or recording-configuration ARN. Filters are
        *           mutually exclusive and cannot be used together. If you try to use both filters, you will
        *           get an error (409 Conflict Exception).</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>UpdateChannel</a> — Updates a channel's configuration. This does
        *           not affect an ongoing stream of this channel. You must stop and restart the stream for the
        *           changes to take effect.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>DeleteChannel</a> — Deletes the specified channel.</p>
        *             </li>
        *          </ul>
        *          <p>
        *             <b>StreamKey Endpoints</b>
        *          </p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <a>CreateStreamKey</a> — Creates a stream key, used to initiate a
        *           stream, for the specified channel ARN.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>GetStreamKey</a> — Gets stream key information for the specified
        *           ARN.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>BatchGetStreamKey</a> — Performs <a>GetStreamKey</a> on
        *           multiple ARNs simultaneously.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>ListStreamKeys</a> — Gets summary information about stream keys
        *           for the specified channel.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>DeleteStreamKey</a> — Deletes the stream key for the specified
        *           ARN, so it can no longer be used to stream.</p>
        *             </li>
        *          </ul>
        *          <p>
        *             <b>Stream Endpoints</b>
        *          </p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <a>GetStream</a> — Gets information about the active (live) stream on
        *           a specified channel.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>GetStreamSession</a> — Gets metadata on a specified stream.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>ListStreams</a> — Gets summary information about live streams in
        *           your account, in the Amazon Web Services region where the API request is processed.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>ListStreamSessions</a> — Gets a summary of current and previous
        *           streams for a specified channel in your account, in the AWS region where the API request
        *           is processed.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>StopStream</a> — Disconnects the incoming RTMPS stream for the
        *           specified channel. Can be used in conjunction with <a>DeleteStreamKey</a> to
        *           prevent further streaming to a channel.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>PutMetadata</a> — Inserts metadata into the active stream of the
        *           specified channel. At most 5 requests per second per channel are allowed, each with a
        *           maximum 1 KB payload. (If 5 TPS is not sufficient for your needs, we recommend batching
        *           your data into a single PutMetadata call.) At most 155 requests per second per account are
        *           allowed.</p>
        *             </li>
        *          </ul>
        *          <p>
        *             <b>PlaybackKeyPair Endpoints</b>
        *          </p>
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/private-channels.html">Setting Up Private Channels</a> in the
        *         <i>Amazon IVS User Guide</i>.</p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <a>ImportPlaybackKeyPair</a> — Imports the public portion of a new
        *           key pair and returns its <code>arn</code> and <code>fingerprint</code>. The
        *             <code>privateKey</code> can then be used to generate viewer authorization tokens, to
        *           grant viewers access to private channels (channels enabled for playback
        *           authorization).</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>GetPlaybackKeyPair</a> — Gets a specified playback authorization
        *           key pair and returns the <code>arn</code> and <code>fingerprint</code>. The
        *             <code>privateKey</code> held by the caller can be used to generate viewer authorization
        *           tokens, to grant viewers access to private channels.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>ListPlaybackKeyPairs</a> — Gets summary information about playback
        *           key pairs.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>DeletePlaybackKeyPair</a> — Deletes a specified authorization key
        *           pair. This invalidates future viewer tokens generated using the key pair’s
        *             <code>privateKey</code>.</p>
        *             </li>
        *          </ul>
        *          <p>
        *             <b>RecordingConfiguration Endpoints</b>
        *          </p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <a>CreateRecordingConfiguration</a> — Creates a new recording
        *           configuration, used to enable recording to Amazon S3.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>GetRecordingConfiguration</a> — Gets the recording-configuration
        *           metadata for the specified ARN.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>ListRecordingConfigurations</a> — Gets summary information about
        *           all recording configurations in your account, in the Amazon Web Services region where the
        *           API request is processed.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>DeleteRecordingConfiguration</a> — Deletes the recording
        *           configuration for the specified ARN.</p>
        *             </li>
        *          </ul>
        *          <p>
        *             <b>Amazon Web Services Tags Endpoints</b>
        *          </p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <a>TagResource</a> — Adds or updates tags for the Amazon Web Services
        *           resource with the specified ARN.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>UntagResource</a> — Removes tags from the resource with the
        *           specified ARN.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a>ListTagsForResource</a> — Gets information about Amazon Web Services tags for the specified ARN.</p>
        *             </li>
        *          </ul>
        */
    export class IvsClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, IvsClientResolvedConfig> {
            /**
                * The resolved configuration of IvsClient class. This is resolved and normalized from the {@link IvsClientConfig | constructor configuration interface}.
                */
            readonly config: IvsClientResolvedConfig;
            constructor(configuration: IvsClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { IvsServiceException as __BaseException } from "@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/IvsServiceException";
    /**
        * <p/>
        */
    export class AccessDeniedException extends __BaseException {
            readonly name: "AccessDeniedException";
            readonly $fault: "client";
            /**
                * <p>User does not have sufficient access to perform this action.</p>
                */
            exceptionMessage?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AccessDeniedException, __BaseException>);
    }
    export interface BatchGetChannelRequest {
            /**
                * <p>Array of ARNs, one per channel.</p>
                */
            arns: string[] | undefined;
    }
    export namespace BatchGetChannelRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetChannelRequest) => any;
    }
    export enum ChannelLatencyMode {
            LowLatency = "LOW",
            NormalLatency = "NORMAL"
    }
    export enum ChannelType {
            BasicChannelType = "BASIC",
            StandardChannelType = "STANDARD"
    }
    /**
        * <p>Object specifying a channel.</p>
        */
    export interface Channel {
            /**
                * <p>Channel ARN.</p>
                */
            arn?: string;
            /**
                * <p>Channel name.</p>
                */
            name?: string;
            /**
                * <p>Channel latency mode. Use <code>NORMAL</code> to broadcast and deliver live video up to
                *       Full HD. Use <code>LOW</code> for near-real-time interaction with viewers. Default:
                *         <code>LOW</code>. (Note: In the Amazon IVS console, <code>LOW</code> and <code>NORMAL</code>
                *       correspond to Ultra-low and Standard, respectively.)</p>
                */
            latencyMode?: ChannelLatencyMode | string;
            /**
                * <p>Channel type, which determines the allowable resolution and bitrate. <i>If you
                *         exceed the allowable resolution or bitrate, the stream probably will disconnect
                *         immediately.</i> Default: <code>STANDARD</code>. Valid values:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>STANDARD</code>: Multiple qualities are generated from the original input, to
                *           automatically give viewers the best experience for their devices and network conditions.
                *           Resolution can be up to 1080p and bitrate can be up to 8.5 Mbps. Audio is transcoded only
                *           for renditions 360p and below; above that, audio is passed through.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>BASIC</code>: Amazon IVS delivers the original input to viewers. The viewer’s
                *           video-quality choice is limited to the original input. Resolution can be up to 480p and
                *           bitrate can be up to 1.5 Mbps.</p>
                *             </li>
                *          </ul>
                */
            type?: ChannelType | string;
            /**
                * <p>Recording-configuration ARN. A value other than an empty string indicates that recording
                *       is enabled. Default: "" (empty string, recording is disabled).</p>
                */
            recordingConfigurationArn?: string;
            /**
                * <p>Channel ingest endpoint, part of the definition of an ingest server, used when you set up
                *       streaming software.</p>
                */
            ingestEndpoint?: string;
            /**
                * <p>Channel playback URL.</p>
                */
            playbackUrl?: string;
            /**
                * <p>Whether the channel is private (enabled for playback authorization). Default:
                *         <code>false</code>.</p>
                */
            authorized?: boolean;
            /**
                * <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace Channel {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Channel) => any;
    }
    /**
        * <p>Error related to a specific channel, specified by its ARN.</p>
        */
    export interface BatchError {
            /**
                * <p>Channel ARN.</p>
                */
            arn?: string;
            /**
                * <p>Error code.</p>
                */
            code?: string;
            /**
                * <p>Error message, determined by the application.</p>
                */
            message?: string;
    }
    export namespace BatchError {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchError) => any;
    }
    export interface BatchGetChannelResponse {
            /**
                * <p/>
                */
            channels?: Channel[];
            /**
                * <p>Each error object is related to a specific ARN in the request.</p>
                */
            errors?: BatchError[];
    }
    export namespace BatchGetChannelResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetChannelResponse) => any;
    }
    export interface BatchGetStreamKeyRequest {
            /**
                * <p>Array of ARNs, one per channel.</p>
                */
            arns: string[] | undefined;
    }
    export namespace BatchGetStreamKeyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetStreamKeyRequest) => any;
    }
    /**
        * <p>Object specifying a stream key.</p>
        */
    export interface StreamKey {
            /**
                * <p>Stream-key ARN.</p>
                */
            arn?: string;
            /**
                * <p>Stream-key value.</p>
                */
            value?: string;
            /**
                * <p>Channel ARN for the stream.</p>
                */
            channelArn?: string;
            /**
                * <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace StreamKey {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StreamKey) => any;
    }
    export interface BatchGetStreamKeyResponse {
            /**
                * <p/>
                */
            streamKeys?: StreamKey[];
            /**
                * <p/>
                */
            errors?: BatchError[];
    }
    export namespace BatchGetStreamKeyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetStreamKeyResponse) => any;
    }
    export interface CreateChannelRequest {
            /**
                * <p>Channel name.</p>
                */
            name?: string;
            /**
                * <p>Channel latency mode. Use <code>NORMAL</code> to broadcast and deliver live video up to
                *       Full HD. Use <code>LOW</code> for near-real-time interaction with viewers. (Note: In the
                *       Amazon IVS console, <code>LOW</code> and <code>NORMAL</code> correspond to Ultra-low and
                *       Standard, respectively.) Default: <code>LOW</code>.</p>
                */
            latencyMode?: ChannelLatencyMode | string;
            /**
                * <p>Channel type, which determines the allowable resolution and bitrate. <i>If you
                *         exceed the allowable resolution or bitrate, the stream probably will disconnect
                *         immediately.</i> Default: <code>STANDARD</code>. Valid values:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>STANDARD</code>: Multiple qualities are generated from the original input, to
                *           automatically give viewers the best experience for their devices and network conditions.
                *           Resolution can be up to 1080p and bitrate can be up to 8.5 Mbps. Audio is transcoded only
                *           for renditions 360p and below; above that, audio is passed through.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>BASIC</code>: Amazon IVS delivers the original input to viewers. The viewer’s
                *           video-quality choice is limited to the original input. Resolution can be up to 480p and
                *           bitrate can be up to 1.5 Mbps.</p>
                *             </li>
                *          </ul>
                */
            type?: ChannelType | string;
            /**
                * <p>Whether the channel is private (enabled for playback authorization). Default:
                *         <code>false</code>.</p>
                */
            authorized?: boolean;
            /**
                * <p>Recording-configuration ARN. Default: "" (empty string, recording is disabled).</p>
                */
            recordingConfigurationArn?: string;
            /**
                * <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace CreateChannelRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateChannelRequest) => any;
    }
    export interface CreateChannelResponse {
            /**
                * <p/>
                */
            channel?: Channel;
            /**
                * <p/>
                */
            streamKey?: StreamKey;
    }
    export namespace CreateChannelResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateChannelResponse) => any;
    }
    /**
        * <p/>
        */
    export class PendingVerification extends __BaseException {
            readonly name: "PendingVerification";
            readonly $fault: "client";
            /**
                * <p> Your account is pending verification. </p>
                */
            exceptionMessage?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<PendingVerification, __BaseException>);
    }
    /**
        * <p/>
        */
    export class ResourceNotFoundException extends __BaseException {
            readonly name: "ResourceNotFoundException";
            readonly $fault: "client";
            /**
                * <p>Request references a resource which does not exist.</p>
                */
            exceptionMessage?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>);
    }
    /**
        * <p/>
        */
    export class ServiceQuotaExceededException extends __BaseException {
            readonly name: "ServiceQuotaExceededException";
            readonly $fault: "client";
            /**
                * <p>Request would cause a service quota to be exceeded.</p>
                */
            exceptionMessage?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ServiceQuotaExceededException, __BaseException>);
    }
    /**
        * <p/>
        */
    export class ValidationException extends __BaseException {
            readonly name: "ValidationException";
            readonly $fault: "client";
            /**
                * <p>The input fails to satisfy the constraints specified by an Amazon Web Services service.</p>
                */
            exceptionMessage?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ValidationException, __BaseException>);
    }
    /**
        * <p/>
        */
    export class ConflictException extends __BaseException {
            readonly name: "ConflictException";
            readonly $fault: "client";
            /**
                * <p>Updating or deleting a resource can cause an inconsistent state.</p>
                */
            exceptionMessage?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ConflictException, __BaseException>);
    }
    /**
        * <p>A complex type that describes an S3 location where recorded videos will be stored.</p>
        */
    export interface S3DestinationConfiguration {
            /**
                * <p>Location (S3 bucket name) where recorded videos will be stored.</p>
                */
            bucketName: string | undefined;
    }
    export namespace S3DestinationConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: S3DestinationConfiguration) => any;
    }
    /**
        * <p>A complex type that describes a location where recorded videos will be stored. Each member
        *       represents a type of destination configuration. For recording, you define one and only one
        *       type of destination configuration.</p>
        */
    export interface DestinationConfiguration {
            /**
                * <p>An S3 destination configuration where recorded videos will be stored.</p>
                */
            s3?: S3DestinationConfiguration;
    }
    export namespace DestinationConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DestinationConfiguration) => any;
    }
    export enum RecordingMode {
            Disabled = "DISABLED",
            Interval = "INTERVAL"
    }
    /**
        * <p>An object representing a configuration of thumbnails for recorded video.</p>
        */
    export interface ThumbnailConfiguration {
            /**
                * <p>Thumbnail recording mode. Default: <code>INTERVAL</code>.</p>
                */
            recordingMode?: RecordingMode | string;
            /**
                * <p>The targeted thumbnail-generation interval in seconds. This is configurable (and required)
                *       only if <code>recordingMode</code> is <code>INTERVAL</code>. Default: 60.</p>
                *          <p>
                *             <b>Important:</b> Setting a value for <code>targetIntervalSeconds</code> does not guarantee that thumbnails
                *       are generated at the specified interval. For thumbnails to be generated at the
                *       <code>targetIntervalSeconds</code> interval, the <code>IDR/Keyframe</code> value for the input video must be less than
                *       the <code>targetIntervalSeconds</code> value. See <a href="https://docs.aws.amazon.com/ivs/latest/userguide/streaming-config.html"> Amazon IVS Streaming Configuration</a> for information on
                *       setting <code>IDR/Keyframe</code> to the recommended value in video-encoder settings.</p>
                */
            targetIntervalSeconds?: number;
    }
    export namespace ThumbnailConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ThumbnailConfiguration) => any;
    }
    export interface CreateRecordingConfigurationRequest {
            /**
                * <p>Recording-configuration name. The value does not need to be unique.</p>
                */
            name?: string;
            /**
                * <p>A complex type that contains a destination configuration for where recorded video will be
                *       stored.</p>
                */
            destinationConfiguration: DestinationConfiguration | undefined;
            /**
                * <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
                */
            tags?: Record<string, string>;
            /**
                * <p>A complex type that allows you to enable/disable the recording of thumbnails for a live
                *       session and modify the interval at which thumbnails are generated for the live session.</p>
                */
            thumbnailConfiguration?: ThumbnailConfiguration;
    }
    export namespace CreateRecordingConfigurationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateRecordingConfigurationRequest) => any;
    }
    export enum RecordingConfigurationState {
            Active = "ACTIVE",
            CreateFailed = "CREATE_FAILED",
            Creating = "CREATING"
    }
    /**
        * <p>An object representing a configuration to record a channel stream.</p>
        */
    export interface RecordingConfiguration {
            /**
                * <p>Recording-configuration ARN.</p>
                */
            arn: string | undefined;
            /**
                * <p>Recording-configuration name. The value does not need to be unique.</p>
                */
            name?: string;
            /**
                * <p>A complex type that contains information about where recorded video will be stored.</p>
                */
            destinationConfiguration: DestinationConfiguration | undefined;
            /**
                * <p>Indicates the current state of the recording configuration. When the state is
                *         <code>ACTIVE</code>, the configuration is ready for recording a channel stream.</p>
                */
            state: RecordingConfigurationState | string | undefined;
            /**
                * <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
                */
            tags?: Record<string, string>;
            /**
                * <p>A complex type that allows you to enable/disable the recording of thumbnails for a live
                *       session and modify the interval at which thumbnails are generated for the live session.</p>
                */
            thumbnailConfiguration?: ThumbnailConfiguration;
    }
    export namespace RecordingConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RecordingConfiguration) => any;
    }
    export interface CreateRecordingConfigurationResponse {
            /**
                *
                */
            recordingConfiguration?: RecordingConfiguration;
    }
    export namespace CreateRecordingConfigurationResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateRecordingConfigurationResponse) => any;
    }
    /**
        * <p/>
        */
    export class InternalServerException extends __BaseException {
            readonly name: "InternalServerException";
            readonly $fault: "server";
            /**
                * <p>Unexpected error during processing of request.</p>
                */
            exceptionMessage?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InternalServerException, __BaseException>);
    }
    export interface CreateStreamKeyRequest {
            /**
                * <p>ARN of the channel for which to create the stream key.</p>
                */
            channelArn: string | undefined;
            /**
                * <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace CreateStreamKeyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateStreamKeyRequest) => any;
    }
    export interface CreateStreamKeyResponse {
            /**
                * <p>Stream key used to authenticate an RTMPS stream for ingestion.</p>
                */
            streamKey?: StreamKey;
    }
    export namespace CreateStreamKeyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateStreamKeyResponse) => any;
    }
    export interface DeleteChannelRequest {
            /**
                * <p>ARN of the channel to be deleted.</p>
                */
            arn: string | undefined;
    }
    export namespace DeleteChannelRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteChannelRequest) => any;
    }
    export interface DeletePlaybackKeyPairRequest {
            /**
                * <p>ARN of the key pair to be deleted.</p>
                */
            arn: string | undefined;
    }
    export namespace DeletePlaybackKeyPairRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeletePlaybackKeyPairRequest) => any;
    }
    export interface DeletePlaybackKeyPairResponse {
    }
    export namespace DeletePlaybackKeyPairResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeletePlaybackKeyPairResponse) => any;
    }
    export interface DeleteRecordingConfigurationRequest {
            /**
                * <p>ARN of the recording configuration to be deleted.</p>
                */
            arn: string | undefined;
    }
    export namespace DeleteRecordingConfigurationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteRecordingConfigurationRequest) => any;
    }
    export interface DeleteStreamKeyRequest {
            /**
                * <p>ARN of the stream key to be deleted.</p>
                */
            arn: string | undefined;
    }
    export namespace DeleteStreamKeyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteStreamKeyRequest) => any;
    }
    export interface GetChannelRequest {
            /**
                * <p>ARN of the channel for which the configuration is to be retrieved.</p>
                */
            arn: string | undefined;
    }
    export namespace GetChannelRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetChannelRequest) => any;
    }
    export interface GetChannelResponse {
            /**
                * <p/>
                */
            channel?: Channel;
    }
    export namespace GetChannelResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetChannelResponse) => any;
    }
    export interface GetPlaybackKeyPairRequest {
            /**
                * <p>ARN of the key pair to be returned.</p>
                */
            arn: string | undefined;
    }
    export namespace GetPlaybackKeyPairRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetPlaybackKeyPairRequest) => any;
    }
    /**
        * <p>A key pair used to sign and validate a playback authorization token.</p>
        */
    export interface PlaybackKeyPair {
            /**
                * <p>Key-pair ARN.</p>
                */
            arn?: string;
            /**
                * <p>Playback-key-pair name. The value does not need to be unique.</p>
                */
            name?: string;
            /**
                * <p>Key-pair identifier.</p>
                */
            fingerprint?: string;
            /**
                * <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace PlaybackKeyPair {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PlaybackKeyPair) => any;
    }
    export interface GetPlaybackKeyPairResponse {
            /**
                *
                */
            keyPair?: PlaybackKeyPair;
    }
    export namespace GetPlaybackKeyPairResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetPlaybackKeyPairResponse) => any;
    }
    export interface GetRecordingConfigurationRequest {
            /**
                * <p>ARN of the recording configuration to be retrieved.</p>
                */
            arn: string | undefined;
    }
    export namespace GetRecordingConfigurationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetRecordingConfigurationRequest) => any;
    }
    export interface GetRecordingConfigurationResponse {
            /**
                *
                */
            recordingConfiguration?: RecordingConfiguration;
    }
    export namespace GetRecordingConfigurationResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetRecordingConfigurationResponse) => any;
    }
    /**
        * <p/>
        */
    export class ChannelNotBroadcasting extends __BaseException {
            readonly name: "ChannelNotBroadcasting";
            readonly $fault: "client";
            /**
                * <p>The stream is offline for the given channel ARN.</p>
                */
            exceptionMessage?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ChannelNotBroadcasting, __BaseException>);
    }
    export interface GetStreamRequest {
            /**
                * <p>Channel ARN for stream to be accessed.</p>
                */
            channelArn: string | undefined;
    }
    export namespace GetStreamRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetStreamRequest) => any;
    }
    export enum StreamHealth {
            Starving = "STARVING",
            StreamHealthy = "HEALTHY",
            Unknown = "UNKNOWN"
    }
    export enum StreamState {
            StreamLive = "LIVE",
            StreamOffline = "OFFLINE"
    }
    /**
        * <p>Specifies a live video stream that has been ingested and distributed.</p>
        */
    export interface _Stream {
            /**
                * <p>Channel ARN for the stream.</p>
                */
            channelArn?: string;
            /**
                * <p>Unique identifier for a live or previously live stream in the specified channel.</p>
                */
            streamId?: string;
            /**
                * <p>URL of the master playlist, required by the video player to play the HLS stream.</p>
                */
            playbackUrl?: string;
            /**
                * <p>Time of the stream’s start. This is an ISO 8601 timestamp returned as a string.</p>
                */
            startTime?: Date;
            /**
                * <p>The stream’s state.</p>
                */
            state?: StreamState | string;
            /**
                * <p>The stream’s health.</p>
                */
            health?: StreamHealth | string;
            /**
                * <p>A count of concurrent views of the stream. Typically, a new view appears in
                *         <code>viewerCount</code> within 15 seconds of when video playback starts and a view is
                *       removed from <code>viewerCount</code> within 1 minute of when video playback ends. A value of
                *       -1 indicates that the request timed out; in this case, retry.</p>
                */
            viewerCount?: number;
    }
    export namespace _Stream {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: _Stream) => any;
    }
    export interface GetStreamResponse {
            /**
                * <p/>
                */
            stream?: _Stream;
    }
    export namespace GetStreamResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetStreamResponse) => any;
    }
    export interface GetStreamKeyRequest {
            /**
                * <p>ARN for the stream key to be retrieved.</p>
                */
            arn: string | undefined;
    }
    export namespace GetStreamKeyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetStreamKeyRequest) => any;
    }
    export interface GetStreamKeyResponse {
            /**
                *
                */
            streamKey?: StreamKey;
    }
    export namespace GetStreamKeyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetStreamKeyResponse) => any;
    }
    export interface GetStreamSessionRequest {
            /**
                * <p>ARN of the channel resource</p>
                */
            channelArn: string | undefined;
            /**
                * <p>Unique identifier for a live or previously live stream in the specified channel. If no
                *         <code>streamId</code> is provided, this returns the most recent stream session for the
                *       channel, if it exists.</p>
                */
            streamId?: string;
    }
    export namespace GetStreamSessionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetStreamSessionRequest) => any;
    }
    /**
        * <p>Object specifying a stream’s audio configuration.</p>
        */
    export interface AudioConfiguration {
            /**
                * <p>Codec used for the audio encoding.</p>
                */
            codec?: string;
            /**
                * <p>The expected ingest bitrate (bits per second). This is configured in the encoder.</p>
                */
            targetBitrate?: number;
            /**
                * <p>Number of audio samples recorded per second.</p>
                */
            sampleRate?: number;
            /**
                * <p>Number of audio channels.</p>
                */
            channels?: number;
    }
    export namespace AudioConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AudioConfiguration) => any;
    }
    /**
        * <p>Object specifying a stream’s video configuration.</p>
        */
    export interface VideoConfiguration {
            /**
                * <p>Indicates to the decoder the requirements for decoding the stream. For definitions of the
                *       valid values, see the H.264 specification.</p>
                */
            avcProfile?: string;
            /**
                * <p>Indicates the degree of required decoder performance for a profile. Normally this is set
                *       automatically by the encoder. For details, see the H.264 specification.</p>
                */
            avcLevel?: string;
            /**
                * <p>Codec used for the video encoding.</p>
                */
            codec?: string;
            /**
                * <p>Software or hardware used to encode the video.</p>
                */
            encoder?: string;
            /**
                * <p>The expected ingest bitrate (bits per second). This is configured in the encoder.</p>
                */
            targetBitrate?: number;
            /**
                * <p>The expected ingest framerate. This is configured in the encoder.</p>
                */
            targetFramerate?: number;
            /**
                * <p>Video-resolution height in pixels.</p>
                */
            videoHeight?: number;
            /**
                * <p>Video-resolution width in pixels.</p>
                */
            videoWidth?: number;
    }
    export namespace VideoConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: VideoConfiguration) => any;
    }
    /**
        * <p>Object specifying the ingest configuration set up by the broadcaster, usually in an
        *       encoder.</p>
        */
    export interface IngestConfiguration {
            /**
                * <p>Encoder settings for video.</p>
                */
            video?: VideoConfiguration;
            /**
                * <p>Encoder settings for audio.</p>
                */
            audio?: AudioConfiguration;
    }
    export namespace IngestConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: IngestConfiguration) => any;
    }
    /**
        * <p>Object specifying a stream’s events. For a list of events, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/eventbridge.html">Using Amazon EventBridge with Amazon
        *       IVS</a>.</p>
        */
    export interface StreamEvent {
            /**
                * <p>Name that identifies the stream event within a <code>type</code>.</p>
                */
            name?: string;
            /**
                * <p>Logical group for certain events.</p>
                */
            type?: string;
            /**
                * <p>UTC ISO-8601 formatted timestamp of when the event occurred.</p>
                */
            eventTime?: Date;
    }
    export namespace StreamEvent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StreamEvent) => any;
    }
    /**
        * <p>Object that captures the Amazon IVS configuration that the customer provisioned, the
        *       ingest configurations that the broadcaster used, and the most recent Amazon IVS stream events
        *       it encountered.</p>
        */
    export interface StreamSession {
            /**
                * <p>Unique identifier for a live or previously live stream in the specified channel.</p>
                */
            streamId?: string;
            /**
                * <p>UTC ISO-8601 formatted timestamp of when the channel went live.</p>
                */
            startTime?: Date;
            /**
                * <p>UTC ISO-8601 formatted timestamp of when the channel went offline. For live streams, this
                *       is <code>NULL</code>.</p>
                */
            endTime?: Date;
            /**
                * <p>The properties of the channel at the time of going live.</p>
                */
            channel?: Channel;
            /**
                * <p>The properties of the incoming RTMP stream for the stream.</p>
                */
            ingestConfiguration?: IngestConfiguration;
            /**
                * <p>The properties of recording the live stream.</p>
                */
            recordingConfiguration?: RecordingConfiguration;
            /**
                * <p>List of Amazon IVS events that the stream encountered. The list is sorted by most recent
                *       events and contains up to 500 events. For Amazon IVS events, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/eventbridge.html">Using Amazon EventBridge with Amazon
                *       IVS</a>.</p>
                */
            truncatedEvents?: StreamEvent[];
    }
    export namespace StreamSession {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StreamSession) => any;
    }
    export interface GetStreamSessionResponse {
            /**
                * <p>List of stream details.</p>
                */
            streamSession?: StreamSession;
    }
    export namespace GetStreamSessionResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetStreamSessionResponse) => any;
    }
    export interface ImportPlaybackKeyPairRequest {
            /**
                * <p>The public portion of a customer-generated key pair.</p>
                */
            publicKeyMaterial: string | undefined;
            /**
                * <p>Playback-key-pair name. The value does not need to be unique.</p>
                */
            name?: string;
            /**
                * <p>Any tags provided with the request are added to the playback key pair tags.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace ImportPlaybackKeyPairRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImportPlaybackKeyPairRequest) => any;
    }
    export interface ImportPlaybackKeyPairResponse {
            /**
                * <p/>
                */
            keyPair?: PlaybackKeyPair;
    }
    export namespace ImportPlaybackKeyPairResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImportPlaybackKeyPairResponse) => any;
    }
    export interface ListChannelsRequest {
            /**
                * <p>Filters the channel list to match the specified name.</p>
                */
            filterByName?: string;
            /**
                * <p>Filters the channel list to match the specified recording-configuration ARN.</p>
                */
            filterByRecordingConfigurationArn?: string;
            /**
                * <p>The first channel to retrieve. This is used for pagination; see the <code>nextToken</code>
                *       response field.</p>
                */
            nextToken?: string;
            /**
                * <p>Maximum number of channels to return. Default: 50.</p>
                */
            maxResults?: number;
    }
    export namespace ListChannelsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListChannelsRequest) => any;
    }
    /**
        * <p>Summary information about a channel.</p>
        */
    export interface ChannelSummary {
            /**
                * <p>Channel ARN.</p>
                */
            arn?: string;
            /**
                * <p>Channel name.</p>
                */
            name?: string;
            /**
                * <p>Channel latency mode. Use <code>NORMAL</code> to broadcast and deliver live video up to
                *       Full HD. Use <code>LOW</code> for near-real-time interaction with viewers. Default:
                *         <code>LOW</code>. (Note: In the Amazon IVS console, <code>LOW</code> and <code>NORMAL</code>
                *       correspond to Ultra-low and Standard, respectively.)</p>
                */
            latencyMode?: ChannelLatencyMode | string;
            /**
                * <p>Whether the channel is private (enabled for playback authorization). Default:
                *         <code>false</code>.</p>
                */
            authorized?: boolean;
            /**
                * <p>Recording-configuration ARN. A value other than an empty string indicates that recording
                *       is enabled. Default: "" (empty string, recording is disabled).</p>
                */
            recordingConfigurationArn?: string;
            /**
                * <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace ChannelSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ChannelSummary) => any;
    }
    export interface ListChannelsResponse {
            /**
                * <p>List of the matching channels.</p>
                */
            channels: ChannelSummary[] | undefined;
            /**
                * <p>If there are more channels than <code>maxResults</code>, use <code>nextToken</code> in the
                *       request to get the next set.</p>
                */
            nextToken?: string;
    }
    export namespace ListChannelsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListChannelsResponse) => any;
    }
    export interface ListPlaybackKeyPairsRequest {
            /**
                * <p>Maximum number of key pairs to return.</p>
                */
            nextToken?: string;
            /**
                * <p>The first key pair to retrieve. This is used for pagination; see the
                *         <code>nextToken</code> response field. Default: 50.</p>
                */
            maxResults?: number;
    }
    export namespace ListPlaybackKeyPairsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListPlaybackKeyPairsRequest) => any;
    }
    /**
        * <p>Summary information about a playback key pair.</p>
        */
    export interface PlaybackKeyPairSummary {
            /**
                * <p>Key-pair ARN.</p>
                */
            arn?: string;
            /**
                * <p>Playback-key-pair name. The value does not need to be unique.</p>
                */
            name?: string;
            /**
                * <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace PlaybackKeyPairSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PlaybackKeyPairSummary) => any;
    }
    export interface ListPlaybackKeyPairsResponse {
            /**
                * <p>List of key pairs.</p>
                */
            keyPairs: PlaybackKeyPairSummary[] | undefined;
            /**
                * <p>If there are more key pairs than <code>maxResults</code>, use <code>nextToken</code> in
                *       the request to get the next set.</p>
                */
            nextToken?: string;
    }
    export namespace ListPlaybackKeyPairsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListPlaybackKeyPairsResponse) => any;
    }
    export interface ListRecordingConfigurationsRequest {
            /**
                * <p>The first recording configuration to retrieve. This is used for pagination; see the
                *         <code>nextToken</code> response field.</p>
                */
            nextToken?: string;
            /**
                * <p>Maximum number of recording configurations to return. Default: 50. </p>
                */
            maxResults?: number;
    }
    export namespace ListRecordingConfigurationsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListRecordingConfigurationsRequest) => any;
    }
    /**
        * <p>Summary information about a RecordingConfiguration.</p>
        */
    export interface RecordingConfigurationSummary {
            /**
                * <p>Recording-configuration ARN.</p>
                */
            arn: string | undefined;
            /**
                * <p>Recording-configuration name. The value does not need to be unique.</p>
                */
            name?: string;
            /**
                * <p>A complex type that contains information about where recorded video will be stored.</p>
                */
            destinationConfiguration: DestinationConfiguration | undefined;
            /**
                * <p>Indicates the current state of the recording configuration. When the state is
                *         <code>ACTIVE</code>, the configuration is ready for recording a channel stream.</p>
                */
            state: RecordingConfigurationState | string | undefined;
            /**
                * <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace RecordingConfigurationSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RecordingConfigurationSummary) => any;
    }
    export interface ListRecordingConfigurationsResponse {
            /**
                * <p>List of the matching recording configurations.</p>
                */
            recordingConfigurations: RecordingConfigurationSummary[] | undefined;
            /**
                * <p>If there are more recording configurations than <code>maxResults</code>, use
                *         <code>nextToken</code> in the request to get the next set.</p>
                */
            nextToken?: string;
    }
    export namespace ListRecordingConfigurationsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListRecordingConfigurationsResponse) => any;
    }
    export interface ListStreamKeysRequest {
            /**
                * <p>Channel ARN used to filter the list.</p>
                */
            channelArn: string | undefined;
            /**
                * <p>The first stream key to retrieve. This is used for pagination; see the
                *         <code>nextToken</code> response field.</p>
                */
            nextToken?: string;
            /**
                * <p>Maximum number of streamKeys to return. Default: 50.</p>
                */
            maxResults?: number;
    }
    export namespace ListStreamKeysRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListStreamKeysRequest) => any;
    }
    /**
        * <p>Summary information about a stream key.</p>
        */
    export interface StreamKeySummary {
            /**
                * <p>Stream-key ARN.</p>
                */
            arn?: string;
            /**
                * <p>Channel ARN for the stream.</p>
                */
            channelArn?: string;
            /**
                * <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace StreamKeySummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StreamKeySummary) => any;
    }
    export interface ListStreamKeysResponse {
            /**
                * <p>List of stream keys.</p>
                */
            streamKeys: StreamKeySummary[] | undefined;
            /**
                * <p>If there are more stream keys than <code>maxResults</code>, use <code>nextToken</code> in
                *       the request to get the next set.</p>
                */
            nextToken?: string;
    }
    export namespace ListStreamKeysResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListStreamKeysResponse) => any;
    }
    /**
        * <p>Object specifying the stream attribute on which to filter.</p>
        */
    export interface StreamFilters {
            /**
                * <p>The stream’s health.</p>
                */
            health?: StreamHealth | string;
    }
    export namespace StreamFilters {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StreamFilters) => any;
    }
    export interface ListStreamsRequest {
            /**
                * <p>Filters the stream list to match the specified criterion.</p>
                */
            filterBy?: StreamFilters;
            /**
                * <p>The first stream to retrieve. This is used for pagination; see the <code>nextToken</code>
                *       response field.</p>
                */
            nextToken?: string;
            /**
                * <p>Maximum number of streams to return. Default: 50.</p>
                */
            maxResults?: number;
    }
    export namespace ListStreamsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListStreamsRequest) => any;
    }
    /**
        * <p>Summary information about a stream.</p>
        */
    export interface StreamSummary {
            /**
                * <p>Channel ARN for the stream.</p>
                */
            channelArn?: string;
            /**
                * <p>Unique identifier for a live or previously live stream in the specified channel.</p>
                */
            streamId?: string;
            /**
                * <p>The stream’s state.</p>
                */
            state?: StreamState | string;
            /**
                * <p>The stream’s health.</p>
                */
            health?: StreamHealth | string;
            /**
                * <p>A count of concurrent views of the stream. Typically, a new view appears in
                *         <code>viewerCount</code> within 15 seconds of when video playback starts and a view is
                *       removed from <code>viewerCount</code> within 1 minute of when video playback ends. A value of
                *       -1 indicates that the request timed out; in this case, retry.</p>
                */
            viewerCount?: number;
            /**
                * <p>Time of the stream’s start. This is an ISO 8601 timestamp returned as a string.</p>
                */
            startTime?: Date;
    }
    export namespace StreamSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StreamSummary) => any;
    }
    export interface ListStreamsResponse {
            /**
                * <p>List of streams.</p>
                */
            streams: StreamSummary[] | undefined;
            /**
                * <p>If there are more streams than <code>maxResults</code>, use <code>nextToken</code> in the
                *       request to get the next set.</p>
                */
            nextToken?: string;
    }
    export namespace ListStreamsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListStreamsResponse) => any;
    }
    export interface ListStreamSessionsRequest {
            /**
                * <p>Channel ARN used to filter the list.</p>
                */
            channelArn: string | undefined;
            /**
                * <p>The first stream to retrieve. This is used for pagination; see the <code>nextToken</code>
                *       response field.</p>
                */
            nextToken?: string;
            /**
                * <p>Maximum number of streams to return. Default: 50.</p>
                */
            maxResults?: number;
    }
    export namespace ListStreamSessionsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListStreamSessionsRequest) => any;
    }
    /**
        * <p>Summary information about a stream session.</p>
        */
    export interface StreamSessionSummary {
            /**
                * <p>Unique identifier for a live or previously live stream in the specified channel.</p>
                */
            streamId?: string;
            /**
                * <p>UTC ISO-8601 formatted timestamp of when the channel went live.</p>
                */
            startTime?: Date;
            /**
                * <p>UTC ISO-8601 formatted timestamp of when the channel went offline. For live streams, this
                *       is <code>NULL</code>.</p>
                */
            endTime?: Date;
            /**
                * <p>If <code>true</code>, this stream encountered a quota breach or failure.</p>
                */
            hasErrorEvent?: boolean;
    }
    export namespace StreamSessionSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StreamSessionSummary) => any;
    }
    export interface ListStreamSessionsResponse {
            /**
                * <p>List of stream sessions.</p>
                */
            streamSessions: StreamSessionSummary[] | undefined;
            /**
                * <p>If there are more streams than <code>maxResults</code>, use <code>nextToken</code> in the
                *       request to get the next set.</p>
                */
            nextToken?: string;
    }
    export namespace ListStreamSessionsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListStreamSessionsResponse) => any;
    }
    export interface ListTagsForResourceRequest {
            /**
                * <p>The ARN of the resource to be retrieved.</p>
                */
            resourceArn: string | undefined;
    }
    export namespace ListTagsForResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceRequest) => any;
    }
    export interface ListTagsForResourceResponse {
            /**
                * <p/>
                */
            tags: Record<string, string> | undefined;
    }
    export namespace ListTagsForResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceResponse) => any;
    }
    export interface PutMetadataRequest {
            /**
                * <p>ARN of the channel into which metadata is inserted. This channel must have an active
                *       stream.</p>
                */
            channelArn: string | undefined;
            /**
                * <p>Metadata to insert into the stream. Maximum: 1 KB per request.</p>
                */
            metadata: string | undefined;
    }
    export namespace PutMetadataRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutMetadataRequest) => any;
    }
    /**
        * <p/>
        */
    export class ThrottlingException extends __BaseException {
            readonly name: "ThrottlingException";
            readonly $fault: "client";
            /**
                * <p>Request was denied due to request throttling.</p>
                */
            exceptionMessage?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ThrottlingException, __BaseException>);
    }
    export interface StopStreamRequest {
            /**
                * <p>ARN of the channel for which the stream is to be stopped.</p>
                */
            channelArn: string | undefined;
    }
    export namespace StopStreamRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StopStreamRequest) => any;
    }
    export interface StopStreamResponse {
    }
    export namespace StopStreamResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StopStreamResponse) => any;
    }
    /**
        * <p/>
        */
    export class StreamUnavailable extends __BaseException {
            readonly name: "StreamUnavailable";
            readonly $fault: "server";
            /**
                * <p>The stream is temporarily unavailable.</p>
                */
            exceptionMessage?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<StreamUnavailable, __BaseException>);
    }
    export interface TagResourceRequest {
            /**
                * <p>ARN of the resource for which tags are to be added or updated.</p>
                */
            resourceArn: string | undefined;
            /**
                * <p>Array of tags to be added or updated.</p>
                */
            tags: Record<string, string> | undefined;
    }
    export namespace TagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceRequest) => any;
    }
    export interface TagResourceResponse {
    }
    export namespace TagResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceResponse) => any;
    }
    export interface UntagResourceRequest {
            /**
                * <p>ARN of the resource for which tags are to be removed.</p>
                */
            resourceArn: string | undefined;
            /**
                * <p>Array of tags to be removed.</p>
                */
            tagKeys: string[] | undefined;
    }
    export namespace UntagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceRequest) => any;
    }
    export interface UntagResourceResponse {
    }
    export namespace UntagResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceResponse) => any;
    }
    export interface UpdateChannelRequest {
            /**
                * <p>ARN of the channel to be updated.</p>
                */
            arn: string | undefined;
            /**
                * <p>Channel name.</p>
                */
            name?: string;
            /**
                * <p>Channel latency mode. Use <code>NORMAL</code> to broadcast and deliver live video up to
                *       Full HD. Use <code>LOW</code> for near-real-time interaction with viewers. (Note: In the
                *       Amazon IVS console, <code>LOW</code> and <code>NORMAL</code> correspond to Ultra-low and
                *       Standard, respectively.)</p>
                */
            latencyMode?: ChannelLatencyMode | string;
            /**
                * <p>Channel type, which determines the allowable resolution and bitrate. <i>If you
                *         exceed the allowable resolution or bitrate, the stream probably will disconnect
                *         immediately</i>. Valid values:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>STANDARD</code>: Multiple qualities are generated from the original input, to
                *           automatically give viewers the best experience for their devices and network conditions.
                *           Resolution can be up to 1080p and bitrate can be up to 8.5 Mbps. Audio is transcoded only
                *           for renditions 360p and below; above that, audio is passed through.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>BASIC</code>: Amazon IVS delivers the original input to viewers. The viewer’s
                *           video-quality choice is limited to the original input. Resolution can be up to 480p and
                *           bitrate can be up to 1.5 Mbps.</p>
                *             </li>
                *          </ul>
                */
            type?: ChannelType | string;
            /**
                * <p>Whether the channel is private (enabled for playback authorization).</p>
                */
            authorized?: boolean;
            /**
                * <p>Recording-configuration ARN. If this is set to an empty string, recording is disabled. A
                *       value other than an empty string indicates that recording is enabled</p>
                */
            recordingConfigurationArn?: string;
    }
    export namespace UpdateChannelRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateChannelRequest) => any;
    }
    export interface UpdateChannelResponse {
            /**
                * <p>Object specifying a channel.</p>
                */
            channel?: Channel;
    }
    export namespace UpdateChannelResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateChannelResponse) => any;
    }
}

declare module '@aws-sdk/client-ivs/node_modules/@aws-sdk/client-ivs/dist-types/models/IvsServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from Ivs service.
        */
    export class IvsServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

