// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/smithy-client
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http

declare module '@aws-sdk/client-kinesis-video' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { CreateSignalingChannelCommandInput, CreateSignalingChannelCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/CreateSignalingChannelCommand";
    import { CreateStreamCommandInput, CreateStreamCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/CreateStreamCommand";
    import { DeleteSignalingChannelCommandInput, DeleteSignalingChannelCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/DeleteSignalingChannelCommand";
    import { DeleteStreamCommandInput, DeleteStreamCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/DeleteStreamCommand";
    import { DescribeImageGenerationConfigurationCommandInput, DescribeImageGenerationConfigurationCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/DescribeImageGenerationConfigurationCommand";
    import { DescribeNotificationConfigurationCommandInput, DescribeNotificationConfigurationCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/DescribeNotificationConfigurationCommand";
    import { DescribeSignalingChannelCommandInput, DescribeSignalingChannelCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/DescribeSignalingChannelCommand";
    import { DescribeStreamCommandInput, DescribeStreamCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/DescribeStreamCommand";
    import { GetDataEndpointCommandInput, GetDataEndpointCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/GetDataEndpointCommand";
    import { GetSignalingChannelEndpointCommandInput, GetSignalingChannelEndpointCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/GetSignalingChannelEndpointCommand";
    import { ListSignalingChannelsCommandInput, ListSignalingChannelsCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/ListSignalingChannelsCommand";
    import { ListStreamsCommandInput, ListStreamsCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/ListStreamsCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/ListTagsForResourceCommand";
    import { ListTagsForStreamCommandInput, ListTagsForStreamCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/ListTagsForStreamCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/TagResourceCommand";
    import { TagStreamCommandInput, TagStreamCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/TagStreamCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/UntagResourceCommand";
    import { UntagStreamCommandInput, UntagStreamCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/UntagStreamCommand";
    import { UpdateDataRetentionCommandInput, UpdateDataRetentionCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/UpdateDataRetentionCommand";
    import { UpdateImageGenerationConfigurationCommandInput, UpdateImageGenerationConfigurationCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/UpdateImageGenerationConfigurationCommand";
    import { UpdateNotificationConfigurationCommandInput, UpdateNotificationConfigurationCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/UpdateNotificationConfigurationCommand";
    import { UpdateSignalingChannelCommandInput, UpdateSignalingChannelCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/UpdateSignalingChannelCommand";
    import { UpdateStreamCommandInput, UpdateStreamCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/UpdateStreamCommand";
    import { KinesisVideoClient } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    /**
        * <p></p>
        */
    export class KinesisVideo extends KinesisVideoClient {
            /**
                * <p>Creates a signaling channel. </p>
                *         <p>
                *             <code>CreateSignalingChannel</code> is an asynchronous operation.</p>
                */
            createSignalingChannel(args: CreateSignalingChannelCommandInput, options?: __HttpHandlerOptions): Promise<CreateSignalingChannelCommandOutput>;
            createSignalingChannel(args: CreateSignalingChannelCommandInput, cb: (err: any, data?: CreateSignalingChannelCommandOutput) => void): void;
            createSignalingChannel(args: CreateSignalingChannelCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateSignalingChannelCommandOutput) => void): void;
            /**
                * <p>Creates a new Kinesis video stream. </p>
                *
                *         <p>When you create a new stream, Kinesis Video Streams assigns it a version number.
                *             When you change the stream's metadata, Kinesis Video Streams updates the version. </p>
                *         <p>
                *             <code>CreateStream</code> is an asynchronous operation.</p>
                *         <p>For information about how the service works, see <a href="https://docs.aws.amazon.com/kinesisvideostreams/latest/dg/how-it-works.html">How it Works</a>. </p>
                *         <p>You must have permissions for the <code>KinesisVideo:CreateStream</code>
                *             action.</p>
                */
            createStream(args: CreateStreamCommandInput, options?: __HttpHandlerOptions): Promise<CreateStreamCommandOutput>;
            createStream(args: CreateStreamCommandInput, cb: (err: any, data?: CreateStreamCommandOutput) => void): void;
            createStream(args: CreateStreamCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateStreamCommandOutput) => void): void;
            /**
                * <p>Deletes a specified signaling channel. <code>DeleteSignalingChannel</code> is an
                *             asynchronous operation. If you don't specify the channel's current version, the most
                *             recent version is deleted.</p>
                */
            deleteSignalingChannel(args: DeleteSignalingChannelCommandInput, options?: __HttpHandlerOptions): Promise<DeleteSignalingChannelCommandOutput>;
            deleteSignalingChannel(args: DeleteSignalingChannelCommandInput, cb: (err: any, data?: DeleteSignalingChannelCommandOutput) => void): void;
            deleteSignalingChannel(args: DeleteSignalingChannelCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteSignalingChannelCommandOutput) => void): void;
            /**
                * <p>Deletes a Kinesis video stream and the data contained in the stream. </p>
                *         <p>This method marks the stream for deletion, and makes the data in the stream
                *             inaccessible immediately.</p>
                *         <p> </p>
                *         <p> To ensure that you have the latest version of the stream before deleting it, you
                *             can specify the stream version. Kinesis Video Streams assigns a version to each stream.
                *             When you update a stream, Kinesis Video Streams assigns a new version number. To get the
                *             latest stream version, use the <code>DescribeStream</code> API. </p>
                *         <p>This operation requires permission for the <code>KinesisVideo:DeleteStream</code>
                *             action.</p>
                */
            deleteStream(args: DeleteStreamCommandInput, options?: __HttpHandlerOptions): Promise<DeleteStreamCommandOutput>;
            deleteStream(args: DeleteStreamCommandInput, cb: (err: any, data?: DeleteStreamCommandOutput) => void): void;
            deleteStream(args: DeleteStreamCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteStreamCommandOutput) => void): void;
            /**
                * <p>Gets the <code>ImageGenerationConfiguration</code> for a given Kinesis video stream.</p>
                */
            describeImageGenerationConfiguration(args: DescribeImageGenerationConfigurationCommandInput, options?: __HttpHandlerOptions): Promise<DescribeImageGenerationConfigurationCommandOutput>;
            describeImageGenerationConfiguration(args: DescribeImageGenerationConfigurationCommandInput, cb: (err: any, data?: DescribeImageGenerationConfigurationCommandOutput) => void): void;
            describeImageGenerationConfiguration(args: DescribeImageGenerationConfigurationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeImageGenerationConfigurationCommandOutput) => void): void;
            /**
                * <p>Gets the <code>NotificationConfiguration</code> for a given Kinesis video stream.</p>
                */
            describeNotificationConfiguration(args: DescribeNotificationConfigurationCommandInput, options?: __HttpHandlerOptions): Promise<DescribeNotificationConfigurationCommandOutput>;
            describeNotificationConfiguration(args: DescribeNotificationConfigurationCommandInput, cb: (err: any, data?: DescribeNotificationConfigurationCommandOutput) => void): void;
            describeNotificationConfiguration(args: DescribeNotificationConfigurationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeNotificationConfigurationCommandOutput) => void): void;
            /**
                * <p>Returns the most current information about the signaling channel. You must specify
                *             either the name or the Amazon Resource Name (ARN) of the channel that you want to
                *             describe.</p>
                */
            describeSignalingChannel(args: DescribeSignalingChannelCommandInput, options?: __HttpHandlerOptions): Promise<DescribeSignalingChannelCommandOutput>;
            describeSignalingChannel(args: DescribeSignalingChannelCommandInput, cb: (err: any, data?: DescribeSignalingChannelCommandOutput) => void): void;
            describeSignalingChannel(args: DescribeSignalingChannelCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeSignalingChannelCommandOutput) => void): void;
            /**
                * <p>Returns the most current information about the specified stream. You must specify
                *             either the <code>StreamName</code> or the <code>StreamARN</code>. </p>
                */
            describeStream(args: DescribeStreamCommandInput, options?: __HttpHandlerOptions): Promise<DescribeStreamCommandOutput>;
            describeStream(args: DescribeStreamCommandInput, cb: (err: any, data?: DescribeStreamCommandOutput) => void): void;
            describeStream(args: DescribeStreamCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeStreamCommandOutput) => void): void;
            /**
                * <p>Gets an endpoint for a specified stream for either reading or writing. Use this
                *             endpoint in your application to read from the specified stream (using the
                *                 <code>GetMedia</code> or <code>GetMediaForFragmentList</code> operations) or write
                *             to it (using the <code>PutMedia</code> operation).
                *             </p>
                *         <note>
                *             <p>The returned endpoint does not have the API name appended. The client needs to
                *                 add the API name to the returned endpoint.</p>
                *         </note>
                *
                *         <p>In the request, specify the stream either by <code>StreamName</code> or
                *                 <code>StreamARN</code>.</p>
                */
            getDataEndpoint(args: GetDataEndpointCommandInput, options?: __HttpHandlerOptions): Promise<GetDataEndpointCommandOutput>;
            getDataEndpoint(args: GetDataEndpointCommandInput, cb: (err: any, data?: GetDataEndpointCommandOutput) => void): void;
            getDataEndpoint(args: GetDataEndpointCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetDataEndpointCommandOutput) => void): void;
            /**
                * <p>Provides an endpoint for the specified signaling channel to send and receive messages.
                *             This API uses the <code>SingleMasterChannelEndpointConfiguration</code> input parameter,
                *             which consists of the <code>Protocols</code> and <code>Role</code> properties.</p>
                *         <p>
                *             <code>Protocols</code> is used to determine the communication mechanism. For example,
                *             if you specify <code>WSS</code> as the protocol, this API produces a secure websocket
                *             endpoint. If you specify <code>HTTPS</code> as the protocol, this API generates an HTTPS
                *             endpoint. </p>
                *         <p>
                *             <code>Role</code> determines the messaging permissions. A <code>MASTER</code> role
                *             results in this API generating an endpoint that a client can use to communicate with any
                *             of the viewers on the channel. A <code>VIEWER</code> role results in this API generating
                *             an endpoint that a client can use to communicate only with a <code>MASTER</code>.
                *         </p>
                */
            getSignalingChannelEndpoint(args: GetSignalingChannelEndpointCommandInput, options?: __HttpHandlerOptions): Promise<GetSignalingChannelEndpointCommandOutput>;
            getSignalingChannelEndpoint(args: GetSignalingChannelEndpointCommandInput, cb: (err: any, data?: GetSignalingChannelEndpointCommandOutput) => void): void;
            getSignalingChannelEndpoint(args: GetSignalingChannelEndpointCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetSignalingChannelEndpointCommandOutput) => void): void;
            /**
                * <p>Returns an array of <code>ChannelInfo</code> objects. Each object describes a
                *             signaling channel. To retrieve only those channels that satisfy a specific condition,
                *             you can specify a <code>ChannelNameCondition</code>.</p>
                */
            listSignalingChannels(args: ListSignalingChannelsCommandInput, options?: __HttpHandlerOptions): Promise<ListSignalingChannelsCommandOutput>;
            listSignalingChannels(args: ListSignalingChannelsCommandInput, cb: (err: any, data?: ListSignalingChannelsCommandOutput) => void): void;
            listSignalingChannels(args: ListSignalingChannelsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListSignalingChannelsCommandOutput) => void): void;
            /**
                * <p>Returns an array of <code>StreamInfo</code> objects. Each object describes a
                *             stream. To retrieve only streams that satisfy a specific condition, you can specify a
                *                 <code>StreamNameCondition</code>. </p>
                */
            listStreams(args: ListStreamsCommandInput, options?: __HttpHandlerOptions): Promise<ListStreamsCommandOutput>;
            listStreams(args: ListStreamsCommandInput, cb: (err: any, data?: ListStreamsCommandOutput) => void): void;
            listStreams(args: ListStreamsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListStreamsCommandOutput) => void): void;
            /**
                * <p>Returns a list of tags associated with the specified signaling channel.</p>
                */
            listTagsForResource(args: ListTagsForResourceCommandInput, options?: __HttpHandlerOptions): Promise<ListTagsForResourceCommandOutput>;
            listTagsForResource(args: ListTagsForResourceCommandInput, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            listTagsForResource(args: ListTagsForResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            /**
                * <p>Returns a list of tags associated with the specified stream.</p>
                *         <p>In the request, you must specify either the <code>StreamName</code> or the
                *                 <code>StreamARN</code>. </p>
                */
            listTagsForStream(args: ListTagsForStreamCommandInput, options?: __HttpHandlerOptions): Promise<ListTagsForStreamCommandOutput>;
            listTagsForStream(args: ListTagsForStreamCommandInput, cb: (err: any, data?: ListTagsForStreamCommandOutput) => void): void;
            listTagsForStream(args: ListTagsForStreamCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTagsForStreamCommandOutput) => void): void;
            /**
                * <p>Adds one or more tags to a signaling channel. A <i>tag</i> is a
                *             key-value pair (the value is optional) that you can define and assign to Amazon Web Services resources.
                *             If you specify a tag that already exists, the tag value is replaced with the value that
                *             you specify in the request. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using Cost Allocation
                *                 Tags</a> in the <i>Billing and Cost Management and Cost Management User
                *             Guide</i>.</p>
                */
            tagResource(args: TagResourceCommandInput, options?: __HttpHandlerOptions): Promise<TagResourceCommandOutput>;
            tagResource(args: TagResourceCommandInput, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            tagResource(args: TagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            /**
                * <p>Adds one or more tags to a stream. A <i>tag</i> is a key-value pair
                *             (the value is optional) that you can define and assign to Amazon Web Services resources. If you specify
                *             a tag that already exists, the tag value is replaced with the value that you specify in
                *             the request. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using Cost Allocation
                *                 Tags</a> in the <i>Billing and Cost Management and Cost Management User Guide</i>. </p>
                *         <p>You must provide either the <code>StreamName</code> or the
                *             <code>StreamARN</code>.</p>
                *         <p>This operation requires permission for the <code>KinesisVideo:TagStream</code>
                *             action.</p>
                *         <p>A Kinesis video stream can support up to 50 tags.</p>
                */
            tagStream(args: TagStreamCommandInput, options?: __HttpHandlerOptions): Promise<TagStreamCommandOutput>;
            tagStream(args: TagStreamCommandInput, cb: (err: any, data?: TagStreamCommandOutput) => void): void;
            tagStream(args: TagStreamCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TagStreamCommandOutput) => void): void;
            /**
                * <p>Removes one or more tags from a signaling channel. In the request, specify only a tag
                *             key or keys; don't specify the value. If you specify a tag key that does not exist, it's
                *             ignored.</p>
                */
            untagResource(args: UntagResourceCommandInput, options?: __HttpHandlerOptions): Promise<UntagResourceCommandOutput>;
            untagResource(args: UntagResourceCommandInput, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            untagResource(args: UntagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            /**
                * <p>Removes one or more tags from a stream. In the request, specify only a tag key or
                *             keys; don't specify the value. If you specify a tag key that does not exist, it's
                *             ignored.</p>
                *         <p>In the request, you must provide the <code>StreamName</code> or
                *                 <code>StreamARN</code>.</p>
                */
            untagStream(args: UntagStreamCommandInput, options?: __HttpHandlerOptions): Promise<UntagStreamCommandOutput>;
            untagStream(args: UntagStreamCommandInput, cb: (err: any, data?: UntagStreamCommandOutput) => void): void;
            untagStream(args: UntagStreamCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UntagStreamCommandOutput) => void): void;
            /**
                * <p> Increases or decreases the stream's data retention period by the value that you
                *             specify. To indicate whether you want to increase or decrease the data retention period,
                *             specify the <code>Operation</code> parameter in the request body. In the request, you
                *             must specify either the <code>StreamName</code> or the <code>StreamARN</code>. </p>
                *         <note>
                *             <p>The retention period that you specify replaces the current value.</p>
                *         </note>
                *
                *         <p>This operation requires permission for the
                *                 <code>KinesisVideo:UpdateDataRetention</code> action.</p>
                *
                *         <p>Changing the data retention period affects the data in the stream as
                *             follows:</p>
                *         <ul>
                *             <li>
                *                 <p>If the data retention period is increased, existing data is retained for
                *                     the new retention period. For example, if the data retention period is increased
                *                     from one hour to seven hours, all existing data is retained for seven
                *                     hours.</p>
                *             </li>
                *             <li>
                *                 <p>If the data retention period is decreased, existing data is retained for
                *                     the new retention period. For example, if the data retention period is decreased
                *                     from seven hours to one hour, all existing data is retained for one hour, and
                *                     any data older than one hour is deleted immediately.</p>
                *             </li>
                *          </ul>
                */
            updateDataRetention(args: UpdateDataRetentionCommandInput, options?: __HttpHandlerOptions): Promise<UpdateDataRetentionCommandOutput>;
            updateDataRetention(args: UpdateDataRetentionCommandInput, cb: (err: any, data?: UpdateDataRetentionCommandOutput) => void): void;
            updateDataRetention(args: UpdateDataRetentionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateDataRetentionCommandOutput) => void): void;
            /**
                * <p>Updates the <code>StreamInfo</code> and <code>ImageProcessingConfiguration</code> fields.</p>
                */
            updateImageGenerationConfiguration(args: UpdateImageGenerationConfigurationCommandInput, options?: __HttpHandlerOptions): Promise<UpdateImageGenerationConfigurationCommandOutput>;
            updateImageGenerationConfiguration(args: UpdateImageGenerationConfigurationCommandInput, cb: (err: any, data?: UpdateImageGenerationConfigurationCommandOutput) => void): void;
            updateImageGenerationConfiguration(args: UpdateImageGenerationConfigurationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateImageGenerationConfigurationCommandOutput) => void): void;
            /**
                * <p>Updates the notification information for a stream.</p>
                */
            updateNotificationConfiguration(args: UpdateNotificationConfigurationCommandInput, options?: __HttpHandlerOptions): Promise<UpdateNotificationConfigurationCommandOutput>;
            updateNotificationConfiguration(args: UpdateNotificationConfigurationCommandInput, cb: (err: any, data?: UpdateNotificationConfigurationCommandOutput) => void): void;
            updateNotificationConfiguration(args: UpdateNotificationConfigurationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateNotificationConfigurationCommandOutput) => void): void;
            /**
                * <p>Updates the existing signaling channel. This is an asynchronous operation and takes
                *             time to complete. </p>
                *         <p>If the <code>MessageTtlSeconds</code> value is updated (either increased or reduced),
                *             it only applies to new messages sent via this channel after it's been updated. Existing
                *             messages are still expired as per the previous <code>MessageTtlSeconds</code>
                *             value.</p>
                */
            updateSignalingChannel(args: UpdateSignalingChannelCommandInput, options?: __HttpHandlerOptions): Promise<UpdateSignalingChannelCommandOutput>;
            updateSignalingChannel(args: UpdateSignalingChannelCommandInput, cb: (err: any, data?: UpdateSignalingChannelCommandOutput) => void): void;
            updateSignalingChannel(args: UpdateSignalingChannelCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateSignalingChannelCommandOutput) => void): void;
            /**
                * <p>Updates stream metadata, such as the device name and media type.</p>
                *         <p>You must provide the stream name or the Amazon Resource Name (ARN) of the
                *             stream.</p>
                *         <p>To make sure that you have the latest version of the stream before updating it, you
                *             can specify the stream version. Kinesis Video Streams assigns a version to each stream.
                *             When you update a stream, Kinesis Video Streams assigns a new version number. To get the
                *             latest stream version, use the <code>DescribeStream</code> API. </p>
                *         <p>
                *             <code>UpdateStream</code> is an asynchronous operation, and takes time to
                *             complete.</p>
                */
            updateStream(args: UpdateStreamCommandInput, options?: __HttpHandlerOptions): Promise<UpdateStreamCommandOutput>;
            updateStream(args: UpdateStreamCommandInput, cb: (err: any, data?: UpdateStreamCommandOutput) => void): void;
            updateStream(args: UpdateStreamCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateStreamCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/CreateSignalingChannelCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { CreateSignalingChannelInput, CreateSignalingChannelOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface CreateSignalingChannelCommandInput extends CreateSignalingChannelInput {
    }
    export interface CreateSignalingChannelCommandOutput extends CreateSignalingChannelOutput, __MetadataBearer {
    }
    /**
        * <p>Creates a signaling channel. </p>
        *         <p>
        *             <code>CreateSignalingChannel</code> is an asynchronous operation.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, CreateSignalingChannelCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, CreateSignalingChannelCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new CreateSignalingChannelCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateSignalingChannelCommandInput} for command's `input` shape.
        * @see {@link CreateSignalingChannelCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class CreateSignalingChannelCommand extends $Command<CreateSignalingChannelCommandInput, CreateSignalingChannelCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: CreateSignalingChannelCommandInput;
            constructor(input: CreateSignalingChannelCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateSignalingChannelCommandInput, CreateSignalingChannelCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/CreateStreamCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { CreateStreamInput, CreateStreamOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface CreateStreamCommandInput extends CreateStreamInput {
    }
    export interface CreateStreamCommandOutput extends CreateStreamOutput, __MetadataBearer {
    }
    /**
        * <p>Creates a new Kinesis video stream. </p>
        *
        *         <p>When you create a new stream, Kinesis Video Streams assigns it a version number.
        *             When you change the stream's metadata, Kinesis Video Streams updates the version. </p>
        *         <p>
        *             <code>CreateStream</code> is an asynchronous operation.</p>
        *         <p>For information about how the service works, see <a href="https://docs.aws.amazon.com/kinesisvideostreams/latest/dg/how-it-works.html">How it Works</a>. </p>
        *         <p>You must have permissions for the <code>KinesisVideo:CreateStream</code>
        *             action.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, CreateStreamCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, CreateStreamCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new CreateStreamCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateStreamCommandInput} for command's `input` shape.
        * @see {@link CreateStreamCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class CreateStreamCommand extends $Command<CreateStreamCommandInput, CreateStreamCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: CreateStreamCommandInput;
            constructor(input: CreateStreamCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateStreamCommandInput, CreateStreamCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/DeleteSignalingChannelCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { DeleteSignalingChannelInput, DeleteSignalingChannelOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface DeleteSignalingChannelCommandInput extends DeleteSignalingChannelInput {
    }
    export interface DeleteSignalingChannelCommandOutput extends DeleteSignalingChannelOutput, __MetadataBearer {
    }
    /**
        * <p>Deletes a specified signaling channel. <code>DeleteSignalingChannel</code> is an
        *             asynchronous operation. If you don't specify the channel's current version, the most
        *             recent version is deleted.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, DeleteSignalingChannelCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, DeleteSignalingChannelCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new DeleteSignalingChannelCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteSignalingChannelCommandInput} for command's `input` shape.
        * @see {@link DeleteSignalingChannelCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class DeleteSignalingChannelCommand extends $Command<DeleteSignalingChannelCommandInput, DeleteSignalingChannelCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: DeleteSignalingChannelCommandInput;
            constructor(input: DeleteSignalingChannelCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteSignalingChannelCommandInput, DeleteSignalingChannelCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/DeleteStreamCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { DeleteStreamInput, DeleteStreamOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface DeleteStreamCommandInput extends DeleteStreamInput {
    }
    export interface DeleteStreamCommandOutput extends DeleteStreamOutput, __MetadataBearer {
    }
    /**
        * <p>Deletes a Kinesis video stream and the data contained in the stream. </p>
        *         <p>This method marks the stream for deletion, and makes the data in the stream
        *             inaccessible immediately.</p>
        *         <p> </p>
        *         <p> To ensure that you have the latest version of the stream before deleting it, you
        *             can specify the stream version. Kinesis Video Streams assigns a version to each stream.
        *             When you update a stream, Kinesis Video Streams assigns a new version number. To get the
        *             latest stream version, use the <code>DescribeStream</code> API. </p>
        *         <p>This operation requires permission for the <code>KinesisVideo:DeleteStream</code>
        *             action.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, DeleteStreamCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, DeleteStreamCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new DeleteStreamCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteStreamCommandInput} for command's `input` shape.
        * @see {@link DeleteStreamCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class DeleteStreamCommand extends $Command<DeleteStreamCommandInput, DeleteStreamCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: DeleteStreamCommandInput;
            constructor(input: DeleteStreamCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteStreamCommandInput, DeleteStreamCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/DescribeImageGenerationConfigurationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { DescribeImageGenerationConfigurationInput, DescribeImageGenerationConfigurationOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface DescribeImageGenerationConfigurationCommandInput extends DescribeImageGenerationConfigurationInput {
    }
    export interface DescribeImageGenerationConfigurationCommandOutput extends DescribeImageGenerationConfigurationOutput, __MetadataBearer {
    }
    /**
        * <p>Gets the <code>ImageGenerationConfiguration</code> for a given Kinesis video stream.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, DescribeImageGenerationConfigurationCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, DescribeImageGenerationConfigurationCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new DescribeImageGenerationConfigurationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeImageGenerationConfigurationCommandInput} for command's `input` shape.
        * @see {@link DescribeImageGenerationConfigurationCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class DescribeImageGenerationConfigurationCommand extends $Command<DescribeImageGenerationConfigurationCommandInput, DescribeImageGenerationConfigurationCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: DescribeImageGenerationConfigurationCommandInput;
            constructor(input: DescribeImageGenerationConfigurationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeImageGenerationConfigurationCommandInput, DescribeImageGenerationConfigurationCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/DescribeNotificationConfigurationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { DescribeNotificationConfigurationInput, DescribeNotificationConfigurationOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface DescribeNotificationConfigurationCommandInput extends DescribeNotificationConfigurationInput {
    }
    export interface DescribeNotificationConfigurationCommandOutput extends DescribeNotificationConfigurationOutput, __MetadataBearer {
    }
    /**
        * <p>Gets the <code>NotificationConfiguration</code> for a given Kinesis video stream.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, DescribeNotificationConfigurationCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, DescribeNotificationConfigurationCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new DescribeNotificationConfigurationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeNotificationConfigurationCommandInput} for command's `input` shape.
        * @see {@link DescribeNotificationConfigurationCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class DescribeNotificationConfigurationCommand extends $Command<DescribeNotificationConfigurationCommandInput, DescribeNotificationConfigurationCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: DescribeNotificationConfigurationCommandInput;
            constructor(input: DescribeNotificationConfigurationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeNotificationConfigurationCommandInput, DescribeNotificationConfigurationCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/DescribeSignalingChannelCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { DescribeSignalingChannelInput, DescribeSignalingChannelOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface DescribeSignalingChannelCommandInput extends DescribeSignalingChannelInput {
    }
    export interface DescribeSignalingChannelCommandOutput extends DescribeSignalingChannelOutput, __MetadataBearer {
    }
    /**
        * <p>Returns the most current information about the signaling channel. You must specify
        *             either the name or the Amazon Resource Name (ARN) of the channel that you want to
        *             describe.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, DescribeSignalingChannelCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, DescribeSignalingChannelCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new DescribeSignalingChannelCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeSignalingChannelCommandInput} for command's `input` shape.
        * @see {@link DescribeSignalingChannelCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class DescribeSignalingChannelCommand extends $Command<DescribeSignalingChannelCommandInput, DescribeSignalingChannelCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: DescribeSignalingChannelCommandInput;
            constructor(input: DescribeSignalingChannelCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeSignalingChannelCommandInput, DescribeSignalingChannelCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/DescribeStreamCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { DescribeStreamInput, DescribeStreamOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface DescribeStreamCommandInput extends DescribeStreamInput {
    }
    export interface DescribeStreamCommandOutput extends DescribeStreamOutput, __MetadataBearer {
    }
    /**
        * <p>Returns the most current information about the specified stream. You must specify
        *             either the <code>StreamName</code> or the <code>StreamARN</code>. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, DescribeStreamCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, DescribeStreamCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new DescribeStreamCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeStreamCommandInput} for command's `input` shape.
        * @see {@link DescribeStreamCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class DescribeStreamCommand extends $Command<DescribeStreamCommandInput, DescribeStreamCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: DescribeStreamCommandInput;
            constructor(input: DescribeStreamCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeStreamCommandInput, DescribeStreamCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/GetDataEndpointCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { GetDataEndpointInput, GetDataEndpointOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface GetDataEndpointCommandInput extends GetDataEndpointInput {
    }
    export interface GetDataEndpointCommandOutput extends GetDataEndpointOutput, __MetadataBearer {
    }
    /**
        * <p>Gets an endpoint for a specified stream for either reading or writing. Use this
        *             endpoint in your application to read from the specified stream (using the
        *                 <code>GetMedia</code> or <code>GetMediaForFragmentList</code> operations) or write
        *             to it (using the <code>PutMedia</code> operation).
        *             </p>
        *         <note>
        *             <p>The returned endpoint does not have the API name appended. The client needs to
        *                 add the API name to the returned endpoint.</p>
        *         </note>
        *
        *         <p>In the request, specify the stream either by <code>StreamName</code> or
        *                 <code>StreamARN</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, GetDataEndpointCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, GetDataEndpointCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new GetDataEndpointCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetDataEndpointCommandInput} for command's `input` shape.
        * @see {@link GetDataEndpointCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class GetDataEndpointCommand extends $Command<GetDataEndpointCommandInput, GetDataEndpointCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: GetDataEndpointCommandInput;
            constructor(input: GetDataEndpointCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetDataEndpointCommandInput, GetDataEndpointCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/GetSignalingChannelEndpointCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { GetSignalingChannelEndpointInput, GetSignalingChannelEndpointOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface GetSignalingChannelEndpointCommandInput extends GetSignalingChannelEndpointInput {
    }
    export interface GetSignalingChannelEndpointCommandOutput extends GetSignalingChannelEndpointOutput, __MetadataBearer {
    }
    /**
        * <p>Provides an endpoint for the specified signaling channel to send and receive messages.
        *             This API uses the <code>SingleMasterChannelEndpointConfiguration</code> input parameter,
        *             which consists of the <code>Protocols</code> and <code>Role</code> properties.</p>
        *         <p>
        *             <code>Protocols</code> is used to determine the communication mechanism. For example,
        *             if you specify <code>WSS</code> as the protocol, this API produces a secure websocket
        *             endpoint. If you specify <code>HTTPS</code> as the protocol, this API generates an HTTPS
        *             endpoint. </p>
        *         <p>
        *             <code>Role</code> determines the messaging permissions. A <code>MASTER</code> role
        *             results in this API generating an endpoint that a client can use to communicate with any
        *             of the viewers on the channel. A <code>VIEWER</code> role results in this API generating
        *             an endpoint that a client can use to communicate only with a <code>MASTER</code>.
        *         </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, GetSignalingChannelEndpointCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, GetSignalingChannelEndpointCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new GetSignalingChannelEndpointCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetSignalingChannelEndpointCommandInput} for command's `input` shape.
        * @see {@link GetSignalingChannelEndpointCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class GetSignalingChannelEndpointCommand extends $Command<GetSignalingChannelEndpointCommandInput, GetSignalingChannelEndpointCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: GetSignalingChannelEndpointCommandInput;
            constructor(input: GetSignalingChannelEndpointCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetSignalingChannelEndpointCommandInput, GetSignalingChannelEndpointCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/ListSignalingChannelsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { ListSignalingChannelsInput, ListSignalingChannelsOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface ListSignalingChannelsCommandInput extends ListSignalingChannelsInput {
    }
    export interface ListSignalingChannelsCommandOutput extends ListSignalingChannelsOutput, __MetadataBearer {
    }
    /**
        * <p>Returns an array of <code>ChannelInfo</code> objects. Each object describes a
        *             signaling channel. To retrieve only those channels that satisfy a specific condition,
        *             you can specify a <code>ChannelNameCondition</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, ListSignalingChannelsCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, ListSignalingChannelsCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new ListSignalingChannelsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListSignalingChannelsCommandInput} for command's `input` shape.
        * @see {@link ListSignalingChannelsCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class ListSignalingChannelsCommand extends $Command<ListSignalingChannelsCommandInput, ListSignalingChannelsCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: ListSignalingChannelsCommandInput;
            constructor(input: ListSignalingChannelsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListSignalingChannelsCommandInput, ListSignalingChannelsCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/ListStreamsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { ListStreamsInput, ListStreamsOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface ListStreamsCommandInput extends ListStreamsInput {
    }
    export interface ListStreamsCommandOutput extends ListStreamsOutput, __MetadataBearer {
    }
    /**
        * <p>Returns an array of <code>StreamInfo</code> objects. Each object describes a
        *             stream. To retrieve only streams that satisfy a specific condition, you can specify a
        *                 <code>StreamNameCondition</code>. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, ListStreamsCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, ListStreamsCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new ListStreamsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListStreamsCommandInput} for command's `input` shape.
        * @see {@link ListStreamsCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class ListStreamsCommand extends $Command<ListStreamsCommandInput, ListStreamsCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: ListStreamsCommandInput;
            constructor(input: ListStreamsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListStreamsCommandInput, ListStreamsCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/ListTagsForResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { ListTagsForResourceInput, ListTagsForResourceOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface ListTagsForResourceCommandInput extends ListTagsForResourceInput {
    }
    export interface ListTagsForResourceCommandOutput extends ListTagsForResourceOutput, __MetadataBearer {
    }
    /**
        * <p>Returns a list of tags associated with the specified signaling channel.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, ListTagsForResourceCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, ListTagsForResourceCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new ListTagsForResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTagsForResourceCommandInput} for command's `input` shape.
        * @see {@link ListTagsForResourceCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class ListTagsForResourceCommand extends $Command<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: ListTagsForResourceCommandInput;
            constructor(input: ListTagsForResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/ListTagsForStreamCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { ListTagsForStreamInput, ListTagsForStreamOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface ListTagsForStreamCommandInput extends ListTagsForStreamInput {
    }
    export interface ListTagsForStreamCommandOutput extends ListTagsForStreamOutput, __MetadataBearer {
    }
    /**
        * <p>Returns a list of tags associated with the specified stream.</p>
        *         <p>In the request, you must specify either the <code>StreamName</code> or the
        *                 <code>StreamARN</code>. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, ListTagsForStreamCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, ListTagsForStreamCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new ListTagsForStreamCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTagsForStreamCommandInput} for command's `input` shape.
        * @see {@link ListTagsForStreamCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class ListTagsForStreamCommand extends $Command<ListTagsForStreamCommandInput, ListTagsForStreamCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: ListTagsForStreamCommandInput;
            constructor(input: ListTagsForStreamCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTagsForStreamCommandInput, ListTagsForStreamCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/TagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { TagResourceInput, TagResourceOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface TagResourceCommandInput extends TagResourceInput {
    }
    export interface TagResourceCommandOutput extends TagResourceOutput, __MetadataBearer {
    }
    /**
        * <p>Adds one or more tags to a signaling channel. A <i>tag</i> is a
        *             key-value pair (the value is optional) that you can define and assign to Amazon Web Services resources.
        *             If you specify a tag that already exists, the tag value is replaced with the value that
        *             you specify in the request. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using Cost Allocation
        *                 Tags</a> in the <i>Billing and Cost Management and Cost Management User
        *             Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, TagResourceCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, TagResourceCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new TagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TagResourceCommandInput} for command's `input` shape.
        * @see {@link TagResourceCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class TagResourceCommand extends $Command<TagResourceCommandInput, TagResourceCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: TagResourceCommandInput;
            constructor(input: TagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TagResourceCommandInput, TagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/TagStreamCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { TagStreamInput, TagStreamOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface TagStreamCommandInput extends TagStreamInput {
    }
    export interface TagStreamCommandOutput extends TagStreamOutput, __MetadataBearer {
    }
    /**
        * <p>Adds one or more tags to a stream. A <i>tag</i> is a key-value pair
        *             (the value is optional) that you can define and assign to Amazon Web Services resources. If you specify
        *             a tag that already exists, the tag value is replaced with the value that you specify in
        *             the request. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using Cost Allocation
        *                 Tags</a> in the <i>Billing and Cost Management and Cost Management User Guide</i>. </p>
        *         <p>You must provide either the <code>StreamName</code> or the
        *             <code>StreamARN</code>.</p>
        *         <p>This operation requires permission for the <code>KinesisVideo:TagStream</code>
        *             action.</p>
        *         <p>A Kinesis video stream can support up to 50 tags.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, TagStreamCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, TagStreamCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new TagStreamCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TagStreamCommandInput} for command's `input` shape.
        * @see {@link TagStreamCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class TagStreamCommand extends $Command<TagStreamCommandInput, TagStreamCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: TagStreamCommandInput;
            constructor(input: TagStreamCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TagStreamCommandInput, TagStreamCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/UntagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { UntagResourceInput, UntagResourceOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface UntagResourceCommandInput extends UntagResourceInput {
    }
    export interface UntagResourceCommandOutput extends UntagResourceOutput, __MetadataBearer {
    }
    /**
        * <p>Removes one or more tags from a signaling channel. In the request, specify only a tag
        *             key or keys; don't specify the value. If you specify a tag key that does not exist, it's
        *             ignored.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, UntagResourceCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, UntagResourceCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new UntagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UntagResourceCommandInput} for command's `input` shape.
        * @see {@link UntagResourceCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class UntagResourceCommand extends $Command<UntagResourceCommandInput, UntagResourceCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: UntagResourceCommandInput;
            constructor(input: UntagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UntagResourceCommandInput, UntagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/UntagStreamCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { UntagStreamInput, UntagStreamOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface UntagStreamCommandInput extends UntagStreamInput {
    }
    export interface UntagStreamCommandOutput extends UntagStreamOutput, __MetadataBearer {
    }
    /**
        * <p>Removes one or more tags from a stream. In the request, specify only a tag key or
        *             keys; don't specify the value. If you specify a tag key that does not exist, it's
        *             ignored.</p>
        *         <p>In the request, you must provide the <code>StreamName</code> or
        *                 <code>StreamARN</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, UntagStreamCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, UntagStreamCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new UntagStreamCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UntagStreamCommandInput} for command's `input` shape.
        * @see {@link UntagStreamCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class UntagStreamCommand extends $Command<UntagStreamCommandInput, UntagStreamCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: UntagStreamCommandInput;
            constructor(input: UntagStreamCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UntagStreamCommandInput, UntagStreamCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/UpdateDataRetentionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { UpdateDataRetentionInput, UpdateDataRetentionOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface UpdateDataRetentionCommandInput extends UpdateDataRetentionInput {
    }
    export interface UpdateDataRetentionCommandOutput extends UpdateDataRetentionOutput, __MetadataBearer {
    }
    /**
        * <p> Increases or decreases the stream's data retention period by the value that you
        *             specify. To indicate whether you want to increase or decrease the data retention period,
        *             specify the <code>Operation</code> parameter in the request body. In the request, you
        *             must specify either the <code>StreamName</code> or the <code>StreamARN</code>. </p>
        *         <note>
        *             <p>The retention period that you specify replaces the current value.</p>
        *         </note>
        *
        *         <p>This operation requires permission for the
        *                 <code>KinesisVideo:UpdateDataRetention</code> action.</p>
        *
        *         <p>Changing the data retention period affects the data in the stream as
        *             follows:</p>
        *         <ul>
        *             <li>
        *                 <p>If the data retention period is increased, existing data is retained for
        *                     the new retention period. For example, if the data retention period is increased
        *                     from one hour to seven hours, all existing data is retained for seven
        *                     hours.</p>
        *             </li>
        *             <li>
        *                 <p>If the data retention period is decreased, existing data is retained for
        *                     the new retention period. For example, if the data retention period is decreased
        *                     from seven hours to one hour, all existing data is retained for one hour, and
        *                     any data older than one hour is deleted immediately.</p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, UpdateDataRetentionCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, UpdateDataRetentionCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new UpdateDataRetentionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateDataRetentionCommandInput} for command's `input` shape.
        * @see {@link UpdateDataRetentionCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class UpdateDataRetentionCommand extends $Command<UpdateDataRetentionCommandInput, UpdateDataRetentionCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: UpdateDataRetentionCommandInput;
            constructor(input: UpdateDataRetentionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateDataRetentionCommandInput, UpdateDataRetentionCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/UpdateImageGenerationConfigurationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { UpdateImageGenerationConfigurationInput, UpdateImageGenerationConfigurationOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface UpdateImageGenerationConfigurationCommandInput extends UpdateImageGenerationConfigurationInput {
    }
    export interface UpdateImageGenerationConfigurationCommandOutput extends UpdateImageGenerationConfigurationOutput, __MetadataBearer {
    }
    /**
        * <p>Updates the <code>StreamInfo</code> and <code>ImageProcessingConfiguration</code> fields.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, UpdateImageGenerationConfigurationCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, UpdateImageGenerationConfigurationCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new UpdateImageGenerationConfigurationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateImageGenerationConfigurationCommandInput} for command's `input` shape.
        * @see {@link UpdateImageGenerationConfigurationCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class UpdateImageGenerationConfigurationCommand extends $Command<UpdateImageGenerationConfigurationCommandInput, UpdateImageGenerationConfigurationCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: UpdateImageGenerationConfigurationCommandInput;
            constructor(input: UpdateImageGenerationConfigurationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateImageGenerationConfigurationCommandInput, UpdateImageGenerationConfigurationCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/UpdateNotificationConfigurationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { UpdateNotificationConfigurationInput, UpdateNotificationConfigurationOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface UpdateNotificationConfigurationCommandInput extends UpdateNotificationConfigurationInput {
    }
    export interface UpdateNotificationConfigurationCommandOutput extends UpdateNotificationConfigurationOutput, __MetadataBearer {
    }
    /**
        * <p>Updates the notification information for a stream.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, UpdateNotificationConfigurationCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, UpdateNotificationConfigurationCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new UpdateNotificationConfigurationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateNotificationConfigurationCommandInput} for command's `input` shape.
        * @see {@link UpdateNotificationConfigurationCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class UpdateNotificationConfigurationCommand extends $Command<UpdateNotificationConfigurationCommandInput, UpdateNotificationConfigurationCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: UpdateNotificationConfigurationCommandInput;
            constructor(input: UpdateNotificationConfigurationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateNotificationConfigurationCommandInput, UpdateNotificationConfigurationCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/UpdateSignalingChannelCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { UpdateSignalingChannelInput, UpdateSignalingChannelOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface UpdateSignalingChannelCommandInput extends UpdateSignalingChannelInput {
    }
    export interface UpdateSignalingChannelCommandOutput extends UpdateSignalingChannelOutput, __MetadataBearer {
    }
    /**
        * <p>Updates the existing signaling channel. This is an asynchronous operation and takes
        *             time to complete. </p>
        *         <p>If the <code>MessageTtlSeconds</code> value is updated (either increased or reduced),
        *             it only applies to new messages sent via this channel after it's been updated. Existing
        *             messages are still expired as per the previous <code>MessageTtlSeconds</code>
        *             value.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, UpdateSignalingChannelCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, UpdateSignalingChannelCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new UpdateSignalingChannelCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateSignalingChannelCommandInput} for command's `input` shape.
        * @see {@link UpdateSignalingChannelCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class UpdateSignalingChannelCommand extends $Command<UpdateSignalingChannelCommandInput, UpdateSignalingChannelCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: UpdateSignalingChannelCommandInput;
            constructor(input: UpdateSignalingChannelCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateSignalingChannelCommandInput, UpdateSignalingChannelCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/UpdateStreamCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient";
    import { UpdateStreamInput, UpdateStreamOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0";
    export interface UpdateStreamCommandInput extends UpdateStreamInput {
    }
    export interface UpdateStreamCommandOutput extends UpdateStreamOutput, __MetadataBearer {
    }
    /**
        * <p>Updates stream metadata, such as the device name and media type.</p>
        *         <p>You must provide the stream name or the Amazon Resource Name (ARN) of the
        *             stream.</p>
        *         <p>To make sure that you have the latest version of the stream before updating it, you
        *             can specify the stream version. Kinesis Video Streams assigns a version to each stream.
        *             When you update a stream, Kinesis Video Streams assigns a new version number. To get the
        *             latest stream version, use the <code>DescribeStream</code> API. </p>
        *         <p>
        *             <code>UpdateStream</code> is an asynchronous operation, and takes time to
        *             complete.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoClient, UpdateStreamCommand } from "@aws-sdk/client-kinesis-video"; // ES Modules import
        * // const { KinesisVideoClient, UpdateStreamCommand } = require("@aws-sdk/client-kinesis-video"); // CommonJS import
        * const client = new KinesisVideoClient(config);
        * const command = new UpdateStreamCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateStreamCommandInput} for command's `input` shape.
        * @see {@link UpdateStreamCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoClientResolvedConfig | config} for KinesisVideoClient's `config` shape.
        *
        */
    export class UpdateStreamCommand extends $Command<UpdateStreamCommandInput, UpdateStreamCommandOutput, KinesisVideoClientResolvedConfig> {
            readonly input: UpdateStreamCommandInput;
            constructor(input: UpdateStreamCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateStreamCommandInput, UpdateStreamCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/KinesisVideoClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { CreateSignalingChannelCommandInput, CreateSignalingChannelCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/CreateSignalingChannelCommand";
    import { CreateStreamCommandInput, CreateStreamCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/CreateStreamCommand";
    import { DeleteSignalingChannelCommandInput, DeleteSignalingChannelCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/DeleteSignalingChannelCommand";
    import { DeleteStreamCommandInput, DeleteStreamCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/DeleteStreamCommand";
    import { DescribeImageGenerationConfigurationCommandInput, DescribeImageGenerationConfigurationCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/DescribeImageGenerationConfigurationCommand";
    import { DescribeNotificationConfigurationCommandInput, DescribeNotificationConfigurationCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/DescribeNotificationConfigurationCommand";
    import { DescribeSignalingChannelCommandInput, DescribeSignalingChannelCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/DescribeSignalingChannelCommand";
    import { DescribeStreamCommandInput, DescribeStreamCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/DescribeStreamCommand";
    import { GetDataEndpointCommandInput, GetDataEndpointCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/GetDataEndpointCommand";
    import { GetSignalingChannelEndpointCommandInput, GetSignalingChannelEndpointCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/GetSignalingChannelEndpointCommand";
    import { ListSignalingChannelsCommandInput, ListSignalingChannelsCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/ListSignalingChannelsCommand";
    import { ListStreamsCommandInput, ListStreamsCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/ListStreamsCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/ListTagsForResourceCommand";
    import { ListTagsForStreamCommandInput, ListTagsForStreamCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/ListTagsForStreamCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/TagResourceCommand";
    import { TagStreamCommandInput, TagStreamCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/TagStreamCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/UntagResourceCommand";
    import { UntagStreamCommandInput, UntagStreamCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/UntagStreamCommand";
    import { UpdateDataRetentionCommandInput, UpdateDataRetentionCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/UpdateDataRetentionCommand";
    import { UpdateImageGenerationConfigurationCommandInput, UpdateImageGenerationConfigurationCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/UpdateImageGenerationConfigurationCommand";
    import { UpdateNotificationConfigurationCommandInput, UpdateNotificationConfigurationCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/UpdateNotificationConfigurationCommand";
    import { UpdateSignalingChannelCommandInput, UpdateSignalingChannelCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/UpdateSignalingChannelCommand";
    import { UpdateStreamCommandInput, UpdateStreamCommandOutput } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/commands/UpdateStreamCommand";
    export type ServiceInputTypes = CreateSignalingChannelCommandInput | CreateStreamCommandInput | DeleteSignalingChannelCommandInput | DeleteStreamCommandInput | DescribeImageGenerationConfigurationCommandInput | DescribeNotificationConfigurationCommandInput | DescribeSignalingChannelCommandInput | DescribeStreamCommandInput | GetDataEndpointCommandInput | GetSignalingChannelEndpointCommandInput | ListSignalingChannelsCommandInput | ListStreamsCommandInput | ListTagsForResourceCommandInput | ListTagsForStreamCommandInput | TagResourceCommandInput | TagStreamCommandInput | UntagResourceCommandInput | UntagStreamCommandInput | UpdateDataRetentionCommandInput | UpdateImageGenerationConfigurationCommandInput | UpdateNotificationConfigurationCommandInput | UpdateSignalingChannelCommandInput | UpdateStreamCommandInput;
    export type ServiceOutputTypes = CreateSignalingChannelCommandOutput | CreateStreamCommandOutput | DeleteSignalingChannelCommandOutput | DeleteStreamCommandOutput | DescribeImageGenerationConfigurationCommandOutput | DescribeNotificationConfigurationCommandOutput | DescribeSignalingChannelCommandOutput | DescribeStreamCommandOutput | GetDataEndpointCommandOutput | GetSignalingChannelEndpointCommandOutput | ListSignalingChannelsCommandOutput | ListStreamsCommandOutput | ListTagsForResourceCommandOutput | ListTagsForStreamCommandOutput | TagResourceCommandOutput | TagStreamCommandOutput | UntagResourceCommandOutput | UntagStreamCommandOutput | UpdateDataRetentionCommandOutput | UpdateImageGenerationConfigurationCommandOutput | UpdateNotificationConfigurationCommandOutput | UpdateSignalingChannelCommandOutput | UpdateStreamCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type KinesisVideoClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of KinesisVideoClient class constructor that set the region, credentials and other options.
        */
    export interface KinesisVideoClientConfig extends KinesisVideoClientConfigType {
    }
    type KinesisVideoClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of KinesisVideoClient class. This is resolved and normalized from the {@link KinesisVideoClientConfig | constructor configuration interface}.
        */
    export interface KinesisVideoClientResolvedConfig extends KinesisVideoClientResolvedConfigType {
    }
    /**
        * <p></p>
        */
    export class KinesisVideoClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, KinesisVideoClientResolvedConfig> {
            /**
                * The resolved configuration of KinesisVideoClient class. This is resolved and normalized from the {@link KinesisVideoClientConfig | constructor configuration interface}.
                */
            readonly config: KinesisVideoClientResolvedConfig;
            constructor(configuration: KinesisVideoClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { KinesisVideoServiceException as __BaseException } from "@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/KinesisVideoServiceException";
    /**
        * <p>You do not have required permissions to perform this operation.</p>
        */
    export class AccessDeniedException extends __BaseException {
            readonly name: "AccessDeniedException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AccessDeniedException, __BaseException>);
    }
    /**
        * <p>You have reached the maximum limit of active signaling channels for this Amazon Web Services account
        *             in this region.</p>
        */
    export class AccountChannelLimitExceededException extends __BaseException {
            readonly name: "AccountChannelLimitExceededException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AccountChannelLimitExceededException, __BaseException>);
    }
    /**
        * <p>The number of streams created for the account is too high.</p>
        */
    export class AccountStreamLimitExceededException extends __BaseException {
            readonly name: "AccountStreamLimitExceededException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AccountStreamLimitExceededException, __BaseException>);
    }
    export enum APIName {
            GET_CLIP = "GET_CLIP",
            GET_DASH_STREAMING_SESSION_URL = "GET_DASH_STREAMING_SESSION_URL",
            GET_HLS_STREAMING_SESSION_URL = "GET_HLS_STREAMING_SESSION_URL",
            GET_IMAGES = "GET_IMAGES",
            GET_MEDIA = "GET_MEDIA",
            GET_MEDIA_FOR_FRAGMENT_LIST = "GET_MEDIA_FOR_FRAGMENT_LIST",
            LIST_FRAGMENTS = "LIST_FRAGMENTS",
            PUT_MEDIA = "PUT_MEDIA"
    }
    export enum Status {
            ACTIVE = "ACTIVE",
            CREATING = "CREATING",
            DELETING = "DELETING",
            UPDATING = "UPDATING"
    }
    export enum ChannelType {
            FULL_MESH = "FULL_MESH",
            SINGLE_MASTER = "SINGLE_MASTER"
    }
    /**
        * <p>A structure that contains the configuration for the <code>SINGLE_MASTER</code> channel
        *             type.</p>
        */
    export interface SingleMasterConfiguration {
            /**
                * <p>The period of time a signaling channel retains undelivered messages before they are
                *             discarded.</p>
                */
            MessageTtlSeconds?: number;
    }
    export namespace SingleMasterConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SingleMasterConfiguration) => any;
    }
    /**
        * <p>A structure that encapsulates a signaling channel's metadata and properties.</p>
        */
    export interface ChannelInfo {
            /**
                * <p>The name of the signaling channel.</p>
                */
            ChannelName?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the signaling channel.</p>
                */
            ChannelARN?: string;
            /**
                * <p>The type of the signaling channel.</p>
                */
            ChannelType?: ChannelType | string;
            /**
                * <p>Current status of the signaling channel.</p>
                */
            ChannelStatus?: Status | string;
            /**
                * <p>The time at which the signaling channel was created.</p>
                */
            CreationTime?: Date;
            /**
                * <p>A structure that contains the configuration for the <code>SINGLE_MASTER</code> channel
                *             type.</p>
                */
            SingleMasterConfiguration?: SingleMasterConfiguration;
            /**
                * <p>The current version of the signaling channel.</p>
                */
            Version?: string;
    }
    export namespace ChannelInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ChannelInfo) => any;
    }
    export enum ComparisonOperator {
            BEGINS_WITH = "BEGINS_WITH"
    }
    /**
        * <p>An optional input parameter for the <code>ListSignalingChannels</code> API. When this
        *             parameter is specified while invoking <code>ListSignalingChannels</code>, the API
        *             returns only the channels that satisfy a condition specified in
        *                 <code>ChannelNameCondition</code>.</p>
        */
    export interface ChannelNameCondition {
            /**
                * <p>A comparison operator. Currently, you can only specify the <code>BEGINS_WITH</code>
                *             operator, which finds signaling channels whose names begin with a given prefix.</p>
                */
            ComparisonOperator?: ComparisonOperator | string;
            /**
                * <p>A value to compare.</p>
                */
            ComparisonValue?: string;
    }
    export namespace ChannelNameCondition {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ChannelNameCondition) => any;
    }
    export enum ChannelProtocol {
            HTTPS = "HTTPS",
            WSS = "WSS"
    }
    export enum ChannelRole {
            MASTER = "MASTER",
            VIEWER = "VIEWER"
    }
    /**
        * <p>Kinesis Video Streams has throttled the request because you have exceeded the limit of
        *             allowed client calls. Try making the call later.</p>
        */
    export class ClientLimitExceededException extends __BaseException {
            readonly name: "ClientLimitExceededException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClientLimitExceededException, __BaseException>);
    }
    export enum ConfigurationStatus {
            DISABLED = "DISABLED",
            ENABLED = "ENABLED"
    }
    /**
        * <p>A key and value pair that is associated with the specified signaling channel.</p>
        */
    export interface Tag {
            /**
                * <p>The key of the tag that is associated with the specified signaling channel.</p>
                */
            Key: string | undefined;
            /**
                * <p>The value of the tag that is associated with the specified signaling channel.</p>
                */
            Value: string | undefined;
    }
    export namespace Tag {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Tag) => any;
    }
    export interface CreateSignalingChannelInput {
            /**
                * <p>A name for the signaling channel that you are creating. It must be unique for each Amazon Web Services account and Amazon Web Services Region.</p>
                */
            ChannelName: string | undefined;
            /**
                * <p>A type of the signaling channel that you are creating. Currently,
                *                 <code>SINGLE_MASTER</code> is the only supported channel type. </p>
                */
            ChannelType?: ChannelType | string;
            /**
                * <p>A structure containing the configuration for the <code>SINGLE_MASTER</code> channel
                *             type. </p>
                */
            SingleMasterConfiguration?: SingleMasterConfiguration;
            /**
                * <p>A set of tags (key-value pairs) that you want to associate with this channel.</p>
                */
            Tags?: Tag[];
    }
    export namespace CreateSignalingChannelInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateSignalingChannelInput) => any;
    }
    export interface CreateSignalingChannelOutput {
            /**
                * <p>The Amazon Resource Name (ARN) of the created channel.</p>
                */
            ChannelARN?: string;
    }
    export namespace CreateSignalingChannelOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateSignalingChannelOutput) => any;
    }
    /**
        * <p>The value for this input parameter is invalid.</p>
        */
    export class InvalidArgumentException extends __BaseException {
            readonly name: "InvalidArgumentException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidArgumentException, __BaseException>);
    }
    /**
        * <p>The resource is currently not available for this operation. New resources cannot be
        *             created with the same name as existing resources. Also, resources cannot be updated or
        *             deleted unless they are in an <code>ACTIVE</code> state.</p>
        *         <p>If this exception is returned, do not use it to determine whether the requested
        *             resource already exists. Instead, it is recommended you use the resource-specific
        *             describe API, for example, <code>DescribeStream</code> for video streams.</p>
        */
    export class ResourceInUseException extends __BaseException {
            readonly name: "ResourceInUseException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceInUseException, __BaseException>);
    }
    /**
        * <p>You have exceeded the limit of tags that you can associate with the resource.
        *             A Kinesis video stream can support up to 50 tags. </p>
        */
    export class TagsPerResourceExceededLimitException extends __BaseException {
            readonly name: "TagsPerResourceExceededLimitException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TagsPerResourceExceededLimitException, __BaseException>);
    }
    export interface CreateStreamInput {
            /**
                * <p>The name of the device that is writing to the stream. </p>
                *         <note>
                *             <p>In the current implementation, Kinesis Video Streams does not use this
                *                 name.</p>
                *         </note>
                */
            DeviceName?: string;
            /**
                * <p>A name for the stream that you are creating.</p>
                *         <p>The stream name is an identifier for the stream, and must be unique for each
                *             account and region.</p>
                */
            StreamName: string | undefined;
            /**
                * <p>The media type of the stream. Consumers of the stream can use this information when
                *             processing the stream. For more information about media types, see <a href="http://www.iana.org/assignments/media-types/media-types.xhtml">Media
                *                 Types</a>. If you choose to specify the <code>MediaType</code>, see <a href="https://tools.ietf.org/html/rfc6838#section-4.2">Naming Requirements</a>
                *             for guidelines.</p>
                *
                *         <p>Example valid values include "video/h264" and "video/h264,audio/aac".</p>
                *         <p>This parameter is optional; the default value is <code>null</code> (or empty in
                *             JSON).</p>
                */
            MediaType?: string;
            /**
                * <p>The ID of the Key Management Service (KMS) key that you want Kinesis Video
                *             Streams to use to encrypt stream data.</p>
                *         <p>If no key ID is specified, the default, Kinesis Video-managed key
                *                 (<code>aws/kinesisvideo</code>) is used.</p>
                *         <p> For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters">DescribeKey</a>. </p>
                */
            KmsKeyId?: string;
            /**
                * <p>The number of hours that you want to retain the data in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream.</p>
                *         <p>The default value is 0, indicating that the stream does not persist data.</p>
                *         <p>When the <code>DataRetentionInHours</code> value is 0, consumers can still consume
                *             the fragments that remain in the service host buffer, which has a retention time limit
                *             of 5 minutes and a retention memory limit of 200 MB. Fragments are removed from the
                *             buffer when either limit is reached.</p>
                */
            DataRetentionInHours?: number;
            /**
                * <p>A list of tags to associate with the specified stream. Each tag is a key-value pair
                *             (the value is optional).</p>
                */
            Tags?: Record<string, string>;
    }
    export namespace CreateStreamInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateStreamInput) => any;
    }
    export interface CreateStreamOutput {
            /**
                * <p>The Amazon Resource Name (ARN) of the stream.</p>
                */
            StreamARN?: string;
    }
    export namespace CreateStreamOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateStreamOutput) => any;
    }
    /**
        * <p>Not implemented.
        *             </p>
        */
    export class DeviceStreamLimitExceededException extends __BaseException {
            readonly name: "DeviceStreamLimitExceededException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DeviceStreamLimitExceededException, __BaseException>);
    }
    /**
        * <p>Not implemented.</p>
        */
    export class InvalidDeviceException extends __BaseException {
            readonly name: "InvalidDeviceException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidDeviceException, __BaseException>);
    }
    export interface DeleteSignalingChannelInput {
            /**
                * <p>The Amazon Resource Name (ARN) of the signaling channel that you want to
                *             delete.</p>
                */
            ChannelARN: string | undefined;
            /**
                * <p>The current version of the signaling channel that you want to delete. You can obtain
                *             the current version by invoking the <code>DescribeSignalingChannel</code> or
                *                 <code>ListSignalingChannels</code> API operations.</p>
                */
            CurrentVersion?: string;
    }
    export namespace DeleteSignalingChannelInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteSignalingChannelInput) => any;
    }
    export interface DeleteSignalingChannelOutput {
    }
    export namespace DeleteSignalingChannelOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteSignalingChannelOutput) => any;
    }
    /**
        * <p>Amazon Kinesis Video Streams can't find the stream that you specified.</p>
        */
    export class ResourceNotFoundException extends __BaseException {
            readonly name: "ResourceNotFoundException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>);
    }
    /**
        * <p>The stream version that you specified is not the latest version. To get the latest
        *             version, use the <a href="https://docs.aws.amazon.com/kinesisvideostreams/latest/dg/API_DescribeStream.html">DescribeStream</a>
        *             API.</p>
        */
    export class VersionMismatchException extends __BaseException {
            readonly name: "VersionMismatchException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<VersionMismatchException, __BaseException>);
    }
    export interface DeleteStreamInput {
            /**
                * <p>The Amazon Resource Name (ARN) of the stream that you want to delete. </p>
                */
            StreamARN: string | undefined;
            /**
                * <p>Optional: The version of the stream that you want to delete. </p>
                *         <p>Specify the version as a safeguard to ensure that your are deleting the correct
                *             stream. To get the stream version, use the <code>DescribeStream</code> API.</p>
                *         <p>If not specified, only the <code>CreationTime</code> is checked before deleting the
                *             stream.</p>
                */
            CurrentVersion?: string;
    }
    export namespace DeleteStreamInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteStreamInput) => any;
    }
    export interface DeleteStreamOutput {
    }
    export namespace DeleteStreamOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteStreamOutput) => any;
    }
    /**
        * <p>The caller is not authorized to perform this operation.</p>
        */
    export class NotAuthorizedException extends __BaseException {
            readonly name: "NotAuthorizedException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NotAuthorizedException, __BaseException>);
    }
    export interface DescribeImageGenerationConfigurationInput {
            /**
                * <p>The name of the stream from which to retrieve the image generation configuration. You must specify either the <code>StreamName</code> or the <code>StreamARN</code>.  </p>
                */
            StreamName?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the Kinesis video stream from which to retrieve the image generation configuration. You must specify either the <code>StreamName</code> or the <code>StreamARN</code>.</p>
                */
            StreamARN?: string;
    }
    export namespace DescribeImageGenerationConfigurationInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeImageGenerationConfigurationInput) => any;
    }
    /**
        * <p>The structure that contains the information required to deliver images to a customer.</p>
        */
    export interface ImageGenerationDestinationConfig {
            /**
                * <p>The Uniform Resource Idenifier (URI) that identifies where the images will be delivered.</p>
                */
            Uri: string | undefined;
            /**
                * <p>The AWS Region of the S3 bucket where images will be delivered. This <code>DestinationRegion</code> must match the Region where the stream is located.</p>
                */
            DestinationRegion: string | undefined;
    }
    export namespace ImageGenerationDestinationConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImageGenerationDestinationConfig) => any;
    }
    export enum Format {
            JPEG = "JPEG",
            PNG = "PNG"
    }
    export enum FormatConfigKey {
            JPEGQuality = "JPEGQuality"
    }
    export enum ImageSelectorType {
            PRODUCER_TIMESTAMP = "PRODUCER_TIMESTAMP",
            SERVER_TIMESTAMP = "SERVER_TIMESTAMP"
    }
    /**
        * <p>The structure that contains the information required for the KVS images delivery. If null, the configuration will be deleted from the stream.</p>
        */
    export interface ImageGenerationConfiguration {
            /**
                * <p>Indicates whether the <code>ContinuousImageGenerationConfigurations</code> API is enabled or disabled.</p>
                */
            Status: ConfigurationStatus | string | undefined;
            /**
                * <p>The origin of the Server or Producer timestamps to use to generate the images.</p>
                */
            ImageSelectorType: ImageSelectorType | string | undefined;
            /**
                * <p>The structure that contains the information required to deliver images to a customer.</p>
                */
            DestinationConfig: ImageGenerationDestinationConfig | undefined;
            /**
                * <p>The time interval in milliseconds (ms) at which the images need to be generated from the stream. The minimum value that can be provided is 33 ms,
                *             because a camera that generates content at 30 FPS would create a frame every 33.3 ms. If the timestamp range is less than the sampling interval, the
                *             Image from the <code>StartTimestamp</code> will be returned if available. </p>
                */
            SamplingInterval: number | undefined;
            /**
                * <p>The accepted image format.</p>
                */
            Format: Format | string | undefined;
            /**
                * <p>The list of a key-value pair structure that contains extra parameters that can be applied when the image is generated.
                *             The <code>FormatConfig</code> key is the <code>JPEGQuality</code>, which indicates the JPEG quality key to be used to generate the image.
                *             The <code>FormatConfig</code> value accepts ints from 1 to 100. If the value is 1, the image will be generated with less quality and the best compression.
                *             If the value is 100, the image will be generated with the best quality and less compression. If no value is provided, the default value of the <code>JPEGQuality</code>
                *             key will be set to 80.</p>
                */
            FormatConfig?: Record<string, string>;
            /**
                * <p>The width of the output image that is used in conjunction with the <code>HeightPixels</code> parameter. When both <code>WidthPixels</code> and
                *             <code>HeightPixels</code> parameters are provided, the image will be stretched to fit the specified aspect ratio. If only the <code>WidthPixels</code> parameter is
                *             provided, its original aspect ratio will be used to calculate the <code>HeightPixels</code> ratio. If neither parameter is provided, the original image size will be returned.</p>
                */
            WidthPixels?: number;
            /**
                * <p>The height of the output image that is used in conjunction with the <code>WidthPixels</code> parameter. When both
                *             <code>HeightPixels</code> and <code>WidthPixels</code> parameters are provided, the image will be stretched to fit the specified aspect ratio.
                *             If only the <code>HeightPixels</code> parameter is provided, its original aspect ratio will be used to calculate the <code>WidthPixels</code> ratio.
                *             If neither parameter is provided, the original image size will be returned.</p>
                */
            HeightPixels?: number;
    }
    export namespace ImageGenerationConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImageGenerationConfiguration) => any;
    }
    export interface DescribeImageGenerationConfigurationOutput {
            /**
                * <p>The structure that contains the information required for the Kinesis video stream (KVS) images delivery. If this structure is null, the configuration will be deleted from the stream.</p>
                */
            ImageGenerationConfiguration?: ImageGenerationConfiguration;
    }
    export namespace DescribeImageGenerationConfigurationOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeImageGenerationConfigurationOutput) => any;
    }
    export interface DescribeNotificationConfigurationInput {
            /**
                * <p>The name of the stream from which to retrieve the notification configuration. You must specify either the <code>StreamName</code> or the <code>StreamARN</code>.</p>
                */
            StreamName?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the Kinesis video stream from where you want to retrieve the notification configuration. You must specify either the <code>StreamName</code> or the StreamARN.</p>
                */
            StreamARN?: string;
    }
    export namespace DescribeNotificationConfigurationInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeNotificationConfigurationInput) => any;
    }
    /**
        * <p>The structure that contains the information required to deliver a notification to a customer.</p>
        */
    export interface NotificationDestinationConfig {
            /**
                * <p>The Uniform Resource Idenifier (URI) that identifies where the images will be delivered.</p>
                */
            Uri: string | undefined;
    }
    export namespace NotificationDestinationConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: NotificationDestinationConfig) => any;
    }
    /**
        * <p>The structure that contains the notification information for the KVS images delivery. If this parameter is null, the configuration will be deleted from the stream.</p>
        */
    export interface NotificationConfiguration {
            /**
                * <p>Indicates if a notification configuration is enabled or disabled.</p>
                */
            Status: ConfigurationStatus | string | undefined;
            /**
                * <p>The destination information required to deliver a notification to a customer.</p>
                */
            DestinationConfig: NotificationDestinationConfig | undefined;
    }
    export namespace NotificationConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: NotificationConfiguration) => any;
    }
    export interface DescribeNotificationConfigurationOutput {
            /**
                * <p>The structure that contains the information required for notifications. If the structure is null, the configuration will be deleted from the stream.</p>
                */
            NotificationConfiguration?: NotificationConfiguration;
    }
    export namespace DescribeNotificationConfigurationOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeNotificationConfigurationOutput) => any;
    }
    export interface DescribeSignalingChannelInput {
            /**
                * <p>The name of the signaling channel that you want to describe.</p>
                */
            ChannelName?: string;
            /**
                * <p>The ARN of the signaling channel that you want to describe.</p>
                */
            ChannelARN?: string;
    }
    export namespace DescribeSignalingChannelInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeSignalingChannelInput) => any;
    }
    export interface DescribeSignalingChannelOutput {
            /**
                * <p>A structure that encapsulates the specified signaling channel's metadata and
                *             properties.</p>
                */
            ChannelInfo?: ChannelInfo;
    }
    export namespace DescribeSignalingChannelOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeSignalingChannelOutput) => any;
    }
    export interface DescribeStreamInput {
            /**
                * <p>The name of the stream.</p>
                */
            StreamName?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the stream.</p>
                */
            StreamARN?: string;
    }
    export namespace DescribeStreamInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeStreamInput) => any;
    }
    /**
        * <p>An object describing a Kinesis video stream.</p>
        */
    export interface StreamInfo {
            /**
                * <p>The name of the device that is associated with the stream.</p>
                */
            DeviceName?: string;
            /**
                * <p>The name of the stream.</p>
                */
            StreamName?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the stream.</p>
                */
            StreamARN?: string;
            /**
                * <p>The <code>MediaType</code> of the stream. </p>
                */
            MediaType?: string;
            /**
                * <p>The ID of the Key Management Service (KMS) key that Kinesis Video Streams
                *             uses to encrypt data on the stream.</p>
                */
            KmsKeyId?: string;
            /**
                * <p>The version of the stream.</p>
                */
            Version?: string;
            /**
                * <p>The status of the stream.</p>
                */
            Status?: Status | string;
            /**
                * <p>A time stamp that indicates when the stream was created.</p>
                */
            CreationTime?: Date;
            /**
                * <p>How long the stream retains data, in hours.</p>
                */
            DataRetentionInHours?: number;
    }
    export namespace StreamInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StreamInfo) => any;
    }
    export interface DescribeStreamOutput {
            /**
                * <p>An object that describes the stream.</p>
                */
            StreamInfo?: StreamInfo;
    }
    export namespace DescribeStreamOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeStreamOutput) => any;
    }
    export interface GetDataEndpointInput {
            /**
                * <p>The name of the stream that you want to get the endpoint for. You must specify
                *             either this parameter or a <code>StreamARN</code> in the request.</p>
                */
            StreamName?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the stream that you want to get the endpoint for.
                *             You must specify either this parameter or a <code>StreamName</code> in the request.
                *         </p>
                */
            StreamARN?: string;
            /**
                * <p>The name of the API action for which to get an endpoint.</p>
                */
            APIName: APIName | string | undefined;
    }
    export namespace GetDataEndpointInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetDataEndpointInput) => any;
    }
    export interface GetDataEndpointOutput {
            /**
                * <p>The endpoint value. To read data from the stream or to write data to it, specify
                *             this endpoint in your application.</p>
                */
            DataEndpoint?: string;
    }
    export namespace GetDataEndpointOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetDataEndpointOutput) => any;
    }
    /**
        * <p>An object that contains the endpoint configuration for the <code>SINGLE_MASTER</code>
        *             channel type. </p>
        */
    export interface SingleMasterChannelEndpointConfiguration {
            /**
                * <p>This property is used to determine the nature of communication over this
                *                 <code>SINGLE_MASTER</code> signaling channel. If <code>WSS</code> is specified, this
                *             API returns a websocket endpoint. If <code>HTTPS</code> is specified, this API returns
                *             an <code>HTTPS</code> endpoint.</p>
                */
            Protocols?: (ChannelProtocol | string)[];
            /**
                * <p>This property is used to determine messaging permissions in this
                *                 <code>SINGLE_MASTER</code> signaling channel. If <code>MASTER</code> is specified,
                *             this API returns an endpoint that a client can use to receive offers from and send
                *             answers to any of the viewers on this signaling channel. If <code>VIEWER</code> is
                *             specified, this API returns an endpoint that a client can use only to send offers to
                *             another <code>MASTER</code> client on this signaling channel. </p>
                */
            Role?: ChannelRole | string;
    }
    export namespace SingleMasterChannelEndpointConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SingleMasterChannelEndpointConfiguration) => any;
    }
    export interface GetSignalingChannelEndpointInput {
            /**
                * <p>The Amazon Resource Name (ARN) of the signalling channel for which you want to get an
                *             endpoint.</p>
                */
            ChannelARN: string | undefined;
            /**
                * <p>A structure containing the endpoint configuration for the <code>SINGLE_MASTER</code>
                *             channel type.</p>
                */
            SingleMasterChannelEndpointConfiguration?: SingleMasterChannelEndpointConfiguration;
    }
    export namespace GetSignalingChannelEndpointInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetSignalingChannelEndpointInput) => any;
    }
    /**
        * <p>An object that describes the endpoint of the signaling channel returned by the
        *                 <code>GetSignalingChannelEndpoint</code> API.</p>
        */
    export interface ResourceEndpointListItem {
            /**
                * <p>The protocol of the signaling channel returned by the
                *                 <code>GetSignalingChannelEndpoint</code> API.</p>
                */
            Protocol?: ChannelProtocol | string;
            /**
                * <p>The endpoint of the signaling channel returned by the
                *                 <code>GetSignalingChannelEndpoint</code> API.</p>
                */
            ResourceEndpoint?: string;
    }
    export namespace ResourceEndpointListItem {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResourceEndpointListItem) => any;
    }
    export interface GetSignalingChannelEndpointOutput {
            /**
                * <p>A list of endpoints for the specified signaling channel.</p>
                */
            ResourceEndpointList?: ResourceEndpointListItem[];
    }
    export namespace GetSignalingChannelEndpointOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetSignalingChannelEndpointOutput) => any;
    }
    /**
        * <p>The format of the <code>StreamARN</code> is invalid.</p>
        */
    export class InvalidResourceFormatException extends __BaseException {
            readonly name: "InvalidResourceFormatException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidResourceFormatException, __BaseException>);
    }
    export interface ListSignalingChannelsInput {
            /**
                * <p>The maximum number of channels to return in the response. The default is 500.</p>
                */
            MaxResults?: number;
            /**
                * <p>If you specify this parameter, when the result of a <code>ListSignalingChannels</code>
                *             operation is truncated, the call returns the <code>NextToken</code> in the response. To
                *             get another batch of channels, provide this token in your next request.</p>
                */
            NextToken?: string;
            /**
                * <p>Optional: Returns only the channels that satisfy a specific condition.</p>
                */
            ChannelNameCondition?: ChannelNameCondition;
    }
    export namespace ListSignalingChannelsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListSignalingChannelsInput) => any;
    }
    export interface ListSignalingChannelsOutput {
            /**
                * <p>An array of <code>ChannelInfo</code> objects.</p>
                */
            ChannelInfoList?: ChannelInfo[];
            /**
                * <p>If the response is truncated, the call returns this element with a token. To get the
                *             next batch of streams, use this token in your next request.</p>
                */
            NextToken?: string;
    }
    export namespace ListSignalingChannelsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListSignalingChannelsOutput) => any;
    }
    /**
        * <p>Specifies the condition that streams must satisfy to be returned when you list
        *             streams (see the <code>ListStreams</code> API). A condition has a comparison operation
        *             and a value. Currently, you can specify only the <code>BEGINS_WITH</code> operator,
        *             which finds streams whose names start with a given prefix. </p>
        */
    export interface StreamNameCondition {
            /**
                * <p>A comparison operator. Currently, you can specify only the <code>BEGINS_WITH</code>
                *             operator, which finds streams whose names start with a given prefix.</p>
                */
            ComparisonOperator?: ComparisonOperator | string;
            /**
                * <p>A value to compare.</p>
                */
            ComparisonValue?: string;
    }
    export namespace StreamNameCondition {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StreamNameCondition) => any;
    }
    export interface ListStreamsInput {
            /**
                * <p>The maximum number of streams to return in the response. The default is
                *             10,000.</p>
                */
            MaxResults?: number;
            /**
                * <p>If you specify this parameter, when the result of a <code>ListStreams</code>
                *             operation is truncated, the call returns the <code>NextToken</code> in the response. To
                *             get another batch of streams, provide this token in your next request.</p>
                */
            NextToken?: string;
            /**
                * <p>Optional: Returns only streams that satisfy a specific condition. Currently, you
                *             can specify only the prefix of a stream name as a condition. </p>
                */
            StreamNameCondition?: StreamNameCondition;
    }
    export namespace ListStreamsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListStreamsInput) => any;
    }
    export interface ListStreamsOutput {
            /**
                * <p>An array of <code>StreamInfo</code> objects.</p>
                */
            StreamInfoList?: StreamInfo[];
            /**
                * <p>If the response is truncated, the call returns this element with a token. To get
                *             the next batch of streams, use this token in your next request. </p>
                */
            NextToken?: string;
    }
    export namespace ListStreamsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListStreamsOutput) => any;
    }
    export interface ListTagsForResourceInput {
            /**
                * <p>If you specify this parameter and the result of a <code>ListTagsForResource</code>
                *             call is truncated, the response includes a token that you can use in the next request to
                *             fetch the next batch of tags. </p>
                */
            NextToken?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the signaling channel for which you want to list
                *             tags.</p>
                */
            ResourceARN: string | undefined;
    }
    export namespace ListTagsForResourceInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceInput) => any;
    }
    export interface ListTagsForResourceOutput {
            /**
                * <p>If you specify this parameter and the result of a <code>ListTagsForResource</code>
                *             call is truncated, the response includes a token that you can use in the next request to
                *             fetch the next set of tags. </p>
                */
            NextToken?: string;
            /**
                * <p>A map of tag keys and values associated with the specified signaling channel.</p>
                */
            Tags?: Record<string, string>;
    }
    export namespace ListTagsForResourceOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceOutput) => any;
    }
    export interface ListTagsForStreamInput {
            /**
                * <p>If you specify this parameter and the result of a <code>ListTagsForStream</code>
                *             call is truncated, the response includes a token that you can use in the next request to
                *             fetch the next batch of tags.</p>
                */
            NextToken?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the stream that you want to list tags
                *             for.</p>
                */
            StreamARN?: string;
            /**
                * <p>The name of the stream that you want to list tags for.</p>
                */
            StreamName?: string;
    }
    export namespace ListTagsForStreamInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForStreamInput) => any;
    }
    export interface ListTagsForStreamOutput {
            /**
                * <p>If you specify this parameter and the result of a <code>ListTags</code> call is
                *             truncated, the response includes a token that you can use in the next request to fetch
                *             the next set of tags.</p>
                */
            NextToken?: string;
            /**
                * <p>A map of tag keys and values associated with the specified stream.</p>
                */
            Tags?: Record<string, string>;
    }
    export namespace ListTagsForStreamOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForStreamOutput) => any;
    }
    export interface TagResourceInput {
            /**
                * <p>The Amazon Resource Name (ARN) of the signaling channel to which you want to add
                *             tags.</p>
                */
            ResourceARN: string | undefined;
            /**
                * <p>A list of tags to associate with the specified signaling channel. Each tag is a
                *             key-value pair.</p>
                */
            Tags: Tag[] | undefined;
    }
    export namespace TagResourceInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceInput) => any;
    }
    export interface TagResourceOutput {
    }
    export namespace TagResourceOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceOutput) => any;
    }
    export interface TagStreamInput {
            /**
                * <p>The Amazon Resource Name (ARN) of the resource that you want to add the tag or tags
                *             to.</p>
                */
            StreamARN?: string;
            /**
                * <p>The name of the stream that you want to add the tag or tags to.</p>
                */
            StreamName?: string;
            /**
                * <p>A list of tags to associate with the specified stream. Each tag is a key-value pair
                *             (the value is optional).</p>
                */
            Tags: Record<string, string> | undefined;
    }
    export namespace TagStreamInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagStreamInput) => any;
    }
    export interface TagStreamOutput {
    }
    export namespace TagStreamOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagStreamOutput) => any;
    }
    export interface UntagResourceInput {
            /**
                * <p>The Amazon Resource Name (ARN) of the signaling channel from which you want to remove
                *             tags.</p>
                */
            ResourceARN: string | undefined;
            /**
                * <p>A list of the keys of the tags that you want to remove.</p>
                */
            TagKeyList: string[] | undefined;
    }
    export namespace UntagResourceInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceInput) => any;
    }
    export interface UntagResourceOutput {
    }
    export namespace UntagResourceOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceOutput) => any;
    }
    export interface UntagStreamInput {
            /**
                * <p>The Amazon Resource Name (ARN) of the stream that you want to remove tags
                *             from.</p>
                */
            StreamARN?: string;
            /**
                * <p>The name of the stream that you want to remove tags from.</p>
                */
            StreamName?: string;
            /**
                * <p>A list of the keys of the tags that you want to remove.</p>
                */
            TagKeyList: string[] | undefined;
    }
    export namespace UntagStreamInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagStreamInput) => any;
    }
    export interface UntagStreamOutput {
    }
    export namespace UntagStreamOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagStreamOutput) => any;
    }
    export enum UpdateDataRetentionOperation {
            DECREASE_DATA_RETENTION = "DECREASE_DATA_RETENTION",
            INCREASE_DATA_RETENTION = "INCREASE_DATA_RETENTION"
    }
    export interface UpdateDataRetentionInput {
            /**
                * <p>The name of the stream whose retention period you want to change.</p>
                */
            StreamName?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the stream whose retention period you want to
                *             change.</p>
                */
            StreamARN?: string;
            /**
                * <p>The version of the stream whose retention period you want to change. To get the
                *             version, call either the <code>DescribeStream</code> or the <code>ListStreams</code>
                *             API.</p>
                */
            CurrentVersion: string | undefined;
            /**
                * <p>Indicates whether you want to increase or decrease the retention period.</p>
                */
            Operation: UpdateDataRetentionOperation | string | undefined;
            /**
                * <p>The retention period, in hours. The value you specify replaces the current value.
                *             The maximum value for this parameter is 87600 (ten years).</p>
                */
            DataRetentionChangeInHours: number | undefined;
    }
    export namespace UpdateDataRetentionInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateDataRetentionInput) => any;
    }
    export interface UpdateDataRetentionOutput {
    }
    export namespace UpdateDataRetentionOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateDataRetentionOutput) => any;
    }
    /**
        * <p>The Stream data retention in hours is equal to zero.</p>
        */
    export class NoDataRetentionException extends __BaseException {
            readonly name: "NoDataRetentionException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NoDataRetentionException, __BaseException>);
    }
    export interface UpdateImageGenerationConfigurationInput {
            /**
                * <p>The name of the stream from which to update the image generation configuration. You must specify either the <code>StreamName</code> or the <code>StreamARN</code>.</p>
                */
            StreamName?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the Kinesis video stream from where you want to update the image generation configuration. You must specify either the <code>StreamName</code>
                *             or the <code>StreamARN</code>.</p>
                */
            StreamARN?: string;
            /**
                * <p>The structure that contains the information required for the KVS images delivery. If the structure is null, the configuration will be deleted from the stream.</p>
                */
            ImageGenerationConfiguration?: ImageGenerationConfiguration;
    }
    export namespace UpdateImageGenerationConfigurationInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateImageGenerationConfigurationInput) => any;
    }
    export interface UpdateImageGenerationConfigurationOutput {
    }
    export namespace UpdateImageGenerationConfigurationOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateImageGenerationConfigurationOutput) => any;
    }
    export interface UpdateNotificationConfigurationInput {
            /**
                * <p>The name of the stream from which to update the notification configuration. You must specify either the <code>StreamName</code> or the <code>StreamARN</code>.</p>
                */
            StreamName?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the Kinesis video stream from where you want to update the notification configuration. You must specify either the <code>StreamName</code> or the <code>StreamARN</code>.</p>
                */
            StreamARN?: string;
            /**
                * <p>The structure containing the information required for notifications. If the structure is null, the configuration will be deleted from the stream.</p>
                */
            NotificationConfiguration?: NotificationConfiguration;
    }
    export namespace UpdateNotificationConfigurationInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateNotificationConfigurationInput) => any;
    }
    export interface UpdateNotificationConfigurationOutput {
    }
    export namespace UpdateNotificationConfigurationOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateNotificationConfigurationOutput) => any;
    }
    export interface UpdateSignalingChannelInput {
            /**
                * <p>The Amazon Resource Name (ARN) of the signaling channel that you want to
                *             update.</p>
                */
            ChannelARN: string | undefined;
            /**
                * <p>The current version of the signaling channel that you want to update.</p>
                */
            CurrentVersion: string | undefined;
            /**
                * <p>The structure containing the configuration for the <code>SINGLE_MASTER</code> type of
                *             the signaling channel that you want to update. </p>
                */
            SingleMasterConfiguration?: SingleMasterConfiguration;
    }
    export namespace UpdateSignalingChannelInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateSignalingChannelInput) => any;
    }
    export interface UpdateSignalingChannelOutput {
    }
    export namespace UpdateSignalingChannelOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateSignalingChannelOutput) => any;
    }
    export interface UpdateStreamInput {
            /**
                * <p>The name of the stream whose metadata you want to update.</p>
                *         <p>The stream name is an identifier for the stream, and must be unique for each
                *             account and region.</p>
                */
            StreamName?: string;
            /**
                * <p>The ARN of the stream whose metadata you want to update.</p>
                */
            StreamARN?: string;
            /**
                * <p>The version of the stream whose metadata you want to update.</p>
                */
            CurrentVersion: string | undefined;
            /**
                * <p>The name of the device that is writing to the stream. </p>
                *         <note>
                *             <p> In the current implementation, Kinesis Video Streams does not use this name.
                *             </p>
                *         </note>
                */
            DeviceName?: string;
            /**
                * <p>The stream's media type. Use <code>MediaType</code> to specify the type of content
                *             that the stream contains to the consumers of the stream. For more information about
                *             media types, see <a href="http://www.iana.org/assignments/media-types/media-types.xhtml">Media
                *                 Types</a>. If you choose to specify the <code>MediaType</code>, see <a href="https://tools.ietf.org/html/rfc6838#section-4.2">Naming
                *             Requirements</a>.</p>
                *         <p>To play video on the console, you must specify the correct video type. For example,
                *             if the video in the stream is H.264, specify <code>video/h264</code> as the
                *                 <code>MediaType</code>.</p>
                */
            MediaType?: string;
    }
    export namespace UpdateStreamInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateStreamInput) => any;
    }
    export interface UpdateStreamOutput {
    }
    export namespace UpdateStreamOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateStreamOutput) => any;
    }
}

declare module '@aws-sdk/client-kinesis-video/node_modules/@aws-sdk/client-kinesis-video/dist-types/models/KinesisVideoServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from KinesisVideo service.
        */
    export class KinesisVideoServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

