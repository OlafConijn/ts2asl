// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http
//   @aws-sdk/smithy-client

declare module '@aws-sdk/client-acm' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { ACMClient } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/ACMClient";
    import { AddTagsToCertificateCommandInput, AddTagsToCertificateCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/AddTagsToCertificateCommand";
    import { DeleteCertificateCommandInput, DeleteCertificateCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/DeleteCertificateCommand";
    import { DescribeCertificateCommandInput, DescribeCertificateCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/DescribeCertificateCommand";
    import { ExportCertificateCommandInput, ExportCertificateCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/ExportCertificateCommand";
    import { GetAccountConfigurationCommandInput, GetAccountConfigurationCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/GetAccountConfigurationCommand";
    import { GetCertificateCommandInput, GetCertificateCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/GetCertificateCommand";
    import { ImportCertificateCommandInput, ImportCertificateCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/ImportCertificateCommand";
    import { ListCertificatesCommandInput, ListCertificatesCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/ListCertificatesCommand";
    import { ListTagsForCertificateCommandInput, ListTagsForCertificateCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/ListTagsForCertificateCommand";
    import { PutAccountConfigurationCommandInput, PutAccountConfigurationCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/PutAccountConfigurationCommand";
    import { RemoveTagsFromCertificateCommandInput, RemoveTagsFromCertificateCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/RemoveTagsFromCertificateCommand";
    import { RenewCertificateCommandInput, RenewCertificateCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/RenewCertificateCommand";
    import { RequestCertificateCommandInput, RequestCertificateCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/RequestCertificateCommand";
    import { ResendValidationEmailCommandInput, ResendValidationEmailCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/ResendValidationEmailCommand";
    import { UpdateCertificateOptionsCommandInput, UpdateCertificateOptionsCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/UpdateCertificateOptionsCommand";
    /**
        * <fullname>Amazon Web Services Certificate Manager</fullname>
        *          <p>You can use Amazon Web Services Certificate Manager (ACM) to manage SSL/TLS certificates for your Amazon Web Services-based websites
        *       and applications. For more information about using ACM, see the <a href="https://docs.aws.amazon.com/acm/latest/userguide/">Amazon Web Services Certificate Manager User Guide</a>.</p>
        */
    export class ACM extends ACMClient {
            /**
                * <p>Adds one or more tags to an ACM certificate. Tags are labels that you can use to
                *       identify and organize your Amazon Web Services resources. Each tag consists of a <code>key</code> and an
                *       optional <code>value</code>. You specify the certificate on input by its Amazon Resource Name
                *       (ARN). You specify the tag by using a key-value pair. </p>
                *
                *          <p>You can apply a tag to just one certificate if you want to identify a specific
                *       characteristic of that certificate, or you can apply the same tag to multiple certificates if
                *       you want to filter for a common relationship among those certificates. Similarly, you can
                *       apply the same tag to multiple resources if you want to specify a relationship among those
                *       resources. For example, you can add the same tag to an ACM certificate and an Elastic Load
                *       Balancing load balancer to indicate that they are both used by the same website. For more
                *       information, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/tags.html">Tagging ACM
                *         certificates</a>. </p>
                *
                *          <p>To remove one or more tags, use the <a>RemoveTagsFromCertificate</a> action. To
                *       view all of the tags that have been applied to the certificate, use the <a>ListTagsForCertificate</a> action. </p>
                */
            addTagsToCertificate(args: AddTagsToCertificateCommandInput, options?: __HttpHandlerOptions): Promise<AddTagsToCertificateCommandOutput>;
            addTagsToCertificate(args: AddTagsToCertificateCommandInput, cb: (err: any, data?: AddTagsToCertificateCommandOutput) => void): void;
            addTagsToCertificate(args: AddTagsToCertificateCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AddTagsToCertificateCommandOutput) => void): void;
            /**
                * <p>Deletes a certificate and its associated private key. If this action succeeds, the
                *       certificate no longer appears in the list that can be displayed by calling the <a>ListCertificates</a> action or be retrieved by calling the <a>GetCertificate</a> action. The certificate will not be available for use by Amazon Web Services
                *       services integrated with ACM. </p>
                *          <note>
                *             <p>You cannot delete an ACM certificate that is being used by another Amazon Web Services service. To
                *         delete a certificate that is in use, the certificate association must first be
                *         removed.</p>
                *          </note>
                */
            deleteCertificate(args: DeleteCertificateCommandInput, options?: __HttpHandlerOptions): Promise<DeleteCertificateCommandOutput>;
            deleteCertificate(args: DeleteCertificateCommandInput, cb: (err: any, data?: DeleteCertificateCommandOutput) => void): void;
            deleteCertificate(args: DeleteCertificateCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteCertificateCommandOutput) => void): void;
            /**
                * <p>Returns detailed metadata about the specified ACM certificate.</p>
                */
            describeCertificate(args: DescribeCertificateCommandInput, options?: __HttpHandlerOptions): Promise<DescribeCertificateCommandOutput>;
            describeCertificate(args: DescribeCertificateCommandInput, cb: (err: any, data?: DescribeCertificateCommandOutput) => void): void;
            describeCertificate(args: DescribeCertificateCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeCertificateCommandOutput) => void): void;
            /**
                * <p>Exports a private certificate issued by a private certificate authority (CA) for use
                *       anywhere. The exported file contains the certificate, the certificate chain, and the encrypted
                *       private 2048-bit RSA key associated with the public key that is embedded in the certificate.
                *       For security, you must assign a passphrase for the private key when exporting it. </p>
                *          <p>For information about exporting and formatting a certificate using the ACM console or
                *       CLI, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-export-private.html">Export a
                *         Private Certificate</a>.</p>
                */
            exportCertificate(args: ExportCertificateCommandInput, options?: __HttpHandlerOptions): Promise<ExportCertificateCommandOutput>;
            exportCertificate(args: ExportCertificateCommandInput, cb: (err: any, data?: ExportCertificateCommandOutput) => void): void;
            exportCertificate(args: ExportCertificateCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ExportCertificateCommandOutput) => void): void;
            /**
                * <p>Returns the account
                *       configuration options associated with an Amazon Web Services account.</p>
                */
            getAccountConfiguration(args: GetAccountConfigurationCommandInput, options?: __HttpHandlerOptions): Promise<GetAccountConfigurationCommandOutput>;
            getAccountConfiguration(args: GetAccountConfigurationCommandInput, cb: (err: any, data?: GetAccountConfigurationCommandOutput) => void): void;
            getAccountConfiguration(args: GetAccountConfigurationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetAccountConfigurationCommandOutput) => void): void;
            /**
                * <p>Retrieves an Amazon-issued certificate and its certificate chain. The chain consists of
                *       the certificate of the issuing CA and the intermediate certificates of any other subordinate
                *       CAs. All of the certificates are base64 encoded. You can use <a href="https://wiki.openssl.org/index.php/Command_Line_Utilities">OpenSSL</a> to decode
                *       the certificates and inspect individual fields.</p>
                */
            getCertificate(args: GetCertificateCommandInput, options?: __HttpHandlerOptions): Promise<GetCertificateCommandOutput>;
            getCertificate(args: GetCertificateCommandInput, cb: (err: any, data?: GetCertificateCommandOutput) => void): void;
            getCertificate(args: GetCertificateCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetCertificateCommandOutput) => void): void;
            /**
                * <p>Imports a certificate into Amazon Web Services Certificate Manager (ACM) to use with services that are integrated with
                *       ACM. Note that <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-services.html">integrated
                *         services</a> allow only certificate types and keys they support to be associated with
                *       their resources. Further, their support differs depending on whether the certificate is
                *       imported into IAM or into ACM. For more information, see the documentation for each
                *       service. For more information about importing certificates into ACM, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html">Importing
                *         Certificates</a> in the <i>Amazon Web Services Certificate Manager User Guide</i>. </p>
                *
                *          <note>
                *             <p>ACM does not provide <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-renewal.html">managed renewal</a> for certificates that you import.</p>
                *          </note>
                *
                *          <p>Note the following guidelines when importing third party certificates:</p>
                *
                *
                *          <ul>
                *             <li>
                *                <p>You must enter the private key that matches the certificate you are importing.</p>
                *             </li>
                *             <li>
                *                <p>The private key must be unencrypted. You cannot import a private key that is protected
                *           by a password or a passphrase.</p>
                *             </li>
                *             <li>
                *                <p>The private key must be no larger than 5 KB (5,120 bytes).</p>
                *             </li>
                *             <li>
                *                <p>If the certificate you are importing is not self-signed, you must enter its
                *           certificate chain.</p>
                *             </li>
                *             <li>
                *                <p>If a certificate chain is included, the issuer must be the subject of one of the
                *           certificates in the chain.</p>
                *             </li>
                *             <li>
                *                <p>The certificate, private key, and certificate chain must be PEM-encoded.</p>
                *             </li>
                *             <li>
                *                <p>The current time must be between the <code>Not Before</code> and <code>Not
                *             After</code> certificate fields.</p>
                *             </li>
                *             <li>
                *                <p>The <code>Issuer</code> field must not be empty.</p>
                *             </li>
                *             <li>
                *                <p>The OCSP authority URL, if present, must not exceed 1000 characters.</p>
                *             </li>
                *             <li>
                *                <p>To import a new certificate, omit the <code>CertificateArn</code> argument. Include
                *           this argument only when you want to replace a previously imported certificate.</p>
                *             </li>
                *             <li>
                *                <p>When you import a certificate by using the CLI, you must specify the certificate, the
                *           certificate chain, and the private key by their file names preceded by
                *             <code>fileb://</code>. For example, you can specify a certificate saved in the
                *             <code>C:\temp</code> folder as <code>fileb://C:\temp\certificate_to_import.pem</code>.
                *           If you are making an HTTP or HTTPS Query request, include these arguments as BLOBs.
                *         </p>
                *             </li>
                *             <li>
                *                <p>When you import a certificate by using an SDK, you must specify the certificate, the
                *           certificate chain, and the private key files in the manner required by the programming
                *           language you're using. </p>
                *             </li>
                *             <li>
                *                <p>The cryptographic algorithm of an imported certificate must match the algorithm of the
                *           signing CA. For example, if the signing CA key type is RSA, then the certificate key type
                *           must also be RSA.</p>
                *             </li>
                *          </ul>
                *
                *          <p>This operation returns the <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon
                *         Resource Name (ARN)</a> of the imported certificate.</p>
                */
            importCertificate(args: ImportCertificateCommandInput, options?: __HttpHandlerOptions): Promise<ImportCertificateCommandOutput>;
            importCertificate(args: ImportCertificateCommandInput, cb: (err: any, data?: ImportCertificateCommandOutput) => void): void;
            importCertificate(args: ImportCertificateCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ImportCertificateCommandOutput) => void): void;
            /**
                * <p>Retrieves a list of certificate ARNs and domain names. You can request that only
                *       certificates that match a specific status be listed. You can also filter by specific
                *       attributes of the certificate. Default filtering returns only <code>RSA_2048</code>
                *       certificates. For more information, see <a>Filters</a>.</p>
                */
            listCertificates(args: ListCertificatesCommandInput, options?: __HttpHandlerOptions): Promise<ListCertificatesCommandOutput>;
            listCertificates(args: ListCertificatesCommandInput, cb: (err: any, data?: ListCertificatesCommandOutput) => void): void;
            listCertificates(args: ListCertificatesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListCertificatesCommandOutput) => void): void;
            /**
                * <p>Lists the tags that have been applied to the ACM certificate. Use the certificate's
                *       Amazon Resource Name (ARN) to specify the certificate. To add a tag to an ACM certificate,
                *       use the <a>AddTagsToCertificate</a> action. To delete a tag, use the <a>RemoveTagsFromCertificate</a> action. </p>
                */
            listTagsForCertificate(args: ListTagsForCertificateCommandInput, options?: __HttpHandlerOptions): Promise<ListTagsForCertificateCommandOutput>;
            listTagsForCertificate(args: ListTagsForCertificateCommandInput, cb: (err: any, data?: ListTagsForCertificateCommandOutput) => void): void;
            listTagsForCertificate(args: ListTagsForCertificateCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTagsForCertificateCommandOutput) => void): void;
            /**
                * <p>Adds or modifies
                *       account-level configurations in ACM.
                *       </p>
                *          <p>The
                *       supported configuration option is <code>DaysBeforeExpiry</code>. This option specifies the
                *       number of days prior to certificate expiration when ACM starts generating
                *         <code>EventBridge</code> events. ACM sends one event per day per certificate until the
                *       certificate expires. By default, accounts receive events starting 45 days before certificate
                *       expiration.</p>
                */
            putAccountConfiguration(args: PutAccountConfigurationCommandInput, options?: __HttpHandlerOptions): Promise<PutAccountConfigurationCommandOutput>;
            putAccountConfiguration(args: PutAccountConfigurationCommandInput, cb: (err: any, data?: PutAccountConfigurationCommandOutput) => void): void;
            putAccountConfiguration(args: PutAccountConfigurationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutAccountConfigurationCommandOutput) => void): void;
            /**
                * <p>Remove one or more tags from an ACM certificate. A tag consists of a key-value pair. If
                *       you do not specify the value portion of the tag when calling this function, the tag will be
                *       removed regardless of value. If you specify a value, the tag is removed only if it is
                *       associated with the specified value. </p>
                *
                *          <p>To add tags to a certificate, use the <a>AddTagsToCertificate</a> action. To
                *       view all of the tags that have been applied to a specific ACM certificate, use the <a>ListTagsForCertificate</a> action. </p>
                */
            removeTagsFromCertificate(args: RemoveTagsFromCertificateCommandInput, options?: __HttpHandlerOptions): Promise<RemoveTagsFromCertificateCommandOutput>;
            removeTagsFromCertificate(args: RemoveTagsFromCertificateCommandInput, cb: (err: any, data?: RemoveTagsFromCertificateCommandOutput) => void): void;
            removeTagsFromCertificate(args: RemoveTagsFromCertificateCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RemoveTagsFromCertificateCommandOutput) => void): void;
            /**
                * <p>Renews an eligible ACM certificate. At this time, only exported private certificates can
                *       be renewed with this operation. In order to renew your ACM PCA certificates with ACM, you must
                *       first <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/PcaPermissions.html">grant the ACM
                *         service principal permission to do so</a>. For more information, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/manual-renewal.html">Testing Managed Renewal</a>
                *       in the ACM User Guide.</p>
                */
            renewCertificate(args: RenewCertificateCommandInput, options?: __HttpHandlerOptions): Promise<RenewCertificateCommandOutput>;
            renewCertificate(args: RenewCertificateCommandInput, cb: (err: any, data?: RenewCertificateCommandOutput) => void): void;
            renewCertificate(args: RenewCertificateCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RenewCertificateCommandOutput) => void): void;
            /**
                * <p>Requests an ACM certificate for use with other Amazon Web Services services. To request an ACM
                *       certificate, you must specify a fully qualified domain name (FQDN) in the
                *         <code>DomainName</code> parameter. You can also specify additional FQDNs in the
                *         <code>SubjectAlternativeNames</code> parameter. </p>
                *          <p>If you are requesting a private certificate, domain validation is not required. If you are
                *       requesting a public certificate, each domain name that you specify must be validated to verify
                *       that you own or control the domain. You can use <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-validate-dns.html">DNS validation</a> or <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-validate-email.html">email validation</a>.
                *       We recommend that you use DNS validation. ACM issues public certificates after receiving
                *       approval from the domain owner. </p>
                *
                *          <note>
                *             <p>ACM behavior differs from the <a href="https://tools.ietf.org/html/rfc6125#appendix-B.2">https://tools.ietf.org/html/rfc6125#appendix-B.2</a>RFC 6125 specification of the
                *         certificate validation process. first checks for a subject alternative name, and, if it
                *         finds one, ignores the common name (CN)</p>
                *          </note>
                */
            requestCertificate(args: RequestCertificateCommandInput, options?: __HttpHandlerOptions): Promise<RequestCertificateCommandOutput>;
            requestCertificate(args: RequestCertificateCommandInput, cb: (err: any, data?: RequestCertificateCommandOutput) => void): void;
            requestCertificate(args: RequestCertificateCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RequestCertificateCommandOutput) => void): void;
            /**
                * <p>Resends the email that requests domain ownership validation. The domain owner or an
                *       authorized representative must approve the ACM certificate before it can be issued. The
                *       certificate can be approved by clicking a link in the mail to navigate to the Amazon
                *       certificate approval website and then clicking <b>I Approve</b>.
                *       However, the validation email can be blocked by spam filters. Therefore, if you do not receive
                *       the original mail, you can request that the mail be resent within 72 hours of requesting the
                *       ACM certificate. If more than 72 hours have elapsed since your original request or since
                *       your last attempt to resend validation mail, you must request a new certificate. For more
                *       information about setting up your contact email addresses, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/setup-email.html">Configure Email for your Domain</a>. </p>
                */
            resendValidationEmail(args: ResendValidationEmailCommandInput, options?: __HttpHandlerOptions): Promise<ResendValidationEmailCommandOutput>;
            resendValidationEmail(args: ResendValidationEmailCommandInput, cb: (err: any, data?: ResendValidationEmailCommandOutput) => void): void;
            resendValidationEmail(args: ResendValidationEmailCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ResendValidationEmailCommandOutput) => void): void;
            /**
                * <p>Updates a certificate. Currently, you can use this function to specify whether to opt in
                *       to or out of recording your certificate in a certificate transparency log. For more
                *       information, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-bestpractices.html#best-practices-transparency"> Opting Out of
                *         Certificate Transparency Logging</a>. </p>
                */
            updateCertificateOptions(args: UpdateCertificateOptionsCommandInput, options?: __HttpHandlerOptions): Promise<UpdateCertificateOptionsCommandOutput>;
            updateCertificateOptions(args: UpdateCertificateOptionsCommandInput, cb: (err: any, data?: UpdateCertificateOptionsCommandOutput) => void): void;
            updateCertificateOptions(args: UpdateCertificateOptionsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateCertificateOptionsCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/ACMClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { AddTagsToCertificateCommandInput, AddTagsToCertificateCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/AddTagsToCertificateCommand";
    import { DeleteCertificateCommandInput, DeleteCertificateCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/DeleteCertificateCommand";
    import { DescribeCertificateCommandInput, DescribeCertificateCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/DescribeCertificateCommand";
    import { ExportCertificateCommandInput, ExportCertificateCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/ExportCertificateCommand";
    import { GetAccountConfigurationCommandInput, GetAccountConfigurationCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/GetAccountConfigurationCommand";
    import { GetCertificateCommandInput, GetCertificateCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/GetCertificateCommand";
    import { ImportCertificateCommandInput, ImportCertificateCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/ImportCertificateCommand";
    import { ListCertificatesCommandInput, ListCertificatesCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/ListCertificatesCommand";
    import { ListTagsForCertificateCommandInput, ListTagsForCertificateCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/ListTagsForCertificateCommand";
    import { PutAccountConfigurationCommandInput, PutAccountConfigurationCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/PutAccountConfigurationCommand";
    import { RemoveTagsFromCertificateCommandInput, RemoveTagsFromCertificateCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/RemoveTagsFromCertificateCommand";
    import { RenewCertificateCommandInput, RenewCertificateCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/RenewCertificateCommand";
    import { RequestCertificateCommandInput, RequestCertificateCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/RequestCertificateCommand";
    import { ResendValidationEmailCommandInput, ResendValidationEmailCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/ResendValidationEmailCommand";
    import { UpdateCertificateOptionsCommandInput, UpdateCertificateOptionsCommandOutput } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/UpdateCertificateOptionsCommand";
    export type ServiceInputTypes = AddTagsToCertificateCommandInput | DeleteCertificateCommandInput | DescribeCertificateCommandInput | ExportCertificateCommandInput | GetAccountConfigurationCommandInput | GetCertificateCommandInput | ImportCertificateCommandInput | ListCertificatesCommandInput | ListTagsForCertificateCommandInput | PutAccountConfigurationCommandInput | RemoveTagsFromCertificateCommandInput | RenewCertificateCommandInput | RequestCertificateCommandInput | ResendValidationEmailCommandInput | UpdateCertificateOptionsCommandInput;
    export type ServiceOutputTypes = AddTagsToCertificateCommandOutput | DeleteCertificateCommandOutput | DescribeCertificateCommandOutput | ExportCertificateCommandOutput | GetAccountConfigurationCommandOutput | GetCertificateCommandOutput | ImportCertificateCommandOutput | ListCertificatesCommandOutput | ListTagsForCertificateCommandOutput | PutAccountConfigurationCommandOutput | RemoveTagsFromCertificateCommandOutput | RenewCertificateCommandOutput | RequestCertificateCommandOutput | ResendValidationEmailCommandOutput | UpdateCertificateOptionsCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type ACMClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of ACMClient class constructor that set the region, credentials and other options.
        */
    export interface ACMClientConfig extends ACMClientConfigType {
    }
    type ACMClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of ACMClient class. This is resolved and normalized from the {@link ACMClientConfig | constructor configuration interface}.
        */
    export interface ACMClientResolvedConfig extends ACMClientResolvedConfigType {
    }
    /**
        * <fullname>Amazon Web Services Certificate Manager</fullname>
        *          <p>You can use Amazon Web Services Certificate Manager (ACM) to manage SSL/TLS certificates for your Amazon Web Services-based websites
        *       and applications. For more information about using ACM, see the <a href="https://docs.aws.amazon.com/acm/latest/userguide/">Amazon Web Services Certificate Manager User Guide</a>.</p>
        */
    export class ACMClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, ACMClientResolvedConfig> {
            /**
                * The resolved configuration of ACMClient class. This is resolved and normalized from the {@link ACMClientConfig | constructor configuration interface}.
                */
            readonly config: ACMClientResolvedConfig;
            constructor(configuration: ACMClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/AddTagsToCertificateCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ACMClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/ACMClient";
    import { AddTagsToCertificateRequest } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/models/models_0";
    export interface AddTagsToCertificateCommandInput extends AddTagsToCertificateRequest {
    }
    export interface AddTagsToCertificateCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Adds one or more tags to an ACM certificate. Tags are labels that you can use to
        *       identify and organize your Amazon Web Services resources. Each tag consists of a <code>key</code> and an
        *       optional <code>value</code>. You specify the certificate on input by its Amazon Resource Name
        *       (ARN). You specify the tag by using a key-value pair. </p>
        *
        *          <p>You can apply a tag to just one certificate if you want to identify a specific
        *       characteristic of that certificate, or you can apply the same tag to multiple certificates if
        *       you want to filter for a common relationship among those certificates. Similarly, you can
        *       apply the same tag to multiple resources if you want to specify a relationship among those
        *       resources. For example, you can add the same tag to an ACM certificate and an Elastic Load
        *       Balancing load balancer to indicate that they are both used by the same website. For more
        *       information, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/tags.html">Tagging ACM
        *         certificates</a>. </p>
        *
        *          <p>To remove one or more tags, use the <a>RemoveTagsFromCertificate</a> action. To
        *       view all of the tags that have been applied to the certificate, use the <a>ListTagsForCertificate</a> action. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ACMClient, AddTagsToCertificateCommand } from "@aws-sdk/client-acm"; // ES Modules import
        * // const { ACMClient, AddTagsToCertificateCommand } = require("@aws-sdk/client-acm"); // CommonJS import
        * const client = new ACMClient(config);
        * const command = new AddTagsToCertificateCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link AddTagsToCertificateCommandInput} for command's `input` shape.
        * @see {@link AddTagsToCertificateCommandOutput} for command's `response` shape.
        * @see {@link ACMClientResolvedConfig | config} for ACMClient's `config` shape.
        *
        */
    export class AddTagsToCertificateCommand extends $Command<AddTagsToCertificateCommandInput, AddTagsToCertificateCommandOutput, ACMClientResolvedConfig> {
            readonly input: AddTagsToCertificateCommandInput;
            constructor(input: AddTagsToCertificateCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ACMClientResolvedConfig, options?: __HttpHandlerOptions): Handler<AddTagsToCertificateCommandInput, AddTagsToCertificateCommandOutput>;
    }
}

declare module '@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/DeleteCertificateCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ACMClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/ACMClient";
    import { DeleteCertificateRequest } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/models/models_0";
    export interface DeleteCertificateCommandInput extends DeleteCertificateRequest {
    }
    export interface DeleteCertificateCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes a certificate and its associated private key. If this action succeeds, the
        *       certificate no longer appears in the list that can be displayed by calling the <a>ListCertificates</a> action or be retrieved by calling the <a>GetCertificate</a> action. The certificate will not be available for use by Amazon Web Services
        *       services integrated with ACM. </p>
        *          <note>
        *             <p>You cannot delete an ACM certificate that is being used by another Amazon Web Services service. To
        *         delete a certificate that is in use, the certificate association must first be
        *         removed.</p>
        *          </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ACMClient, DeleteCertificateCommand } from "@aws-sdk/client-acm"; // ES Modules import
        * // const { ACMClient, DeleteCertificateCommand } = require("@aws-sdk/client-acm"); // CommonJS import
        * const client = new ACMClient(config);
        * const command = new DeleteCertificateCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteCertificateCommandInput} for command's `input` shape.
        * @see {@link DeleteCertificateCommandOutput} for command's `response` shape.
        * @see {@link ACMClientResolvedConfig | config} for ACMClient's `config` shape.
        *
        */
    export class DeleteCertificateCommand extends $Command<DeleteCertificateCommandInput, DeleteCertificateCommandOutput, ACMClientResolvedConfig> {
            readonly input: DeleteCertificateCommandInput;
            constructor(input: DeleteCertificateCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ACMClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteCertificateCommandInput, DeleteCertificateCommandOutput>;
    }
}

declare module '@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/DescribeCertificateCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ACMClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/ACMClient";
    import { DescribeCertificateRequest, DescribeCertificateResponse } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/models/models_0";
    export interface DescribeCertificateCommandInput extends DescribeCertificateRequest {
    }
    export interface DescribeCertificateCommandOutput extends DescribeCertificateResponse, __MetadataBearer {
    }
    /**
        * <p>Returns detailed metadata about the specified ACM certificate.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ACMClient, DescribeCertificateCommand } from "@aws-sdk/client-acm"; // ES Modules import
        * // const { ACMClient, DescribeCertificateCommand } = require("@aws-sdk/client-acm"); // CommonJS import
        * const client = new ACMClient(config);
        * const command = new DescribeCertificateCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeCertificateCommandInput} for command's `input` shape.
        * @see {@link DescribeCertificateCommandOutput} for command's `response` shape.
        * @see {@link ACMClientResolvedConfig | config} for ACMClient's `config` shape.
        *
        */
    export class DescribeCertificateCommand extends $Command<DescribeCertificateCommandInput, DescribeCertificateCommandOutput, ACMClientResolvedConfig> {
            readonly input: DescribeCertificateCommandInput;
            constructor(input: DescribeCertificateCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ACMClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeCertificateCommandInput, DescribeCertificateCommandOutput>;
    }
}

declare module '@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/ExportCertificateCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ACMClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/ACMClient";
    import { ExportCertificateRequest, ExportCertificateResponse } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/models/models_0";
    export interface ExportCertificateCommandInput extends ExportCertificateRequest {
    }
    export interface ExportCertificateCommandOutput extends ExportCertificateResponse, __MetadataBearer {
    }
    /**
        * <p>Exports a private certificate issued by a private certificate authority (CA) for use
        *       anywhere. The exported file contains the certificate, the certificate chain, and the encrypted
        *       private 2048-bit RSA key associated with the public key that is embedded in the certificate.
        *       For security, you must assign a passphrase for the private key when exporting it. </p>
        *          <p>For information about exporting and formatting a certificate using the ACM console or
        *       CLI, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-export-private.html">Export a
        *         Private Certificate</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ACMClient, ExportCertificateCommand } from "@aws-sdk/client-acm"; // ES Modules import
        * // const { ACMClient, ExportCertificateCommand } = require("@aws-sdk/client-acm"); // CommonJS import
        * const client = new ACMClient(config);
        * const command = new ExportCertificateCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ExportCertificateCommandInput} for command's `input` shape.
        * @see {@link ExportCertificateCommandOutput} for command's `response` shape.
        * @see {@link ACMClientResolvedConfig | config} for ACMClient's `config` shape.
        *
        */
    export class ExportCertificateCommand extends $Command<ExportCertificateCommandInput, ExportCertificateCommandOutput, ACMClientResolvedConfig> {
            readonly input: ExportCertificateCommandInput;
            constructor(input: ExportCertificateCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ACMClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ExportCertificateCommandInput, ExportCertificateCommandOutput>;
    }
}

declare module '@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/GetAccountConfigurationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ACMClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/ACMClient";
    import { GetAccountConfigurationResponse } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/models/models_0";
    export interface GetAccountConfigurationCommandInput {
    }
    export interface GetAccountConfigurationCommandOutput extends GetAccountConfigurationResponse, __MetadataBearer {
    }
    /**
        * <p>Returns the account
        *       configuration options associated with an Amazon Web Services account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ACMClient, GetAccountConfigurationCommand } from "@aws-sdk/client-acm"; // ES Modules import
        * // const { ACMClient, GetAccountConfigurationCommand } = require("@aws-sdk/client-acm"); // CommonJS import
        * const client = new ACMClient(config);
        * const command = new GetAccountConfigurationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetAccountConfigurationCommandInput} for command's `input` shape.
        * @see {@link GetAccountConfigurationCommandOutput} for command's `response` shape.
        * @see {@link ACMClientResolvedConfig | config} for ACMClient's `config` shape.
        *
        */
    export class GetAccountConfigurationCommand extends $Command<GetAccountConfigurationCommandInput, GetAccountConfigurationCommandOutput, ACMClientResolvedConfig> {
            readonly input: GetAccountConfigurationCommandInput;
            constructor(input: GetAccountConfigurationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ACMClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetAccountConfigurationCommandInput, GetAccountConfigurationCommandOutput>;
    }
}

declare module '@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/GetCertificateCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ACMClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/ACMClient";
    import { GetCertificateRequest, GetCertificateResponse } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/models/models_0";
    export interface GetCertificateCommandInput extends GetCertificateRequest {
    }
    export interface GetCertificateCommandOutput extends GetCertificateResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves an Amazon-issued certificate and its certificate chain. The chain consists of
        *       the certificate of the issuing CA and the intermediate certificates of any other subordinate
        *       CAs. All of the certificates are base64 encoded. You can use <a href="https://wiki.openssl.org/index.php/Command_Line_Utilities">OpenSSL</a> to decode
        *       the certificates and inspect individual fields.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ACMClient, GetCertificateCommand } from "@aws-sdk/client-acm"; // ES Modules import
        * // const { ACMClient, GetCertificateCommand } = require("@aws-sdk/client-acm"); // CommonJS import
        * const client = new ACMClient(config);
        * const command = new GetCertificateCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetCertificateCommandInput} for command's `input` shape.
        * @see {@link GetCertificateCommandOutput} for command's `response` shape.
        * @see {@link ACMClientResolvedConfig | config} for ACMClient's `config` shape.
        *
        */
    export class GetCertificateCommand extends $Command<GetCertificateCommandInput, GetCertificateCommandOutput, ACMClientResolvedConfig> {
            readonly input: GetCertificateCommandInput;
            constructor(input: GetCertificateCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ACMClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetCertificateCommandInput, GetCertificateCommandOutput>;
    }
}

declare module '@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/ImportCertificateCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ACMClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/ACMClient";
    import { ImportCertificateRequest, ImportCertificateResponse } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/models/models_0";
    export interface ImportCertificateCommandInput extends ImportCertificateRequest {
    }
    export interface ImportCertificateCommandOutput extends ImportCertificateResponse, __MetadataBearer {
    }
    /**
        * <p>Imports a certificate into Amazon Web Services Certificate Manager (ACM) to use with services that are integrated with
        *       ACM. Note that <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-services.html">integrated
        *         services</a> allow only certificate types and keys they support to be associated with
        *       their resources. Further, their support differs depending on whether the certificate is
        *       imported into IAM or into ACM. For more information, see the documentation for each
        *       service. For more information about importing certificates into ACM, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html">Importing
        *         Certificates</a> in the <i>Amazon Web Services Certificate Manager User Guide</i>. </p>
        *
        *          <note>
        *             <p>ACM does not provide <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-renewal.html">managed renewal</a> for certificates that you import.</p>
        *          </note>
        *
        *          <p>Note the following guidelines when importing third party certificates:</p>
        *
        *
        *          <ul>
        *             <li>
        *                <p>You must enter the private key that matches the certificate you are importing.</p>
        *             </li>
        *             <li>
        *                <p>The private key must be unencrypted. You cannot import a private key that is protected
        *           by a password or a passphrase.</p>
        *             </li>
        *             <li>
        *                <p>The private key must be no larger than 5 KB (5,120 bytes).</p>
        *             </li>
        *             <li>
        *                <p>If the certificate you are importing is not self-signed, you must enter its
        *           certificate chain.</p>
        *             </li>
        *             <li>
        *                <p>If a certificate chain is included, the issuer must be the subject of one of the
        *           certificates in the chain.</p>
        *             </li>
        *             <li>
        *                <p>The certificate, private key, and certificate chain must be PEM-encoded.</p>
        *             </li>
        *             <li>
        *                <p>The current time must be between the <code>Not Before</code> and <code>Not
        *             After</code> certificate fields.</p>
        *             </li>
        *             <li>
        *                <p>The <code>Issuer</code> field must not be empty.</p>
        *             </li>
        *             <li>
        *                <p>The OCSP authority URL, if present, must not exceed 1000 characters.</p>
        *             </li>
        *             <li>
        *                <p>To import a new certificate, omit the <code>CertificateArn</code> argument. Include
        *           this argument only when you want to replace a previously imported certificate.</p>
        *             </li>
        *             <li>
        *                <p>When you import a certificate by using the CLI, you must specify the certificate, the
        *           certificate chain, and the private key by their file names preceded by
        *             <code>fileb://</code>. For example, you can specify a certificate saved in the
        *             <code>C:\temp</code> folder as <code>fileb://C:\temp\certificate_to_import.pem</code>.
        *           If you are making an HTTP or HTTPS Query request, include these arguments as BLOBs.
        *         </p>
        *             </li>
        *             <li>
        *                <p>When you import a certificate by using an SDK, you must specify the certificate, the
        *           certificate chain, and the private key files in the manner required by the programming
        *           language you're using. </p>
        *             </li>
        *             <li>
        *                <p>The cryptographic algorithm of an imported certificate must match the algorithm of the
        *           signing CA. For example, if the signing CA key type is RSA, then the certificate key type
        *           must also be RSA.</p>
        *             </li>
        *          </ul>
        *
        *          <p>This operation returns the <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon
        *         Resource Name (ARN)</a> of the imported certificate.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ACMClient, ImportCertificateCommand } from "@aws-sdk/client-acm"; // ES Modules import
        * // const { ACMClient, ImportCertificateCommand } = require("@aws-sdk/client-acm"); // CommonJS import
        * const client = new ACMClient(config);
        * const command = new ImportCertificateCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ImportCertificateCommandInput} for command's `input` shape.
        * @see {@link ImportCertificateCommandOutput} for command's `response` shape.
        * @see {@link ACMClientResolvedConfig | config} for ACMClient's `config` shape.
        *
        */
    export class ImportCertificateCommand extends $Command<ImportCertificateCommandInput, ImportCertificateCommandOutput, ACMClientResolvedConfig> {
            readonly input: ImportCertificateCommandInput;
            constructor(input: ImportCertificateCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ACMClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ImportCertificateCommandInput, ImportCertificateCommandOutput>;
    }
}

declare module '@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/ListCertificatesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ACMClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/ACMClient";
    import { ListCertificatesRequest, ListCertificatesResponse } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/models/models_0";
    export interface ListCertificatesCommandInput extends ListCertificatesRequest {
    }
    export interface ListCertificatesCommandOutput extends ListCertificatesResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves a list of certificate ARNs and domain names. You can request that only
        *       certificates that match a specific status be listed. You can also filter by specific
        *       attributes of the certificate. Default filtering returns only <code>RSA_2048</code>
        *       certificates. For more information, see <a>Filters</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ACMClient, ListCertificatesCommand } from "@aws-sdk/client-acm"; // ES Modules import
        * // const { ACMClient, ListCertificatesCommand } = require("@aws-sdk/client-acm"); // CommonJS import
        * const client = new ACMClient(config);
        * const command = new ListCertificatesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListCertificatesCommandInput} for command's `input` shape.
        * @see {@link ListCertificatesCommandOutput} for command's `response` shape.
        * @see {@link ACMClientResolvedConfig | config} for ACMClient's `config` shape.
        *
        */
    export class ListCertificatesCommand extends $Command<ListCertificatesCommandInput, ListCertificatesCommandOutput, ACMClientResolvedConfig> {
            readonly input: ListCertificatesCommandInput;
            constructor(input: ListCertificatesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ACMClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListCertificatesCommandInput, ListCertificatesCommandOutput>;
    }
}

declare module '@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/ListTagsForCertificateCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ACMClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/ACMClient";
    import { ListTagsForCertificateRequest, ListTagsForCertificateResponse } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/models/models_0";
    export interface ListTagsForCertificateCommandInput extends ListTagsForCertificateRequest {
    }
    export interface ListTagsForCertificateCommandOutput extends ListTagsForCertificateResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the tags that have been applied to the ACM certificate. Use the certificate's
        *       Amazon Resource Name (ARN) to specify the certificate. To add a tag to an ACM certificate,
        *       use the <a>AddTagsToCertificate</a> action. To delete a tag, use the <a>RemoveTagsFromCertificate</a> action. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ACMClient, ListTagsForCertificateCommand } from "@aws-sdk/client-acm"; // ES Modules import
        * // const { ACMClient, ListTagsForCertificateCommand } = require("@aws-sdk/client-acm"); // CommonJS import
        * const client = new ACMClient(config);
        * const command = new ListTagsForCertificateCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTagsForCertificateCommandInput} for command's `input` shape.
        * @see {@link ListTagsForCertificateCommandOutput} for command's `response` shape.
        * @see {@link ACMClientResolvedConfig | config} for ACMClient's `config` shape.
        *
        */
    export class ListTagsForCertificateCommand extends $Command<ListTagsForCertificateCommandInput, ListTagsForCertificateCommandOutput, ACMClientResolvedConfig> {
            readonly input: ListTagsForCertificateCommandInput;
            constructor(input: ListTagsForCertificateCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ACMClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTagsForCertificateCommandInput, ListTagsForCertificateCommandOutput>;
    }
}

declare module '@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/PutAccountConfigurationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ACMClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/ACMClient";
    import { PutAccountConfigurationRequest } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/models/models_0";
    export interface PutAccountConfigurationCommandInput extends PutAccountConfigurationRequest {
    }
    export interface PutAccountConfigurationCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Adds or modifies
        *       account-level configurations in ACM.
        *       </p>
        *          <p>The
        *       supported configuration option is <code>DaysBeforeExpiry</code>. This option specifies the
        *       number of days prior to certificate expiration when ACM starts generating
        *         <code>EventBridge</code> events. ACM sends one event per day per certificate until the
        *       certificate expires. By default, accounts receive events starting 45 days before certificate
        *       expiration.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ACMClient, PutAccountConfigurationCommand } from "@aws-sdk/client-acm"; // ES Modules import
        * // const { ACMClient, PutAccountConfigurationCommand } = require("@aws-sdk/client-acm"); // CommonJS import
        * const client = new ACMClient(config);
        * const command = new PutAccountConfigurationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutAccountConfigurationCommandInput} for command's `input` shape.
        * @see {@link PutAccountConfigurationCommandOutput} for command's `response` shape.
        * @see {@link ACMClientResolvedConfig | config} for ACMClient's `config` shape.
        *
        */
    export class PutAccountConfigurationCommand extends $Command<PutAccountConfigurationCommandInput, PutAccountConfigurationCommandOutput, ACMClientResolvedConfig> {
            readonly input: PutAccountConfigurationCommandInput;
            constructor(input: PutAccountConfigurationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ACMClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutAccountConfigurationCommandInput, PutAccountConfigurationCommandOutput>;
    }
}

declare module '@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/RemoveTagsFromCertificateCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ACMClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/ACMClient";
    import { RemoveTagsFromCertificateRequest } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/models/models_0";
    export interface RemoveTagsFromCertificateCommandInput extends RemoveTagsFromCertificateRequest {
    }
    export interface RemoveTagsFromCertificateCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Remove one or more tags from an ACM certificate. A tag consists of a key-value pair. If
        *       you do not specify the value portion of the tag when calling this function, the tag will be
        *       removed regardless of value. If you specify a value, the tag is removed only if it is
        *       associated with the specified value. </p>
        *
        *          <p>To add tags to a certificate, use the <a>AddTagsToCertificate</a> action. To
        *       view all of the tags that have been applied to a specific ACM certificate, use the <a>ListTagsForCertificate</a> action. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ACMClient, RemoveTagsFromCertificateCommand } from "@aws-sdk/client-acm"; // ES Modules import
        * // const { ACMClient, RemoveTagsFromCertificateCommand } = require("@aws-sdk/client-acm"); // CommonJS import
        * const client = new ACMClient(config);
        * const command = new RemoveTagsFromCertificateCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RemoveTagsFromCertificateCommandInput} for command's `input` shape.
        * @see {@link RemoveTagsFromCertificateCommandOutput} for command's `response` shape.
        * @see {@link ACMClientResolvedConfig | config} for ACMClient's `config` shape.
        *
        */
    export class RemoveTagsFromCertificateCommand extends $Command<RemoveTagsFromCertificateCommandInput, RemoveTagsFromCertificateCommandOutput, ACMClientResolvedConfig> {
            readonly input: RemoveTagsFromCertificateCommandInput;
            constructor(input: RemoveTagsFromCertificateCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ACMClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RemoveTagsFromCertificateCommandInput, RemoveTagsFromCertificateCommandOutput>;
    }
}

declare module '@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/RenewCertificateCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ACMClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/ACMClient";
    import { RenewCertificateRequest } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/models/models_0";
    export interface RenewCertificateCommandInput extends RenewCertificateRequest {
    }
    export interface RenewCertificateCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Renews an eligible ACM certificate. At this time, only exported private certificates can
        *       be renewed with this operation. In order to renew your ACM PCA certificates with ACM, you must
        *       first <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/PcaPermissions.html">grant the ACM
        *         service principal permission to do so</a>. For more information, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/manual-renewal.html">Testing Managed Renewal</a>
        *       in the ACM User Guide.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ACMClient, RenewCertificateCommand } from "@aws-sdk/client-acm"; // ES Modules import
        * // const { ACMClient, RenewCertificateCommand } = require("@aws-sdk/client-acm"); // CommonJS import
        * const client = new ACMClient(config);
        * const command = new RenewCertificateCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RenewCertificateCommandInput} for command's `input` shape.
        * @see {@link RenewCertificateCommandOutput} for command's `response` shape.
        * @see {@link ACMClientResolvedConfig | config} for ACMClient's `config` shape.
        *
        */
    export class RenewCertificateCommand extends $Command<RenewCertificateCommandInput, RenewCertificateCommandOutput, ACMClientResolvedConfig> {
            readonly input: RenewCertificateCommandInput;
            constructor(input: RenewCertificateCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ACMClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RenewCertificateCommandInput, RenewCertificateCommandOutput>;
    }
}

declare module '@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/RequestCertificateCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ACMClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/ACMClient";
    import { RequestCertificateRequest, RequestCertificateResponse } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/models/models_0";
    export interface RequestCertificateCommandInput extends RequestCertificateRequest {
    }
    export interface RequestCertificateCommandOutput extends RequestCertificateResponse, __MetadataBearer {
    }
    /**
        * <p>Requests an ACM certificate for use with other Amazon Web Services services. To request an ACM
        *       certificate, you must specify a fully qualified domain name (FQDN) in the
        *         <code>DomainName</code> parameter. You can also specify additional FQDNs in the
        *         <code>SubjectAlternativeNames</code> parameter. </p>
        *          <p>If you are requesting a private certificate, domain validation is not required. If you are
        *       requesting a public certificate, each domain name that you specify must be validated to verify
        *       that you own or control the domain. You can use <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-validate-dns.html">DNS validation</a> or <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-validate-email.html">email validation</a>.
        *       We recommend that you use DNS validation. ACM issues public certificates after receiving
        *       approval from the domain owner. </p>
        *
        *          <note>
        *             <p>ACM behavior differs from the <a href="https://tools.ietf.org/html/rfc6125#appendix-B.2">https://tools.ietf.org/html/rfc6125#appendix-B.2</a>RFC 6125 specification of the
        *         certificate validation process. first checks for a subject alternative name, and, if it
        *         finds one, ignores the common name (CN)</p>
        *          </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ACMClient, RequestCertificateCommand } from "@aws-sdk/client-acm"; // ES Modules import
        * // const { ACMClient, RequestCertificateCommand } = require("@aws-sdk/client-acm"); // CommonJS import
        * const client = new ACMClient(config);
        * const command = new RequestCertificateCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RequestCertificateCommandInput} for command's `input` shape.
        * @see {@link RequestCertificateCommandOutput} for command's `response` shape.
        * @see {@link ACMClientResolvedConfig | config} for ACMClient's `config` shape.
        *
        */
    export class RequestCertificateCommand extends $Command<RequestCertificateCommandInput, RequestCertificateCommandOutput, ACMClientResolvedConfig> {
            readonly input: RequestCertificateCommandInput;
            constructor(input: RequestCertificateCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ACMClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RequestCertificateCommandInput, RequestCertificateCommandOutput>;
    }
}

declare module '@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/ResendValidationEmailCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ACMClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/ACMClient";
    import { ResendValidationEmailRequest } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/models/models_0";
    export interface ResendValidationEmailCommandInput extends ResendValidationEmailRequest {
    }
    export interface ResendValidationEmailCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Resends the email that requests domain ownership validation. The domain owner or an
        *       authorized representative must approve the ACM certificate before it can be issued. The
        *       certificate can be approved by clicking a link in the mail to navigate to the Amazon
        *       certificate approval website and then clicking <b>I Approve</b>.
        *       However, the validation email can be blocked by spam filters. Therefore, if you do not receive
        *       the original mail, you can request that the mail be resent within 72 hours of requesting the
        *       ACM certificate. If more than 72 hours have elapsed since your original request or since
        *       your last attempt to resend validation mail, you must request a new certificate. For more
        *       information about setting up your contact email addresses, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/setup-email.html">Configure Email for your Domain</a>. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ACMClient, ResendValidationEmailCommand } from "@aws-sdk/client-acm"; // ES Modules import
        * // const { ACMClient, ResendValidationEmailCommand } = require("@aws-sdk/client-acm"); // CommonJS import
        * const client = new ACMClient(config);
        * const command = new ResendValidationEmailCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ResendValidationEmailCommandInput} for command's `input` shape.
        * @see {@link ResendValidationEmailCommandOutput} for command's `response` shape.
        * @see {@link ACMClientResolvedConfig | config} for ACMClient's `config` shape.
        *
        */
    export class ResendValidationEmailCommand extends $Command<ResendValidationEmailCommandInput, ResendValidationEmailCommandOutput, ACMClientResolvedConfig> {
            readonly input: ResendValidationEmailCommandInput;
            constructor(input: ResendValidationEmailCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ACMClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ResendValidationEmailCommandInput, ResendValidationEmailCommandOutput>;
    }
}

declare module '@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/commands/UpdateCertificateOptionsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ACMClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/ACMClient";
    import { UpdateCertificateOptionsRequest } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/models/models_0";
    export interface UpdateCertificateOptionsCommandInput extends UpdateCertificateOptionsRequest {
    }
    export interface UpdateCertificateOptionsCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Updates a certificate. Currently, you can use this function to specify whether to opt in
        *       to or out of recording your certificate in a certificate transparency log. For more
        *       information, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-bestpractices.html#best-practices-transparency"> Opting Out of
        *         Certificate Transparency Logging</a>. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ACMClient, UpdateCertificateOptionsCommand } from "@aws-sdk/client-acm"; // ES Modules import
        * // const { ACMClient, UpdateCertificateOptionsCommand } = require("@aws-sdk/client-acm"); // CommonJS import
        * const client = new ACMClient(config);
        * const command = new UpdateCertificateOptionsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateCertificateOptionsCommandInput} for command's `input` shape.
        * @see {@link UpdateCertificateOptionsCommandOutput} for command's `response` shape.
        * @see {@link ACMClientResolvedConfig | config} for ACMClient's `config` shape.
        *
        */
    export class UpdateCertificateOptionsCommand extends $Command<UpdateCertificateOptionsCommandInput, UpdateCertificateOptionsCommandOutput, ACMClientResolvedConfig> {
            readonly input: UpdateCertificateOptionsCommandInput;
            constructor(input: UpdateCertificateOptionsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ACMClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateCertificateOptionsCommandInput, UpdateCertificateOptionsCommandOutput>;
    }
}

declare module '@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { ACMServiceException as __BaseException } from "@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/models/ACMServiceException";
    /**
        * <p>You do not have access
        *       required to perform this action.</p>
        */
    export class AccessDeniedException extends __BaseException {
            readonly name: "AccessDeniedException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AccessDeniedException, __BaseException>);
    }
    /**
        * <p>A key-value pair that identifies or specifies metadata about an ACM resource.</p>
        */
    export interface Tag {
            /**
                * <p>The key of the tag.</p>
                */
            Key: string | undefined;
            /**
                * <p>The value of the tag.</p>
                */
            Value?: string;
    }
    export namespace Tag {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Tag) => any;
    }
    export interface AddTagsToCertificateRequest {
            /**
                * <p>String that contains the ARN of the ACM certificate to which the tag is to be applied.
                *       This must be of the form:</p>
                *
                *          <p>
                *             <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
                *          </p>
                *
                *          <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a>.</p>
                */
            CertificateArn: string | undefined;
            /**
                * <p>The key-value pair that defines the tag. The tag value is optional.</p>
                */
            Tags: Tag[] | undefined;
    }
    export namespace AddTagsToCertificateRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AddTagsToCertificateRequest) => any;
    }
    /**
        * <p>The requested Amazon Resource Name (ARN) does not refer to an existing resource.</p>
        */
    export class InvalidArnException extends __BaseException {
            readonly name: "InvalidArnException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidArnException, __BaseException>);
    }
    /**
        * <p>An input parameter was invalid.</p>
        */
    export class InvalidParameterException extends __BaseException {
            readonly name: "InvalidParameterException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidParameterException, __BaseException>);
    }
    /**
        * <p>One or both of the values that make up the key-value pair is not valid. For example, you
        *       cannot specify a tag value that begins with <code>aws:</code>.</p>
        */
    export class InvalidTagException extends __BaseException {
            readonly name: "InvalidTagException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidTagException, __BaseException>);
    }
    /**
        * <p>The specified certificate cannot be found in the caller's account or the caller's account
        *       cannot be found.</p>
        */
    export class ResourceNotFoundException extends __BaseException {
            readonly name: "ResourceNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>);
    }
    /**
        * <p>A specified tag did not comply with an existing tag policy and was rejected.</p>
        */
    export class TagPolicyException extends __BaseException {
            readonly name: "TagPolicyException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TagPolicyException, __BaseException>);
    }
    /**
        * <p>The request was denied
        *       because it exceeded a quota.</p>
        */
    export class ThrottlingException extends __BaseException {
            readonly name: "ThrottlingException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ThrottlingException, __BaseException>);
    }
    /**
        * <p>The request contains too many tags. Try the request again with fewer tags.</p>
        */
    export class TooManyTagsException extends __BaseException {
            readonly name: "TooManyTagsException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyTagsException, __BaseException>);
    }
    export enum RecordType {
            CNAME = "CNAME"
    }
    /**
        * <p>Contains a DNS record value that you can use to validate ownership or control
        *       of a domain. This is used by the <a>DescribeCertificate</a> action. </p>
        */
    export interface ResourceRecord {
            /**
                * <p>The name of the DNS record to create in your domain. This is supplied by ACM.</p>
                */
            Name: string | undefined;
            /**
                * <p>The type of DNS record. Currently this can be <code>CNAME</code>.</p>
                */
            Type: RecordType | string | undefined;
            /**
                * <p>The value of the CNAME record to add to your DNS database. This is supplied by
                *       ACM.</p>
                */
            Value: string | undefined;
    }
    export namespace ResourceRecord {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResourceRecord) => any;
    }
    export enum ValidationMethod {
            DNS = "DNS",
            EMAIL = "EMAIL"
    }
    export enum DomainStatus {
            FAILED = "FAILED",
            PENDING_VALIDATION = "PENDING_VALIDATION",
            SUCCESS = "SUCCESS"
    }
    /**
        * <p>Contains information about the validation of each domain name in the certificate.</p>
        */
    export interface DomainValidation {
            /**
                * <p>A fully qualified domain name (FQDN) in the certificate. For example,
                *         <code>www.example.com</code> or <code>example.com</code>. </p>
                */
            DomainName: string | undefined;
            /**
                * <p>A list of email addresses that ACM used to send domain validation emails.</p>
                */
            ValidationEmails?: string[];
            /**
                * <p>The domain name that ACM used to send domain validation emails.</p>
                */
            ValidationDomain?: string;
            /**
                * <p>The validation status of the domain name. This can be one of the following values:</p>
                *
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>PENDING_VALIDATION</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code></code>SUCCESS</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code></code>FAILED</p>
                *             </li>
                *          </ul>
                */
            ValidationStatus?: DomainStatus | string;
            /**
                * <p>Contains the CNAME record that you add to your DNS database for domain validation. For
                *       more information, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-validate-dns.html">Use DNS to Validate Domain Ownership</a>.</p>
                *          <p>Note: The CNAME information that you need does not include the name of your domain. If you
                *       include
         your domain name in the DNS database CNAME record, validation fails.
         For example, if
                *       the name is "_a79865eb4cd1a6ab990a45779b4e0b96.yourdomain.com", only
                *       "_a79865eb4cd1a6ab990a45779b4e0b96" must be used.</p>
                */
            ResourceRecord?: ResourceRecord;
            /**
                * <p>Specifies the domain validation method.</p>
                */
            ValidationMethod?: ValidationMethod | string;
    }
    export namespace DomainValidation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DomainValidation) => any;
    }
    export enum ExtendedKeyUsageName {
            ANY = "ANY",
            CODE_SIGNING = "CODE_SIGNING",
            CUSTOM = "CUSTOM",
            EMAIL_PROTECTION = "EMAIL_PROTECTION",
            IPSEC_END_SYSTEM = "IPSEC_END_SYSTEM",
            IPSEC_TUNNEL = "IPSEC_TUNNEL",
            IPSEC_USER = "IPSEC_USER",
            NONE = "NONE",
            OCSP_SIGNING = "OCSP_SIGNING",
            TIME_STAMPING = "TIME_STAMPING",
            TLS_WEB_CLIENT_AUTHENTICATION = "TLS_WEB_CLIENT_AUTHENTICATION",
            TLS_WEB_SERVER_AUTHENTICATION = "TLS_WEB_SERVER_AUTHENTICATION"
    }
    /**
        * <p>The Extended Key Usage X.509 v3 extension defines one or more purposes for which the
        *       public key can be used. This is in addition to or in place of the basic purposes specified by
        *       the Key Usage extension. </p>
        */
    export interface ExtendedKeyUsage {
            /**
                * <p>The name of an Extended Key Usage value.</p>
                */
            Name?: ExtendedKeyUsageName | string;
            /**
                * <p>An object identifier (OID) for the extension value. OIDs are strings of numbers separated
                *       by periods. The following OIDs are defined in RFC 3280 and RFC 5280. </p>
                *
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>1.3.6.1.5.5.7.3.1 (TLS_WEB_SERVER_AUTHENTICATION)</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>1.3.6.1.5.5.7.3.2 (TLS_WEB_CLIENT_AUTHENTICATION)</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>1.3.6.1.5.5.7.3.3 (CODE_SIGNING)</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>1.3.6.1.5.5.7.3.4 (EMAIL_PROTECTION)</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>1.3.6.1.5.5.7.3.8 (TIME_STAMPING)</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>1.3.6.1.5.5.7.3.9 (OCSP_SIGNING)</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>1.3.6.1.5.5.7.3.5 (IPSEC_END_SYSTEM)</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>1.3.6.1.5.5.7.3.6 (IPSEC_TUNNEL)</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>1.3.6.1.5.5.7.3.7 (IPSEC_USER)</code>
                *                </p>
                *             </li>
                *          </ul>
                */
            OID?: string;
    }
    export namespace ExtendedKeyUsage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExtendedKeyUsage) => any;
    }
    export enum FailureReason {
            ADDITIONAL_VERIFICATION_REQUIRED = "ADDITIONAL_VERIFICATION_REQUIRED",
            CAA_ERROR = "CAA_ERROR",
            DOMAIN_NOT_ALLOWED = "DOMAIN_NOT_ALLOWED",
            DOMAIN_VALIDATION_DENIED = "DOMAIN_VALIDATION_DENIED",
            INVALID_PUBLIC_DOMAIN = "INVALID_PUBLIC_DOMAIN",
            NO_AVAILABLE_CONTACTS = "NO_AVAILABLE_CONTACTS",
            OTHER = "OTHER",
            PCA_ACCESS_DENIED = "PCA_ACCESS_DENIED",
            PCA_INVALID_ARGS = "PCA_INVALID_ARGS",
            PCA_INVALID_ARN = "PCA_INVALID_ARN",
            PCA_INVALID_DURATION = "PCA_INVALID_DURATION",
            PCA_INVALID_STATE = "PCA_INVALID_STATE",
            PCA_LIMIT_EXCEEDED = "PCA_LIMIT_EXCEEDED",
            PCA_NAME_CONSTRAINTS_VALIDATION = "PCA_NAME_CONSTRAINTS_VALIDATION",
            PCA_REQUEST_FAILED = "PCA_REQUEST_FAILED",
            PCA_RESOURCE_NOT_FOUND = "PCA_RESOURCE_NOT_FOUND",
            SLR_NOT_FOUND = "SLR_NOT_FOUND"
    }
    export enum KeyAlgorithm {
            EC_prime256v1 = "EC_prime256v1",
            EC_secp384r1 = "EC_secp384r1",
            EC_secp521r1 = "EC_secp521r1",
            RSA_1024 = "RSA_1024",
            RSA_2048 = "RSA_2048",
            RSA_3072 = "RSA_3072",
            RSA_4096 = "RSA_4096"
    }
    export enum KeyUsageName {
            ANY = "ANY",
            CERTIFICATE_SIGNING = "CERTIFICATE_SIGNING",
            CRL_SIGNING = "CRL_SIGNING",
            CUSTOM = "CUSTOM",
            DATA_ENCIPHERMENT = "DATA_ENCIPHERMENT",
            DECIPHER_ONLY = "DECIPHER_ONLY",
            DIGITAL_SIGNATURE = "DIGITAL_SIGNATURE",
            ENCHIPER_ONLY = "ENCIPHER_ONLY",
            KEY_AGREEMENT = "KEY_AGREEMENT",
            KEY_ENCIPHERMENT = "KEY_ENCIPHERMENT",
            NON_REPUDATION = "NON_REPUDIATION"
    }
    /**
        * <p>The Key Usage X.509 v3 extension defines the purpose of the public key contained in the
        *       certificate.</p>
        */
    export interface KeyUsage {
            /**
                * <p>A string value that contains a Key Usage extension name.</p>
                */
            Name?: KeyUsageName | string;
    }
    export namespace KeyUsage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: KeyUsage) => any;
    }
    export enum CertificateTransparencyLoggingPreference {
            DISABLED = "DISABLED",
            ENABLED = "ENABLED"
    }
    /**
        * <p>Structure that contains options for your certificate. Currently, you can use this only to
        *       specify whether to opt in to or out of certificate transparency logging. Some browsers require
        *       that public certificates issued for your domain be recorded in a log. Certificates that are
        *       not logged typically generate a browser error. Transparency makes it possible for you to
        *       detect SSL/TLS certificates that have been mistakenly or maliciously issued for your domain.
        *       For general information, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-concepts.html#concept-transparency">Certificate Transparency
        *         Logging</a>. </p>
        */
    export interface CertificateOptions {
            /**
                * <p>You can opt out of certificate transparency logging by specifying the
                *         <code>DISABLED</code> option. Opt in by specifying <code>ENABLED</code>. </p>
                */
            CertificateTransparencyLoggingPreference?: CertificateTransparencyLoggingPreference | string;
    }
    export namespace CertificateOptions {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CertificateOptions) => any;
    }
    export enum RenewalEligibility {
            ELIGIBLE = "ELIGIBLE",
            INELIGIBLE = "INELIGIBLE"
    }
    export enum RenewalStatus {
            FAILED = "FAILED",
            PENDING_AUTO_RENEWAL = "PENDING_AUTO_RENEWAL",
            PENDING_VALIDATION = "PENDING_VALIDATION",
            SUCCESS = "SUCCESS"
    }
    /**
        * <p>Contains information about the status of ACM's <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-renewal.html">managed renewal</a> for the certificate. This
        *       structure exists only when the certificate type is <code>AMAZON_ISSUED</code>.</p>
        */
    export interface RenewalSummary {
            /**
                * <p>The status of ACM's <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-renewal.html">managed renewal</a> of the certificate.</p>
                */
            RenewalStatus: RenewalStatus | string | undefined;
            /**
                * <p>Contains information about the validation of each domain name in the certificate, as it
                *       pertains to ACM's <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-renewal.html">managed
                *         renewal</a>. This is different from the initial validation that occurs as a result of
                *       the <a>RequestCertificate</a> request. This field exists only when the certificate
                *       type is <code>AMAZON_ISSUED</code>.</p>
                */
            DomainValidationOptions: DomainValidation[] | undefined;
            /**
                * <p>The reason that a renewal request was unsuccessful.</p>
                */
            RenewalStatusReason?: FailureReason | string;
            /**
                * <p>The time at which the renewal summary was last updated.</p>
                */
            UpdatedAt: Date | undefined;
    }
    export namespace RenewalSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RenewalSummary) => any;
    }
    export enum RevocationReason {
            AFFILIATION_CHANGED = "AFFILIATION_CHANGED",
            A_A_COMPROMISE = "A_A_COMPROMISE",
            CA_COMPROMISE = "CA_COMPROMISE",
            CERTIFICATE_HOLD = "CERTIFICATE_HOLD",
            CESSATION_OF_OPERATION = "CESSATION_OF_OPERATION",
            KEY_COMPROMISE = "KEY_COMPROMISE",
            PRIVILEGE_WITHDRAWN = "PRIVILEGE_WITHDRAWN",
            REMOVE_FROM_CRL = "REMOVE_FROM_CRL",
            SUPERCEDED = "SUPERCEDED",
            UNSPECIFIED = "UNSPECIFIED"
    }
    export enum CertificateStatus {
            EXPIRED = "EXPIRED",
            FAILED = "FAILED",
            INACTIVE = "INACTIVE",
            ISSUED = "ISSUED",
            PENDING_VALIDATION = "PENDING_VALIDATION",
            REVOKED = "REVOKED",
            VALIDATION_TIMED_OUT = "VALIDATION_TIMED_OUT"
    }
    export enum CertificateType {
            AMAZON_ISSUED = "AMAZON_ISSUED",
            IMPORTED = "IMPORTED",
            PRIVATE = "PRIVATE"
    }
    /**
        * <p>Contains metadata about an ACM certificate. This structure is returned in the response
        *       to a <a>DescribeCertificate</a> request. </p>
        */
    export interface CertificateDetail {
            /**
                * <p>The Amazon Resource Name (ARN) of the certificate. For more information about ARNs, see
                *         <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in
                *       the <i>Amazon Web Services General Reference</i>.</p>
                */
            CertificateArn?: string;
            /**
                * <p>The fully qualified domain name for the certificate, such as www.example.com or
                *       example.com.</p>
                */
            DomainName?: string;
            /**
                * <p>One or more domain names (subject alternative names) included in the certificate. This
                *       list contains the domain names that are bound to the public key that is contained in the
                *       certificate. The subject alternative names include the canonical domain name (CN) of the
                *       certificate and additional domain names that can be used to connect to the website. </p>
                */
            SubjectAlternativeNames?: string[];
            /**
                * <p>Contains information about the initial validation of each domain name that occurs as a
                *       result of the <a>RequestCertificate</a> request. This field exists only when the
                *       certificate type is <code>AMAZON_ISSUED</code>. </p>
                */
            DomainValidationOptions?: DomainValidation[];
            /**
                * <p>The serial number of the certificate.</p>
                */
            Serial?: string;
            /**
                * <p>The name of the entity that is associated with the public key contained in the
                *       certificate.</p>
                */
            Subject?: string;
            /**
                * <p>The name of the certificate authority that issued and signed the certificate.</p>
                */
            Issuer?: string;
            /**
                * <p>The time at which the certificate was requested.</p>
                */
            CreatedAt?: Date;
            /**
                * <p>The time at which the certificate was issued. This value exists only when the certificate
                *       type is <code>AMAZON_ISSUED</code>. </p>
                */
            IssuedAt?: Date;
            /**
                * <p>The date and time at which the certificate was imported. This value exists only when the
                *       certificate type is <code>IMPORTED</code>. </p>
                */
            ImportedAt?: Date;
            /**
                * <p>The status of the certificate.</p>
                */
            Status?: CertificateStatus | string;
            /**
                * <p>The time at which the certificate was revoked. This value exists only when the certificate
                *       status is <code>REVOKED</code>. </p>
                */
            RevokedAt?: Date;
            /**
                * <p>The reason the certificate was revoked. This value exists only when the certificate status
                *       is <code>REVOKED</code>. </p>
                */
            RevocationReason?: RevocationReason | string;
            /**
                * <p>The time before which the certificate is not valid.</p>
                */
            NotBefore?: Date;
            /**
                * <p>The time after which the certificate is not valid.</p>
                */
            NotAfter?: Date;
            /**
                * <p>The algorithm that was used to generate the public-private key pair.</p>
                */
            KeyAlgorithm?: KeyAlgorithm | string;
            /**
                * <p>The algorithm that was used to sign the certificate.</p>
                */
            SignatureAlgorithm?: string;
            /**
                * <p>A list of ARNs for the Amazon Web Services resources that are using the certificate. A certificate can
                *       be used by multiple Amazon Web Services resources. </p>
                */
            InUseBy?: string[];
            /**
                * <p>The reason the certificate request failed. This value exists only when the certificate
                *       status is <code>FAILED</code>. For more information, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/troubleshooting.html#troubleshooting-failed">Certificate Request
                *         Failed</a> in the <i>Amazon Web Services Certificate Manager User Guide</i>. </p>
                */
            FailureReason?: FailureReason | string;
            /**
                * <p>The source of the certificate. For certificates provided by ACM, this value is
                *         <code>AMAZON_ISSUED</code>. For certificates that you imported with <a>ImportCertificate</a>, this value is <code>IMPORTED</code>. ACM does not provide
                *         <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-renewal.html">managed renewal</a> for
                *       imported certificates. For more information about the differences between certificates that
                *       you import and those that ACM provides, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html">Importing Certificates</a> in the
                *         <i>Amazon Web Services Certificate Manager User Guide</i>. </p>
                */
            Type?: CertificateType | string;
            /**
                * <p>Contains information about the status of ACM's <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-renewal.html">managed renewal</a> for the certificate. This field
                *       exists only when the certificate type is <code>AMAZON_ISSUED</code>.</p>
                */
            RenewalSummary?: RenewalSummary;
            /**
                * <p>A list of Key Usage X.509 v3 extension objects. Each object is a string value that
                *       identifies the purpose of the public key contained in the certificate. Possible extension
                *       values include DIGITAL_SIGNATURE, KEY_ENCHIPHERMENT, NON_REPUDIATION, and more.</p>
                */
            KeyUsages?: KeyUsage[];
            /**
                * <p>Contains a list of Extended Key Usage X.509 v3 extension objects. Each object specifies a
                *       purpose for which the certificate public key can be used and consists of a name and an object
                *       identifier (OID). </p>
                */
            ExtendedKeyUsages?: ExtendedKeyUsage[];
            /**
                * <p>The Amazon Resource Name (ARN) of the ACM PCA private certificate authority (CA) that issued
                *       the certificate. This has the following format: </p>
                *          <p>
                *             <code>arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012</code>
                *          </p>
                */
            CertificateAuthorityArn?: string;
            /**
                * <p>Specifies whether the certificate is eligible for renewal. At this time, only exported
                *       private certificates can be renewed with the <a>RenewCertificate</a>
                *       command.</p>
                */
            RenewalEligibility?: RenewalEligibility | string;
            /**
                * <p>Value that specifies whether to add the certificate to a transparency log. Certificate
                *       transparency makes it possible to detect SSL certificates that have been mistakenly or
                *       maliciously issued. A browser might respond to certificate that has not been logged by showing
                *       an error message. The logs are cryptographically secure. </p>
                */
            Options?: CertificateOptions;
    }
    export namespace CertificateDetail {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CertificateDetail) => any;
    }
    export interface DeleteCertificateRequest {
            /**
                * <p>String that contains the ARN of the ACM certificate to be deleted. This must be of the
                *       form:</p>
                *          <p>
                *             <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
                *          </p>
                *          <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a>.</p>
                */
            CertificateArn: string | undefined;
    }
    export namespace DeleteCertificateRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteCertificateRequest) => any;
    }
    /**
        * <p>The certificate is in use by another Amazon Web Services service in the caller's account. Remove the
        *       association and try again.</p>
        */
    export class ResourceInUseException extends __BaseException {
            readonly name: "ResourceInUseException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceInUseException, __BaseException>);
    }
    export interface DescribeCertificateRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the ACM certificate. The ARN must have the following
                *       form:</p>
                *          <p>
                *             <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
                *          </p>
                *          <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a>.</p>
                */
            CertificateArn: string | undefined;
    }
    export namespace DescribeCertificateRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeCertificateRequest) => any;
    }
    export interface DescribeCertificateResponse {
            /**
                * <p>Metadata about an ACM certificate.</p>
                */
            Certificate?: CertificateDetail;
    }
    export namespace DescribeCertificateResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeCertificateResponse) => any;
    }
    export interface ExportCertificateRequest {
            /**
                * <p>An Amazon Resource Name (ARN) of the issued certificate. This must be of the form:</p>
                *          <p>
                *             <code>arn:aws:acm:region:account:certificate/12345678-1234-1234-1234-123456789012</code>
                *          </p>
                */
            CertificateArn: string | undefined;
            /**
                * <p>Passphrase to associate with the encrypted exported private key. If you want to later
                *       decrypt the private key, you must have the passphrase. You can use the following OpenSSL
                *       command to decrypt a private key: </p>
                *          <p>
                *             <code>openssl rsa -in encrypted_key.pem -out decrypted_key.pem</code>
                *          </p>
                */
            Passphrase: Uint8Array | undefined;
    }
    export namespace ExportCertificateRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExportCertificateRequest) => any;
    }
    export interface ExportCertificateResponse {
            /**
                * <p>The base64 PEM-encoded certificate.</p>
                */
            Certificate?: string;
            /**
                * <p>The base64 PEM-encoded certificate chain. This does not include the certificate that you
                *       are exporting.</p>
                */
            CertificateChain?: string;
            /**
                * <p>The encrypted private key associated with the public key in the certificate. The key is
                *       output in PKCS #8 format and is base64 PEM-encoded. </p>
                */
            PrivateKey?: string;
    }
    export namespace ExportCertificateResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExportCertificateResponse) => any;
    }
    /**
        * <p>The certificate request is in process and the certificate in your account has not yet been
        *       issued.</p>
        */
    export class RequestInProgressException extends __BaseException {
            readonly name: "RequestInProgressException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<RequestInProgressException, __BaseException>);
    }
    /**
        * <p>Object containing
        *       expiration events options associated with an Amazon Web Services account.</p>
        */
    export interface ExpiryEventsConfiguration {
            /**
                * <p>Specifies the number of days prior to certificate expiration when ACM starts generating
                *         <code>EventBridge</code> events. ACM sends one event per day per certificate until the
                *       certificate expires. By default, accounts receive events starting 45 days before certificate
                *       expiration.</p>
                */
            DaysBeforeExpiry?: number;
    }
    export namespace ExpiryEventsConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExpiryEventsConfiguration) => any;
    }
    export interface GetAccountConfigurationResponse {
            /**
                * <p>Expiration events
                *       configuration options associated with the Amazon Web Services account.</p>
                */
            ExpiryEvents?: ExpiryEventsConfiguration;
    }
    export namespace GetAccountConfigurationResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetAccountConfigurationResponse) => any;
    }
    export interface GetCertificateRequest {
            /**
                * <p>String that contains a certificate ARN in the following format:</p>
                *          <p>
                *             <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
                *          </p>
                *          <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a>.</p>
                */
            CertificateArn: string | undefined;
    }
    export namespace GetCertificateRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetCertificateRequest) => any;
    }
    export interface GetCertificateResponse {
            /**
                * <p>The ACM-issued certificate corresponding to the ARN specified as input.</p>
                */
            Certificate?: string;
            /**
                * <p>Certificates forming the requested certificate's chain of trust. The chain consists of the
                *       certificate of the issuing CA and the intermediate certificates of any other subordinate CAs.
                *     </p>
                */
            CertificateChain?: string;
    }
    export namespace GetCertificateResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetCertificateResponse) => any;
    }
    export interface ImportCertificateRequest {
            /**
                * <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Name
                *         (ARN)</a> of an imported certificate to replace. To import a new certificate, omit this
                *       field. </p>
                */
            CertificateArn?: string;
            /**
                * <p>The certificate to import.</p>
                */
            Certificate: Uint8Array | undefined;
            /**
                * <p>The private key that matches the public key in the certificate.</p>
                */
            PrivateKey: Uint8Array | undefined;
            /**
                * <p>The PEM encoded certificate chain.</p>
                */
            CertificateChain?: Uint8Array;
            /**
                * <p>One or more resource tags to associate with the imported certificate. </p>
                *          <p>Note: You cannot apply tags when reimporting a certificate.</p>
                */
            Tags?: Tag[];
    }
    export namespace ImportCertificateRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImportCertificateRequest) => any;
    }
    export interface ImportCertificateResponse {
            /**
                * <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Name
                *         (ARN)</a> of the imported certificate.</p>
                */
            CertificateArn?: string;
    }
    export namespace ImportCertificateResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImportCertificateResponse) => any;
    }
    /**
        * <p>An ACM quota has been exceeded.</p>
        */
    export class LimitExceededException extends __BaseException {
            readonly name: "LimitExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<LimitExceededException, __BaseException>);
    }
    /**
        * <p>One or more of of request parameters specified is not valid.</p>
        */
    export class InvalidArgsException extends __BaseException {
            readonly name: "InvalidArgsException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidArgsException, __BaseException>);
    }
    /**
        * <p>This structure can be used in the <a>ListCertificates</a> action to filter the
        *       output of the certificate list. </p>
        */
    export interface Filters {
            /**
                * <p>Specify one or more <a>ExtendedKeyUsage</a> extension values.</p>
                */
            extendedKeyUsage?: (ExtendedKeyUsageName | string)[];
            /**
                * <p>Specify one or more <a>KeyUsage</a> extension values.</p>
                */
            keyUsage?: (KeyUsageName | string)[];
            /**
                * <p>Specify one or more algorithms that can be used to generate key pairs.</p>
                *          <p>Default filtering returns only <code>RSA_1024</code> and <code>RSA_2048</code>
                *       certificates that have at least one domain. To return other certificate types, provide the
                *       desired type signatures in a comma-separated list. For example, <code>"keyTypes":
                *         ["RSA_2048,RSA_4096"]</code> returns both <code>RSA_2048</code> and <code>RSA_4096</code>
                *       certificates.</p>
                */
            keyTypes?: (KeyAlgorithm | string)[];
    }
    export namespace Filters {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Filters) => any;
    }
    export interface ListCertificatesRequest {
            /**
                * <p>Filter the certificate list by status value.</p>
                */
            CertificateStatuses?: (CertificateStatus | string)[];
            /**
                * <p>Filter the certificate list. For more information, see the <a>Filters</a>
                *       structure.</p>
                */
            Includes?: Filters;
            /**
                * <p>Use this parameter only when paginating results and only in a subsequent request after you
                *       receive a response with truncated results. Set it to the value of <code>NextToken</code> from
                *       the response you just received.</p>
                */
            NextToken?: string;
            /**
                * <p>Use this parameter when paginating results to specify the maximum number of items to
                *       return in the response. If additional items exist beyond the number you specify, the
                *         <code>NextToken</code> element is sent in the response. Use this <code>NextToken</code>
                *       value in a subsequent request to retrieve additional items.</p>
                */
            MaxItems?: number;
    }
    export namespace ListCertificatesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListCertificatesRequest) => any;
    }
    /**
        * <p>This structure is returned in the response object of <a>ListCertificates</a>
        *       action. </p>
        */
    export interface CertificateSummary {
            /**
                * <p>Amazon Resource Name (ARN) of the certificate. This is of the form:</p>
                *
                *          <p>
                *             <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
                *          </p>
                *
                *          <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a>.</p>
                */
            CertificateArn?: string;
            /**
                * <p>Fully qualified domain name (FQDN), such as www.example.com or example.com, for the
                *       certificate.</p>
                */
            DomainName?: string;
    }
    export namespace CertificateSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CertificateSummary) => any;
    }
    export interface ListCertificatesResponse {
            /**
                * <p>When the list is truncated, this value is present and contains the value to use for the
                *         <code>NextToken</code> parameter in a subsequent pagination request.</p>
                */
            NextToken?: string;
            /**
                * <p>A list of ACM certificates.</p>
                */
            CertificateSummaryList?: CertificateSummary[];
    }
    export namespace ListCertificatesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListCertificatesResponse) => any;
    }
    export interface ListTagsForCertificateRequest {
            /**
                * <p>String that contains the ARN of the ACM certificate for which you want to list the tags.
                *       This must have the following form:</p>
                *          <p>
                *             <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
                *          </p>
                *          <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a>.</p>
                */
            CertificateArn: string | undefined;
    }
    export namespace ListTagsForCertificateRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForCertificateRequest) => any;
    }
    export interface ListTagsForCertificateResponse {
            /**
                * <p>The key-value pairs that define the applied tags.</p>
                */
            Tags?: Tag[];
    }
    export namespace ListTagsForCertificateResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForCertificateResponse) => any;
    }
    /**
        * <p>You are trying to
        *       update a resource or configuration that is already being created or updated. Wait for the
        *       previous operation to finish and try again.</p>
        */
    export class ConflictException extends __BaseException {
            readonly name: "ConflictException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ConflictException, __BaseException>);
    }
    export interface PutAccountConfigurationRequest {
            /**
                * <p>Specifies expiration
                *       events associated with an account.</p>
                */
            ExpiryEvents?: ExpiryEventsConfiguration;
            /**
                * <p>Customer-chosen string
                *       used to distinguish between calls to <code>PutAccountConfiguration</code>. Idempotency tokens
                *       time out after one hour. If you call <code>PutAccountConfiguration</code> multiple times with
                *       the same unexpired idempotency token, ACM treats it as the same request and returns the
                *       original result. If you change the idempotency token for each call, ACM treats each call as
                *       a new request.</p>
                */
            IdempotencyToken: string | undefined;
    }
    export namespace PutAccountConfigurationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutAccountConfigurationRequest) => any;
    }
    /**
        * <p>The supplied input
        *       failed to satisfy constraints of an Amazon Web Services service.</p>
        */
    export class ValidationException extends __BaseException {
            readonly name: "ValidationException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ValidationException, __BaseException>);
    }
    export interface RemoveTagsFromCertificateRequest {
            /**
                * <p>String that contains the ARN of the ACM Certificate with one or more tags that you want
                *       to remove. This must be of the form:</p>
                *
                *          <p>
                *             <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
                *          </p>
                *
                *          <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a>.</p>
                */
            CertificateArn: string | undefined;
            /**
                * <p>The key-value pair that defines the tag to remove.</p>
                */
            Tags: Tag[] | undefined;
    }
    export namespace RemoveTagsFromCertificateRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RemoveTagsFromCertificateRequest) => any;
    }
    export interface RenewCertificateRequest {
            /**
                * <p>String that contains the ARN of the ACM certificate to be renewed. This must be of the
                *       form:</p>
                *          <p>
                *             <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
                *          </p>
                *          <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a>.</p>
                */
            CertificateArn: string | undefined;
    }
    export namespace RenewCertificateRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RenewCertificateRequest) => any;
    }
    /**
        * <p>One or more values in the <a>DomainValidationOption</a> structure is
        *       incorrect.</p>
        */
    export class InvalidDomainValidationOptionsException extends __BaseException {
            readonly name: "InvalidDomainValidationOptionsException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidDomainValidationOptionsException, __BaseException>);
    }
    /**
        * <p>Contains information about the domain names that you want ACM to use to send you emails
        *       that enable you to validate domain ownership.</p>
        */
    export interface DomainValidationOption {
            /**
                * <p>A fully qualified domain name (FQDN) in the certificate request.</p>
                */
            DomainName: string | undefined;
            /**
                * <p>The domain name that you want ACM to use to send you validation emails. This domain name
                *       is the suffix of the email addresses that you want ACM to use. This must be the same as the
                *         <code>DomainName</code> value or a superdomain of the <code>DomainName</code> value. For
                *       example, if you request a certificate for <code>testing.example.com</code>, you can specify
                *         <code>example.com</code> for this value. In that case, ACM sends domain validation emails
                *       to the following five addresses:</p>
                *          <ul>
                *             <li>
                *                <p>admin@example.com</p>
                *             </li>
                *             <li>
                *                <p>administrator@example.com</p>
                *             </li>
                *             <li>
                *                <p>hostmaster@example.com</p>
                *             </li>
                *             <li>
                *                <p>postmaster@example.com</p>
                *             </li>
                *             <li>
                *                <p>webmaster@example.com</p>
                *             </li>
                *          </ul>
                */
            ValidationDomain: string | undefined;
    }
    export namespace DomainValidationOption {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DomainValidationOption) => any;
    }
    export interface RequestCertificateRequest {
            /**
                * <p> Fully qualified domain name (FQDN), such as www.example.com, that you want to secure with
                *       an ACM certificate. Use an asterisk (*) to create a wildcard certificate that protects
                *       several sites in the same domain. For example, *.example.com protects www.example.com,
                *       site.example.com, and images.example.com. </p>
                *
                *          <p> The first domain name you enter cannot exceed 64 octets, including periods. Each
                *       subsequent Subject Alternative Name (SAN), however, can be up to 253 octets in length. </p>
                */
            DomainName: string | undefined;
            /**
                * <p>The method you want to use if you are requesting a public certificate to validate that you
                *       own or control domain. You can <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-validate-dns.html">validate with DNS</a> or <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-validate-email.html">validate with
                *         email</a>. We recommend that you use DNS validation. </p>
                */
            ValidationMethod?: ValidationMethod | string;
            /**
                * <p>Additional FQDNs to be included in the Subject Alternative Name extension of the ACM
                *       certificate. For example, add the name www.example.net to a certificate for which the
                *         <code>DomainName</code> field is www.example.com if users can reach your site by using
                *       either name. The maximum number of domain names that you can add to an ACM certificate is
                *       100. However, the initial quota is 10 domain names. If you need more than 10 names, you must
                *       request a quota increase. For more information, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-limits.html">Quotas</a>.</p>
                *
                *          <p> The maximum length of a SAN DNS name is 253 octets. The name is made up of multiple
                *       labels separated by periods. No label can be longer than 63 octets. Consider the following
                *       examples: </p>
                *
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>(63 octets).(63 octets).(63 octets).(61 octets)</code> is legal because the
                *           total length is 253 octets (63+1+63+1+63+1+61) and no label exceeds 63 octets.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>(64 octets).(63 octets).(63 octets).(61 octets)</code> is not legal because the
                *           total length exceeds 253 octets (64+1+63+1+63+1+61) and the first label exceeds 63
                *           octets.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>(63 octets).(63 octets).(63 octets).(62 octets)</code> is not legal because the
                *           total length of the DNS name (63+1+63+1+63+1+62) exceeds 253 octets.</p>
                *             </li>
                *          </ul>
                */
            SubjectAlternativeNames?: string[];
            /**
                * <p>Customer chosen string that can be used to distinguish between calls to
                *         <code>RequestCertificate</code>. Idempotency tokens time out after one hour. Therefore, if
                *       you call <code>RequestCertificate</code> multiple times with the same idempotency token within
                *       one hour, ACM recognizes that you are requesting only one certificate and will issue only
                *       one. If you change the idempotency token for each call, ACM recognizes that you are
                *       requesting multiple certificates.</p>
                */
            IdempotencyToken?: string;
            /**
                * <p>The domain name that you want ACM to use to send you emails so that you can validate
                *       domain ownership.</p>
                */
            DomainValidationOptions?: DomainValidationOption[];
            /**
                * <p>Currently, you can use this parameter to specify whether to add the certificate to a
                *       certificate transparency log. Certificate transparency makes it possible to detect SSL/TLS
                *       certificates that have been mistakenly or maliciously issued. Certificates that have not been
                *       logged typically produce an error message in a browser. For more information, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-bestpractices.html#best-practices-transparency">Opting Out of Certificate Transparency Logging</a>.</p>
                */
            Options?: CertificateOptions;
            /**
                * <p>The Amazon Resource Name (ARN) of the private certificate authority (CA) that will be used
                *       to issue the certificate. If you do not provide an ARN and you are trying to request a private
                *       certificate, ACM will attempt to issue a public certificate. For more information about
                *       private CAs, see the <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/PcaWelcome.html">Amazon Web Services Certificate Manager Private Certificate Authority (PCA)</a> user guide. The ARN must have the following form: </p>
                *
                *          <p>
                *             <code>arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012</code>
                *          </p>
                */
            CertificateAuthorityArn?: string;
            /**
                * <p>One or more resource tags to associate with the certificate.</p>
                */
            Tags?: Tag[];
    }
    export namespace RequestCertificateRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RequestCertificateRequest) => any;
    }
    export interface RequestCertificateResponse {
            /**
                * <p>String that contains the ARN of the issued certificate. This must be of the form:</p>
                *          <p>
                *             <code>arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
                *          </p>
                */
            CertificateArn?: string;
    }
    export namespace RequestCertificateResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RequestCertificateResponse) => any;
    }
    /**
        * <p>Processing has reached an invalid state.</p>
        */
    export class InvalidStateException extends __BaseException {
            readonly name: "InvalidStateException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidStateException, __BaseException>);
    }
    export interface ResendValidationEmailRequest {
            /**
                * <p>String that contains the ARN of the requested certificate. The certificate ARN is
                *       generated and returned by the <a>RequestCertificate</a> action as soon as the
                *       request is made. By default, using this parameter causes email to be sent to all top-level
                *       domains you specified in the certificate request. The ARN must be of the form: </p>
                *
                *          <p>
                *             <code>arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
                *          </p>
                */
            CertificateArn: string | undefined;
            /**
                * <p>The fully qualified domain name (FQDN) of the certificate that needs to be
                *       validated.</p>
                */
            Domain: string | undefined;
            /**
                * <p>The base validation domain that will act as the suffix of the email addresses that are
                *       used to send the emails. This must be the same as the <code>Domain</code> value or a
                *       superdomain of the <code>Domain</code> value. For example, if you requested a certificate for
                *         <code>site.subdomain.example.com</code> and specify a <b>ValidationDomain</b> of <code>subdomain.example.com</code>, ACM sends email to the
                *       domain registrant, technical contact, and administrative contact in WHOIS and the following
                *       five addresses:</p>
                *          <ul>
                *             <li>
                *                <p>admin@subdomain.example.com</p>
                *             </li>
                *             <li>
                *                <p>administrator@subdomain.example.com</p>
                *             </li>
                *             <li>
                *                <p>hostmaster@subdomain.example.com</p>
                *             </li>
                *             <li>
                *                <p>postmaster@subdomain.example.com</p>
                *             </li>
                *             <li>
                *                <p>webmaster@subdomain.example.com</p>
                *             </li>
                *          </ul>
                */
            ValidationDomain: string | undefined;
    }
    export namespace ResendValidationEmailRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResendValidationEmailRequest) => any;
    }
    export interface UpdateCertificateOptionsRequest {
            /**
                * <p>ARN of the requested certificate to update. This must be of the form:</p>
                *          <p>
                *             <code>arn:aws:acm:us-east-1:<i>account</i>:certificate/<i>12345678-1234-1234-1234-123456789012</i>
                *             </code>
                *          </p>
                */
            CertificateArn: string | undefined;
            /**
                * <p>Use to update the options for your certificate. Currently, you can specify whether to add
                *       your certificate to a transparency log. Certificate transparency makes it possible to detect
                *       SSL/TLS certificates that have been mistakenly or maliciously issued. Certificates that have
                *       not been logged typically produce an error message in a browser. </p>
                */
            Options: CertificateOptions | undefined;
    }
    export namespace UpdateCertificateOptionsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateCertificateOptionsRequest) => any;
    }
}

declare module '@aws-sdk/client-acm/node_modules/@aws-sdk/client-acm/dist-types/models/ACMServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from ACM service.
        */
    export class ACMServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

