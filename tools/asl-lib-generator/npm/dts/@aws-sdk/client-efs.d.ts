// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/smithy-client
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http

declare module '@aws-sdk/client-efs' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { CreateAccessPointCommandInput, CreateAccessPointCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/CreateAccessPointCommand";
    import { CreateFileSystemCommandInput, CreateFileSystemCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/CreateFileSystemCommand";
    import { CreateMountTargetCommandInput, CreateMountTargetCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/CreateMountTargetCommand";
    import { CreateReplicationConfigurationCommandInput, CreateReplicationConfigurationCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/CreateReplicationConfigurationCommand";
    import { CreateTagsCommandInput, CreateTagsCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/CreateTagsCommand";
    import { DeleteAccessPointCommandInput, DeleteAccessPointCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DeleteAccessPointCommand";
    import { DeleteFileSystemCommandInput, DeleteFileSystemCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DeleteFileSystemCommand";
    import { DeleteFileSystemPolicyCommandInput, DeleteFileSystemPolicyCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DeleteFileSystemPolicyCommand";
    import { DeleteMountTargetCommandInput, DeleteMountTargetCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DeleteMountTargetCommand";
    import { DeleteReplicationConfigurationCommandInput, DeleteReplicationConfigurationCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DeleteReplicationConfigurationCommand";
    import { DeleteTagsCommandInput, DeleteTagsCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DeleteTagsCommand";
    import { DescribeAccessPointsCommandInput, DescribeAccessPointsCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeAccessPointsCommand";
    import { DescribeAccountPreferencesCommandInput, DescribeAccountPreferencesCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeAccountPreferencesCommand";
    import { DescribeBackupPolicyCommandInput, DescribeBackupPolicyCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeBackupPolicyCommand";
    import { DescribeFileSystemPolicyCommandInput, DescribeFileSystemPolicyCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeFileSystemPolicyCommand";
    import { DescribeFileSystemsCommandInput, DescribeFileSystemsCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeFileSystemsCommand";
    import { DescribeLifecycleConfigurationCommandInput, DescribeLifecycleConfigurationCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeLifecycleConfigurationCommand";
    import { DescribeMountTargetsCommandInput, DescribeMountTargetsCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeMountTargetsCommand";
    import { DescribeMountTargetSecurityGroupsCommandInput, DescribeMountTargetSecurityGroupsCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeMountTargetSecurityGroupsCommand";
    import { DescribeReplicationConfigurationsCommandInput, DescribeReplicationConfigurationsCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeReplicationConfigurationsCommand";
    import { DescribeTagsCommandInput, DescribeTagsCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeTagsCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/ListTagsForResourceCommand";
    import { ModifyMountTargetSecurityGroupsCommandInput, ModifyMountTargetSecurityGroupsCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/ModifyMountTargetSecurityGroupsCommand";
    import { PutAccountPreferencesCommandInput, PutAccountPreferencesCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/PutAccountPreferencesCommand";
    import { PutBackupPolicyCommandInput, PutBackupPolicyCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/PutBackupPolicyCommand";
    import { PutFileSystemPolicyCommandInput, PutFileSystemPolicyCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/PutFileSystemPolicyCommand";
    import { PutLifecycleConfigurationCommandInput, PutLifecycleConfigurationCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/PutLifecycleConfigurationCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/UntagResourceCommand";
    import { UpdateFileSystemCommandInput, UpdateFileSystemCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/UpdateFileSystemCommand";
    import { EFSClient } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    /**
        * <fullname>Amazon Elastic File System</fullname>
        *          <p>Amazon Elastic File System (Amazon EFS) provides simple, scalable file storage for
        *       use with Amazon EC2 Linux and Mac instances in the Amazon Web Services Cloud. With Amazon EFS, storage capacity is elastic, growing and shrinking automatically as you add and
        *       remove files, so that your applications have the storage they need, when they need it. For
        *       more information, see the <a href="https://docs.aws.amazon.com/efs/latest/ug/api-reference.html">Amazon Elastic File System API Reference</a> and the <a href="https://docs.aws.amazon.com/efs/latest/ug/whatisefs.html">Amazon Elastic File System User Guide</a>.</p>
        */
    export class EFS extends EFSClient {
            /**
                * <p>Creates an EFS access point. An access point is an application-specific view into an EFS
                *       file system that applies an operating system user and group, and a file system path, to any
                *       file system request made through the access point. The operating system user and group
                *       override any identity information provided by the NFS client. The file system path is exposed
                *       as the access point's root directory. Applications using the access point can only access data in
                *       the application's own directory and any subdirectories. To learn more, see <a href="https://docs.aws.amazon.com/efs/latest/ug/efs-access-points.html">Mounting a file system using EFS access
                *         points</a>.</p>
                *          <p>This operation requires permissions for the <code>elasticfilesystem:CreateAccessPoint</code> action.</p>
                */
            createAccessPoint(args: CreateAccessPointCommandInput, options?: __HttpHandlerOptions): Promise<CreateAccessPointCommandOutput>;
            createAccessPoint(args: CreateAccessPointCommandInput, cb: (err: any, data?: CreateAccessPointCommandOutput) => void): void;
            createAccessPoint(args: CreateAccessPointCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateAccessPointCommandOutput) => void): void;
            /**
                * <p>Creates a new, empty file system. The operation requires a creation token in the
                *       request that Amazon EFS uses to ensure idempotent creation (calling the operation with same
                *       creation token has no effect). If a file system does not currently exist that is owned by the
                *       caller's Amazon Web Services account with the specified creation token, this operation does the
                *       following:</p>
                *          <ul>
                *             <li>
                *                <p>Creates a new, empty file system. The file system will have an Amazon EFS assigned
                *           ID, and an initial lifecycle state <code>creating</code>.</p>
                *             </li>
                *             <li>
                *                <p>Returns with the description of the created file system.</p>
                *             </li>
                *          </ul>
                *          <p>Otherwise, this operation returns a <code>FileSystemAlreadyExists</code> error with the
                *       ID of the existing file system.</p>
                *          <note>
                *             <p>For basic use cases, you can use a randomly generated UUID for the creation
                *         token.</p>
                *          </note>
                *          <p> The idempotent operation allows you to retry a <code>CreateFileSystem</code> call without
                *       risk of creating an extra file system. This can happen when an initial call fails in a way
                *       that leaves it uncertain whether or not a file system was actually created. An example might
                *       be that a transport level timeout occurred or your connection was reset. As long as you use
                *       the same creation token, if the initial call had succeeded in creating a file system, the
                *       client can learn of its existence from the <code>FileSystemAlreadyExists</code> error.</p>
                *          <p>For more information, see
                *       <a href="https://docs.aws.amazon.com/efs/latest/ug/creating-using-create-fs.html#creating-using-create-fs-part1">Creating a file system</a>
                *      in the <i>Amazon EFS User Guide</i>.</p>
                *
                *          <note>
                *             <p>The <code>CreateFileSystem</code> call returns while the file system's lifecycle
                *         state is still <code>creating</code>. You can check the file system creation status by
                *         calling the <a>DescribeFileSystems</a> operation, which among other things returns the file
                *         system state.</p>
                *          </note>
                *
                *          <p>This operation accepts an optional <code>PerformanceMode</code> parameter that you
                *       choose for your file system. We recommend <code>generalPurpose</code> performance mode for
                *       most file systems. File systems using the <code>maxIO</code> performance mode can scale to
                *       higher levels of aggregate throughput and operations per second with a tradeoff of slightly
                *       higher latencies for most file operations. The performance mode can't be changed after
                *       the file system has been created. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/performance.html#performancemodes.html">Amazon EFS performance
                *         modes</a>.</p>
                *
                *          <p>You can set the throughput mode for the file system using the <code>ThroughputMode</code> parameter.</p>
                *
                *          <p>After the file system is fully created, Amazon EFS sets its lifecycle state to
                *         <code>available</code>, at which point you can create one or more mount targets for the file
                *       system in your VPC. For more information, see <a>CreateMountTarget</a>. You mount your Amazon EFS file system on an EC2 instances in
                *       your VPC by using the mount target. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/how-it-works.html">Amazon EFS: How it Works</a>. </p>
                *
                *          <p> This operation requires permissions for the
                *         <code>elasticfilesystem:CreateFileSystem</code> action. </p>
                */
            createFileSystem(args: CreateFileSystemCommandInput, options?: __HttpHandlerOptions): Promise<CreateFileSystemCommandOutput>;
            createFileSystem(args: CreateFileSystemCommandInput, cb: (err: any, data?: CreateFileSystemCommandOutput) => void): void;
            createFileSystem(args: CreateFileSystemCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateFileSystemCommandOutput) => void): void;
            /**
                * <p>Creates a mount target for a file system. You can then mount the file system on EC2
                *       instances by using the mount target.</p>
                *          <p>You can create one mount target in each Availability Zone in your VPC. All EC2
                *       instances in a VPC within a given Availability Zone share a single mount target for a given
                *       file system. If you have multiple subnets in an Availability Zone, you create a mount target
                *       in one of the subnets. EC2 instances do not need to be in the same subnet as the mount target
                *       in order to access their file system.</p>
                *          <p>You can create only one mount target for an EFS file system using One Zone storage
                *       classes. You must create that mount target in the same Availability Zone in which the file
                *       system is located. Use the <code>AvailabilityZoneName</code> and
                *         <code>AvailabiltyZoneId</code> properties in the <a>DescribeFileSystems</a>
                *       response object to get this information. Use the <code>subnetId</code> associated with the
                *       file system's Availability Zone when creating the mount target.</p>
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/how-it-works.html">Amazon EFS: How it Works</a>. </p>
                *          <p>To create a mount target for a file system, the file system's lifecycle state must be
                *         <code>available</code>. For more information, see <a>DescribeFileSystems</a>.</p>
                *          <p>In the request, provide the following:</p>
                *          <ul>
                *             <li>
                *                <p>The file system ID for which you are creating the mount
                *         target.</p>
                *             </li>
                *             <li>
                *                <p>A subnet ID, which determines the following:</p>
                *                <ul>
                *                   <li>
                *                      <p>The VPC in which Amazon EFS creates the mount target</p>
                *                   </li>
                *                   <li>
                *                      <p>The Availability Zone in which Amazon EFS creates the mount target</p>
                *                   </li>
                *                   <li>
                *                      <p>The IP address range from which Amazon EFS selects the IP address of the mount target
                *               (if you don't specify an IP address in the request)</p>
                *                   </li>
                *                </ul>
                *             </li>
                *          </ul>
                *
                *          <p>After creating the mount target, Amazon EFS returns a response that includes, a
                *         <code>MountTargetId</code> and an <code>IpAddress</code>. You use this IP address when
                *       mounting the file system in an EC2 instance. You can also use the mount target's DNS name
                *       when mounting the file system. The EC2 instance on which you mount the file system by using
                *       the mount target can resolve the mount target's DNS name to its IP address. For more
                *       information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/how-it-works.html#how-it-works-implementation">How it Works:
                *         Implementation Overview</a>. </p>
                *          <p>Note that you can create mount targets for a file system in only one VPC, and there can
                *       be only one mount target per Availability Zone. That is, if the file system already has one or
                *       more mount targets created for it, the subnet specified in the request to add another mount
                *       target must meet the following requirements:</p>
                *          <ul>
                *             <li>
                *                <p>Must belong to the same VPC as the subnets of the existing mount targets</p>
                *             </li>
                *             <li>
                *                <p>Must not be in the same Availability Zone as any of the subnets of the existing
                *           mount targets</p>
                *             </li>
                *          </ul>
                *
                *          <p>If the request satisfies the requirements, Amazon EFS does the following:</p>
                *          <ul>
                *             <li>
                *                <p>Creates a new mount target in the specified subnet.</p>
                *             </li>
                *             <li>
                *                <p>Also creates a new network interface in the subnet as follows:</p>
                *                <ul>
                *                   <li>
                *                      <p>If the request provides an <code>IpAddress</code>, Amazon EFS assigns that IP
                *               address to the network interface. Otherwise, Amazon EFS assigns a free address in the
                *               subnet (in the same way that the Amazon EC2 <code>CreateNetworkInterface</code> call
                *               does when a request does not specify a primary private IP address).</p>
                *                   </li>
                *                   <li>
                *                      <p>If the request provides <code>SecurityGroups</code>, this network interface is
                *               associated with those security groups. Otherwise, it belongs to the default security
                *               group for the subnet's VPC.</p>
                *                   </li>
                *                   <li>
                *                      <p>Assigns the description <code>Mount target <i>fsmt-id</i> for
                *                 file system <i>fs-id</i>
                *                         </code> where <code>
                *                            <i>fsmt-id</i>
                *                         </code> is the mount target ID, and <code>
                *                            <i>fs-id</i>
                *                         </code> is the <code>FileSystemId</code>.</p>
                *                   </li>
                *                   <li>
                *                      <p>Sets the <code>requesterManaged</code> property of the network interface to
                *                 <code>true</code>, and the <code>requesterId</code> value to
                *               <code>EFS</code>.</p>
                *                   </li>
                *                </ul>
                *                <p>Each Amazon EFS mount target has one corresponding requester-managed EC2 network
                *           interface. After the network interface is created, Amazon EFS sets the
                *             <code>NetworkInterfaceId</code> field in the mount target's description to the
                *           network interface ID, and the <code>IpAddress</code> field to its address. If network
                *           interface creation fails, the entire <code>CreateMountTarget</code> operation
                *           fails.</p>
                *             </li>
                *          </ul>
                *          <note>
                *             <p>The <code>CreateMountTarget</code> call returns only after creating the network
                *         interface, but while the mount target state is still <code>creating</code>, you can check
                *         the mount target creation status by calling the <a>DescribeMountTargets</a> operation, which among other things returns the mount
                *         target state.</p>
                *          </note>
                *          <p>We recommend that you create a mount target in each of the Availability Zones. There
                *       are cost considerations for using a file system in an Availability Zone through a mount target
                *       created in another Availability Zone. For more information, see <a href="http://aws.amazon.com/efs/">Amazon EFS</a>. In addition, by always using a mount target local to the
                *       instance's Availability Zone, you eliminate a partial failure scenario. If the
                *       Availability Zone in which your mount target is created goes down, then you can't access
                *       your file system through that mount target. </p>
                *          <p>This operation requires permissions for the following action on the file
                *       system:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>elasticfilesystem:CreateMountTarget</code>
                *                </p>
                *             </li>
                *          </ul>
                *          <p>This operation also requires permissions for the following Amazon EC2
                *       actions:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>ec2:DescribeSubnets</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ec2:DescribeNetworkInterfaces</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ec2:CreateNetworkInterface</code>
                *                </p>
                *             </li>
                *          </ul>
                */
            createMountTarget(args: CreateMountTargetCommandInput, options?: __HttpHandlerOptions): Promise<CreateMountTargetCommandOutput>;
            createMountTarget(args: CreateMountTargetCommandInput, cb: (err: any, data?: CreateMountTargetCommandOutput) => void): void;
            createMountTarget(args: CreateMountTargetCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateMountTargetCommandOutput) => void): void;
            /**
                * <p>Creates a replication configuration that replicates an existing EFS file system to a new,
                *       read-only file system. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/efs-replication.html">Amazon EFS replication</a> in the
                *           <i>Amazon EFS User Guide</i>. The replication configuration
                *       specifies the following:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <b>Source file system</b> - An existing EFS file system that you
                *           want replicated. The source file system cannot be a destination file system in an existing
                *           replication configuration.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>Destination file system configuration</b> - The configuration of
                *           the destination file system to which the source file system will be replicated. There can
                *           only be one destination file system in a replication configuration. The destination file
                *           system configuration consists of the following properties:</p>
                *                <ul>
                *                   <li>
                *                      <p>
                *                         <b>Amazon Web Services Region</b> - The Amazon Web Services Region in
                *               which the destination file system is created. Amazon EFS replication is
                *               available in all Amazon Web Services Regions that Amazon EFS is available in,
                *               except Africa (Cape Town), Asia Pacific (Hong Kong), Asia Pacific (Jakarta), Europe
                *               (Milan), and Middle East (Bahrain).</p>
                *                   </li>
                *                   <li>
                *                      <p>
                *                         <b>Availability Zone</b> - If you want the destination file system
                *               to use EFS One Zone availability and durability, you must specify the Availability
                *               Zone to create the file system in. For more information about EFS storage classes, see
                *                 <a href="https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html">
                *                 Amazon EFS storage classes</a> in the <i>Amazon EFS User
                *                 Guide</i>.</p>
                *                   </li>
                *                   <li>
                *                      <p>
                *                         <b>Encryption</b> - All destination file systems are created with
                *               encryption at rest enabled. You can specify the Key Management Service (KMS) key that is used to encrypt the destination file system. If you don't
                *               specify a KMS key, your service-managed KMS key for
                *                 Amazon EFS is used.  </p>
                *                      <note>
                *                         <p>After the file system is created, you cannot change the KMS key.</p>
                *                      </note>
                *                   </li>
                *                </ul>
                *             </li>
                *          </ul>
                *
                *          <p>The following properties are set by default:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <b>Performance mode</b> - The destination file system's performance
                *           mode matches that of the source file system, unless the destination file system uses EFS
                *           One Zone storage. In that case, the General Purpose performance mode is used. The
                *           performance mode cannot be changed.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>Throughput mode</b> - The destination file system uses the
                *           Bursting Throughput mode by default. After the file system is created, you can modify the
                *           throughput mode.</p>
                *             </li>
                *          </ul>
                *
                *          <p>The following properties are turned off by default:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <b>Lifecycle management</b> - EFS lifecycle management and EFS
                *           Intelligent-Tiering are not enabled on the destination file system. After the destination
                *           file system is created, you can enable EFS lifecycle management and EFS
                *           Intelligent-Tiering.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>Automatic backups</b> - Automatic daily backups not enabled on
                *           the destination file system. After the file system is created, you can change this
                *           setting.</p>
                *             </li>
                *          </ul>
                *
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/efs-replication.html">Amazon EFS replication</a> in the
                *           <i>Amazon EFS User Guide</i>.</p>
                */
            createReplicationConfiguration(args: CreateReplicationConfigurationCommandInput, options?: __HttpHandlerOptions): Promise<CreateReplicationConfigurationCommandOutput>;
            createReplicationConfiguration(args: CreateReplicationConfigurationCommandInput, cb: (err: any, data?: CreateReplicationConfigurationCommandOutput) => void): void;
            createReplicationConfiguration(args: CreateReplicationConfigurationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateReplicationConfigurationCommandOutput) => void): void;
            /**
                * @deprecated
                *
                * <note>
                *             <p>DEPRECATED - <code>CreateTags</code> is deprecated and not maintained. To create tags for EFS
                *         resources, use the  API action.</p>
                *          </note>
                *          <p>Creates or overwrites tags associated with a file system. Each tag is a key-value pair. If
                *       a tag key specified in the request already exists on the file system, this operation
                *       overwrites its value with the value provided in the request. If you add the <code>Name</code>
                *       tag to your file system, Amazon EFS returns it in the response to the <a>DescribeFileSystems</a> operation. </p>
                *          <p>This operation requires permission for the <code>elasticfilesystem:CreateTags</code>
                *       action.</p>
                */
            createTags(args: CreateTagsCommandInput, options?: __HttpHandlerOptions): Promise<CreateTagsCommandOutput>;
            createTags(args: CreateTagsCommandInput, cb: (err: any, data?: CreateTagsCommandOutput) => void): void;
            createTags(args: CreateTagsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateTagsCommandOutput) => void): void;
            /**
                * <p>Deletes the specified access point. After deletion is complete, new clients can no
                *       longer connect to the access points. Clients connected to the access point at the time of
                *       deletion will continue to function until they terminate their connection.</p>
                *          <p>This operation requires permissions for the <code>elasticfilesystem:DeleteAccessPoint</code> action.</p>
                */
            deleteAccessPoint(args: DeleteAccessPointCommandInput, options?: __HttpHandlerOptions): Promise<DeleteAccessPointCommandOutput>;
            deleteAccessPoint(args: DeleteAccessPointCommandInput, cb: (err: any, data?: DeleteAccessPointCommandOutput) => void): void;
            deleteAccessPoint(args: DeleteAccessPointCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteAccessPointCommandOutput) => void): void;
            /**
                * <p>Deletes a file system, permanently severing access to its contents. Upon return, the
                *       file system no longer exists and you can't access any contents of the deleted file
                *       system.</p>
                *          <p>You need to manually delete mount targets attached to a file system before you can delete
                *     an EFS file system. This step is performed for you when you use the Amazon Web Services console
                *     to delete a file system.</p>
                *          <note>
                *             <p>You cannot delete a file system that is part of an EFS Replication configuration.
                *       You need to delete the replication configuration first.</p>
                *          </note>
                *          <p> You can't delete a file system that is in use. That is, if the file system has
                *       any mount targets, you must first delete them. For more information, see <a>DescribeMountTargets</a> and <a>DeleteMountTarget</a>. </p>
                *
                *          <note>
                *             <p>The <code>DeleteFileSystem</code> call returns while the file system state is still
                *           <code>deleting</code>. You can check the file system deletion status by calling the <a>DescribeFileSystems</a> operation, which returns a list of file systems in your
                *         account. If you pass file system ID or creation token for the deleted file system, the <a>DescribeFileSystems</a> returns a <code>404 FileSystemNotFound</code>
                *         error.</p>
                *          </note>
                *
                *          <p>This operation requires permissions for the
                *         <code>elasticfilesystem:DeleteFileSystem</code> action.</p>
                */
            deleteFileSystem(args: DeleteFileSystemCommandInput, options?: __HttpHandlerOptions): Promise<DeleteFileSystemCommandOutput>;
            deleteFileSystem(args: DeleteFileSystemCommandInput, cb: (err: any, data?: DeleteFileSystemCommandOutput) => void): void;
            deleteFileSystem(args: DeleteFileSystemCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteFileSystemCommandOutput) => void): void;
            /**
                * <p>Deletes the <code>FileSystemPolicy</code> for the specified file system.
                *       The default <code>FileSystemPolicy</code> goes into effect once the existing policy is deleted.
                *       For more information about the default file system policy, see <a href="https://docs.aws.amazon.com/efs/latest/ug/res-based-policies-efs.html">Using Resource-based Policies with EFS</a>.</p>
                *          <p>This operation requires permissions for the <code>elasticfilesystem:DeleteFileSystemPolicy</code> action.</p>
                */
            deleteFileSystemPolicy(args: DeleteFileSystemPolicyCommandInput, options?: __HttpHandlerOptions): Promise<DeleteFileSystemPolicyCommandOutput>;
            deleteFileSystemPolicy(args: DeleteFileSystemPolicyCommandInput, cb: (err: any, data?: DeleteFileSystemPolicyCommandOutput) => void): void;
            deleteFileSystemPolicy(args: DeleteFileSystemPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteFileSystemPolicyCommandOutput) => void): void;
            /**
                * <p>Deletes the specified mount target.</p>
                *
                *          <p>This operation forcibly breaks any mounts of the file system by using the mount target
                *       that is being deleted, which might disrupt instances or applications using those mounts. To
                *       avoid applications getting cut off abruptly, you might consider unmounting any mounts of the
                *       mount target, if feasible. The operation also deletes the associated network interface.
                *       Uncommitted writes might be lost, but breaking a mount target using this operation does not
                *       corrupt the file system itself. The file system you created remains. You can mount an EC2
                *       instance in your VPC by using another mount target.</p>
                *          <p>This operation requires permissions for the following action on the file
                *       system:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>elasticfilesystem:DeleteMountTarget</code>
                *                </p>
                *             </li>
                *          </ul>
                *
                *          <note>
                *             <p>The <code>DeleteMountTarget</code> call returns while the mount target state is still
                *           <code>deleting</code>. You can check the mount target deletion by calling the <a>DescribeMountTargets</a> operation, which returns a list of mount target
                *         descriptions for the given file system. </p>
                *          </note>
                *
                *          <p>The operation also requires permissions for the following Amazon EC2 action on the
                *       mount target's network interface:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>ec2:DeleteNetworkInterface</code>
                *                </p>
                *             </li>
                *          </ul>
                */
            deleteMountTarget(args: DeleteMountTargetCommandInput, options?: __HttpHandlerOptions): Promise<DeleteMountTargetCommandOutput>;
            deleteMountTarget(args: DeleteMountTargetCommandInput, cb: (err: any, data?: DeleteMountTargetCommandOutput) => void): void;
            deleteMountTarget(args: DeleteMountTargetCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteMountTargetCommandOutput) => void): void;
            /**
                * <p>Deletes an existing replication configuration. To delete a replication configuration, you
                *       must make the request from the Amazon Web Services Region in which the destination file system
                *       is located. Deleting a replication configuration ends the replication process. After a
                *       replication configuration is deleted, the destination file system is no longer read-only. You
                *       can write to the destination file system after its status becomes
                *       <code>Writeable</code>.</p>
                */
            deleteReplicationConfiguration(args: DeleteReplicationConfigurationCommandInput, options?: __HttpHandlerOptions): Promise<DeleteReplicationConfigurationCommandOutput>;
            deleteReplicationConfiguration(args: DeleteReplicationConfigurationCommandInput, cb: (err: any, data?: DeleteReplicationConfigurationCommandOutput) => void): void;
            deleteReplicationConfiguration(args: DeleteReplicationConfigurationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteReplicationConfigurationCommandOutput) => void): void;
            /**
                * @deprecated
                *
                * <note>
                *             <p>DEPRECATED - <code>DeleteTags</code> is deprecated and not maintained. To remove tags from EFS
                *         resources, use the  API action.</p>
                *          </note>
                *          <p>Deletes the specified tags from a file system. If the <code>DeleteTags</code> request
                *       includes a tag key that doesn't exist, Amazon EFS ignores it and doesn't cause an
                *       error. For more information about tags and related restrictions, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Tag restrictions</a> in the
                *         <i>Billing and Cost Management User Guide</i>.</p>
                *
                *          <p>This operation requires permissions for the <code>elasticfilesystem:DeleteTags</code>
                *       action.</p>
                */
            deleteTags(args: DeleteTagsCommandInput, options?: __HttpHandlerOptions): Promise<DeleteTagsCommandOutput>;
            deleteTags(args: DeleteTagsCommandInput, cb: (err: any, data?: DeleteTagsCommandOutput) => void): void;
            deleteTags(args: DeleteTagsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteTagsCommandOutput) => void): void;
            /**
                * <p>Returns the description of a specific Amazon EFS access point if the <code>AccessPointId</code> is provided.
                *       If you provide an EFS <code>FileSystemId</code>, it returns descriptions of all access points for that file system.
                *       You can provide either an <code>AccessPointId</code> or a <code>FileSystemId</code> in the request, but not both. </p>
                *          <p>This operation requires permissions for the <code>elasticfilesystem:DescribeAccessPoints</code> action.</p>
                */
            describeAccessPoints(args: DescribeAccessPointsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeAccessPointsCommandOutput>;
            describeAccessPoints(args: DescribeAccessPointsCommandInput, cb: (err: any, data?: DescribeAccessPointsCommandOutput) => void): void;
            describeAccessPoints(args: DescribeAccessPointsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeAccessPointsCommandOutput) => void): void;
            /**
                * <p>Returns the account preferences settings for the Amazon Web Services account associated with the user making the request, in the current Amazon Web Services Region.
                *       For more information, see <a href="efs/latest/ug/manage-efs-resource-ids.html">Managing Amazon EFS resource IDs</a>.</p>
                */
            describeAccountPreferences(args: DescribeAccountPreferencesCommandInput, options?: __HttpHandlerOptions): Promise<DescribeAccountPreferencesCommandOutput>;
            describeAccountPreferences(args: DescribeAccountPreferencesCommandInput, cb: (err: any, data?: DescribeAccountPreferencesCommandOutput) => void): void;
            describeAccountPreferences(args: DescribeAccountPreferencesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeAccountPreferencesCommandOutput) => void): void;
            /**
                * <p>Returns the backup policy for the specified EFS file system.</p>
                */
            describeBackupPolicy(args: DescribeBackupPolicyCommandInput, options?: __HttpHandlerOptions): Promise<DescribeBackupPolicyCommandOutput>;
            describeBackupPolicy(args: DescribeBackupPolicyCommandInput, cb: (err: any, data?: DescribeBackupPolicyCommandOutput) => void): void;
            describeBackupPolicy(args: DescribeBackupPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeBackupPolicyCommandOutput) => void): void;
            /**
                * <p>Returns the <code>FileSystemPolicy</code> for the specified EFS file system.</p>
                *          <p>This operation requires permissions for the <code>elasticfilesystem:DescribeFileSystemPolicy</code> action.</p>
                */
            describeFileSystemPolicy(args: DescribeFileSystemPolicyCommandInput, options?: __HttpHandlerOptions): Promise<DescribeFileSystemPolicyCommandOutput>;
            describeFileSystemPolicy(args: DescribeFileSystemPolicyCommandInput, cb: (err: any, data?: DescribeFileSystemPolicyCommandOutput) => void): void;
            describeFileSystemPolicy(args: DescribeFileSystemPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeFileSystemPolicyCommandOutput) => void): void;
            /**
                * <p>Returns the description of a specific Amazon EFS file system if either the file system
                *         <code>CreationToken</code> or the <code>FileSystemId</code> is provided. Otherwise, it
                *       returns descriptions of all file systems owned by the caller's Amazon Web Services account in the
                *       Amazon Web Services Region of the endpoint that you're calling.</p>
                *
                *          <p>When retrieving all file system descriptions, you can optionally specify the
                *         <code>MaxItems</code> parameter to limit the number of descriptions in a response.
                *       Currently, this number is automatically set to 10. If more file system descriptions remain,
                *       Amazon EFS returns a <code>NextMarker</code>, an opaque token, in the response. In this case,
                *       you should send a subsequent request with the <code>Marker</code> request parameter set to the
                *       value of <code>NextMarker</code>. </p>
                *
                *          <p>To retrieve a list of your file system descriptions, this operation is used in an
                *       iterative process, where <code>DescribeFileSystems</code> is called first without the
                *         <code>Marker</code> and then the operation continues to call it with the <code>Marker</code>
                *       parameter set to the value of the <code>NextMarker</code> from the previous response until the
                *       response has no <code>NextMarker</code>. </p>
                *
                *          <p> The order of file systems returned in the response of one
                *         <code>DescribeFileSystems</code> call and the order of file systems returned across the
                *       responses of a multi-call iteration is unspecified. </p>
                *          <p> This operation requires permissions for the
                *         <code>elasticfilesystem:DescribeFileSystems</code> action. </p>
                */
            describeFileSystems(args: DescribeFileSystemsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeFileSystemsCommandOutput>;
            describeFileSystems(args: DescribeFileSystemsCommandInput, cb: (err: any, data?: DescribeFileSystemsCommandOutput) => void): void;
            describeFileSystems(args: DescribeFileSystemsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeFileSystemsCommandOutput) => void): void;
            /**
                * <p>Returns the current <code>LifecycleConfiguration</code> object for the specified Amazon
                *       EFS file system. EFS lifecycle management uses the <code>LifecycleConfiguration</code> object
                *       to identify which files to move to the EFS Infrequent Access (IA) storage class. For a file system
                *       without a <code>LifecycleConfiguration</code> object, the call returns an empty array in the
                *       response.</p>
                *          <p>When EFS Intelligent-Tiering is enabled, <code>TransitionToPrimaryStorageClass</code> has
                *       a value of <code>AFTER_1_ACCESS</code>.</p>
                *          <p>This operation requires permissions for the
                *         <code>elasticfilesystem:DescribeLifecycleConfiguration</code> operation.</p>
                */
            describeLifecycleConfiguration(args: DescribeLifecycleConfigurationCommandInput, options?: __HttpHandlerOptions): Promise<DescribeLifecycleConfigurationCommandOutput>;
            describeLifecycleConfiguration(args: DescribeLifecycleConfigurationCommandInput, cb: (err: any, data?: DescribeLifecycleConfigurationCommandOutput) => void): void;
            describeLifecycleConfiguration(args: DescribeLifecycleConfigurationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeLifecycleConfigurationCommandOutput) => void): void;
            /**
                * <p>Returns the descriptions of all the current mount targets, or a specific mount target,
                *       for a file system. When requesting all of the current mount targets, the order of mount
                *       targets returned in the response is unspecified.</p>
                *
                *          <p>This operation requires permissions for the
                *         <code>elasticfilesystem:DescribeMountTargets</code> action, on either the file system ID
                *       that you specify in <code>FileSystemId</code>, or on the file system of the mount target that
                *       you specify in <code>MountTargetId</code>.</p>
                */
            describeMountTargets(args: DescribeMountTargetsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeMountTargetsCommandOutput>;
            describeMountTargets(args: DescribeMountTargetsCommandInput, cb: (err: any, data?: DescribeMountTargetsCommandOutput) => void): void;
            describeMountTargets(args: DescribeMountTargetsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeMountTargetsCommandOutput) => void): void;
            /**
                * <p>Returns the security groups currently in effect for a mount target. This operation
                *       requires that the network interface of the mount target has been created and the lifecycle
                *       state of the mount target is not <code>deleted</code>.</p>
                *          <p>This operation requires permissions for the following actions:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>elasticfilesystem:DescribeMountTargetSecurityGroups</code> action on the mount
                *           target's file system. </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ec2:DescribeNetworkInterfaceAttribute</code> action on the mount target's
                *           network interface. </p>
                *             </li>
                *          </ul>
                */
            describeMountTargetSecurityGroups(args: DescribeMountTargetSecurityGroupsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeMountTargetSecurityGroupsCommandOutput>;
            describeMountTargetSecurityGroups(args: DescribeMountTargetSecurityGroupsCommandInput, cb: (err: any, data?: DescribeMountTargetSecurityGroupsCommandOutput) => void): void;
            describeMountTargetSecurityGroups(args: DescribeMountTargetSecurityGroupsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeMountTargetSecurityGroupsCommandOutput) => void): void;
            /**
                * <p>Retrieves the replication configuration for a specific file system. If a file system is
                *       not specified, all of the replication configurations for the Amazon Web Services account in an
                *         Amazon Web Services Region are retrieved.</p>
                */
            describeReplicationConfigurations(args: DescribeReplicationConfigurationsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeReplicationConfigurationsCommandOutput>;
            describeReplicationConfigurations(args: DescribeReplicationConfigurationsCommandInput, cb: (err: any, data?: DescribeReplicationConfigurationsCommandOutput) => void): void;
            describeReplicationConfigurations(args: DescribeReplicationConfigurationsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeReplicationConfigurationsCommandOutput) => void): void;
            /**
                * @deprecated
                *
                * <note>
                *             <p>DEPRECATED - The <code>DescribeTags</code> action is deprecated and not maintained. To view
                *         tags associated with EFS resources, use the <code>ListTagsForResource</code> API
                *         action.</p>
                *          </note>
                *          <p>Returns the tags associated with a file system. The order of tags returned in the
                *       response of one <code>DescribeTags</code> call and the order of tags returned across the
                *       responses of a multiple-call iteration (when using pagination) is unspecified. </p>
                *          <p> This operation requires permissions for the
                *         <code>elasticfilesystem:DescribeTags</code> action. </p>
                */
            describeTags(args: DescribeTagsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeTagsCommandOutput>;
            describeTags(args: DescribeTagsCommandInput, cb: (err: any, data?: DescribeTagsCommandOutput) => void): void;
            describeTags(args: DescribeTagsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeTagsCommandOutput) => void): void;
            /**
                * <p>Lists all tags for a top-level EFS resource. You must provide the ID of the resource that you want to retrieve the tags for.</p>
                *          <p>This operation requires permissions for the <code>elasticfilesystem:DescribeAccessPoints</code> action.</p>
                */
            listTagsForResource(args: ListTagsForResourceCommandInput, options?: __HttpHandlerOptions): Promise<ListTagsForResourceCommandOutput>;
            listTagsForResource(args: ListTagsForResourceCommandInput, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            listTagsForResource(args: ListTagsForResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            /**
                * <p>Modifies the set of security groups in effect for a mount target.</p>
                *          <p>When you create a mount target, Amazon EFS also creates a new network interface. For
                *       more information, see <a>CreateMountTarget</a>. This operation replaces the security groups in effect for the
                *       network interface associated with a mount target, with the <code>SecurityGroups</code>
                *       provided in the request. This operation requires that the network interface of the mount
                *       target has been created and the lifecycle state of the mount target is not
                *         <code>deleted</code>. </p>
                *          <p>The operation requires permissions for the following actions:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>elasticfilesystem:ModifyMountTargetSecurityGroups</code> action on the mount
                *           target's file system. </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ec2:ModifyNetworkInterfaceAttribute</code> action on the mount target's network
                *           interface. </p>
                *             </li>
                *          </ul>
                */
            modifyMountTargetSecurityGroups(args: ModifyMountTargetSecurityGroupsCommandInput, options?: __HttpHandlerOptions): Promise<ModifyMountTargetSecurityGroupsCommandOutput>;
            modifyMountTargetSecurityGroups(args: ModifyMountTargetSecurityGroupsCommandInput, cb: (err: any, data?: ModifyMountTargetSecurityGroupsCommandOutput) => void): void;
            modifyMountTargetSecurityGroups(args: ModifyMountTargetSecurityGroupsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ModifyMountTargetSecurityGroupsCommandOutput) => void): void;
            /**
                * <p>Use this operation to set the account preference in the current Amazon Web Services Region
                *       to use long 17 character (63 bit) or short 8 character (32 bit) resource IDs for
                *       new EFS file system and mount target resources. All existing resource IDs are not affected
                *       by any changes you make. You can set the ID preference during the
                *       opt-in period as EFS transitions to long resource IDs. For more information,
                *       see <a href="https://docs.aws.amazon.com/efs/latest/ug/manage-efs-resource-ids.html">Managing Amazon EFS resource IDs</a>.</p>
                *          <note>
                *             <p>Starting in October, 2021, you will receive an error if you try to set the account preference
                *         to use the short 8 character format resource ID. Contact Amazon Web Services support if you
                *         receive an error and must use short IDs for file system and mount target resources.</p>
                *          </note>
                */
            putAccountPreferences(args: PutAccountPreferencesCommandInput, options?: __HttpHandlerOptions): Promise<PutAccountPreferencesCommandOutput>;
            putAccountPreferences(args: PutAccountPreferencesCommandInput, cb: (err: any, data?: PutAccountPreferencesCommandOutput) => void): void;
            putAccountPreferences(args: PutAccountPreferencesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutAccountPreferencesCommandOutput) => void): void;
            /**
                * <p>Updates the file system's backup policy. Use this action to start or stop automatic backups of the file system. </p>
                */
            putBackupPolicy(args: PutBackupPolicyCommandInput, options?: __HttpHandlerOptions): Promise<PutBackupPolicyCommandOutput>;
            putBackupPolicy(args: PutBackupPolicyCommandInput, cb: (err: any, data?: PutBackupPolicyCommandOutput) => void): void;
            putBackupPolicy(args: PutBackupPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutBackupPolicyCommandOutput) => void): void;
            /**
                * <p>Applies an Amazon EFS <code>FileSystemPolicy</code> to an Amazon EFS file system.
                *       A file system policy is an IAM resource-based policy and can contain multiple policy statements.
                *       A file system always has exactly one file system policy, which can be the default policy or
                *       an explicit policy set or updated using this API operation.
                *       EFS file system policies have a 20,000 character limit.
                *       When an explicit policy is set, it overrides the default policy. For more information about the default file system policy, see
                *       <a href="https://docs.aws.amazon.com/efs/latest/ug/iam-access-control-nfs-efs.html#default-filesystempolicy">Default EFS File System Policy</a>.
                *     </p>
                *          <note>
                *             <p>EFS file system policies have a 20,000 character limit.</p>
                *          </note>
                *          <p>This operation requires permissions for the <code>elasticfilesystem:PutFileSystemPolicy</code> action.</p>
                */
            putFileSystemPolicy(args: PutFileSystemPolicyCommandInput, options?: __HttpHandlerOptions): Promise<PutFileSystemPolicyCommandOutput>;
            putFileSystemPolicy(args: PutFileSystemPolicyCommandInput, cb: (err: any, data?: PutFileSystemPolicyCommandOutput) => void): void;
            putFileSystemPolicy(args: PutFileSystemPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutFileSystemPolicyCommandOutput) => void): void;
            /**
                * <p>Use this action to manage EFS lifecycle management and intelligent tiering. A
                *       <code>LifecycleConfiguration</code> consists of one or more <code>LifecyclePolicy</code> objects that
                *       define the following:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <b>EFS Lifecycle management</b> - When Amazon EFS
                *         automatically transitions files in a file system into the lower-cost Infrequent Access (IA) storage class.</p>
                *                <p>To enable EFS Lifecycle management, set the value of <code>TransitionToIA</code> to one of the available options.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>EFS Intelligent tiering</b> - When Amazon EFS
                *         automatically transitions files from IA back into the file system's primary storage class (Standard or One Zone Standard.</p>
                *                <p>To enable EFS Intelligent Tiering, set the value of <code>TransitionToPrimaryStorageClass</code> to <code>AFTER_1_ACCESS</code>.</p>
                *             </li>
                *          </ul>
                *
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/lifecycle-management-efs.html">EFS Lifecycle Management</a>.</p>
                *          <p>Each Amazon EFS file system supports one lifecycle configuration, which applies to all files in the file system. If a
                *         <code>LifecycleConfiguration</code> object already exists for the specified file system, a
                *         <code>PutLifecycleConfiguration</code> call modifies the existing configuration. A
                *         <code>PutLifecycleConfiguration</code> call with an empty <code>LifecyclePolicies</code>
                *       array in the request body deletes any existing <code>LifecycleConfiguration</code> and
                *       turns off lifecycle management and intelligent tiering for the file system.</p>
                *          <p>In the request, specify the following: </p>
                *          <ul>
                *             <li>
                *                <p>The ID for the file system for which you are enabling, disabling, or modifying lifecycle management
                *           and intelligent tiering.</p>
                *             </li>
                *             <li>
                *                <p>A <code>LifecyclePolicies</code> array of <code>LifecyclePolicy</code> objects that
                *           define when files are moved into IA storage, and when they are moved back to Standard storage.</p>
                *                <note>
                *                   <p>Amazon EFS requires that each <code>LifecyclePolicy</code>
                *           object have only have a single transition, so the <code>LifecyclePolicies</code> array needs to be structured with separate
                *           <code>LifecyclePolicy</code> objects. See the example requests in the following section for more information.</p>
                *                </note>
                *             </li>
                *          </ul>
                *
                *          <p>This operation requires permissions for the <code>elasticfilesystem:PutLifecycleConfiguration</code> operation.</p>
                *          <p>To apply a <code>LifecycleConfiguration</code> object to an encrypted file system, you
                *       need the same Key Management Service permissions as when you created the encrypted file system.</p>
                */
            putLifecycleConfiguration(args: PutLifecycleConfigurationCommandInput, options?: __HttpHandlerOptions): Promise<PutLifecycleConfigurationCommandOutput>;
            putLifecycleConfiguration(args: PutLifecycleConfigurationCommandInput, cb: (err: any, data?: PutLifecycleConfigurationCommandOutput) => void): void;
            putLifecycleConfiguration(args: PutLifecycleConfigurationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutLifecycleConfigurationCommandOutput) => void): void;
            /**
                * <p>Creates a tag for an EFS resource. You can create tags for EFS file systems and access points using this API operation.</p>
                *          <p>This operation requires permissions for the <code>elasticfilesystem:TagResource</code> action.</p>
                */
            tagResource(args: TagResourceCommandInput, options?: __HttpHandlerOptions): Promise<TagResourceCommandOutput>;
            tagResource(args: TagResourceCommandInput, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            tagResource(args: TagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            /**
                * <p>Removes tags from an EFS resource. You can remove tags from EFS file systems and access points using this API operation.</p>
                *          <p>This operation requires permissions for the <code>elasticfilesystem:UntagResource</code> action.</p>
                */
            untagResource(args: UntagResourceCommandInput, options?: __HttpHandlerOptions): Promise<UntagResourceCommandOutput>;
            untagResource(args: UntagResourceCommandInput, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            untagResource(args: UntagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            /**
                * <p>Updates the throughput mode or the amount of provisioned throughput of an existing file
                *       system.</p>
                */
            updateFileSystem(args: UpdateFileSystemCommandInput, options?: __HttpHandlerOptions): Promise<UpdateFileSystemCommandOutput>;
            updateFileSystem(args: UpdateFileSystemCommandInput, cb: (err: any, data?: UpdateFileSystemCommandOutput) => void): void;
            updateFileSystem(args: UpdateFileSystemCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateFileSystemCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/CreateAccessPointCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { AccessPointDescription, CreateAccessPointRequest } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface CreateAccessPointCommandInput extends CreateAccessPointRequest {
    }
    export interface CreateAccessPointCommandOutput extends AccessPointDescription, __MetadataBearer {
    }
    /**
        * <p>Creates an EFS access point. An access point is an application-specific view into an EFS
        *       file system that applies an operating system user and group, and a file system path, to any
        *       file system request made through the access point. The operating system user and group
        *       override any identity information provided by the NFS client. The file system path is exposed
        *       as the access point's root directory. Applications using the access point can only access data in
        *       the application's own directory and any subdirectories. To learn more, see <a href="https://docs.aws.amazon.com/efs/latest/ug/efs-access-points.html">Mounting a file system using EFS access
        *         points</a>.</p>
        *          <p>This operation requires permissions for the <code>elasticfilesystem:CreateAccessPoint</code> action.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, CreateAccessPointCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, CreateAccessPointCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new CreateAccessPointCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateAccessPointCommandInput} for command's `input` shape.
        * @see {@link CreateAccessPointCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class CreateAccessPointCommand extends $Command<CreateAccessPointCommandInput, CreateAccessPointCommandOutput, EFSClientResolvedConfig> {
            readonly input: CreateAccessPointCommandInput;
            constructor(input: CreateAccessPointCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateAccessPointCommandInput, CreateAccessPointCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/CreateFileSystemCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { CreateFileSystemRequest, FileSystemDescription } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface CreateFileSystemCommandInput extends CreateFileSystemRequest {
    }
    export interface CreateFileSystemCommandOutput extends FileSystemDescription, __MetadataBearer {
    }
    /**
        * <p>Creates a new, empty file system. The operation requires a creation token in the
        *       request that Amazon EFS uses to ensure idempotent creation (calling the operation with same
        *       creation token has no effect). If a file system does not currently exist that is owned by the
        *       caller's Amazon Web Services account with the specified creation token, this operation does the
        *       following:</p>
        *          <ul>
        *             <li>
        *                <p>Creates a new, empty file system. The file system will have an Amazon EFS assigned
        *           ID, and an initial lifecycle state <code>creating</code>.</p>
        *             </li>
        *             <li>
        *                <p>Returns with the description of the created file system.</p>
        *             </li>
        *          </ul>
        *          <p>Otherwise, this operation returns a <code>FileSystemAlreadyExists</code> error with the
        *       ID of the existing file system.</p>
        *          <note>
        *             <p>For basic use cases, you can use a randomly generated UUID for the creation
        *         token.</p>
        *          </note>
        *          <p> The idempotent operation allows you to retry a <code>CreateFileSystem</code> call without
        *       risk of creating an extra file system. This can happen when an initial call fails in a way
        *       that leaves it uncertain whether or not a file system was actually created. An example might
        *       be that a transport level timeout occurred or your connection was reset. As long as you use
        *       the same creation token, if the initial call had succeeded in creating a file system, the
        *       client can learn of its existence from the <code>FileSystemAlreadyExists</code> error.</p>
        *          <p>For more information, see
        *       <a href="https://docs.aws.amazon.com/efs/latest/ug/creating-using-create-fs.html#creating-using-create-fs-part1">Creating a file system</a>
        *      in the <i>Amazon EFS User Guide</i>.</p>
        *
        *          <note>
        *             <p>The <code>CreateFileSystem</code> call returns while the file system's lifecycle
        *         state is still <code>creating</code>. You can check the file system creation status by
        *         calling the <a>DescribeFileSystems</a> operation, which among other things returns the file
        *         system state.</p>
        *          </note>
        *
        *          <p>This operation accepts an optional <code>PerformanceMode</code> parameter that you
        *       choose for your file system. We recommend <code>generalPurpose</code> performance mode for
        *       most file systems. File systems using the <code>maxIO</code> performance mode can scale to
        *       higher levels of aggregate throughput and operations per second with a tradeoff of slightly
        *       higher latencies for most file operations. The performance mode can't be changed after
        *       the file system has been created. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/performance.html#performancemodes.html">Amazon EFS performance
        *         modes</a>.</p>
        *
        *          <p>You can set the throughput mode for the file system using the <code>ThroughputMode</code> parameter.</p>
        *
        *          <p>After the file system is fully created, Amazon EFS sets its lifecycle state to
        *         <code>available</code>, at which point you can create one or more mount targets for the file
        *       system in your VPC. For more information, see <a>CreateMountTarget</a>. You mount your Amazon EFS file system on an EC2 instances in
        *       your VPC by using the mount target. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/how-it-works.html">Amazon EFS: How it Works</a>. </p>
        *
        *          <p> This operation requires permissions for the
        *         <code>elasticfilesystem:CreateFileSystem</code> action. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, CreateFileSystemCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, CreateFileSystemCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new CreateFileSystemCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateFileSystemCommandInput} for command's `input` shape.
        * @see {@link CreateFileSystemCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class CreateFileSystemCommand extends $Command<CreateFileSystemCommandInput, CreateFileSystemCommandOutput, EFSClientResolvedConfig> {
            readonly input: CreateFileSystemCommandInput;
            constructor(input: CreateFileSystemCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateFileSystemCommandInput, CreateFileSystemCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/CreateMountTargetCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { CreateMountTargetRequest, MountTargetDescription } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface CreateMountTargetCommandInput extends CreateMountTargetRequest {
    }
    export interface CreateMountTargetCommandOutput extends MountTargetDescription, __MetadataBearer {
    }
    /**
        * <p>Creates a mount target for a file system. You can then mount the file system on EC2
        *       instances by using the mount target.</p>
        *          <p>You can create one mount target in each Availability Zone in your VPC. All EC2
        *       instances in a VPC within a given Availability Zone share a single mount target for a given
        *       file system. If you have multiple subnets in an Availability Zone, you create a mount target
        *       in one of the subnets. EC2 instances do not need to be in the same subnet as the mount target
        *       in order to access their file system.</p>
        *          <p>You can create only one mount target for an EFS file system using One Zone storage
        *       classes. You must create that mount target in the same Availability Zone in which the file
        *       system is located. Use the <code>AvailabilityZoneName</code> and
        *         <code>AvailabiltyZoneId</code> properties in the <a>DescribeFileSystems</a>
        *       response object to get this information. Use the <code>subnetId</code> associated with the
        *       file system's Availability Zone when creating the mount target.</p>
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/how-it-works.html">Amazon EFS: How it Works</a>. </p>
        *          <p>To create a mount target for a file system, the file system's lifecycle state must be
        *         <code>available</code>. For more information, see <a>DescribeFileSystems</a>.</p>
        *          <p>In the request, provide the following:</p>
        *          <ul>
        *             <li>
        *                <p>The file system ID for which you are creating the mount
        *         target.</p>
        *             </li>
        *             <li>
        *                <p>A subnet ID, which determines the following:</p>
        *                <ul>
        *                   <li>
        *                      <p>The VPC in which Amazon EFS creates the mount target</p>
        *                   </li>
        *                   <li>
        *                      <p>The Availability Zone in which Amazon EFS creates the mount target</p>
        *                   </li>
        *                   <li>
        *                      <p>The IP address range from which Amazon EFS selects the IP address of the mount target
        *               (if you don't specify an IP address in the request)</p>
        *                   </li>
        *                </ul>
        *             </li>
        *          </ul>
        *
        *          <p>After creating the mount target, Amazon EFS returns a response that includes, a
        *         <code>MountTargetId</code> and an <code>IpAddress</code>. You use this IP address when
        *       mounting the file system in an EC2 instance. You can also use the mount target's DNS name
        *       when mounting the file system. The EC2 instance on which you mount the file system by using
        *       the mount target can resolve the mount target's DNS name to its IP address. For more
        *       information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/how-it-works.html#how-it-works-implementation">How it Works:
        *         Implementation Overview</a>. </p>
        *          <p>Note that you can create mount targets for a file system in only one VPC, and there can
        *       be only one mount target per Availability Zone. That is, if the file system already has one or
        *       more mount targets created for it, the subnet specified in the request to add another mount
        *       target must meet the following requirements:</p>
        *          <ul>
        *             <li>
        *                <p>Must belong to the same VPC as the subnets of the existing mount targets</p>
        *             </li>
        *             <li>
        *                <p>Must not be in the same Availability Zone as any of the subnets of the existing
        *           mount targets</p>
        *             </li>
        *          </ul>
        *
        *          <p>If the request satisfies the requirements, Amazon EFS does the following:</p>
        *          <ul>
        *             <li>
        *                <p>Creates a new mount target in the specified subnet.</p>
        *             </li>
        *             <li>
        *                <p>Also creates a new network interface in the subnet as follows:</p>
        *                <ul>
        *                   <li>
        *                      <p>If the request provides an <code>IpAddress</code>, Amazon EFS assigns that IP
        *               address to the network interface. Otherwise, Amazon EFS assigns a free address in the
        *               subnet (in the same way that the Amazon EC2 <code>CreateNetworkInterface</code> call
        *               does when a request does not specify a primary private IP address).</p>
        *                   </li>
        *                   <li>
        *                      <p>If the request provides <code>SecurityGroups</code>, this network interface is
        *               associated with those security groups. Otherwise, it belongs to the default security
        *               group for the subnet's VPC.</p>
        *                   </li>
        *                   <li>
        *                      <p>Assigns the description <code>Mount target <i>fsmt-id</i> for
        *                 file system <i>fs-id</i>
        *                         </code> where <code>
        *                            <i>fsmt-id</i>
        *                         </code> is the mount target ID, and <code>
        *                            <i>fs-id</i>
        *                         </code> is the <code>FileSystemId</code>.</p>
        *                   </li>
        *                   <li>
        *                      <p>Sets the <code>requesterManaged</code> property of the network interface to
        *                 <code>true</code>, and the <code>requesterId</code> value to
        *               <code>EFS</code>.</p>
        *                   </li>
        *                </ul>
        *                <p>Each Amazon EFS mount target has one corresponding requester-managed EC2 network
        *           interface. After the network interface is created, Amazon EFS sets the
        *             <code>NetworkInterfaceId</code> field in the mount target's description to the
        *           network interface ID, and the <code>IpAddress</code> field to its address. If network
        *           interface creation fails, the entire <code>CreateMountTarget</code> operation
        *           fails.</p>
        *             </li>
        *          </ul>
        *          <note>
        *             <p>The <code>CreateMountTarget</code> call returns only after creating the network
        *         interface, but while the mount target state is still <code>creating</code>, you can check
        *         the mount target creation status by calling the <a>DescribeMountTargets</a> operation, which among other things returns the mount
        *         target state.</p>
        *          </note>
        *          <p>We recommend that you create a mount target in each of the Availability Zones. There
        *       are cost considerations for using a file system in an Availability Zone through a mount target
        *       created in another Availability Zone. For more information, see <a href="http://aws.amazon.com/efs/">Amazon EFS</a>. In addition, by always using a mount target local to the
        *       instance's Availability Zone, you eliminate a partial failure scenario. If the
        *       Availability Zone in which your mount target is created goes down, then you can't access
        *       your file system through that mount target. </p>
        *          <p>This operation requires permissions for the following action on the file
        *       system:</p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <code>elasticfilesystem:CreateMountTarget</code>
        *                </p>
        *             </li>
        *          </ul>
        *          <p>This operation also requires permissions for the following Amazon EC2
        *       actions:</p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <code>ec2:DescribeSubnets</code>
        *                </p>
        *             </li>
        *             <li>
        *                <p>
        *                   <code>ec2:DescribeNetworkInterfaces</code>
        *                </p>
        *             </li>
        *             <li>
        *                <p>
        *                   <code>ec2:CreateNetworkInterface</code>
        *                </p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, CreateMountTargetCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, CreateMountTargetCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new CreateMountTargetCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateMountTargetCommandInput} for command's `input` shape.
        * @see {@link CreateMountTargetCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class CreateMountTargetCommand extends $Command<CreateMountTargetCommandInput, CreateMountTargetCommandOutput, EFSClientResolvedConfig> {
            readonly input: CreateMountTargetCommandInput;
            constructor(input: CreateMountTargetCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateMountTargetCommandInput, CreateMountTargetCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/CreateReplicationConfigurationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { CreateReplicationConfigurationRequest, ReplicationConfigurationDescription } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface CreateReplicationConfigurationCommandInput extends CreateReplicationConfigurationRequest {
    }
    export interface CreateReplicationConfigurationCommandOutput extends ReplicationConfigurationDescription, __MetadataBearer {
    }
    /**
        * <p>Creates a replication configuration that replicates an existing EFS file system to a new,
        *       read-only file system. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/efs-replication.html">Amazon EFS replication</a> in the
        *           <i>Amazon EFS User Guide</i>. The replication configuration
        *       specifies the following:</p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <b>Source file system</b> - An existing EFS file system that you
        *           want replicated. The source file system cannot be a destination file system in an existing
        *           replication configuration.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <b>Destination file system configuration</b> - The configuration of
        *           the destination file system to which the source file system will be replicated. There can
        *           only be one destination file system in a replication configuration. The destination file
        *           system configuration consists of the following properties:</p>
        *                <ul>
        *                   <li>
        *                      <p>
        *                         <b>Amazon Web Services Region</b> - The Amazon Web Services Region in
        *               which the destination file system is created. Amazon EFS replication is
        *               available in all Amazon Web Services Regions that Amazon EFS is available in,
        *               except Africa (Cape Town), Asia Pacific (Hong Kong), Asia Pacific (Jakarta), Europe
        *               (Milan), and Middle East (Bahrain).</p>
        *                   </li>
        *                   <li>
        *                      <p>
        *                         <b>Availability Zone</b> - If you want the destination file system
        *               to use EFS One Zone availability and durability, you must specify the Availability
        *               Zone to create the file system in. For more information about EFS storage classes, see
        *                 <a href="https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html">
        *                 Amazon EFS storage classes</a> in the <i>Amazon EFS User
        *                 Guide</i>.</p>
        *                   </li>
        *                   <li>
        *                      <p>
        *                         <b>Encryption</b> - All destination file systems are created with
        *               encryption at rest enabled. You can specify the Key Management Service (KMS) key that is used to encrypt the destination file system. If you don't
        *               specify a KMS key, your service-managed KMS key for
        *                 Amazon EFS is used.  </p>
        *                      <note>
        *                         <p>After the file system is created, you cannot change the KMS key.</p>
        *                      </note>
        *                   </li>
        *                </ul>
        *             </li>
        *          </ul>
        *
        *          <p>The following properties are set by default:</p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <b>Performance mode</b> - The destination file system's performance
        *           mode matches that of the source file system, unless the destination file system uses EFS
        *           One Zone storage. In that case, the General Purpose performance mode is used. The
        *           performance mode cannot be changed.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <b>Throughput mode</b> - The destination file system uses the
        *           Bursting Throughput mode by default. After the file system is created, you can modify the
        *           throughput mode.</p>
        *             </li>
        *          </ul>
        *
        *          <p>The following properties are turned off by default:</p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <b>Lifecycle management</b> - EFS lifecycle management and EFS
        *           Intelligent-Tiering are not enabled on the destination file system. After the destination
        *           file system is created, you can enable EFS lifecycle management and EFS
        *           Intelligent-Tiering.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <b>Automatic backups</b> - Automatic daily backups not enabled on
        *           the destination file system. After the file system is created, you can change this
        *           setting.</p>
        *             </li>
        *          </ul>
        *
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/efs-replication.html">Amazon EFS replication</a> in the
        *           <i>Amazon EFS User Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, CreateReplicationConfigurationCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, CreateReplicationConfigurationCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new CreateReplicationConfigurationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateReplicationConfigurationCommandInput} for command's `input` shape.
        * @see {@link CreateReplicationConfigurationCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class CreateReplicationConfigurationCommand extends $Command<CreateReplicationConfigurationCommandInput, CreateReplicationConfigurationCommandOutput, EFSClientResolvedConfig> {
            readonly input: CreateReplicationConfigurationCommandInput;
            constructor(input: CreateReplicationConfigurationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateReplicationConfigurationCommandInput, CreateReplicationConfigurationCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/CreateTagsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { CreateTagsRequest } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface CreateTagsCommandInput extends CreateTagsRequest {
    }
    export interface CreateTagsCommandOutput extends __MetadataBearer {
    }
    /**
        * @deprecated
        *
        * <note>
        *             <p>DEPRECATED - <code>CreateTags</code> is deprecated and not maintained. To create tags for EFS
        *         resources, use the  API action.</p>
        *          </note>
        *          <p>Creates or overwrites tags associated with a file system. Each tag is a key-value pair. If
        *       a tag key specified in the request already exists on the file system, this operation
        *       overwrites its value with the value provided in the request. If you add the <code>Name</code>
        *       tag to your file system, Amazon EFS returns it in the response to the <a>DescribeFileSystems</a> operation. </p>
        *          <p>This operation requires permission for the <code>elasticfilesystem:CreateTags</code>
        *       action.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, CreateTagsCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, CreateTagsCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new CreateTagsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateTagsCommandInput} for command's `input` shape.
        * @see {@link CreateTagsCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class CreateTagsCommand extends $Command<CreateTagsCommandInput, CreateTagsCommandOutput, EFSClientResolvedConfig> {
            readonly input: CreateTagsCommandInput;
            constructor(input: CreateTagsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateTagsCommandInput, CreateTagsCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DeleteAccessPointCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { DeleteAccessPointRequest } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface DeleteAccessPointCommandInput extends DeleteAccessPointRequest {
    }
    export interface DeleteAccessPointCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes the specified access point. After deletion is complete, new clients can no
        *       longer connect to the access points. Clients connected to the access point at the time of
        *       deletion will continue to function until they terminate their connection.</p>
        *          <p>This operation requires permissions for the <code>elasticfilesystem:DeleteAccessPoint</code> action.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, DeleteAccessPointCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, DeleteAccessPointCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new DeleteAccessPointCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteAccessPointCommandInput} for command's `input` shape.
        * @see {@link DeleteAccessPointCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class DeleteAccessPointCommand extends $Command<DeleteAccessPointCommandInput, DeleteAccessPointCommandOutput, EFSClientResolvedConfig> {
            readonly input: DeleteAccessPointCommandInput;
            constructor(input: DeleteAccessPointCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteAccessPointCommandInput, DeleteAccessPointCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DeleteFileSystemCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { DeleteFileSystemRequest } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface DeleteFileSystemCommandInput extends DeleteFileSystemRequest {
    }
    export interface DeleteFileSystemCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes a file system, permanently severing access to its contents. Upon return, the
        *       file system no longer exists and you can't access any contents of the deleted file
        *       system.</p>
        *          <p>You need to manually delete mount targets attached to a file system before you can delete
        *     an EFS file system. This step is performed for you when you use the Amazon Web Services console
        *     to delete a file system.</p>
        *          <note>
        *             <p>You cannot delete a file system that is part of an EFS Replication configuration.
        *       You need to delete the replication configuration first.</p>
        *          </note>
        *          <p> You can't delete a file system that is in use. That is, if the file system has
        *       any mount targets, you must first delete them. For more information, see <a>DescribeMountTargets</a> and <a>DeleteMountTarget</a>. </p>
        *
        *          <note>
        *             <p>The <code>DeleteFileSystem</code> call returns while the file system state is still
        *           <code>deleting</code>. You can check the file system deletion status by calling the <a>DescribeFileSystems</a> operation, which returns a list of file systems in your
        *         account. If you pass file system ID or creation token for the deleted file system, the <a>DescribeFileSystems</a> returns a <code>404 FileSystemNotFound</code>
        *         error.</p>
        *          </note>
        *
        *          <p>This operation requires permissions for the
        *         <code>elasticfilesystem:DeleteFileSystem</code> action.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, DeleteFileSystemCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, DeleteFileSystemCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new DeleteFileSystemCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteFileSystemCommandInput} for command's `input` shape.
        * @see {@link DeleteFileSystemCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class DeleteFileSystemCommand extends $Command<DeleteFileSystemCommandInput, DeleteFileSystemCommandOutput, EFSClientResolvedConfig> {
            readonly input: DeleteFileSystemCommandInput;
            constructor(input: DeleteFileSystemCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteFileSystemCommandInput, DeleteFileSystemCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DeleteFileSystemPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { DeleteFileSystemPolicyRequest } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface DeleteFileSystemPolicyCommandInput extends DeleteFileSystemPolicyRequest {
    }
    export interface DeleteFileSystemPolicyCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes the <code>FileSystemPolicy</code> for the specified file system.
        *       The default <code>FileSystemPolicy</code> goes into effect once the existing policy is deleted.
        *       For more information about the default file system policy, see <a href="https://docs.aws.amazon.com/efs/latest/ug/res-based-policies-efs.html">Using Resource-based Policies with EFS</a>.</p>
        *          <p>This operation requires permissions for the <code>elasticfilesystem:DeleteFileSystemPolicy</code> action.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, DeleteFileSystemPolicyCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, DeleteFileSystemPolicyCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new DeleteFileSystemPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteFileSystemPolicyCommandInput} for command's `input` shape.
        * @see {@link DeleteFileSystemPolicyCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class DeleteFileSystemPolicyCommand extends $Command<DeleteFileSystemPolicyCommandInput, DeleteFileSystemPolicyCommandOutput, EFSClientResolvedConfig> {
            readonly input: DeleteFileSystemPolicyCommandInput;
            constructor(input: DeleteFileSystemPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteFileSystemPolicyCommandInput, DeleteFileSystemPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DeleteMountTargetCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { DeleteMountTargetRequest } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface DeleteMountTargetCommandInput extends DeleteMountTargetRequest {
    }
    export interface DeleteMountTargetCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes the specified mount target.</p>
        *
        *          <p>This operation forcibly breaks any mounts of the file system by using the mount target
        *       that is being deleted, which might disrupt instances or applications using those mounts. To
        *       avoid applications getting cut off abruptly, you might consider unmounting any mounts of the
        *       mount target, if feasible. The operation also deletes the associated network interface.
        *       Uncommitted writes might be lost, but breaking a mount target using this operation does not
        *       corrupt the file system itself. The file system you created remains. You can mount an EC2
        *       instance in your VPC by using another mount target.</p>
        *          <p>This operation requires permissions for the following action on the file
        *       system:</p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <code>elasticfilesystem:DeleteMountTarget</code>
        *                </p>
        *             </li>
        *          </ul>
        *
        *          <note>
        *             <p>The <code>DeleteMountTarget</code> call returns while the mount target state is still
        *           <code>deleting</code>. You can check the mount target deletion by calling the <a>DescribeMountTargets</a> operation, which returns a list of mount target
        *         descriptions for the given file system. </p>
        *          </note>
        *
        *          <p>The operation also requires permissions for the following Amazon EC2 action on the
        *       mount target's network interface:</p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <code>ec2:DeleteNetworkInterface</code>
        *                </p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, DeleteMountTargetCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, DeleteMountTargetCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new DeleteMountTargetCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteMountTargetCommandInput} for command's `input` shape.
        * @see {@link DeleteMountTargetCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class DeleteMountTargetCommand extends $Command<DeleteMountTargetCommandInput, DeleteMountTargetCommandOutput, EFSClientResolvedConfig> {
            readonly input: DeleteMountTargetCommandInput;
            constructor(input: DeleteMountTargetCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteMountTargetCommandInput, DeleteMountTargetCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DeleteReplicationConfigurationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { DeleteReplicationConfigurationRequest } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface DeleteReplicationConfigurationCommandInput extends DeleteReplicationConfigurationRequest {
    }
    export interface DeleteReplicationConfigurationCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes an existing replication configuration. To delete a replication configuration, you
        *       must make the request from the Amazon Web Services Region in which the destination file system
        *       is located. Deleting a replication configuration ends the replication process. After a
        *       replication configuration is deleted, the destination file system is no longer read-only. You
        *       can write to the destination file system after its status becomes
        *       <code>Writeable</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, DeleteReplicationConfigurationCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, DeleteReplicationConfigurationCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new DeleteReplicationConfigurationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteReplicationConfigurationCommandInput} for command's `input` shape.
        * @see {@link DeleteReplicationConfigurationCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class DeleteReplicationConfigurationCommand extends $Command<DeleteReplicationConfigurationCommandInput, DeleteReplicationConfigurationCommandOutput, EFSClientResolvedConfig> {
            readonly input: DeleteReplicationConfigurationCommandInput;
            constructor(input: DeleteReplicationConfigurationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteReplicationConfigurationCommandInput, DeleteReplicationConfigurationCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DeleteTagsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { DeleteTagsRequest } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface DeleteTagsCommandInput extends DeleteTagsRequest {
    }
    export interface DeleteTagsCommandOutput extends __MetadataBearer {
    }
    /**
        * @deprecated
        *
        * <note>
        *             <p>DEPRECATED - <code>DeleteTags</code> is deprecated and not maintained. To remove tags from EFS
        *         resources, use the  API action.</p>
        *          </note>
        *          <p>Deletes the specified tags from a file system. If the <code>DeleteTags</code> request
        *       includes a tag key that doesn't exist, Amazon EFS ignores it and doesn't cause an
        *       error. For more information about tags and related restrictions, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Tag restrictions</a> in the
        *         <i>Billing and Cost Management User Guide</i>.</p>
        *
        *          <p>This operation requires permissions for the <code>elasticfilesystem:DeleteTags</code>
        *       action.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, DeleteTagsCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, DeleteTagsCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new DeleteTagsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteTagsCommandInput} for command's `input` shape.
        * @see {@link DeleteTagsCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class DeleteTagsCommand extends $Command<DeleteTagsCommandInput, DeleteTagsCommandOutput, EFSClientResolvedConfig> {
            readonly input: DeleteTagsCommandInput;
            constructor(input: DeleteTagsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteTagsCommandInput, DeleteTagsCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeAccessPointsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { DescribeAccessPointsRequest, DescribeAccessPointsResponse } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface DescribeAccessPointsCommandInput extends DescribeAccessPointsRequest {
    }
    export interface DescribeAccessPointsCommandOutput extends DescribeAccessPointsResponse, __MetadataBearer {
    }
    /**
        * <p>Returns the description of a specific Amazon EFS access point if the <code>AccessPointId</code> is provided.
        *       If you provide an EFS <code>FileSystemId</code>, it returns descriptions of all access points for that file system.
        *       You can provide either an <code>AccessPointId</code> or a <code>FileSystemId</code> in the request, but not both. </p>
        *          <p>This operation requires permissions for the <code>elasticfilesystem:DescribeAccessPoints</code> action.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, DescribeAccessPointsCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, DescribeAccessPointsCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new DescribeAccessPointsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeAccessPointsCommandInput} for command's `input` shape.
        * @see {@link DescribeAccessPointsCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class DescribeAccessPointsCommand extends $Command<DescribeAccessPointsCommandInput, DescribeAccessPointsCommandOutput, EFSClientResolvedConfig> {
            readonly input: DescribeAccessPointsCommandInput;
            constructor(input: DescribeAccessPointsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeAccessPointsCommandInput, DescribeAccessPointsCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeAccountPreferencesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { DescribeAccountPreferencesRequest, DescribeAccountPreferencesResponse } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface DescribeAccountPreferencesCommandInput extends DescribeAccountPreferencesRequest {
    }
    export interface DescribeAccountPreferencesCommandOutput extends DescribeAccountPreferencesResponse, __MetadataBearer {
    }
    /**
        * <p>Returns the account preferences settings for the Amazon Web Services account associated with the user making the request, in the current Amazon Web Services Region.
        *       For more information, see <a href="efs/latest/ug/manage-efs-resource-ids.html">Managing Amazon EFS resource IDs</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, DescribeAccountPreferencesCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, DescribeAccountPreferencesCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new DescribeAccountPreferencesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeAccountPreferencesCommandInput} for command's `input` shape.
        * @see {@link DescribeAccountPreferencesCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class DescribeAccountPreferencesCommand extends $Command<DescribeAccountPreferencesCommandInput, DescribeAccountPreferencesCommandOutput, EFSClientResolvedConfig> {
            readonly input: DescribeAccountPreferencesCommandInput;
            constructor(input: DescribeAccountPreferencesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeAccountPreferencesCommandInput, DescribeAccountPreferencesCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeBackupPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { BackupPolicyDescription, DescribeBackupPolicyRequest } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface DescribeBackupPolicyCommandInput extends DescribeBackupPolicyRequest {
    }
    export interface DescribeBackupPolicyCommandOutput extends BackupPolicyDescription, __MetadataBearer {
    }
    /**
        * <p>Returns the backup policy for the specified EFS file system.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, DescribeBackupPolicyCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, DescribeBackupPolicyCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new DescribeBackupPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeBackupPolicyCommandInput} for command's `input` shape.
        * @see {@link DescribeBackupPolicyCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class DescribeBackupPolicyCommand extends $Command<DescribeBackupPolicyCommandInput, DescribeBackupPolicyCommandOutput, EFSClientResolvedConfig> {
            readonly input: DescribeBackupPolicyCommandInput;
            constructor(input: DescribeBackupPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeBackupPolicyCommandInput, DescribeBackupPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeFileSystemPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { DescribeFileSystemPolicyRequest, FileSystemPolicyDescription } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface DescribeFileSystemPolicyCommandInput extends DescribeFileSystemPolicyRequest {
    }
    export interface DescribeFileSystemPolicyCommandOutput extends FileSystemPolicyDescription, __MetadataBearer {
    }
    /**
        * <p>Returns the <code>FileSystemPolicy</code> for the specified EFS file system.</p>
        *          <p>This operation requires permissions for the <code>elasticfilesystem:DescribeFileSystemPolicy</code> action.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, DescribeFileSystemPolicyCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, DescribeFileSystemPolicyCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new DescribeFileSystemPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeFileSystemPolicyCommandInput} for command's `input` shape.
        * @see {@link DescribeFileSystemPolicyCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class DescribeFileSystemPolicyCommand extends $Command<DescribeFileSystemPolicyCommandInput, DescribeFileSystemPolicyCommandOutput, EFSClientResolvedConfig> {
            readonly input: DescribeFileSystemPolicyCommandInput;
            constructor(input: DescribeFileSystemPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeFileSystemPolicyCommandInput, DescribeFileSystemPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeFileSystemsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { DescribeFileSystemsRequest, DescribeFileSystemsResponse } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface DescribeFileSystemsCommandInput extends DescribeFileSystemsRequest {
    }
    export interface DescribeFileSystemsCommandOutput extends DescribeFileSystemsResponse, __MetadataBearer {
    }
    /**
        * <p>Returns the description of a specific Amazon EFS file system if either the file system
        *         <code>CreationToken</code> or the <code>FileSystemId</code> is provided. Otherwise, it
        *       returns descriptions of all file systems owned by the caller's Amazon Web Services account in the
        *       Amazon Web Services Region of the endpoint that you're calling.</p>
        *
        *          <p>When retrieving all file system descriptions, you can optionally specify the
        *         <code>MaxItems</code> parameter to limit the number of descriptions in a response.
        *       Currently, this number is automatically set to 10. If more file system descriptions remain,
        *       Amazon EFS returns a <code>NextMarker</code>, an opaque token, in the response. In this case,
        *       you should send a subsequent request with the <code>Marker</code> request parameter set to the
        *       value of <code>NextMarker</code>. </p>
        *
        *          <p>To retrieve a list of your file system descriptions, this operation is used in an
        *       iterative process, where <code>DescribeFileSystems</code> is called first without the
        *         <code>Marker</code> and then the operation continues to call it with the <code>Marker</code>
        *       parameter set to the value of the <code>NextMarker</code> from the previous response until the
        *       response has no <code>NextMarker</code>. </p>
        *
        *          <p> The order of file systems returned in the response of one
        *         <code>DescribeFileSystems</code> call and the order of file systems returned across the
        *       responses of a multi-call iteration is unspecified. </p>
        *          <p> This operation requires permissions for the
        *         <code>elasticfilesystem:DescribeFileSystems</code> action. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, DescribeFileSystemsCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, DescribeFileSystemsCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new DescribeFileSystemsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeFileSystemsCommandInput} for command's `input` shape.
        * @see {@link DescribeFileSystemsCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class DescribeFileSystemsCommand extends $Command<DescribeFileSystemsCommandInput, DescribeFileSystemsCommandOutput, EFSClientResolvedConfig> {
            readonly input: DescribeFileSystemsCommandInput;
            constructor(input: DescribeFileSystemsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeFileSystemsCommandInput, DescribeFileSystemsCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeLifecycleConfigurationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { DescribeLifecycleConfigurationRequest, LifecycleConfigurationDescription } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface DescribeLifecycleConfigurationCommandInput extends DescribeLifecycleConfigurationRequest {
    }
    export interface DescribeLifecycleConfigurationCommandOutput extends LifecycleConfigurationDescription, __MetadataBearer {
    }
    /**
        * <p>Returns the current <code>LifecycleConfiguration</code> object for the specified Amazon
        *       EFS file system. EFS lifecycle management uses the <code>LifecycleConfiguration</code> object
        *       to identify which files to move to the EFS Infrequent Access (IA) storage class. For a file system
        *       without a <code>LifecycleConfiguration</code> object, the call returns an empty array in the
        *       response.</p>
        *          <p>When EFS Intelligent-Tiering is enabled, <code>TransitionToPrimaryStorageClass</code> has
        *       a value of <code>AFTER_1_ACCESS</code>.</p>
        *          <p>This operation requires permissions for the
        *         <code>elasticfilesystem:DescribeLifecycleConfiguration</code> operation.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, DescribeLifecycleConfigurationCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, DescribeLifecycleConfigurationCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new DescribeLifecycleConfigurationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeLifecycleConfigurationCommandInput} for command's `input` shape.
        * @see {@link DescribeLifecycleConfigurationCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class DescribeLifecycleConfigurationCommand extends $Command<DescribeLifecycleConfigurationCommandInput, DescribeLifecycleConfigurationCommandOutput, EFSClientResolvedConfig> {
            readonly input: DescribeLifecycleConfigurationCommandInput;
            constructor(input: DescribeLifecycleConfigurationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeLifecycleConfigurationCommandInput, DescribeLifecycleConfigurationCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeMountTargetsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { DescribeMountTargetsRequest, DescribeMountTargetsResponse } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface DescribeMountTargetsCommandInput extends DescribeMountTargetsRequest {
    }
    export interface DescribeMountTargetsCommandOutput extends DescribeMountTargetsResponse, __MetadataBearer {
    }
    /**
        * <p>Returns the descriptions of all the current mount targets, or a specific mount target,
        *       for a file system. When requesting all of the current mount targets, the order of mount
        *       targets returned in the response is unspecified.</p>
        *
        *          <p>This operation requires permissions for the
        *         <code>elasticfilesystem:DescribeMountTargets</code> action, on either the file system ID
        *       that you specify in <code>FileSystemId</code>, or on the file system of the mount target that
        *       you specify in <code>MountTargetId</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, DescribeMountTargetsCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, DescribeMountTargetsCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new DescribeMountTargetsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeMountTargetsCommandInput} for command's `input` shape.
        * @see {@link DescribeMountTargetsCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class DescribeMountTargetsCommand extends $Command<DescribeMountTargetsCommandInput, DescribeMountTargetsCommandOutput, EFSClientResolvedConfig> {
            readonly input: DescribeMountTargetsCommandInput;
            constructor(input: DescribeMountTargetsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeMountTargetsCommandInput, DescribeMountTargetsCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeMountTargetSecurityGroupsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { DescribeMountTargetSecurityGroupsRequest, DescribeMountTargetSecurityGroupsResponse } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface DescribeMountTargetSecurityGroupsCommandInput extends DescribeMountTargetSecurityGroupsRequest {
    }
    export interface DescribeMountTargetSecurityGroupsCommandOutput extends DescribeMountTargetSecurityGroupsResponse, __MetadataBearer {
    }
    /**
        * <p>Returns the security groups currently in effect for a mount target. This operation
        *       requires that the network interface of the mount target has been created and the lifecycle
        *       state of the mount target is not <code>deleted</code>.</p>
        *          <p>This operation requires permissions for the following actions:</p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <code>elasticfilesystem:DescribeMountTargetSecurityGroups</code> action on the mount
        *           target's file system. </p>
        *             </li>
        *             <li>
        *                <p>
        *                   <code>ec2:DescribeNetworkInterfaceAttribute</code> action on the mount target's
        *           network interface. </p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, DescribeMountTargetSecurityGroupsCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, DescribeMountTargetSecurityGroupsCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new DescribeMountTargetSecurityGroupsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeMountTargetSecurityGroupsCommandInput} for command's `input` shape.
        * @see {@link DescribeMountTargetSecurityGroupsCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class DescribeMountTargetSecurityGroupsCommand extends $Command<DescribeMountTargetSecurityGroupsCommandInput, DescribeMountTargetSecurityGroupsCommandOutput, EFSClientResolvedConfig> {
            readonly input: DescribeMountTargetSecurityGroupsCommandInput;
            constructor(input: DescribeMountTargetSecurityGroupsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeMountTargetSecurityGroupsCommandInput, DescribeMountTargetSecurityGroupsCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeReplicationConfigurationsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { DescribeReplicationConfigurationsRequest, DescribeReplicationConfigurationsResponse } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface DescribeReplicationConfigurationsCommandInput extends DescribeReplicationConfigurationsRequest {
    }
    export interface DescribeReplicationConfigurationsCommandOutput extends DescribeReplicationConfigurationsResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves the replication configuration for a specific file system. If a file system is
        *       not specified, all of the replication configurations for the Amazon Web Services account in an
        *         Amazon Web Services Region are retrieved.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, DescribeReplicationConfigurationsCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, DescribeReplicationConfigurationsCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new DescribeReplicationConfigurationsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeReplicationConfigurationsCommandInput} for command's `input` shape.
        * @see {@link DescribeReplicationConfigurationsCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class DescribeReplicationConfigurationsCommand extends $Command<DescribeReplicationConfigurationsCommandInput, DescribeReplicationConfigurationsCommandOutput, EFSClientResolvedConfig> {
            readonly input: DescribeReplicationConfigurationsCommandInput;
            constructor(input: DescribeReplicationConfigurationsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeReplicationConfigurationsCommandInput, DescribeReplicationConfigurationsCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeTagsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { DescribeTagsRequest, DescribeTagsResponse } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface DescribeTagsCommandInput extends DescribeTagsRequest {
    }
    export interface DescribeTagsCommandOutput extends DescribeTagsResponse, __MetadataBearer {
    }
    /**
        * @deprecated
        *
        * <note>
        *             <p>DEPRECATED - The <code>DescribeTags</code> action is deprecated and not maintained. To view
        *         tags associated with EFS resources, use the <code>ListTagsForResource</code> API
        *         action.</p>
        *          </note>
        *          <p>Returns the tags associated with a file system. The order of tags returned in the
        *       response of one <code>DescribeTags</code> call and the order of tags returned across the
        *       responses of a multiple-call iteration (when using pagination) is unspecified. </p>
        *          <p> This operation requires permissions for the
        *         <code>elasticfilesystem:DescribeTags</code> action. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, DescribeTagsCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, DescribeTagsCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new DescribeTagsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeTagsCommandInput} for command's `input` shape.
        * @see {@link DescribeTagsCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class DescribeTagsCommand extends $Command<DescribeTagsCommandInput, DescribeTagsCommandOutput, EFSClientResolvedConfig> {
            readonly input: DescribeTagsCommandInput;
            constructor(input: DescribeTagsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeTagsCommandInput, DescribeTagsCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/ListTagsForResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { ListTagsForResourceRequest, ListTagsForResourceResponse } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface ListTagsForResourceCommandInput extends ListTagsForResourceRequest {
    }
    export interface ListTagsForResourceCommandOutput extends ListTagsForResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Lists all tags for a top-level EFS resource. You must provide the ID of the resource that you want to retrieve the tags for.</p>
        *          <p>This operation requires permissions for the <code>elasticfilesystem:DescribeAccessPoints</code> action.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, ListTagsForResourceCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, ListTagsForResourceCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new ListTagsForResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTagsForResourceCommandInput} for command's `input` shape.
        * @see {@link ListTagsForResourceCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class ListTagsForResourceCommand extends $Command<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput, EFSClientResolvedConfig> {
            readonly input: ListTagsForResourceCommandInput;
            constructor(input: ListTagsForResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/ModifyMountTargetSecurityGroupsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { ModifyMountTargetSecurityGroupsRequest } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface ModifyMountTargetSecurityGroupsCommandInput extends ModifyMountTargetSecurityGroupsRequest {
    }
    export interface ModifyMountTargetSecurityGroupsCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Modifies the set of security groups in effect for a mount target.</p>
        *          <p>When you create a mount target, Amazon EFS also creates a new network interface. For
        *       more information, see <a>CreateMountTarget</a>. This operation replaces the security groups in effect for the
        *       network interface associated with a mount target, with the <code>SecurityGroups</code>
        *       provided in the request. This operation requires that the network interface of the mount
        *       target has been created and the lifecycle state of the mount target is not
        *         <code>deleted</code>. </p>
        *          <p>The operation requires permissions for the following actions:</p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <code>elasticfilesystem:ModifyMountTargetSecurityGroups</code> action on the mount
        *           target's file system. </p>
        *             </li>
        *             <li>
        *                <p>
        *                   <code>ec2:ModifyNetworkInterfaceAttribute</code> action on the mount target's network
        *           interface. </p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, ModifyMountTargetSecurityGroupsCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, ModifyMountTargetSecurityGroupsCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new ModifyMountTargetSecurityGroupsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ModifyMountTargetSecurityGroupsCommandInput} for command's `input` shape.
        * @see {@link ModifyMountTargetSecurityGroupsCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class ModifyMountTargetSecurityGroupsCommand extends $Command<ModifyMountTargetSecurityGroupsCommandInput, ModifyMountTargetSecurityGroupsCommandOutput, EFSClientResolvedConfig> {
            readonly input: ModifyMountTargetSecurityGroupsCommandInput;
            constructor(input: ModifyMountTargetSecurityGroupsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ModifyMountTargetSecurityGroupsCommandInput, ModifyMountTargetSecurityGroupsCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/PutAccountPreferencesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { PutAccountPreferencesRequest, PutAccountPreferencesResponse } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface PutAccountPreferencesCommandInput extends PutAccountPreferencesRequest {
    }
    export interface PutAccountPreferencesCommandOutput extends PutAccountPreferencesResponse, __MetadataBearer {
    }
    /**
        * <p>Use this operation to set the account preference in the current Amazon Web Services Region
        *       to use long 17 character (63 bit) or short 8 character (32 bit) resource IDs for
        *       new EFS file system and mount target resources. All existing resource IDs are not affected
        *       by any changes you make. You can set the ID preference during the
        *       opt-in period as EFS transitions to long resource IDs. For more information,
        *       see <a href="https://docs.aws.amazon.com/efs/latest/ug/manage-efs-resource-ids.html">Managing Amazon EFS resource IDs</a>.</p>
        *          <note>
        *             <p>Starting in October, 2021, you will receive an error if you try to set the account preference
        *         to use the short 8 character format resource ID. Contact Amazon Web Services support if you
        *         receive an error and must use short IDs for file system and mount target resources.</p>
        *          </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, PutAccountPreferencesCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, PutAccountPreferencesCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new PutAccountPreferencesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutAccountPreferencesCommandInput} for command's `input` shape.
        * @see {@link PutAccountPreferencesCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class PutAccountPreferencesCommand extends $Command<PutAccountPreferencesCommandInput, PutAccountPreferencesCommandOutput, EFSClientResolvedConfig> {
            readonly input: PutAccountPreferencesCommandInput;
            constructor(input: PutAccountPreferencesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutAccountPreferencesCommandInput, PutAccountPreferencesCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/PutBackupPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { BackupPolicyDescription, PutBackupPolicyRequest } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface PutBackupPolicyCommandInput extends PutBackupPolicyRequest {
    }
    export interface PutBackupPolicyCommandOutput extends BackupPolicyDescription, __MetadataBearer {
    }
    /**
        * <p>Updates the file system's backup policy. Use this action to start or stop automatic backups of the file system. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, PutBackupPolicyCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, PutBackupPolicyCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new PutBackupPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutBackupPolicyCommandInput} for command's `input` shape.
        * @see {@link PutBackupPolicyCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class PutBackupPolicyCommand extends $Command<PutBackupPolicyCommandInput, PutBackupPolicyCommandOutput, EFSClientResolvedConfig> {
            readonly input: PutBackupPolicyCommandInput;
            constructor(input: PutBackupPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutBackupPolicyCommandInput, PutBackupPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/PutFileSystemPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { FileSystemPolicyDescription, PutFileSystemPolicyRequest } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface PutFileSystemPolicyCommandInput extends PutFileSystemPolicyRequest {
    }
    export interface PutFileSystemPolicyCommandOutput extends FileSystemPolicyDescription, __MetadataBearer {
    }
    /**
        * <p>Applies an Amazon EFS <code>FileSystemPolicy</code> to an Amazon EFS file system.
        *       A file system policy is an IAM resource-based policy and can contain multiple policy statements.
        *       A file system always has exactly one file system policy, which can be the default policy or
        *       an explicit policy set or updated using this API operation.
        *       EFS file system policies have a 20,000 character limit.
        *       When an explicit policy is set, it overrides the default policy. For more information about the default file system policy, see
        *       <a href="https://docs.aws.amazon.com/efs/latest/ug/iam-access-control-nfs-efs.html#default-filesystempolicy">Default EFS File System Policy</a>.
        *     </p>
        *          <note>
        *             <p>EFS file system policies have a 20,000 character limit.</p>
        *          </note>
        *          <p>This operation requires permissions for the <code>elasticfilesystem:PutFileSystemPolicy</code> action.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, PutFileSystemPolicyCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, PutFileSystemPolicyCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new PutFileSystemPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutFileSystemPolicyCommandInput} for command's `input` shape.
        * @see {@link PutFileSystemPolicyCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class PutFileSystemPolicyCommand extends $Command<PutFileSystemPolicyCommandInput, PutFileSystemPolicyCommandOutput, EFSClientResolvedConfig> {
            readonly input: PutFileSystemPolicyCommandInput;
            constructor(input: PutFileSystemPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutFileSystemPolicyCommandInput, PutFileSystemPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/PutLifecycleConfigurationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { LifecycleConfigurationDescription, PutLifecycleConfigurationRequest } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface PutLifecycleConfigurationCommandInput extends PutLifecycleConfigurationRequest {
    }
    export interface PutLifecycleConfigurationCommandOutput extends LifecycleConfigurationDescription, __MetadataBearer {
    }
    /**
        * <p>Use this action to manage EFS lifecycle management and intelligent tiering. A
        *       <code>LifecycleConfiguration</code> consists of one or more <code>LifecyclePolicy</code> objects that
        *       define the following:</p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <b>EFS Lifecycle management</b> - When Amazon EFS
        *         automatically transitions files in a file system into the lower-cost Infrequent Access (IA) storage class.</p>
        *                <p>To enable EFS Lifecycle management, set the value of <code>TransitionToIA</code> to one of the available options.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <b>EFS Intelligent tiering</b> - When Amazon EFS
        *         automatically transitions files from IA back into the file system's primary storage class (Standard or One Zone Standard.</p>
        *                <p>To enable EFS Intelligent Tiering, set the value of <code>TransitionToPrimaryStorageClass</code> to <code>AFTER_1_ACCESS</code>.</p>
        *             </li>
        *          </ul>
        *
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/lifecycle-management-efs.html">EFS Lifecycle Management</a>.</p>
        *          <p>Each Amazon EFS file system supports one lifecycle configuration, which applies to all files in the file system. If a
        *         <code>LifecycleConfiguration</code> object already exists for the specified file system, a
        *         <code>PutLifecycleConfiguration</code> call modifies the existing configuration. A
        *         <code>PutLifecycleConfiguration</code> call with an empty <code>LifecyclePolicies</code>
        *       array in the request body deletes any existing <code>LifecycleConfiguration</code> and
        *       turns off lifecycle management and intelligent tiering for the file system.</p>
        *          <p>In the request, specify the following: </p>
        *          <ul>
        *             <li>
        *                <p>The ID for the file system for which you are enabling, disabling, or modifying lifecycle management
        *           and intelligent tiering.</p>
        *             </li>
        *             <li>
        *                <p>A <code>LifecyclePolicies</code> array of <code>LifecyclePolicy</code> objects that
        *           define when files are moved into IA storage, and when they are moved back to Standard storage.</p>
        *                <note>
        *                   <p>Amazon EFS requires that each <code>LifecyclePolicy</code>
        *           object have only have a single transition, so the <code>LifecyclePolicies</code> array needs to be structured with separate
        *           <code>LifecyclePolicy</code> objects. See the example requests in the following section for more information.</p>
        *                </note>
        *             </li>
        *          </ul>
        *
        *          <p>This operation requires permissions for the <code>elasticfilesystem:PutLifecycleConfiguration</code> operation.</p>
        *          <p>To apply a <code>LifecycleConfiguration</code> object to an encrypted file system, you
        *       need the same Key Management Service permissions as when you created the encrypted file system.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, PutLifecycleConfigurationCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, PutLifecycleConfigurationCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new PutLifecycleConfigurationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutLifecycleConfigurationCommandInput} for command's `input` shape.
        * @see {@link PutLifecycleConfigurationCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class PutLifecycleConfigurationCommand extends $Command<PutLifecycleConfigurationCommandInput, PutLifecycleConfigurationCommandOutput, EFSClientResolvedConfig> {
            readonly input: PutLifecycleConfigurationCommandInput;
            constructor(input: PutLifecycleConfigurationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutLifecycleConfigurationCommandInput, PutLifecycleConfigurationCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/TagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { TagResourceRequest } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface TagResourceCommandInput extends TagResourceRequest {
    }
    export interface TagResourceCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Creates a tag for an EFS resource. You can create tags for EFS file systems and access points using this API operation.</p>
        *          <p>This operation requires permissions for the <code>elasticfilesystem:TagResource</code> action.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, TagResourceCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, TagResourceCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new TagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TagResourceCommandInput} for command's `input` shape.
        * @see {@link TagResourceCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class TagResourceCommand extends $Command<TagResourceCommandInput, TagResourceCommandOutput, EFSClientResolvedConfig> {
            readonly input: TagResourceCommandInput;
            constructor(input: TagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TagResourceCommandInput, TagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/UntagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { UntagResourceRequest } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface UntagResourceCommandInput extends UntagResourceRequest {
    }
    export interface UntagResourceCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Removes tags from an EFS resource. You can remove tags from EFS file systems and access points using this API operation.</p>
        *          <p>This operation requires permissions for the <code>elasticfilesystem:UntagResource</code> action.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, UntagResourceCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, UntagResourceCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new UntagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UntagResourceCommandInput} for command's `input` shape.
        * @see {@link UntagResourceCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class UntagResourceCommand extends $Command<UntagResourceCommandInput, UntagResourceCommandOutput, EFSClientResolvedConfig> {
            readonly input: UntagResourceCommandInput;
            constructor(input: UntagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UntagResourceCommandInput, UntagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/UpdateFileSystemCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EFSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient";
    import { FileSystemDescription, UpdateFileSystemRequest } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0";
    export interface UpdateFileSystemCommandInput extends UpdateFileSystemRequest {
    }
    export interface UpdateFileSystemCommandOutput extends FileSystemDescription, __MetadataBearer {
    }
    /**
        * <p>Updates the throughput mode or the amount of provisioned throughput of an existing file
        *       system.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EFSClient, UpdateFileSystemCommand } from "@aws-sdk/client-efs"; // ES Modules import
        * // const { EFSClient, UpdateFileSystemCommand } = require("@aws-sdk/client-efs"); // CommonJS import
        * const client = new EFSClient(config);
        * const command = new UpdateFileSystemCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateFileSystemCommandInput} for command's `input` shape.
        * @see {@link UpdateFileSystemCommandOutput} for command's `response` shape.
        * @see {@link EFSClientResolvedConfig | config} for EFSClient's `config` shape.
        *
        */
    export class UpdateFileSystemCommand extends $Command<UpdateFileSystemCommandInput, UpdateFileSystemCommandOutput, EFSClientResolvedConfig> {
            readonly input: UpdateFileSystemCommandInput;
            constructor(input: UpdateFileSystemCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EFSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateFileSystemCommandInput, UpdateFileSystemCommandOutput>;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/EFSClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { CreateAccessPointCommandInput, CreateAccessPointCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/CreateAccessPointCommand";
    import { CreateFileSystemCommandInput, CreateFileSystemCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/CreateFileSystemCommand";
    import { CreateMountTargetCommandInput, CreateMountTargetCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/CreateMountTargetCommand";
    import { CreateReplicationConfigurationCommandInput, CreateReplicationConfigurationCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/CreateReplicationConfigurationCommand";
    import { CreateTagsCommandInput, CreateTagsCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/CreateTagsCommand";
    import { DeleteAccessPointCommandInput, DeleteAccessPointCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DeleteAccessPointCommand";
    import { DeleteFileSystemCommandInput, DeleteFileSystemCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DeleteFileSystemCommand";
    import { DeleteFileSystemPolicyCommandInput, DeleteFileSystemPolicyCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DeleteFileSystemPolicyCommand";
    import { DeleteMountTargetCommandInput, DeleteMountTargetCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DeleteMountTargetCommand";
    import { DeleteReplicationConfigurationCommandInput, DeleteReplicationConfigurationCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DeleteReplicationConfigurationCommand";
    import { DeleteTagsCommandInput, DeleteTagsCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DeleteTagsCommand";
    import { DescribeAccessPointsCommandInput, DescribeAccessPointsCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeAccessPointsCommand";
    import { DescribeAccountPreferencesCommandInput, DescribeAccountPreferencesCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeAccountPreferencesCommand";
    import { DescribeBackupPolicyCommandInput, DescribeBackupPolicyCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeBackupPolicyCommand";
    import { DescribeFileSystemPolicyCommandInput, DescribeFileSystemPolicyCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeFileSystemPolicyCommand";
    import { DescribeFileSystemsCommandInput, DescribeFileSystemsCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeFileSystemsCommand";
    import { DescribeLifecycleConfigurationCommandInput, DescribeLifecycleConfigurationCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeLifecycleConfigurationCommand";
    import { DescribeMountTargetsCommandInput, DescribeMountTargetsCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeMountTargetsCommand";
    import { DescribeMountTargetSecurityGroupsCommandInput, DescribeMountTargetSecurityGroupsCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeMountTargetSecurityGroupsCommand";
    import { DescribeReplicationConfigurationsCommandInput, DescribeReplicationConfigurationsCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeReplicationConfigurationsCommand";
    import { DescribeTagsCommandInput, DescribeTagsCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/DescribeTagsCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/ListTagsForResourceCommand";
    import { ModifyMountTargetSecurityGroupsCommandInput, ModifyMountTargetSecurityGroupsCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/ModifyMountTargetSecurityGroupsCommand";
    import { PutAccountPreferencesCommandInput, PutAccountPreferencesCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/PutAccountPreferencesCommand";
    import { PutBackupPolicyCommandInput, PutBackupPolicyCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/PutBackupPolicyCommand";
    import { PutFileSystemPolicyCommandInput, PutFileSystemPolicyCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/PutFileSystemPolicyCommand";
    import { PutLifecycleConfigurationCommandInput, PutLifecycleConfigurationCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/PutLifecycleConfigurationCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/UntagResourceCommand";
    import { UpdateFileSystemCommandInput, UpdateFileSystemCommandOutput } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/commands/UpdateFileSystemCommand";
    export type ServiceInputTypes = CreateAccessPointCommandInput | CreateFileSystemCommandInput | CreateMountTargetCommandInput | CreateReplicationConfigurationCommandInput | CreateTagsCommandInput | DeleteAccessPointCommandInput | DeleteFileSystemCommandInput | DeleteFileSystemPolicyCommandInput | DeleteMountTargetCommandInput | DeleteReplicationConfigurationCommandInput | DeleteTagsCommandInput | DescribeAccessPointsCommandInput | DescribeAccountPreferencesCommandInput | DescribeBackupPolicyCommandInput | DescribeFileSystemPolicyCommandInput | DescribeFileSystemsCommandInput | DescribeLifecycleConfigurationCommandInput | DescribeMountTargetSecurityGroupsCommandInput | DescribeMountTargetsCommandInput | DescribeReplicationConfigurationsCommandInput | DescribeTagsCommandInput | ListTagsForResourceCommandInput | ModifyMountTargetSecurityGroupsCommandInput | PutAccountPreferencesCommandInput | PutBackupPolicyCommandInput | PutFileSystemPolicyCommandInput | PutLifecycleConfigurationCommandInput | TagResourceCommandInput | UntagResourceCommandInput | UpdateFileSystemCommandInput;
    export type ServiceOutputTypes = CreateAccessPointCommandOutput | CreateFileSystemCommandOutput | CreateMountTargetCommandOutput | CreateReplicationConfigurationCommandOutput | CreateTagsCommandOutput | DeleteAccessPointCommandOutput | DeleteFileSystemCommandOutput | DeleteFileSystemPolicyCommandOutput | DeleteMountTargetCommandOutput | DeleteReplicationConfigurationCommandOutput | DeleteTagsCommandOutput | DescribeAccessPointsCommandOutput | DescribeAccountPreferencesCommandOutput | DescribeBackupPolicyCommandOutput | DescribeFileSystemPolicyCommandOutput | DescribeFileSystemsCommandOutput | DescribeLifecycleConfigurationCommandOutput | DescribeMountTargetSecurityGroupsCommandOutput | DescribeMountTargetsCommandOutput | DescribeReplicationConfigurationsCommandOutput | DescribeTagsCommandOutput | ListTagsForResourceCommandOutput | ModifyMountTargetSecurityGroupsCommandOutput | PutAccountPreferencesCommandOutput | PutBackupPolicyCommandOutput | PutFileSystemPolicyCommandOutput | PutLifecycleConfigurationCommandOutput | TagResourceCommandOutput | UntagResourceCommandOutput | UpdateFileSystemCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type EFSClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of EFSClient class constructor that set the region, credentials and other options.
        */
    export interface EFSClientConfig extends EFSClientConfigType {
    }
    type EFSClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of EFSClient class. This is resolved and normalized from the {@link EFSClientConfig | constructor configuration interface}.
        */
    export interface EFSClientResolvedConfig extends EFSClientResolvedConfigType {
    }
    /**
        * <fullname>Amazon Elastic File System</fullname>
        *          <p>Amazon Elastic File System (Amazon EFS) provides simple, scalable file storage for
        *       use with Amazon EC2 Linux and Mac instances in the Amazon Web Services Cloud. With Amazon EFS, storage capacity is elastic, growing and shrinking automatically as you add and
        *       remove files, so that your applications have the storage they need, when they need it. For
        *       more information, see the <a href="https://docs.aws.amazon.com/efs/latest/ug/api-reference.html">Amazon Elastic File System API Reference</a> and the <a href="https://docs.aws.amazon.com/efs/latest/ug/whatisefs.html">Amazon Elastic File System User Guide</a>.</p>
        */
    export class EFSClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, EFSClientResolvedConfig> {
            /**
                * The resolved configuration of EFSClient class. This is resolved and normalized from the {@link EFSClientConfig | constructor configuration interface}.
                */
            readonly config: EFSClientResolvedConfig;
            constructor(configuration: EFSClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { EFSServiceException as __BaseException } from "@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/EFSServiceException";
    /**
        * <p>Returned if the access point that you are trying to create already exists, with the
        *             creation token you provided in the request.</p>
        */
    export class AccessPointAlreadyExists extends __BaseException {
            readonly name: "AccessPointAlreadyExists";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            AccessPointId: string | undefined;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AccessPointAlreadyExists, __BaseException>);
    }
    export enum LifeCycleState {
            AVAILABLE = "available",
            CREATING = "creating",
            DELETED = "deleted",
            DELETING = "deleting",
            ERROR = "error",
            UPDATING = "updating"
    }
    /**
        * <p>The full POSIX identity, including the user ID, group ID, and any secondary group IDs, on the access point that is used for all file system operations performed by
        *       NFS clients using the access point.</p>
        */
    export interface PosixUser {
            /**
                * <p>The POSIX user ID used for all file system operations using this access point.</p>
                */
            Uid: number | undefined;
            /**
                * <p>The POSIX group ID used for all file system operations using this access point.</p>
                */
            Gid: number | undefined;
            /**
                * <p>Secondary POSIX group IDs used for all file system operations using this access point.</p>
                */
            SecondaryGids?: number[];
    }
    export namespace PosixUser {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PosixUser) => any;
    }
    /**
        * <p>Required if the <code>RootDirectory</code> > <code>Path</code> specified does not exist.
        *       Specifies the POSIX IDs and permissions to apply to the access point's <code>RootDirectory</code> > <code>Path</code>.
        *       If the access point root directory does not exist, EFS creates it with these settings when a client connects to the access point.
        *       When specifying <code>CreationInfo</code>, you must include values for all properties.
        *    </p>
        *          <p>Amazon EFS creates a root directory only if you have provided the  CreationInfo: OwnUid, OwnGID, and permissions for the directory.
        *       If  you do not provide this information, Amazon EFS does not create the root directory. If the root directory does not exist, attempts to mount
        *       using the access point will fail.</p>
        *          <important>
        *             <p>If you do not provide <code>CreationInfo</code> and the specified <code>RootDirectory</code> does not exist,
        *       attempts to mount the file system using the access point will fail.</p>
        *          </important>
        */
    export interface CreationInfo {
            /**
                * <p>Specifies the POSIX user ID to apply to the <code>RootDirectory</code>. Accepts values from 0 to 2^32 (4294967295).</p>
                */
            OwnerUid: number | undefined;
            /**
                * <p>Specifies the POSIX group ID to apply to the <code>RootDirectory</code>. Accepts values from 0 to 2^32 (4294967295).</p>
                */
            OwnerGid: number | undefined;
            /**
                * <p>Specifies the POSIX permissions to apply to the <code>RootDirectory</code>, in the format of an octal number representing the file's mode bits.</p>
                */
            Permissions: string | undefined;
    }
    export namespace CreationInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreationInfo) => any;
    }
    /**
        * <p>Specifies the directory on the Amazon EFS file system that the access point provides access to.
        *       The access point exposes the specified file system path as
        *       the root directory of your file system to applications using the access point.
        *       NFS clients using the access point can only access data in the access point's <code>RootDirectory</code> and it's subdirectories.</p>
        */
    export interface RootDirectory {
            /**
                * <p>Specifies the path on the EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system.
                *        A path can have up to four subdirectories.
                *     If the specified path does not exist, you are required to provide the <code>CreationInfo</code>.</p>
                */
            Path?: string;
            /**
                * <p>(Optional) Specifies the POSIX IDs and permissions to apply to the access point's <code>RootDirectory</code>.
                *       If the <code>RootDirectory</code> > <code>Path</code> specified does not exist,
                *       EFS creates the root directory using the <code>CreationInfo</code> settings when a client connects to an access point.
                *       When specifying the <code>CreationInfo</code>, you must provide values for all properties.
                *     </p>
                *          <important>
                *             <p>If you do not provide <code>CreationInfo</code> and the specified <code>RootDirectory</code> > <code>Path</code> does not exist,
                *       attempts to mount the file system using the access point will fail.</p>
                *          </important>
                */
            CreationInfo?: CreationInfo;
    }
    export namespace RootDirectory {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RootDirectory) => any;
    }
    /**
        * <p>A tag is a key-value pair. Allowed characters are letters, white space, and numbers that
        *       can be represented in UTF-8, and the following characters:<code> + - = . _ : /</code>.</p>
        */
    export interface Tag {
            /**
                * <p>The tag key (String). The key can't start with <code>aws:</code>.</p>
                */
            Key: string | undefined;
            /**
                * <p>The value of the tag key.</p>
                */
            Value: string | undefined;
    }
    export namespace Tag {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Tag) => any;
    }
    /**
        * <p>Provides a description of an EFS file system access point.</p>
        */
    export interface AccessPointDescription {
            /**
                * <p>The opaque string specified in the request to ensure idempotent creation.</p>
                */
            ClientToken?: string;
            /**
                * <p>The name of the access point. This is the value of the <code>Name</code> tag.</p>
                */
            Name?: string;
            /**
                * <p>The tags associated with the access point, presented as an array of Tag objects.</p>
                */
            Tags?: Tag[];
            /**
                * <p>The ID of the access point, assigned by Amazon EFS.</p>
                */
            AccessPointId?: string;
            /**
                * <p>The  unique Amazon Resource Name (ARN) associated with the access point.</p>
                */
            AccessPointArn?: string;
            /**
                * <p>The ID of the EFS file system that the access point applies to.</p>
                */
            FileSystemId?: string;
            /**
                * <p>The full POSIX identity, including the user ID, group ID, and secondary group IDs on the access point that is used for all file operations by
                *       NFS clients using the access point.</p>
                */
            PosixUser?: PosixUser;
            /**
                * <p>The directory on the Amazon EFS file system that the access point exposes as the root directory to NFS clients using the access point.</p>
                */
            RootDirectory?: RootDirectory;
            /**
                * <p>Identified the Amazon Web Services account that owns the access point resource.</p>
                */
            OwnerId?: string;
            /**
                * <p>Identifies the lifecycle phase of the access point.</p>
                */
            LifeCycleState?: LifeCycleState | string;
    }
    export namespace AccessPointDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AccessPointDescription) => any;
    }
    /**
        * <p>Returned if the Amazon Web Services account has already created the maximum number of access points
        *             allowed per file system. For more informaton, see <a href="https://docs.aws.amazon.com/efs/latest/ug/limits.html#limits-efs-resources-per-account-per-region">https://docs.aws.amazon.com/efs/latest/ug/limits.html#limits-efs-resources-per-account-per-region</a>.</p>
        */
    export class AccessPointLimitExceeded extends __BaseException {
            readonly name: "AccessPointLimitExceeded";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AccessPointLimitExceeded, __BaseException>);
    }
    /**
        * <p>Returned if the specified <code>AccessPointId</code> value doesn't exist in the
        *             requester's Amazon Web Services account.</p>
        */
    export class AccessPointNotFound extends __BaseException {
            readonly name: "AccessPointNotFound";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AccessPointNotFound, __BaseException>);
    }
    /**
        * <p>Returned if the Availability Zone that was specified for a mount target is
        *             different from the Availability Zone that was specified for One Zone storage.
        *             For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/availability-durability.html">Regional and One Zone storage redundancy</a>.</p>
        */
    export class AvailabilityZonesMismatch extends __BaseException {
            readonly name: "AvailabilityZonesMismatch";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode?: string;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AvailabilityZonesMismatch, __BaseException>);
    }
    export enum Status {
            DISABLED = "DISABLED",
            DISABLING = "DISABLING",
            ENABLED = "ENABLED",
            ENABLING = "ENABLING"
    }
    /**
        * <p>The backup policy for the file system used to create automatic daily backups. If status has a value of
        *       <code>ENABLED</code>, the file system is being automatically backed up. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/awsbackup.html#automatic-backups">Automatic backups</a>.</p>
        */
    export interface BackupPolicy {
            /**
                * <p>Describes the status of the file system's backup policy.</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <b>
                *                      <code>ENABLED</code>
                *                   </b> - EFS is automatically backing up the file system.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>
                *                      <code>ENABLING</code>
                *                   </b> - EFS is turning on automatic backups for the file system.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>
                *                      <code>DISABLED</code>
                *                   </b> - Automatic back ups are turned off for
                *           the file system.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>
                *                      <code>DISABLING</code>
                *                   </b> - EFS is turning off automatic backups for the file system.</p>
                *             </li>
                *          </ul>
                */
            Status: Status | string | undefined;
    }
    export namespace BackupPolicy {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BackupPolicy) => any;
    }
    export interface BackupPolicyDescription {
            /**
                * <p>Describes the file system's backup policy, indicating whether automatic backups are
                *       turned on or off.</p>
                */
            BackupPolicy?: BackupPolicy;
    }
    export namespace BackupPolicyDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BackupPolicyDescription) => any;
    }
    /**
        * <p>Returned if the request is malformed or contains an error such as an invalid
        *             parameter value or a missing required parameter.</p>
        */
    export class BadRequest extends __BaseException {
            readonly name: "BadRequest";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<BadRequest, __BaseException>);
    }
    export interface CreateAccessPointRequest {
            /**
                * <p>A string of up to 64 ASCII characters that Amazon EFS uses to ensure idempotent
                *       creation.</p>
                */
            ClientToken?: string;
            /**
                * <p>Creates tags associated with the access point. Each tag is a key-value pair, each key must be unique. For more
                *       information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a>
                *       in the <i>Amazon Web Services General Reference Guide</i>.</p>
                */
            Tags?: Tag[];
            /**
                * <p>The ID of the EFS file system that the access point provides access to.</p>
                */
            FileSystemId: string | undefined;
            /**
                * <p>The operating system user and
                *       group applied to all file system requests made using the access point.</p>
                */
            PosixUser?: PosixUser;
            /**
                * <p>Specifies the directory on the Amazon EFS file system that the access point
                *       exposes as the root directory of your file system to NFS clients using the access point. The
                *       clients using the access point can only access the root directory and below. If the
                *         <code>RootDirectory</code> > <code>Path</code> specified does not exist, EFS creates it
                *       and applies the <code>CreationInfo</code> settings when a client connects to an access point.
                *       When specifying a <code>RootDirectory</code>, you must provide the <code>Path</code>, and the
                *         <code>CreationInfo</code>.</p>
                *          <p>Amazon EFS creates a root directory only if you have provided the  CreationInfo: OwnUid, OwnGID, and permissions for the directory.
                *       If  you do not provide this information, Amazon EFS does not create the root directory. If the root directory does not exist, attempts to mount
                *       using the access point will fail.</p>
                */
            RootDirectory?: RootDirectory;
    }
    export namespace CreateAccessPointRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateAccessPointRequest) => any;
    }
    /**
        * <p>Returned if the specified <code>FileSystemId</code> value doesn't exist in the
        *             requester's Amazon Web Services account.</p>
        */
    export class FileSystemNotFound extends __BaseException {
            readonly name: "FileSystemNotFound";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<FileSystemNotFound, __BaseException>);
    }
    /**
        * <p>Returned if the file system's lifecycle state is not "available".</p>
        */
    export class IncorrectFileSystemLifeCycleState extends __BaseException {
            readonly name: "IncorrectFileSystemLifeCycleState";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<IncorrectFileSystemLifeCycleState, __BaseException>);
    }
    /**
        * <p>Returned if an error occurred on the server side.</p>
        */
    export class InternalServerError extends __BaseException {
            readonly name: "InternalServerError";
            readonly $fault: "server";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InternalServerError, __BaseException>);
    }
    /**
        * <p>Returned when the <code>CreateAccessPoint</code> API action is called too quickly and
        *             the number of Access Points in the account is nearing the limit of 120.</p>
        */
    export class ThrottlingException extends __BaseException {
            readonly name: "ThrottlingException";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode?: string;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ThrottlingException, __BaseException>);
    }
    export enum PerformanceMode {
            GENERAL_PURPOSE = "generalPurpose",
            MAX_IO = "maxIO"
    }
    export enum ThroughputMode {
            BURSTING = "bursting",
            PROVISIONED = "provisioned"
    }
    export interface CreateFileSystemRequest {
            /**
                * <p>A string of up to 64 ASCII characters. Amazon EFS uses this to ensure idempotent
                *       creation.</p>
                */
            CreationToken?: string;
            /**
                * <p>The performance mode of the file system. We recommend <code>generalPurpose</code>
                *       performance mode for most file systems. File systems using the <code>maxIO</code> performance
                *       mode can scale to higher levels of aggregate throughput and operations per second with a
                *       tradeoff of slightly higher latencies for most file operations. The performance mode
                *       can't be changed after the file system has been created.</p>
                *          <note>
                *             <p>The <code>maxIO</code> mode is not supported on file systems using One Zone storage classes.</p>
                *          </note>
                */
            PerformanceMode?: PerformanceMode | string;
            /**
                * <p>A Boolean value that, if true, creates an encrypted file system. When creating an
                *       encrypted file system, you have the option of specifying an existing Key Management Service key (KMS key).
                *       If you don't specify a KMS key, then the default KMS key for
                *       Amazon EFS, <code>/aws/elasticfilesystem</code>, is used to protect the encrypted file system.
                *     </p>
                */
            Encrypted?: boolean;
            /**
                * <p>The ID of the KMS key that you want to use to protect the encrypted file
                *       system. This parameter is required only if you want to use a non-default KMS key. If this parameter is not specified, the default KMS key for Amazon EFS is used. You can specify a KMS key ID using the following
                *       formats:</p>
                *          <ul>
                *             <li>
                *                <p>Key ID - A unique identifier of the key, for example
                *             <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p>
                *             </li>
                *             <li>
                *                <p>ARN - An Amazon Resource Name (ARN) for the key, for example
                *             <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p>
                *             </li>
                *             <li>
                *                <p>Key alias - A previously created display name for a key, for example
                *             <code>alias/projectKey1</code>.</p>
                *             </li>
                *             <li>
                *                <p>Key alias ARN - An ARN for a key alias, for example
                *             <code>arn:aws:kms:us-west-2:444455556666:alias/projectKey1</code>.</p>
                *             </li>
                *          </ul>
                *          <p>If you use <code>KmsKeyId</code>, you must set the <a>CreateFileSystemRequest$Encrypted</a>
                *       parameter to true.</p>
                *          <important>
                *             <p>EFS accepts only symmetric KMS keys. You cannot use asymmetric
                *       KMS keys with Amazon EFS file systems.</p>
                *          </important>
                */
            KmsKeyId?: string;
            /**
                * <p>Specifies the throughput mode for the file system, either <code>bursting</code> or
                *         <code>provisioned</code>. If you set <code>ThroughputMode</code> to
                *       <code>provisioned</code>, you must also set a value for
                *         <code>ProvisionedThroughputInMibps</code>. After you create the file system, you can
                *       decrease your file system's throughput in Provisioned Throughput mode or change between
                *       the throughput modes, as long as it’s been more than 24 hours since the last decrease or
                *       throughput mode change. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/performance.html#provisioned-throughput">Specifying throughput with
                *         provisioned mode</a> in the <i>Amazon EFS User Guide</i>. </p>
                *          <p>Default is <code>bursting</code>.</p>
                */
            ThroughputMode?: ThroughputMode | string;
            /**
                * <p>The throughput, measured in MiB/s, that you want to provision for a file system that
                *       you're creating. Valid values are 1-1024. Required if <code>ThroughputMode</code> is set
                *       to <code>provisioned</code>. The upper limit for throughput is 1024 MiB/s. To increase this
                *       limit, contact Amazon Web Services Support. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/limits.html#soft-limits">Amazon EFS quotas that you can increase</a>
                *       in the <i>Amazon EFS User Guide</i>.</p>
                */
            ProvisionedThroughputInMibps?: number;
            /**
                * <p>Used to create a file system that uses One Zone storage classes. It specifies the Amazon Web Services
                *       Availability Zone in which to create the file system. Use the format <code>us-east-1a</code>
                *       to specify the Availability Zone. For
                *       more information about One Zone storage classes, see <a href="https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html">Using EFS storage classes</a> in the <i>Amazon EFS User Guide</i>.</p>
                *          <note>
                *             <p>One Zone storage classes are not available in all Availability Zones in Amazon Web Services Regions where
                *         Amazon EFS is available.</p>
                *          </note>
                */
            AvailabilityZoneName?: string;
            /**
                * <p>Specifies whether automatic backups are enabled on the file system that you are creating.
                *       Set the value to <code>true</code> to enable automatic backups. If you are creating a file
                *       system that uses One Zone storage classes, automatic backups are enabled by default. For more
                *       information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/awsbackup.html#automatic-backups">Automatic backups</a> in the
                *         <i>Amazon EFS User Guide</i>.</p>
                *          <p>Default is <code>false</code>. However, if you specify an <code>AvailabilityZoneName</code>,
                *       the default is <code>true</code>.</p>
                *          <note>
                *             <p>Backup is not available in all Amazon Web Services Regions where Amazon EFS is available.</p>
                *          </note>
                */
            Backup?: boolean;
            /**
                * <p>Use to create one or more tags associated with the file system. Each
                *         tag is a user-defined key-value pair. Name your file system on creation by including a
                *         <code>"Key":"Name","Value":"{value}"</code> key-value pair. Each key must be unique. For more
                *         information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a>
                *         in the <i>Amazon Web Services General Reference Guide</i>.</p>
                */
            Tags?: Tag[];
    }
    export namespace CreateFileSystemRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateFileSystemRequest) => any;
    }
    /**
        * <p>Returned if the file system you are trying to create already exists, with the
        *             creation token you provided.</p>
        */
    export class FileSystemAlreadyExists extends __BaseException {
            readonly name: "FileSystemAlreadyExists";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            FileSystemId: string | undefined;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<FileSystemAlreadyExists, __BaseException>);
    }
    /**
        * <p>The latest known metered size (in bytes) of data stored in the file system, in its
        *         <code>Value</code> field, and the time at which that size was determined in its
        *         <code>Timestamp</code> field. The value doesn't represent the size of a consistent
        *       snapshot of the file system, but it is eventually consistent when there are no writes to the
        *       file system. That is, the value represents the actual size only if the file system is not
        *       modified for a period longer than a couple of hours. Otherwise, the value is not necessarily
        *       the exact size the file system was at any instant in time.</p>
        */
    export interface FileSystemSize {
            /**
                * <p>The latest known metered size (in bytes) of data stored in the file system.</p>
                */
            Value: number | undefined;
            /**
                * <p>The time at which the size of data, returned in the <code>Value</code> field, was
                *       determined. The value is the integer number of seconds since 1970-01-01T00:00:00Z.</p>
                */
            Timestamp?: Date;
            /**
                * <p>The latest known metered size (in bytes) of data stored in the Infrequent Access
                *       storage class.</p>
                */
            ValueInIA?: number;
            /**
                * <p>The latest known metered size (in bytes) of data stored in the Standard storage
                *       class.</p>
                */
            ValueInStandard?: number;
    }
    export namespace FileSystemSize {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FileSystemSize) => any;
    }
    /**
        * <p>A description of the file system.</p>
        */
    export interface FileSystemDescription {
            /**
                * <p>The Amazon Web Services account that created the file system. If the file system was created by an IAM
                *       user, the parent account to which the user belongs is the owner.</p>
                */
            OwnerId: string | undefined;
            /**
                * <p>The opaque string specified in the request.</p>
                */
            CreationToken: string | undefined;
            /**
                * <p>The ID of the file system, assigned by Amazon EFS.</p>
                */
            FileSystemId: string | undefined;
            /**
                * <p>The Amazon Resource Name (ARN) for the EFS file system, in the format
                *       <code>arn:aws:elasticfilesystem:<i>region</i>:<i>account-id</i>:file-system/<i>file-system-id</i>
                *             </code>.
                *       Example with sample data: <code>arn:aws:elasticfilesystem:us-west-2:1111333322228888:file-system/fs-01234567</code>
                *          </p>
                */
            FileSystemArn?: string;
            /**
                * <p>The time that the file system was created, in seconds (since
                *       1970-01-01T00:00:00Z).</p>
                */
            CreationTime: Date | undefined;
            /**
                * <p>The lifecycle phase of the file system.</p>
                */
            LifeCycleState: LifeCycleState | string | undefined;
            /**
                * <p>You can add tags to a file system, including a <code>Name</code> tag. For more
                *       information, see <a>CreateFileSystem</a>. If the file system has a <code>Name</code> tag, Amazon EFS returns
                *       the value in this field. </p>
                */
            Name?: string;
            /**
                * <p>The current number of mount targets that the file system has. For more information, see <a>CreateMountTarget</a>.</p>
                */
            NumberOfMountTargets: number | undefined;
            /**
                * <p>The latest known metered size (in bytes) of data stored in the file system, in its
                *         <code>Value</code> field, and the time at which that size was determined in its
                *         <code>Timestamp</code> field. The <code>Timestamp</code> value is the integer number of
                *       seconds since 1970-01-01T00:00:00Z. The <code>SizeInBytes</code> value doesn't represent
                *       the size of a consistent snapshot of the file system, but it is eventually consistent when
                *       there are no writes to the file system. That is, <code>SizeInBytes</code> represents actual
                *       size only if the file system is not modified for a period longer than a couple of hours.
                *       Otherwise, the value is not the exact size that the file system was at any point in time.
                *     </p>
                */
            SizeInBytes: FileSystemSize | undefined;
            /**
                * <p>The performance mode of the file system.</p>
                */
            PerformanceMode: PerformanceMode | string | undefined;
            /**
                * <p>A Boolean value that, if true, indicates that the file system is encrypted.</p>
                */
            Encrypted?: boolean;
            /**
                * <p>The ID of an KMS key used to protect the encrypted file system.</p>
                */
            KmsKeyId?: string;
            /**
                * <p>Displays the file system's throughput mode. For more information, see
                *       <a href="https://docs.aws.amazon.com/efs/latest/ug/performance.html#throughput-modes">Throughput modes</a>
                *       in the <i>Amazon EFS User Guide</i>.
                *     </p>
                */
            ThroughputMode?: ThroughputMode | string;
            /**
                * <p>The amount of provisioned throughput, measured in MiB/s, for the file system. Valid for
                *       file systems using <code>ThroughputMode</code> set to <code>provisioned</code>.</p>
                */
            ProvisionedThroughputInMibps?: number;
            /**
                * <p>Describes the Amazon Web Services Availability Zone in which the file system is located, and is valid only
                *       for file systems using One Zone storage classes. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html">Using EFS storage classes</a>
                *       in the <i>Amazon EFS User Guide</i>.</p>
                */
            AvailabilityZoneName?: string;
            /**
                * <p>The unique and consistent identifier of the Availability Zone in which the file system's
                *       One Zone storage classes exist. For example, <code>use1-az1</code> is an Availability Zone ID
                *       for the us-east-1 Amazon Web Services Region, and it has the same location in every Amazon Web Services account.</p>
                */
            AvailabilityZoneId?: string;
            /**
                * <p>The tags associated with the file system, presented as an array of <code>Tag</code>
                *       objects.</p>
                */
            Tags: Tag[] | undefined;
    }
    export namespace FileSystemDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FileSystemDescription) => any;
    }
    /**
        * <p>Returned if the Amazon Web Services account has already created the maximum number of file systems
        *             allowed per account.</p>
        */
    export class FileSystemLimitExceeded extends __BaseException {
            readonly name: "FileSystemLimitExceeded";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<FileSystemLimitExceeded, __BaseException>);
    }
    /**
        * <p>Returned if there's not enough capacity to provision additional throughput. This value
        *             might be returned when you try to create a file system in provisioned throughput mode,
        *             when you attempt to increase the provisioned throughput of an existing file system, or
        *             when you attempt to change an existing file system from Bursting Throughput to
        *             Provisioned Throughput mode. Try again later.</p>
        */
    export class InsufficientThroughputCapacity extends __BaseException {
            readonly name: "InsufficientThroughputCapacity";
            readonly $fault: "server";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InsufficientThroughputCapacity, __BaseException>);
    }
    /**
        * <p>Returned if the throughput mode or amount of provisioned throughput can't be changed
        *             because the throughput limit of 1024 MiB/s has been reached.</p>
        */
    export class ThroughputLimitExceeded extends __BaseException {
            readonly name: "ThroughputLimitExceeded";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ThroughputLimitExceeded, __BaseException>);
    }
    /**
        * <p>Returned if the requested Amazon EFS functionality is not available in the specified Availability Zone.</p>
        */
    export class UnsupportedAvailabilityZone extends __BaseException {
            readonly name: "UnsupportedAvailabilityZone";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UnsupportedAvailabilityZone, __BaseException>);
    }
    /**
        * <p></p>
        */
    export interface CreateMountTargetRequest {
            /**
                * <p>The ID of the file system for which to create the mount target.</p>
                */
            FileSystemId: string | undefined;
            /**
                * <p>The ID of the subnet to add the mount target in. For file systems that use One Zone storage classes, use the subnet
                *     that is associated with the file system's Availability Zone.</p>
                */
            SubnetId: string | undefined;
            /**
                * <p>Valid IPv4 address within the address range of the specified subnet.</p>
                */
            IpAddress?: string;
            /**
                * <p>Up to five VPC security group IDs, of the form <code>sg-xxxxxxxx</code>. These must be
                *       for the same VPC as subnet specified.</p>
                */
            SecurityGroups?: string[];
    }
    export namespace CreateMountTargetRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateMountTargetRequest) => any;
    }
    /**
        * <p>Returned if the request specified an <code>IpAddress</code> that is already in use
        *             in the subnet.</p>
        */
    export class IpAddressInUse extends __BaseException {
            readonly name: "IpAddressInUse";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<IpAddressInUse, __BaseException>);
    }
    /**
        * <p>Returned if the mount target would violate one of the specified restrictions based
        *             on the file system's existing mount targets.</p>
        */
    export class MountTargetConflict extends __BaseException {
            readonly name: "MountTargetConflict";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<MountTargetConflict, __BaseException>);
    }
    /**
        * <p>Provides a description of a mount target.</p>
        */
    export interface MountTargetDescription {
            /**
                * <p>Amazon Web Services account ID that owns the resource.</p>
                */
            OwnerId?: string;
            /**
                * <p>System-assigned mount target ID.</p>
                */
            MountTargetId: string | undefined;
            /**
                * <p>The ID of the file system for which the mount target is intended.</p>
                */
            FileSystemId: string | undefined;
            /**
                * <p>The ID of the mount target's subnet.</p>
                */
            SubnetId: string | undefined;
            /**
                * <p>Lifecycle state of the mount target.</p>
                */
            LifeCycleState: LifeCycleState | string | undefined;
            /**
                * <p>Address at which the file system can be mounted by using the mount target.</p>
                */
            IpAddress?: string;
            /**
                * <p>The ID of the network interface that Amazon EFS created when it created the mount
                *       target.</p>
                */
            NetworkInterfaceId?: string;
            /**
                * <p>The unique and consistent identifier of the Availability Zone that the mount target resides in.
                *       For example, <code>use1-az1</code> is an AZ ID for the us-east-1 Region and it has the same location in every Amazon Web Services account.</p>
                */
            AvailabilityZoneId?: string;
            /**
                * <p>The name of the Availability Zone in which the mount target is located. Availability Zones are
                *       independently mapped to names for each Amazon Web Services account. For example, the Availability Zone
                *       <code>us-east-1a</code> for your Amazon Web Services account might not be the same location as <code>us-east-1a</code> for another Amazon Web Services account.</p>
                */
            AvailabilityZoneName?: string;
            /**
                * <p>The virtual private cloud (VPC) ID that the mount target is configured in.</p>
                */
            VpcId?: string;
    }
    export namespace MountTargetDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: MountTargetDescription) => any;
    }
    /**
        * <p>The calling account has reached the limit for elastic network interfaces for the
        *             specific Amazon Web Services Region. Either delete some network interfaces or request
        *             that the account quota be raised. For more information, see <a href="https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Appendix_Limits.html">Amazon VPC Quotas</a>
        *             in the <i>Amazon VPC User Guide</i> (see the <b>Network
        *                 interfaces per Region</b> entry in the <b>Network
        *                 interfaces</b> table). </p>
        */
    export class NetworkInterfaceLimitExceeded extends __BaseException {
            readonly name: "NetworkInterfaceLimitExceeded";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NetworkInterfaceLimitExceeded, __BaseException>);
    }
    /**
        * <p>Returned if <code>IpAddress</code> was not specified in the request and there are
        *             no free IP addresses in the subnet.</p>
        */
    export class NoFreeAddressesInSubnet extends __BaseException {
            readonly name: "NoFreeAddressesInSubnet";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NoFreeAddressesInSubnet, __BaseException>);
    }
    /**
        * <p>Returned if the size of <code>SecurityGroups</code> specified in the request is
        *             greater than five.</p>
        */
    export class SecurityGroupLimitExceeded extends __BaseException {
            readonly name: "SecurityGroupLimitExceeded";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SecurityGroupLimitExceeded, __BaseException>);
    }
    /**
        * <p>Returned if one of the specified security groups doesn't exist in the subnet's
        *             virtual private cloud (VPC).</p>
        */
    export class SecurityGroupNotFound extends __BaseException {
            readonly name: "SecurityGroupNotFound";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SecurityGroupNotFound, __BaseException>);
    }
    /**
        * <p>Returned if there is no subnet with ID <code>SubnetId</code> provided in the
        *             request.</p>
        */
    export class SubnetNotFound extends __BaseException {
            readonly name: "SubnetNotFound";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SubnetNotFound, __BaseException>);
    }
    /**
        * <p>Describes the destination file system to create in the replication configuration.</p>
        */
    export interface DestinationToCreate {
            /**
                * <p>To create a file system that uses Regional storage, specify the Amazon Web Services Region
                *       in which to create the destination file system.</p>
                */
            Region?: string;
            /**
                * <p>To create a file system that uses EFS One Zone storage, specify the name of the
                *       Availability Zone in which to create the destination file system.</p>
                */
            AvailabilityZoneName?: string;
            /**
                * <p>Specifies the Key Management Service (KMS) key that you want to use to
                *       encrypt the destination file system. If you do not specify a KMS key, Amazon EFS uses your default KMS key for Amazon EFS,
                *         <code>/aws/elasticfilesystem</code>. This ID can be in one of the following formats:</p>
                *          <ul>
                *             <li>
                *                <p>Key ID - The unique identifier of the key, for example
                *             <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p>
                *             </li>
                *             <li>
                *                <p>ARN - The Amazon Resource Name (ARN) for the key, for example
                *             <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p>
                *             </li>
                *             <li>
                *                <p>Key alias - A previously created display name for a key, for example
                *           <code>alias/projectKey1</code>.</p>
                *             </li>
                *             <li>
                *                <p>Key alias ARN - The ARN for a key alias, for example
                *             <code>arn:aws:kms:us-west-2:444455556666:alias/projectKey1</code>.</p>
                *             </li>
                *          </ul>
                */
            KmsKeyId?: string;
    }
    export namespace DestinationToCreate {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DestinationToCreate) => any;
    }
    export interface CreateReplicationConfigurationRequest {
            /**
                * <p>Specifies the Amazon EFS file system that you want to replicate. This file system cannot already be
                *     a source or destination file system in another replication configuration.</p>
                */
            SourceFileSystemId: string | undefined;
            /**
                * <p>An array of destination configuration objects. Only one destination configuration object is supported.</p>
                */
            Destinations: DestinationToCreate[] | undefined;
    }
    export namespace CreateReplicationConfigurationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateReplicationConfigurationRequest) => any;
    }
    export enum ReplicationStatus {
            DELETING = "DELETING",
            ENABLED = "ENABLED",
            ENABLING = "ENABLING",
            ERROR = "ERROR"
    }
    /**
        * <p>Describes the destination file system in the replication configuration.</p>
        */
    export interface Destination {
            /**
                * <p>Describes the status of the destination Amazon EFS file system. If the status is
                *         <code>ERROR</code>, the destination file system in the replication configuration is in a
                *       failed state and is unrecoverable. To access the file system data, restore a backup of the
                *       failed file system to a new file system.</p>
                */
            Status: ReplicationStatus | string | undefined;
            /**
                * <p>The ID of the destination Amazon EFS file system.</p>
                */
            FileSystemId: string | undefined;
            /**
                * <p>The Amazon Web Services Region in which the destination file system is located.</p>
                */
            Region: string | undefined;
            /**
                * <p>The time when the most recent sync was successfully completed on the destination file
                *       system. Any changes to data on the source file system that occurred before this time have been
                *       successfully replicated to the destination file system. Any changes that occurred after this
                *       time might not be fully replicated.</p>
                */
            LastReplicatedTimestamp?: Date;
    }
    export namespace Destination {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Destination) => any;
    }
    export interface ReplicationConfigurationDescription {
            /**
                * <p>The ID of the source Amazon EFS file system that is being replicated.</p>
                */
            SourceFileSystemId: string | undefined;
            /**
                * <p>The Amazon Web Services Region in which the source Amazon EFS  file system is located.</p>
                */
            SourceFileSystemRegion: string | undefined;
            /**
                * <p>The Amazon Resource Name (ARN) of the current source file system in the replication
                *       configuration.</p>
                */
            SourceFileSystemArn: string | undefined;
            /**
                * <p>The Amazon Resource Name (ARN) of the original source Amazon EFS  file system in the replication configuration.</p>
                */
            OriginalSourceFileSystemArn: string | undefined;
            /**
                * <p>Describes when the replication configuration was created.</p>
                */
            CreationTime: Date | undefined;
            /**
                * <p>An array of destination objects. Only one destination object is supported.</p>
                */
            Destinations: Destination[] | undefined;
    }
    export namespace ReplicationConfigurationDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReplicationConfigurationDescription) => any;
    }
    /**
        * <p>Returned if the specified file system does not have a replication
        *             configuration.</p>
        */
    export class ReplicationNotFound extends __BaseException {
            readonly name: "ReplicationNotFound";
            readonly $fault: "client";
            /**
                * <p>ReplicationNotFound</p>
                */
            ErrorCode?: string;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ReplicationNotFound, __BaseException>);
    }
    /**
        * <p>Returned if the Backup service is not available in the Amazon Web Services Region in which the request was made.</p>
        */
    export class ValidationException extends __BaseException {
            readonly name: "ValidationException";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ValidationException, __BaseException>);
    }
    /**
        * <p></p>
        */
    export interface CreateTagsRequest {
            /**
                * <p>The ID of the file system whose tags you want to modify (String). This operation modifies
                *       the tags only, not the file system.</p>
                */
            FileSystemId: string | undefined;
            /**
                * <p>An array of <code>Tag</code> objects to add. Each <code>Tag</code> object is a key-value
                *       pair. </p>
                */
            Tags: Tag[] | undefined;
    }
    export namespace CreateTagsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateTagsRequest) => any;
    }
    export interface DeleteAccessPointRequest {
            /**
                * <p>The ID of the access point that you want to delete.</p>
                */
            AccessPointId: string | undefined;
    }
    export namespace DeleteAccessPointRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteAccessPointRequest) => any;
    }
    /**
        * <p></p>
        */
    export interface DeleteFileSystemRequest {
            /**
                * <p>The ID of the file system you want to delete.</p>
                */
            FileSystemId: string | undefined;
    }
    export namespace DeleteFileSystemRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteFileSystemRequest) => any;
    }
    /**
        * <p>Returned if a file system has mount targets.</p>
        */
    export class FileSystemInUse extends __BaseException {
            readonly name: "FileSystemInUse";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<FileSystemInUse, __BaseException>);
    }
    export interface DeleteFileSystemPolicyRequest {
            /**
                * <p>Specifies the EFS file system for which to delete the <code>FileSystemPolicy</code>.</p>
                */
            FileSystemId: string | undefined;
    }
    export namespace DeleteFileSystemPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteFileSystemPolicyRequest) => any;
    }
    /**
        * <p></p>
        */
    export interface DeleteMountTargetRequest {
            /**
                * <p>The ID of the mount target to delete (String).</p>
                */
            MountTargetId: string | undefined;
    }
    export namespace DeleteMountTargetRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteMountTargetRequest) => any;
    }
    /**
        * <p>The service timed out trying to fulfill the request, and the client should try the
        *             call again.</p>
        */
    export class DependencyTimeout extends __BaseException {
            readonly name: "DependencyTimeout";
            readonly $fault: "server";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DependencyTimeout, __BaseException>);
    }
    /**
        * <p>Returned if there is no mount target with the specified ID found in the
        *             caller's Amazon Web Services account.</p>
        */
    export class MountTargetNotFound extends __BaseException {
            readonly name: "MountTargetNotFound";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<MountTargetNotFound, __BaseException>);
    }
    export interface DeleteReplicationConfigurationRequest {
            /**
                * <p>The ID of the source file system in the replication configuration.</p>
                */
            SourceFileSystemId: string | undefined;
    }
    export namespace DeleteReplicationConfigurationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteReplicationConfigurationRequest) => any;
    }
    /**
        * <p></p>
        */
    export interface DeleteTagsRequest {
            /**
                * <p>The ID of the file system whose tags you want to delete (String).</p>
                */
            FileSystemId: string | undefined;
            /**
                * <p>A list of tag keys to delete.</p>
                */
            TagKeys: string[] | undefined;
    }
    export namespace DeleteTagsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteTagsRequest) => any;
    }
    export interface DescribeAccessPointsRequest {
            /**
                * <p>(Optional) When retrieving all access points for a file system,
                *       you can optionally specify the <code>MaxItems</code> parameter to limit the number of objects returned in a response.
                *       The default value is 100. </p>
                */
            MaxResults?: number;
            /**
                * <p>
                *             <code>NextToken</code> is present if the response is paginated. You can use
                *       <code>NextMarker</code> in the subsequent request to fetch the next page of access point descriptions.</p>
                */
            NextToken?: string;
            /**
                * <p>(Optional) Specifies an EFS access point to describe in the response; mutually exclusive with <code>FileSystemId</code>.</p>
                */
            AccessPointId?: string;
            /**
                * <p>(Optional) If you provide a <code>FileSystemId</code>, EFS returns all access points for that file system; mutually exclusive with <code>AccessPointId</code>.</p>
                */
            FileSystemId?: string;
    }
    export namespace DescribeAccessPointsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeAccessPointsRequest) => any;
    }
    export interface DescribeAccessPointsResponse {
            /**
                * <p>An array of access point descriptions.</p>
                */
            AccessPoints?: AccessPointDescription[];
            /**
                * <p>Present if there are more access points than returned in the response.
                *       You can use the NextMarker in the subsequent request to fetch the additional descriptions.</p>
                */
            NextToken?: string;
    }
    export namespace DescribeAccessPointsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeAccessPointsResponse) => any;
    }
    export interface DescribeAccountPreferencesRequest {
            /**
                * <p>(Optional) You can use <code>NextToken</code> in a subsequent request to fetch the next page of
                *       Amazon Web Services account preferences if the response payload was paginated.</p>
                */
            NextToken?: string;
            /**
                * <p>(Optional) When retrieving account preferences,
                *       you can optionally specify the <code>MaxItems</code> parameter to limit the number of objects returned in a response.
                *       The default value is 100. </p>
                */
            MaxResults?: number;
    }
    export namespace DescribeAccountPreferencesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeAccountPreferencesRequest) => any;
    }
    export enum ResourceIdType {
            LongId = "LONG_ID",
            ShortId = "SHORT_ID"
    }
    export enum Resource {
            FileSystem = "FILE_SYSTEM",
            MountTarget = "MOUNT_TARGET"
    }
    /**
        * <p>Describes the resource type and its ID preference for the user's Amazon Web Services account, in the current Amazon Web Services Region.</p>
        */
    export interface ResourceIdPreference {
            /**
                * <p>Identifies the EFS resource ID preference, either <code>LONG_ID</code> (17 characters) or <code>SHORT_ID</code> (8 characters).</p>
                */
            ResourceIdType?: ResourceIdType | string;
            /**
                * <p>Identifies the Amazon EFS resources to which the ID preference setting applies, <code>FILE_SYSTEM</code> and <code>MOUNT_TARGET</code>.</p>
                */
            Resources?: (Resource | string)[];
    }
    export namespace ResourceIdPreference {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResourceIdPreference) => any;
    }
    export interface DescribeAccountPreferencesResponse {
            /**
                * <p>Describes the resource ID preference setting for the Amazon Web Services account associated with the user making the request, in the current Amazon Web Services Region.</p>
                */
            ResourceIdPreference?: ResourceIdPreference;
            /**
                * <p>Present if there are more records than returned in the response.
                *       You can use the <code>NextToken</code> in the subsequent request to fetch the additional descriptions.</p>
                */
            NextToken?: string;
    }
    export namespace DescribeAccountPreferencesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeAccountPreferencesResponse) => any;
    }
    export interface DescribeBackupPolicyRequest {
            /**
                * <p>Specifies which EFS file system to retrieve the <code>BackupPolicy</code> for.</p>
                */
            FileSystemId: string | undefined;
    }
    export namespace DescribeBackupPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeBackupPolicyRequest) => any;
    }
    /**
        * <p>Returned if the default file system policy is in effect for the EFS file system specified.</p>
        */
    export class PolicyNotFound extends __BaseException {
            readonly name: "PolicyNotFound";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode?: string;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<PolicyNotFound, __BaseException>);
    }
    export interface DescribeFileSystemPolicyRequest {
            /**
                * <p>Specifies which EFS file system to retrieve the <code>FileSystemPolicy</code> for.</p>
                */
            FileSystemId: string | undefined;
    }
    export namespace DescribeFileSystemPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeFileSystemPolicyRequest) => any;
    }
    export interface FileSystemPolicyDescription {
            /**
                * <p>Specifies the EFS file system to which the <code>FileSystemPolicy</code> applies.</p>
                */
            FileSystemId?: string;
            /**
                * <p>The JSON formatted <code>FileSystemPolicy</code> for the EFS file system.</p>
                */
            Policy?: string;
    }
    export namespace FileSystemPolicyDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FileSystemPolicyDescription) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeFileSystemsRequest {
            /**
                * <p>(Optional) Specifies the maximum number of file systems to return in the response
                *       (integer). This number is automatically set to 100. The response is paginated at 100 per page if you have more than 100 file systems.
                *       </p>
                */
            MaxItems?: number;
            /**
                * <p>(Optional) Opaque pagination token returned from a previous
                *         <code>DescribeFileSystems</code> operation (String). If present, specifies to continue the
                *       list from where the returning call had left off. </p>
                */
            Marker?: string;
            /**
                * <p>(Optional) Restricts the list to the file system with this creation token (String). You
                *       specify a creation token when you create an Amazon EFS file system.</p>
                */
            CreationToken?: string;
            /**
                * <p>(Optional) ID of the file system whose description you want to retrieve
                *       (String).</p>
                */
            FileSystemId?: string;
    }
    export namespace DescribeFileSystemsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeFileSystemsRequest) => any;
    }
    export interface DescribeFileSystemsResponse {
            /**
                * <p>Present if provided by caller in the request (String).</p>
                */
            Marker?: string;
            /**
                * <p>An array of file system descriptions.</p>
                */
            FileSystems?: FileSystemDescription[];
            /**
                * <p>Present if there are more file systems than returned in the response (String). You can
                *       use the <code>NextMarker</code> in the subsequent request to fetch the descriptions.</p>
                */
            NextMarker?: string;
    }
    export namespace DescribeFileSystemsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeFileSystemsResponse) => any;
    }
    export interface DescribeLifecycleConfigurationRequest {
            /**
                * <p>The ID of the file system whose <code>LifecycleConfiguration</code> object you want to
                *       retrieve (String).</p>
                */
            FileSystemId: string | undefined;
    }
    export namespace DescribeLifecycleConfigurationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeLifecycleConfigurationRequest) => any;
    }
    export enum TransitionToIARules {
            AFTER_14_DAYS = "AFTER_14_DAYS",
            AFTER_30_DAYS = "AFTER_30_DAYS",
            AFTER_60_DAYS = "AFTER_60_DAYS",
            AFTER_7_DAYS = "AFTER_7_DAYS",
            AFTER_90_DAYS = "AFTER_90_DAYS"
    }
    export enum TransitionToPrimaryStorageClassRules {
            AFTER_1_ACCESS = "AFTER_1_ACCESS"
    }
    /**
        * <p>Describes a policy used by EFS lifecycle management and EFS Intelligent-Tiering that
        *       specifies when to transition files into and out of the file system's Infrequent Access (IA)
        *       storage class. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/lifecycle-management-efs.html">EFS Intelligent‐Tiering and EFS Lifecycle
        *         Management</a>.</p>
        *          <note>
        *             <p>When using the <code>put-lifecycle-configuration</code> CLI command or the
        *           <code>PutLifecycleConfiguration</code> API action, Amazon EFS requires that each
        *           <code>LifecyclePolicy</code> object have only a single transition. This means that in a
        *         request body, <code>LifecyclePolicies</code> must be structured as an array of
        *           <code>LifecyclePolicy</code> objects, one object for each transition,
        *           <code>TransitionToIA</code>, <code>TransitionToPrimaryStorageClass</code>. For more
        *         information, see the request examples in <a>PutLifecycleConfiguration</a>.</p>
        *          </note>
        */
    export interface LifecyclePolicy {
            /**
                * <p>
                *       Describes the period of time that a file is not accessed, after which it transitions to IA storage. Metadata
                *       operations such as listing the contents of a directory don't count as file access
                *       events.</p>
                */
            TransitionToIA?: TransitionToIARules | string;
            /**
                * <p>Describes when to transition a file from IA storage to primary storage. Metadata
                *       operations such as listing the contents of a directory don't count as file access
                *       events.</p>
                */
            TransitionToPrimaryStorageClass?: TransitionToPrimaryStorageClassRules | string;
    }
    export namespace LifecyclePolicy {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LifecyclePolicy) => any;
    }
    export interface LifecycleConfigurationDescription {
            /**
                * <p>An array of lifecycle management policies. EFS supports a maximum of one
                *       policy per file system.</p>
                */
            LifecyclePolicies?: LifecyclePolicy[];
    }
    export namespace LifecycleConfigurationDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LifecycleConfigurationDescription) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeMountTargetsRequest {
            /**
                * <p>(Optional) Maximum number of mount targets to return in the response. Currently, this
                *       number is automatically set to
                *       10, and other values are ignored. The response is paginated at 100 per page if you have more than 100 mount targets.</p>
                */
            MaxItems?: number;
            /**
                * <p>(Optional) Opaque pagination token returned from a previous
                *         <code>DescribeMountTargets</code> operation (String). If present, it specifies to continue
                *       the list from where the previous returning call left off.</p>
                */
            Marker?: string;
            /**
                * <p>(Optional) ID of the file system whose mount targets you want to list (String). It must
                *       be included in your request if an <code>AccessPointId</code> or <code>MountTargetId</code> is not included. Accepts either a file system ID or ARN as input.</p>
                */
            FileSystemId?: string;
            /**
                * <p>(Optional) ID of the mount target that you want to have described (String). It must be
                *       included in your request if <code>FileSystemId</code> is not included. Accepts either a mount target ID or ARN as input.</p>
                */
            MountTargetId?: string;
            /**
                * <p>(Optional) The ID of the access point whose mount targets that you want to list. It must be included in your request if a
                *       <code>FileSystemId</code> or <code>MountTargetId</code> is not included in your request. Accepts either an access point ID or ARN as input.</p>
                */
            AccessPointId?: string;
    }
    export namespace DescribeMountTargetsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeMountTargetsRequest) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeMountTargetsResponse {
            /**
                * <p>If the request included the <code>Marker</code>, the response returns that value in
                *       this field.</p>
                */
            Marker?: string;
            /**
                * <p>Returns the file system's mount targets as an array of
                *         <code>MountTargetDescription</code> objects.</p>
                */
            MountTargets?: MountTargetDescription[];
            /**
                * <p>If a value is present, there are more mount targets to return. In a subsequent request,
                *       you can provide <code>Marker</code> in your request with this value to retrieve the next set
                *       of mount targets.</p>
                */
            NextMarker?: string;
    }
    export namespace DescribeMountTargetsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeMountTargetsResponse) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeMountTargetSecurityGroupsRequest {
            /**
                * <p>The ID of the mount target whose security groups you want to retrieve.</p>
                */
            MountTargetId: string | undefined;
    }
    export namespace DescribeMountTargetSecurityGroupsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeMountTargetSecurityGroupsRequest) => any;
    }
    export interface DescribeMountTargetSecurityGroupsResponse {
            /**
                * <p>An array of security groups.</p>
                */
            SecurityGroups: string[] | undefined;
    }
    export namespace DescribeMountTargetSecurityGroupsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeMountTargetSecurityGroupsResponse) => any;
    }
    /**
        * <p>Returned if the mount target is not in the correct state for the
        *             operation.</p>
        */
    export class IncorrectMountTargetState extends __BaseException {
            readonly name: "IncorrectMountTargetState";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<IncorrectMountTargetState, __BaseException>);
    }
    export interface DescribeReplicationConfigurationsRequest {
            /**
                * <p>You can retrieve the replication configuration for a specific file system by providing its
                *       file system ID.</p>
                */
            FileSystemId?: string;
            /**
                * <p>
                *             <code>NextToken</code> is present if the response is paginated. You can use
                *         <code>NextToken</code> in a subsequent request to fetch the next page of
                *       output.</p>
                */
            NextToken?: string;
            /**
                * <p>(Optional) To limit the number of objects returned in a response, you can specify the
                *         <code>MaxItems</code> parameter. The default value is 100. </p>
                */
            MaxResults?: number;
    }
    export namespace DescribeReplicationConfigurationsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeReplicationConfigurationsRequest) => any;
    }
    export interface DescribeReplicationConfigurationsResponse {
            /**
                * <p>The collection of replication configurations that is returned.</p>
                */
            Replications?: ReplicationConfigurationDescription[];
            /**
                * <p>You can use the <code>NextToken</code> from the previous response in a subsequent
                *       request to fetch the additional descriptions.</p>
                */
            NextToken?: string;
    }
    export namespace DescribeReplicationConfigurationsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeReplicationConfigurationsResponse) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeTagsRequest {
            /**
                * <p>(Optional) The maximum number of file system tags to return in the response. Currently,
                *       this number is automatically set to
                *       100, and other values are ignored. The response is paginated at 100 per page if you have more than 100 tags.</p>
                */
            MaxItems?: number;
            /**
                * <p>(Optional) An opaque pagination token returned from a previous
                *         <code>DescribeTags</code> operation (String). If present, it specifies to continue the list
                *       from where the previous call left off.</p>
                */
            Marker?: string;
            /**
                * <p>The ID of the file system whose tag set you want to retrieve.</p>
                */
            FileSystemId: string | undefined;
    }
    export namespace DescribeTagsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeTagsRequest) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeTagsResponse {
            /**
                * <p>If the request included a <code>Marker</code>, the response returns that value in this
                *       field.</p>
                */
            Marker?: string;
            /**
                * <p>Returns tags associated with the file system as an array of <code>Tag</code> objects.
                *     </p>
                */
            Tags: Tag[] | undefined;
            /**
                * <p>If a value is present, there are more tags to return. In a subsequent request, you can
                *       provide the value of <code>NextMarker</code> as the value of the <code>Marker</code> parameter
                *       in your next request to retrieve the next set of tags.</p>
                */
            NextMarker?: string;
    }
    export namespace DescribeTagsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeTagsResponse) => any;
    }
    /**
        * <p>Returned if the <code>FileSystemPolicy</code> is malformed or contains an error such
        *             as a parameter value that is not valid or a missing required parameter. Returned in the
        *             case of a policy lockout safety check error.</p>
        */
    export class InvalidPolicyException extends __BaseException {
            readonly name: "InvalidPolicyException";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode?: string;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidPolicyException, __BaseException>);
    }
    export interface ListTagsForResourceRequest {
            /**
                * <p>Specifies the EFS resource you want to retrieve tags for. You can retrieve tags for EFS file systems and access points using this API endpoint.</p>
                */
            ResourceId: string | undefined;
            /**
                * <p>(Optional) Specifies the maximum number of tag objects to return in the response. The default value is 100.</p>
                */
            MaxResults?: number;
            /**
                * <p>(Optional) You can use <code>NextToken</code> in a subsequent request to fetch the next page of access point descriptions if the response payload was paginated.</p>
                */
            NextToken?: string;
    }
    export namespace ListTagsForResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceRequest) => any;
    }
    export interface ListTagsForResourceResponse {
            /**
                * <p>An array of the tags for the specified EFS resource.</p>
                */
            Tags?: Tag[];
            /**
                * <p>
                *             <code>NextToken</code> is present if the response payload is paginated. You can use <code>NextToken</code> in a subsequent request to fetch the next page of access point descriptions.</p>
                */
            NextToken?: string;
    }
    export namespace ListTagsForResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceResponse) => any;
    }
    /**
        * <p></p>
        */
    export interface ModifyMountTargetSecurityGroupsRequest {
            /**
                * <p>The ID of the mount target whose security groups you want to modify.</p>
                */
            MountTargetId: string | undefined;
            /**
                * <p>An array of up to five VPC security group IDs.</p>
                */
            SecurityGroups?: string[];
    }
    export namespace ModifyMountTargetSecurityGroupsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyMountTargetSecurityGroupsRequest) => any;
    }
    export interface PutAccountPreferencesRequest {
            /**
                * <p>Specifies the EFS resource ID preference to set for the user's Amazon Web Services account,
                *       in the current Amazon Web Services Region, either <code>LONG_ID</code> (17 characters), or
                *       <code>SHORT_ID</code> (8 characters).</p>
                *          <note>
                *             <p>Starting in October, 2021, you will receive an error when setting the account preference to
                *           <code>SHORT_ID</code>. Contact Amazon Web Services support if you receive an error and must
                *         use short IDs for file system and mount target resources.</p>
                *          </note>
                */
            ResourceIdType: ResourceIdType | string | undefined;
    }
    export namespace PutAccountPreferencesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutAccountPreferencesRequest) => any;
    }
    export interface PutAccountPreferencesResponse {
            /**
                * <p>Describes the resource type and its ID preference for the user's Amazon Web Services account, in the current Amazon Web Services Region.</p>
                */
            ResourceIdPreference?: ResourceIdPreference;
    }
    export namespace PutAccountPreferencesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutAccountPreferencesResponse) => any;
    }
    export interface PutBackupPolicyRequest {
            /**
                * <p>Specifies which EFS file system to update the backup policy for.</p>
                */
            FileSystemId: string | undefined;
            /**
                * <p>The backup policy included in the <code>PutBackupPolicy</code> request.</p>
                */
            BackupPolicy: BackupPolicy | undefined;
    }
    export namespace PutBackupPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutBackupPolicyRequest) => any;
    }
    export interface PutFileSystemPolicyRequest {
            /**
                * <p>The ID of the EFS file system that you want to create or update the <code>FileSystemPolicy</code> for.</p>
                */
            FileSystemId: string | undefined;
            /**
                * <p>The <code>FileSystemPolicy</code> that you're creating. Accepts a JSON formatted policy definition.
                *      EFS file system policies have a 20,000 character limit.
                *       To find out more about the elements that make up a file system policy, see
                *       <a href="https://docs.aws.amazon.com/efs/latest/ug/access-control-overview.html#access-control-manage-access-intro-resource-policies">EFS Resource-based Policies</a>.
                *     </p>
                */
            Policy: string | undefined;
            /**
                * <p>(Optional) A boolean that specifies whether or not to bypass the <code>FileSystemPolicy</code> lockout safety check. The lockout safety check
                *       determines whether the policy in the request will lock out, or prevent, the IAM principal that is making the request from making future <code>PutFileSystemPolicy</code> requests on this file system.
                *       Set <code>BypassPolicyLockoutSafetyCheck</code> to <code>True</code> only when you intend to prevent
                *       the IAM principal that is making the request from making subsequent <code>PutFileSystemPolicy</code> requests on this file system.
                *       The default value is <code>False</code>.
                *     </p>
                */
            BypassPolicyLockoutSafetyCheck?: boolean;
    }
    export namespace PutFileSystemPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutFileSystemPolicyRequest) => any;
    }
    export interface PutLifecycleConfigurationRequest {
            /**
                * <p>The ID of the file system for which you are creating the
                *         <code>LifecycleConfiguration</code> object (String).</p>
                */
            FileSystemId: string | undefined;
            /**
                * <p>An array of <code>LifecyclePolicy</code> objects that define the file system's
                *         <code>LifecycleConfiguration</code> object. A <code>LifecycleConfiguration</code> object
                *       informs EFS lifecycle management and EFS Intelligent-Tiering of the following:</p>
                *          <ul>
                *             <li>
                *                <p>When to move files in the file system from primary storage to the IA storage class.</p>
                *             </li>
                *             <li>
                *                <p>When to move files that are in IA storage to primary storage.</p>
                *             </li>
                *          </ul>
                *          <note>
                *             <p>When using the <code>put-lifecycle-configuration</code> CLI command or the
                *           <code>PutLifecycleConfiguration</code> API action, Amazon EFS requires that each
                *           <code>LifecyclePolicy</code> object have only a single transition. This means that in a
                *         request body, <code>LifecyclePolicies</code> must be structured as an array of
                *           <code>LifecyclePolicy</code> objects, one object for each transition,
                *           <code>TransitionToIA</code>, <code>TransitionToPrimaryStorageClass</code>. See the example
                *         requests in the following section for more information.</p>
                *          </note>
                */
            LifecyclePolicies: LifecyclePolicy[] | undefined;
    }
    export namespace PutLifecycleConfigurationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutLifecycleConfigurationRequest) => any;
    }
    export interface TagResourceRequest {
            /**
                * <p>The ID specifying the EFS resource that you want to create a tag for.</p>
                */
            ResourceId: string | undefined;
            /**
                * <p>An array of <code>Tag</code> objects to add. Each <code>Tag</code> object is a key-value
                *       pair.</p>
                */
            Tags: Tag[] | undefined;
    }
    export namespace TagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceRequest) => any;
    }
    export interface UntagResourceRequest {
            /**
                * <p>Specifies the EFS resource that you want to remove tags from.</p>
                */
            ResourceId: string | undefined;
            /**
                * <p>The keys of the key-value tag pairs that you want to remove from the specified EFS
                *       resource.</p>
                */
            TagKeys: string[] | undefined;
    }
    export namespace UntagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceRequest) => any;
    }
    /**
        * <p>Returned if you don’t wait at least 24 hours before either changing the throughput mode, or
        *             decreasing the Provisioned Throughput value.</p>
        */
    export class TooManyRequests extends __BaseException {
            readonly name: "TooManyRequests";
            readonly $fault: "client";
            /**
                * <p>The error code is a string that uniquely identifies an error condition.
                *         It is meant to be read and understood by programs that detect and handle errors by type. </p>
                */
            ErrorCode: string | undefined;
            /**
                * <p>The error message contains a generic description of the error
                *         condition in English. It is intended for a human audience. Simple programs display the message directly
                *         to the end user if they encounter an error condition they don't know how or don't care to handle.
                *         Sophisticated programs with more exhaustive error handling and proper internationalization are
                *         more likely to ignore the error message.</p>
                */
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyRequests, __BaseException>);
    }
    export interface UpdateFileSystemRequest {
            /**
                * <p>The ID of the file system that you want to update.</p>
                */
            FileSystemId: string | undefined;
            /**
                * <p>(Optional) Updates the file system's throughput mode. If you're not
                *       updating your throughput mode, you don't need to provide this value in your
                *       request. If you are changing the <code>ThroughputMode</code> to <code>provisioned</code>,
                *       you must also set a value for <code>ProvisionedThroughputInMibps</code>.</p>
                */
            ThroughputMode?: ThroughputMode | string;
            /**
                * <p>(Optional) Sets the amount of provisioned throughput, in MiB/s, for the file
                *       system. Valid values are 1-1024. If you are changing the throughput mode to provisioned, you must also
                *       provide the amount of provisioned throughput. Required if <code>ThroughputMode</code> is changed
                *       to <code>provisioned</code> on update.</p>
                */
            ProvisionedThroughputInMibps?: number;
    }
    export namespace UpdateFileSystemRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateFileSystemRequest) => any;
    }
}

declare module '@aws-sdk/client-efs/node_modules/@aws-sdk/client-efs/dist-types/models/EFSServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from EFS service.
        */
    export class EFSServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

