// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http
//   @aws-sdk/smithy-client

declare module '@aws-sdk/client-cloudfront' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { CloudFrontClient } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { AssociateAliasCommandInput, AssociateAliasCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/AssociateAliasCommand";
    import { CreateCachePolicyCommandInput, CreateCachePolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateCachePolicyCommand";
    import { CreateCloudFrontOriginAccessIdentityCommandInput, CreateCloudFrontOriginAccessIdentityCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateCloudFrontOriginAccessIdentityCommand";
    import { CreateDistributionCommandInput, CreateDistributionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateDistributionCommand";
    import { CreateDistributionWithTagsCommandInput, CreateDistributionWithTagsCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateDistributionWithTagsCommand";
    import { CreateFieldLevelEncryptionConfigCommandInput, CreateFieldLevelEncryptionConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateFieldLevelEncryptionConfigCommand";
    import { CreateFieldLevelEncryptionProfileCommandInput, CreateFieldLevelEncryptionProfileCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateFieldLevelEncryptionProfileCommand";
    import { CreateFunctionCommandInput, CreateFunctionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateFunctionCommand";
    import { CreateInvalidationCommandInput, CreateInvalidationCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateInvalidationCommand";
    import { CreateKeyGroupCommandInput, CreateKeyGroupCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateKeyGroupCommand";
    import { CreateMonitoringSubscriptionCommandInput, CreateMonitoringSubscriptionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateMonitoringSubscriptionCommand";
    import { CreateOriginRequestPolicyCommandInput, CreateOriginRequestPolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateOriginRequestPolicyCommand";
    import { CreatePublicKeyCommandInput, CreatePublicKeyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreatePublicKeyCommand";
    import { CreateRealtimeLogConfigCommandInput, CreateRealtimeLogConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateRealtimeLogConfigCommand";
    import { CreateResponseHeadersPolicyCommandInput, CreateResponseHeadersPolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateResponseHeadersPolicyCommand";
    import { CreateStreamingDistributionCommandInput, CreateStreamingDistributionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateStreamingDistributionCommand";
    import { CreateStreamingDistributionWithTagsCommandInput, CreateStreamingDistributionWithTagsCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateStreamingDistributionWithTagsCommand";
    import { DeleteCachePolicyCommandInput, DeleteCachePolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteCachePolicyCommand";
    import { DeleteCloudFrontOriginAccessIdentityCommandInput, DeleteCloudFrontOriginAccessIdentityCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteCloudFrontOriginAccessIdentityCommand";
    import { DeleteDistributionCommandInput, DeleteDistributionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteDistributionCommand";
    import { DeleteFieldLevelEncryptionConfigCommandInput, DeleteFieldLevelEncryptionConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteFieldLevelEncryptionConfigCommand";
    import { DeleteFieldLevelEncryptionProfileCommandInput, DeleteFieldLevelEncryptionProfileCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteFieldLevelEncryptionProfileCommand";
    import { DeleteFunctionCommandInput, DeleteFunctionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteFunctionCommand";
    import { DeleteKeyGroupCommandInput, DeleteKeyGroupCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteKeyGroupCommand";
    import { DeleteMonitoringSubscriptionCommandInput, DeleteMonitoringSubscriptionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteMonitoringSubscriptionCommand";
    import { DeleteOriginRequestPolicyCommandInput, DeleteOriginRequestPolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteOriginRequestPolicyCommand";
    import { DeletePublicKeyCommandInput, DeletePublicKeyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeletePublicKeyCommand";
    import { DeleteRealtimeLogConfigCommandInput, DeleteRealtimeLogConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteRealtimeLogConfigCommand";
    import { DeleteResponseHeadersPolicyCommandInput, DeleteResponseHeadersPolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteResponseHeadersPolicyCommand";
    import { DeleteStreamingDistributionCommandInput, DeleteStreamingDistributionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteStreamingDistributionCommand";
    import { DescribeFunctionCommandInput, DescribeFunctionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DescribeFunctionCommand";
    import { GetCachePolicyCommandInput, GetCachePolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetCachePolicyCommand";
    import { GetCachePolicyConfigCommandInput, GetCachePolicyConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetCachePolicyConfigCommand";
    import { GetCloudFrontOriginAccessIdentityCommandInput, GetCloudFrontOriginAccessIdentityCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetCloudFrontOriginAccessIdentityCommand";
    import { GetCloudFrontOriginAccessIdentityConfigCommandInput, GetCloudFrontOriginAccessIdentityConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetCloudFrontOriginAccessIdentityConfigCommand";
    import { GetDistributionCommandInput, GetDistributionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetDistributionCommand";
    import { GetDistributionConfigCommandInput, GetDistributionConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetDistributionConfigCommand";
    import { GetFieldLevelEncryptionCommandInput, GetFieldLevelEncryptionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetFieldLevelEncryptionCommand";
    import { GetFieldLevelEncryptionConfigCommandInput, GetFieldLevelEncryptionConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetFieldLevelEncryptionConfigCommand";
    import { GetFieldLevelEncryptionProfileCommandInput, GetFieldLevelEncryptionProfileCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetFieldLevelEncryptionProfileCommand";
    import { GetFieldLevelEncryptionProfileConfigCommandInput, GetFieldLevelEncryptionProfileConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetFieldLevelEncryptionProfileConfigCommand";
    import { GetFunctionCommandInput, GetFunctionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetFunctionCommand";
    import { GetInvalidationCommandInput, GetInvalidationCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetInvalidationCommand";
    import { GetKeyGroupCommandInput, GetKeyGroupCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetKeyGroupCommand";
    import { GetKeyGroupConfigCommandInput, GetKeyGroupConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetKeyGroupConfigCommand";
    import { GetMonitoringSubscriptionCommandInput, GetMonitoringSubscriptionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetMonitoringSubscriptionCommand";
    import { GetOriginRequestPolicyCommandInput, GetOriginRequestPolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetOriginRequestPolicyCommand";
    import { GetOriginRequestPolicyConfigCommandInput, GetOriginRequestPolicyConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetOriginRequestPolicyConfigCommand";
    import { GetPublicKeyCommandInput, GetPublicKeyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetPublicKeyCommand";
    import { GetPublicKeyConfigCommandInput, GetPublicKeyConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetPublicKeyConfigCommand";
    import { GetRealtimeLogConfigCommandInput, GetRealtimeLogConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetRealtimeLogConfigCommand";
    import { GetResponseHeadersPolicyCommandInput, GetResponseHeadersPolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetResponseHeadersPolicyCommand";
    import { GetResponseHeadersPolicyConfigCommandInput, GetResponseHeadersPolicyConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetResponseHeadersPolicyConfigCommand";
    import { GetStreamingDistributionCommandInput, GetStreamingDistributionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetStreamingDistributionCommand";
    import { GetStreamingDistributionConfigCommandInput, GetStreamingDistributionConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetStreamingDistributionConfigCommand";
    import { ListCachePoliciesCommandInput, ListCachePoliciesCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListCachePoliciesCommand";
    import { ListCloudFrontOriginAccessIdentitiesCommandInput, ListCloudFrontOriginAccessIdentitiesCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListCloudFrontOriginAccessIdentitiesCommand";
    import { ListConflictingAliasesCommandInput, ListConflictingAliasesCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListConflictingAliasesCommand";
    import { ListDistributionsByCachePolicyIdCommandInput, ListDistributionsByCachePolicyIdCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListDistributionsByCachePolicyIdCommand";
    import { ListDistributionsByKeyGroupCommandInput, ListDistributionsByKeyGroupCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListDistributionsByKeyGroupCommand";
    import { ListDistributionsByOriginRequestPolicyIdCommandInput, ListDistributionsByOriginRequestPolicyIdCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListDistributionsByOriginRequestPolicyIdCommand";
    import { ListDistributionsByRealtimeLogConfigCommandInput, ListDistributionsByRealtimeLogConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListDistributionsByRealtimeLogConfigCommand";
    import { ListDistributionsByResponseHeadersPolicyIdCommandInput, ListDistributionsByResponseHeadersPolicyIdCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListDistributionsByResponseHeadersPolicyIdCommand";
    import { ListDistributionsByWebACLIdCommandInput, ListDistributionsByWebACLIdCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListDistributionsByWebACLIdCommand";
    import { ListDistributionsCommandInput, ListDistributionsCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListDistributionsCommand";
    import { ListFieldLevelEncryptionConfigsCommandInput, ListFieldLevelEncryptionConfigsCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListFieldLevelEncryptionConfigsCommand";
    import { ListFieldLevelEncryptionProfilesCommandInput, ListFieldLevelEncryptionProfilesCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListFieldLevelEncryptionProfilesCommand";
    import { ListFunctionsCommandInput, ListFunctionsCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListFunctionsCommand";
    import { ListInvalidationsCommandInput, ListInvalidationsCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListInvalidationsCommand";
    import { ListKeyGroupsCommandInput, ListKeyGroupsCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListKeyGroupsCommand";
    import { ListOriginRequestPoliciesCommandInput, ListOriginRequestPoliciesCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListOriginRequestPoliciesCommand";
    import { ListPublicKeysCommandInput, ListPublicKeysCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListPublicKeysCommand";
    import { ListRealtimeLogConfigsCommandInput, ListRealtimeLogConfigsCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListRealtimeLogConfigsCommand";
    import { ListResponseHeadersPoliciesCommandInput, ListResponseHeadersPoliciesCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListResponseHeadersPoliciesCommand";
    import { ListStreamingDistributionsCommandInput, ListStreamingDistributionsCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListStreamingDistributionsCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListTagsForResourceCommand";
    import { PublishFunctionCommandInput, PublishFunctionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/PublishFunctionCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/TagResourceCommand";
    import { TestFunctionCommandInput, TestFunctionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/TestFunctionCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UntagResourceCommand";
    import { UpdateCachePolicyCommandInput, UpdateCachePolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateCachePolicyCommand";
    import { UpdateCloudFrontOriginAccessIdentityCommandInput, UpdateCloudFrontOriginAccessIdentityCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateCloudFrontOriginAccessIdentityCommand";
    import { UpdateDistributionCommandInput, UpdateDistributionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateDistributionCommand";
    import { UpdateFieldLevelEncryptionConfigCommandInput, UpdateFieldLevelEncryptionConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateFieldLevelEncryptionConfigCommand";
    import { UpdateFieldLevelEncryptionProfileCommandInput, UpdateFieldLevelEncryptionProfileCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateFieldLevelEncryptionProfileCommand";
    import { UpdateFunctionCommandInput, UpdateFunctionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateFunctionCommand";
    import { UpdateKeyGroupCommandInput, UpdateKeyGroupCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateKeyGroupCommand";
    import { UpdateOriginRequestPolicyCommandInput, UpdateOriginRequestPolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateOriginRequestPolicyCommand";
    import { UpdatePublicKeyCommandInput, UpdatePublicKeyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdatePublicKeyCommand";
    import { UpdateRealtimeLogConfigCommandInput, UpdateRealtimeLogConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateRealtimeLogConfigCommand";
    import { UpdateResponseHeadersPolicyCommandInput, UpdateResponseHeadersPolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateResponseHeadersPolicyCommand";
    import { UpdateStreamingDistributionCommandInput, UpdateStreamingDistributionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateStreamingDistributionCommand";
    /**
        * <fullname>Amazon CloudFront</fullname>
        * 		       <p>This is the <i>Amazon CloudFront API Reference</i>. This guide
        *             is for developers who need detailed information about
        * 			CloudFront API actions, data types, and errors. For detailed information about CloudFront features, see the <i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class CloudFront extends CloudFrontClient {
            /**
                * <p>Associates an alias (also known as a CNAME or an alternate domain name) with a CloudFront
                * 			distribution.</p>
                * 		       <p>With this operation you can move an alias that’s already in use on a CloudFront distribution
                * 			to a different distribution in one step. This prevents the downtime that could occur if
                * 			you first remove the alias from one distribution and then separately add the alias to
                * 			another distribution.</p>
                * 		       <p>To use this operation to associate an alias with a distribution, you provide the alias
                * 			and the ID of the target distribution for the alias. For more information, including how
                * 			to set up the target distribution, prerequisites that you must complete, and other
                * 			restrictions, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/CNAMEs.html#alternate-domain-names-move">Moving an alternate domain name to a different distribution</a>
                * 			in the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            associateAlias(args: AssociateAliasCommandInput, options?: __HttpHandlerOptions): Promise<AssociateAliasCommandOutput>;
            associateAlias(args: AssociateAliasCommandInput, cb: (err: any, data?: AssociateAliasCommandOutput) => void): void;
            associateAlias(args: AssociateAliasCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AssociateAliasCommandOutput) => void): void;
            /**
                * <p>Creates a cache policy.</p>
                * 		       <p>After you create a cache policy, you can attach it to one or more cache behaviors. When it’s
                * 			attached to a cache behavior, the cache policy determines the following:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>The values that CloudFront includes in the <i>cache key</i>. These values can
                * 					include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to
                * 					find an object in its cache that it can return to the viewer.</p>
                * 			         </li>
                *             <li>
                * 				           <p>The default, minimum, and maximum time to live (TTL) values that you want objects to stay
                * 					in the CloudFront cache.</p>
                * 			         </li>
                *          </ul>
                * 		       <p>The headers, cookies, and query strings that are included in the cache key are automatically
                * 			included in requests that CloudFront sends to the origin. CloudFront sends a request when it can’t
                * 			find an object in its cache that matches the request’s cache key. If you want to send
                * 			values to the origin but <i>not</i> include them in the cache key, use
                * 			<code>OriginRequestPolicy</code>.</p>
                * 		       <p>For more information about cache policies, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html">Controlling the cache key</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            createCachePolicy(args: CreateCachePolicyCommandInput, options?: __HttpHandlerOptions): Promise<CreateCachePolicyCommandOutput>;
            createCachePolicy(args: CreateCachePolicyCommandInput, cb: (err: any, data?: CreateCachePolicyCommandOutput) => void): void;
            createCachePolicy(args: CreateCachePolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateCachePolicyCommandOutput) => void): void;
            /**
                * <p>Creates a new origin access identity. If you're using Amazon S3 for your origin, you can
                * 			use an origin access identity to require users to access your content using a CloudFront URL instead
                * 			of the Amazon S3 URL. For more information about how to use origin access identities, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving Private Content through CloudFront</a> in the
                * 				<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            createCloudFrontOriginAccessIdentity(args: CreateCloudFrontOriginAccessIdentityCommandInput, options?: __HttpHandlerOptions): Promise<CreateCloudFrontOriginAccessIdentityCommandOutput>;
            createCloudFrontOriginAccessIdentity(args: CreateCloudFrontOriginAccessIdentityCommandInput, cb: (err: any, data?: CreateCloudFrontOriginAccessIdentityCommandOutput) => void): void;
            createCloudFrontOriginAccessIdentity(args: CreateCloudFrontOriginAccessIdentityCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateCloudFrontOriginAccessIdentityCommandOutput) => void): void;
            /**
                * <p>Creates a new web distribution. You create a CloudFront distribution to tell CloudFront where you
                * 			want content to be delivered from, and the details about how to track and manage content delivery. Send a <code>POST</code> request to the
                * 			<code>/<i>CloudFront API version</i>/distribution</code>/<code>distribution ID</code> resource.</p>
                * 		       <important>
                *             <p>When you update a distribution, there are more required fields than when you create a distribution.
                * 			When you update your distribution by using
                * 			<a href="https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_UpdateDistribution.html">UpdateDistribution</a>,
                * 			follow the steps included
                * 			in the documentation to get the current configuration
                * 			and then make your updates. This helps to make sure that you include all of the required fields. To view a summary,
                * 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-overview-required-fields.html">Required
                * 				Fields for Create Distribution and Update Distribution</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                *          </important>
                */
            createDistribution(args: CreateDistributionCommandInput, options?: __HttpHandlerOptions): Promise<CreateDistributionCommandOutput>;
            createDistribution(args: CreateDistributionCommandInput, cb: (err: any, data?: CreateDistributionCommandOutput) => void): void;
            createDistribution(args: CreateDistributionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateDistributionCommandOutput) => void): void;
            /**
                * <p>Create a new distribution with tags.</p>
                */
            createDistributionWithTags(args: CreateDistributionWithTagsCommandInput, options?: __HttpHandlerOptions): Promise<CreateDistributionWithTagsCommandOutput>;
            createDistributionWithTags(args: CreateDistributionWithTagsCommandInput, cb: (err: any, data?: CreateDistributionWithTagsCommandOutput) => void): void;
            createDistributionWithTags(args: CreateDistributionWithTagsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateDistributionWithTagsCommandOutput) => void): void;
            /**
                * <p>Create a new field-level encryption configuration.</p>
                */
            createFieldLevelEncryptionConfig(args: CreateFieldLevelEncryptionConfigCommandInput, options?: __HttpHandlerOptions): Promise<CreateFieldLevelEncryptionConfigCommandOutput>;
            createFieldLevelEncryptionConfig(args: CreateFieldLevelEncryptionConfigCommandInput, cb: (err: any, data?: CreateFieldLevelEncryptionConfigCommandOutput) => void): void;
            createFieldLevelEncryptionConfig(args: CreateFieldLevelEncryptionConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateFieldLevelEncryptionConfigCommandOutput) => void): void;
            /**
                * <p>Create a field-level encryption profile.</p>
                */
            createFieldLevelEncryptionProfile(args: CreateFieldLevelEncryptionProfileCommandInput, options?: __HttpHandlerOptions): Promise<CreateFieldLevelEncryptionProfileCommandOutput>;
            createFieldLevelEncryptionProfile(args: CreateFieldLevelEncryptionProfileCommandInput, cb: (err: any, data?: CreateFieldLevelEncryptionProfileCommandOutput) => void): void;
            createFieldLevelEncryptionProfile(args: CreateFieldLevelEncryptionProfileCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateFieldLevelEncryptionProfileCommandOutput) => void): void;
            /**
                * <p>Creates a CloudFront function.</p>
                * 		       <p>To create a function, you provide the function code and some configuration information
                * 			about the function. The response contains an Amazon Resource Name (ARN) that uniquely
                * 			identifies the function.</p>
                * 		       <p>When you create a function, it’s in the <code>DEVELOPMENT</code> stage. In this stage, you
                * 			can test the function with <code>TestFunction</code>, and update it with
                * 			<code>UpdateFunction</code>.</p>
                * 		       <p>When you’re ready to use your function with a CloudFront distribution, use
                * 			<code>PublishFunction</code> to copy the function from the <code>DEVELOPMENT</code>
                * 			stage to <code>LIVE</code>. When it’s live, you can attach the function to a
                * 			distribution’s cache behavior, using the function’s ARN.</p>
                */
            createFunction(args: CreateFunctionCommandInput, options?: __HttpHandlerOptions): Promise<CreateFunctionCommandOutput>;
            createFunction(args: CreateFunctionCommandInput, cb: (err: any, data?: CreateFunctionCommandOutput) => void): void;
            createFunction(args: CreateFunctionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateFunctionCommandOutput) => void): void;
            /**
                * <p>Create a new invalidation. </p>
                */
            createInvalidation(args: CreateInvalidationCommandInput, options?: __HttpHandlerOptions): Promise<CreateInvalidationCommandOutput>;
            createInvalidation(args: CreateInvalidationCommandInput, cb: (err: any, data?: CreateInvalidationCommandOutput) => void): void;
            createInvalidation(args: CreateInvalidationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateInvalidationCommandOutput) => void): void;
            /**
                * <p>Creates a key group that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">CloudFront signed URLs and signed cookies</a>.</p>
                * 		       <p>To create a key group, you must specify at least one public key for the key group. After you
                * 			create a key group, you can reference it from one or more cache behaviors. When you
                * 			reference a key group in a cache behavior, CloudFront requires signed URLs or signed cookies
                * 			for all requests that match the cache behavior. The URLs or cookies must be signed with
                * 			a private key whose corresponding public key is in the key group. The signed URL or
                * 			cookie contains information about which public key CloudFront should use to verify the
                * 			signature. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving private content</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            createKeyGroup(args: CreateKeyGroupCommandInput, options?: __HttpHandlerOptions): Promise<CreateKeyGroupCommandOutput>;
            createKeyGroup(args: CreateKeyGroupCommandInput, cb: (err: any, data?: CreateKeyGroupCommandOutput) => void): void;
            createKeyGroup(args: CreateKeyGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateKeyGroupCommandOutput) => void): void;
            /**
                * <p>Enables additional CloudWatch metrics for the specified CloudFront distribution. The
                * 			additional metrics incur an additional cost.</p>
                * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/viewing-cloudfront-metrics.html#monitoring-console.distributions-additional">Viewing additional CloudFront distribution metrics</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            createMonitoringSubscription(args: CreateMonitoringSubscriptionCommandInput, options?: __HttpHandlerOptions): Promise<CreateMonitoringSubscriptionCommandOutput>;
            createMonitoringSubscription(args: CreateMonitoringSubscriptionCommandInput, cb: (err: any, data?: CreateMonitoringSubscriptionCommandOutput) => void): void;
            createMonitoringSubscription(args: CreateMonitoringSubscriptionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateMonitoringSubscriptionCommandOutput) => void): void;
            /**
                * <p>Creates an origin request policy.</p>
                * 		       <p>After you create an origin request policy, you can attach it to one or more cache behaviors.
                * 			When it’s attached to a cache behavior, the origin request policy determines the values
                * 			that CloudFront includes in requests that it sends to the origin. Each request that CloudFront sends
                * 			to the origin includes the following:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>The request body and the URL path (without the domain name) from the viewer
                * 					request.</p>
                * 			         </li>
                *             <li>
                * 				           <p>The headers that CloudFront automatically includes in every origin request, including
                * 					<code>Host</code>, <code>User-Agent</code>, and <code>X-Amz-Cf-Id</code>.</p>
                * 			         </li>
                *             <li>
                * 				           <p>All HTTP headers, cookies, and URL query strings that are specified in the cache policy or
                * 					the origin request policy. These can include items from the viewer request and,
                * 					in the case of headers, additional ones that are added by CloudFront.</p>
                * 			         </li>
                *          </ul>
                * 		       <p>CloudFront sends a request when it can’t find a valid object in its cache that matches the
                * 			request. If you want to send values to the origin and also include them in the cache
                * 			key, use <code>CachePolicy</code>.</p>
                * 		       <p>For more information about origin request policies, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html">Controlling origin requests</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            createOriginRequestPolicy(args: CreateOriginRequestPolicyCommandInput, options?: __HttpHandlerOptions): Promise<CreateOriginRequestPolicyCommandOutput>;
            createOriginRequestPolicy(args: CreateOriginRequestPolicyCommandInput, cb: (err: any, data?: CreateOriginRequestPolicyCommandOutput) => void): void;
            createOriginRequestPolicy(args: CreateOriginRequestPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateOriginRequestPolicyCommandOutput) => void): void;
            /**
                * <p>Uploads a public key to CloudFront that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">signed URLs and signed cookies</a>, or with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html">field-level encryption</a>.</p>
                */
            createPublicKey(args: CreatePublicKeyCommandInput, options?: __HttpHandlerOptions): Promise<CreatePublicKeyCommandOutput>;
            createPublicKey(args: CreatePublicKeyCommandInput, cb: (err: any, data?: CreatePublicKeyCommandOutput) => void): void;
            createPublicKey(args: CreatePublicKeyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreatePublicKeyCommandOutput) => void): void;
            /**
                * <p>Creates a real-time log configuration.</p>
                * 		       <p>After you create a real-time log configuration, you can attach it to one or more cache
                * 			behaviors to send real-time log data to the specified Amazon Kinesis data stream.</p>
                * 		       <p>For more information about real-time log configurations, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html">Real-time logs</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            createRealtimeLogConfig(args: CreateRealtimeLogConfigCommandInput, options?: __HttpHandlerOptions): Promise<CreateRealtimeLogConfigCommandOutput>;
            createRealtimeLogConfig(args: CreateRealtimeLogConfigCommandInput, cb: (err: any, data?: CreateRealtimeLogConfigCommandOutput) => void): void;
            createRealtimeLogConfig(args: CreateRealtimeLogConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateRealtimeLogConfigCommandOutput) => void): void;
            /**
                * <p>Creates a response headers policy.</p>
                * 		       <p>A response headers policy contains information about a set of HTTP response headers
                * 			and their values. To create a response headers policy, you provide some metadata about
                * 			the policy, and a set of configurations that specify the response headers.</p>
                * 		       <p>After you create a response headers policy, you can use its ID to attach it to one or more
                * 			cache behaviors in a CloudFront distribution. When it’s attached to a cache behavior, CloudFront
                * 			adds the headers in the policy to HTTP responses that it sends for requests that match
                * 			the cache behavior.</p>
                */
            createResponseHeadersPolicy(args: CreateResponseHeadersPolicyCommandInput, options?: __HttpHandlerOptions): Promise<CreateResponseHeadersPolicyCommandOutput>;
            createResponseHeadersPolicy(args: CreateResponseHeadersPolicyCommandInput, cb: (err: any, data?: CreateResponseHeadersPolicyCommandOutput) => void): void;
            createResponseHeadersPolicy(args: CreateResponseHeadersPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateResponseHeadersPolicyCommandOutput) => void): void;
            /**
                * <p>This API is deprecated.
                *             Amazon CloudFront is deprecating real-time messaging protocol (RTMP) distributions on December 31, 2020.
                *             For more information, <a href="http://forums.aws.amazon.com/ann.jspa?annID=7356">read the announcement</a> on the Amazon CloudFront discussion forum.</p>
                */
            createStreamingDistribution(args: CreateStreamingDistributionCommandInput, options?: __HttpHandlerOptions): Promise<CreateStreamingDistributionCommandOutput>;
            createStreamingDistribution(args: CreateStreamingDistributionCommandInput, cb: (err: any, data?: CreateStreamingDistributionCommandOutput) => void): void;
            createStreamingDistribution(args: CreateStreamingDistributionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateStreamingDistributionCommandOutput) => void): void;
            /**
                * <p>This API is deprecated.
                *             Amazon CloudFront is deprecating real-time messaging protocol (RTMP) distributions on December 31, 2020.
                *             For more information, <a href="http://forums.aws.amazon.com/ann.jspa?annID=7356">read the announcement</a> on the Amazon CloudFront discussion forum.</p>
                */
            createStreamingDistributionWithTags(args: CreateStreamingDistributionWithTagsCommandInput, options?: __HttpHandlerOptions): Promise<CreateStreamingDistributionWithTagsCommandOutput>;
            createStreamingDistributionWithTags(args: CreateStreamingDistributionWithTagsCommandInput, cb: (err: any, data?: CreateStreamingDistributionWithTagsCommandOutput) => void): void;
            createStreamingDistributionWithTags(args: CreateStreamingDistributionWithTagsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateStreamingDistributionWithTagsCommandOutput) => void): void;
            /**
                * <p>Deletes a cache policy.</p>
                * 		       <p>You cannot delete a cache policy if it’s attached to a cache behavior. First update your
                * 			distributions to remove the cache policy from all cache behaviors, then delete the cache
                * 			policy.</p>
                * 		       <p>To delete a cache policy, you must provide the policy’s identifier and version. To get these
                * 			values, you can use <code>ListCachePolicies</code> or
                * 			<code>GetCachePolicy</code>.</p>
                */
            deleteCachePolicy(args: DeleteCachePolicyCommandInput, options?: __HttpHandlerOptions): Promise<DeleteCachePolicyCommandOutput>;
            deleteCachePolicy(args: DeleteCachePolicyCommandInput, cb: (err: any, data?: DeleteCachePolicyCommandOutput) => void): void;
            deleteCachePolicy(args: DeleteCachePolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteCachePolicyCommandOutput) => void): void;
            /**
                * <p>Delete an origin access identity. </p>
                */
            deleteCloudFrontOriginAccessIdentity(args: DeleteCloudFrontOriginAccessIdentityCommandInput, options?: __HttpHandlerOptions): Promise<DeleteCloudFrontOriginAccessIdentityCommandOutput>;
            deleteCloudFrontOriginAccessIdentity(args: DeleteCloudFrontOriginAccessIdentityCommandInput, cb: (err: any, data?: DeleteCloudFrontOriginAccessIdentityCommandOutput) => void): void;
            deleteCloudFrontOriginAccessIdentity(args: DeleteCloudFrontOriginAccessIdentityCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteCloudFrontOriginAccessIdentityCommandOutput) => void): void;
            /**
                * <p>Delete a distribution. </p>
                */
            deleteDistribution(args: DeleteDistributionCommandInput, options?: __HttpHandlerOptions): Promise<DeleteDistributionCommandOutput>;
            deleteDistribution(args: DeleteDistributionCommandInput, cb: (err: any, data?: DeleteDistributionCommandOutput) => void): void;
            deleteDistribution(args: DeleteDistributionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteDistributionCommandOutput) => void): void;
            /**
                * <p>Remove a field-level encryption configuration.</p>
                */
            deleteFieldLevelEncryptionConfig(args: DeleteFieldLevelEncryptionConfigCommandInput, options?: __HttpHandlerOptions): Promise<DeleteFieldLevelEncryptionConfigCommandOutput>;
            deleteFieldLevelEncryptionConfig(args: DeleteFieldLevelEncryptionConfigCommandInput, cb: (err: any, data?: DeleteFieldLevelEncryptionConfigCommandOutput) => void): void;
            deleteFieldLevelEncryptionConfig(args: DeleteFieldLevelEncryptionConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteFieldLevelEncryptionConfigCommandOutput) => void): void;
            /**
                * <p>Remove a field-level encryption profile.</p>
                */
            deleteFieldLevelEncryptionProfile(args: DeleteFieldLevelEncryptionProfileCommandInput, options?: __HttpHandlerOptions): Promise<DeleteFieldLevelEncryptionProfileCommandOutput>;
            deleteFieldLevelEncryptionProfile(args: DeleteFieldLevelEncryptionProfileCommandInput, cb: (err: any, data?: DeleteFieldLevelEncryptionProfileCommandOutput) => void): void;
            deleteFieldLevelEncryptionProfile(args: DeleteFieldLevelEncryptionProfileCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteFieldLevelEncryptionProfileCommandOutput) => void): void;
            /**
                * <p>Deletes a CloudFront function.</p>
                * 		       <p>You cannot delete a function if it’s associated with a cache behavior. First, update your
                * 			distributions to remove the function association from all cache behaviors, then delete
                * 			the function.</p>
                * 		       <p>To delete a function, you must provide the function’s name and version
                * 			(<code>ETag</code> value). To get these values, you can use <code>ListFunctions</code>
                * 			and <code>DescribeFunction</code>.</p>
                */
            deleteFunction(args: DeleteFunctionCommandInput, options?: __HttpHandlerOptions): Promise<DeleteFunctionCommandOutput>;
            deleteFunction(args: DeleteFunctionCommandInput, cb: (err: any, data?: DeleteFunctionCommandOutput) => void): void;
            deleteFunction(args: DeleteFunctionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteFunctionCommandOutput) => void): void;
            /**
                * <p>Deletes a key group.</p>
                * 		       <p>You cannot delete a key group that is referenced in a cache behavior. First update
                * 			your distributions to remove the key group from all cache behaviors, then delete the key
                * 			group.</p>
                * 		       <p>To delete a key group, you must provide the key group’s identifier and version. To get
                * 			these values, use <code>ListKeyGroups</code> followed by <code>GetKeyGroup</code> or
                * 			<code>GetKeyGroupConfig</code>.</p>
                */
            deleteKeyGroup(args: DeleteKeyGroupCommandInput, options?: __HttpHandlerOptions): Promise<DeleteKeyGroupCommandOutput>;
            deleteKeyGroup(args: DeleteKeyGroupCommandInput, cb: (err: any, data?: DeleteKeyGroupCommandOutput) => void): void;
            deleteKeyGroup(args: DeleteKeyGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteKeyGroupCommandOutput) => void): void;
            /**
                * <p>Disables additional CloudWatch metrics for the specified CloudFront distribution.</p>
                */
            deleteMonitoringSubscription(args: DeleteMonitoringSubscriptionCommandInput, options?: __HttpHandlerOptions): Promise<DeleteMonitoringSubscriptionCommandOutput>;
            deleteMonitoringSubscription(args: DeleteMonitoringSubscriptionCommandInput, cb: (err: any, data?: DeleteMonitoringSubscriptionCommandOutput) => void): void;
            deleteMonitoringSubscription(args: DeleteMonitoringSubscriptionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteMonitoringSubscriptionCommandOutput) => void): void;
            /**
                * <p>Deletes an origin request policy.</p>
                * 		       <p>You cannot delete an origin request policy if it’s attached to any cache behaviors. First
                * 			update your distributions to remove the origin request policy from all cache behaviors,
                * 			then delete the origin request policy.</p>
                * 		       <p>To delete an origin request policy, you must provide the policy’s identifier and version. To
                * 			get the identifier, you can use <code>ListOriginRequestPolicies</code> or
                * 			<code>GetOriginRequestPolicy</code>.</p>
                */
            deleteOriginRequestPolicy(args: DeleteOriginRequestPolicyCommandInput, options?: __HttpHandlerOptions): Promise<DeleteOriginRequestPolicyCommandOutput>;
            deleteOriginRequestPolicy(args: DeleteOriginRequestPolicyCommandInput, cb: (err: any, data?: DeleteOriginRequestPolicyCommandOutput) => void): void;
            deleteOriginRequestPolicy(args: DeleteOriginRequestPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteOriginRequestPolicyCommandOutput) => void): void;
            /**
                * <p>Remove a public key you previously added to CloudFront.</p>
                */
            deletePublicKey(args: DeletePublicKeyCommandInput, options?: __HttpHandlerOptions): Promise<DeletePublicKeyCommandOutput>;
            deletePublicKey(args: DeletePublicKeyCommandInput, cb: (err: any, data?: DeletePublicKeyCommandOutput) => void): void;
            deletePublicKey(args: DeletePublicKeyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeletePublicKeyCommandOutput) => void): void;
            /**
                * <p>Deletes a real-time log configuration.</p>
                * 		       <p>You cannot delete a real-time log configuration if it’s attached to a cache behavior.
                * 			First update your distributions to remove the real-time log configuration from all cache
                * 			behaviors, then delete the real-time log configuration.</p>
                * 		       <p>To delete a real-time log configuration, you can provide the configuration’s name or its
                * 			Amazon Resource Name (ARN). You must provide at least one. If you provide both, CloudFront
                * 			uses the name to identify the real-time log configuration to delete.</p>
                */
            deleteRealtimeLogConfig(args: DeleteRealtimeLogConfigCommandInput, options?: __HttpHandlerOptions): Promise<DeleteRealtimeLogConfigCommandOutput>;
            deleteRealtimeLogConfig(args: DeleteRealtimeLogConfigCommandInput, cb: (err: any, data?: DeleteRealtimeLogConfigCommandOutput) => void): void;
            deleteRealtimeLogConfig(args: DeleteRealtimeLogConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteRealtimeLogConfigCommandOutput) => void): void;
            /**
                * <p>Deletes a response headers policy.</p>
                * 		       <p>You cannot delete a response headers policy if it’s attached to a cache behavior.
                * 			First update your distributions to remove the response headers policy from all cache
                * 			behaviors, then delete the response headers policy.</p>
                * 		       <p>To delete a response headers policy, you must provide the policy’s identifier and
                * 			version. To get these values, you can use <code>ListResponseHeadersPolicies</code> or
                * 				<code>GetResponseHeadersPolicy</code>. </p>
                */
            deleteResponseHeadersPolicy(args: DeleteResponseHeadersPolicyCommandInput, options?: __HttpHandlerOptions): Promise<DeleteResponseHeadersPolicyCommandOutput>;
            deleteResponseHeadersPolicy(args: DeleteResponseHeadersPolicyCommandInput, cb: (err: any, data?: DeleteResponseHeadersPolicyCommandOutput) => void): void;
            deleteResponseHeadersPolicy(args: DeleteResponseHeadersPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteResponseHeadersPolicyCommandOutput) => void): void;
            /**
                * <p>Delete a streaming distribution. To delete an RTMP distribution using the CloudFront API,
                * 			perform the following steps.</p>
                *
                * 		       <p>
                *             <b>To delete an RTMP distribution using the CloudFront
                * 			API</b>:</p>
                * 		       <ol>
                *             <li>
                * 				           <p>Disable the RTMP distribution.</p>
                * 			         </li>
                *             <li>
                * 				           <p>Submit a <code>GET Streaming Distribution Config</code> request to get the current
                * 					configuration and the <code>Etag</code> header for the distribution. </p>
                * 			         </li>
                *             <li>
                * 				           <p>Update the XML document that was returned in the response to your <code>GET
                * 						Streaming Distribution Config</code> request to change the value of <code>Enabled</code>
                * 					to <code>false</code>.</p>
                * 			         </li>
                *             <li>
                * 				           <p>Submit a <code>PUT Streaming Distribution Config</code> request to update the
                * 					configuration for your distribution. In the request body, include the XML document that
                * 					you updated in Step 3. Then set the value of the HTTP <code>If-Match</code> header to the
                * 					value of the <code>ETag</code> header that CloudFront returned when you submitted the <code>GET
                * 						Streaming Distribution Config</code> request in Step 2.</p>
                * 			         </li>
                *             <li>
                * 				           <p>Review the response to the <code>PUT Streaming Distribution Config</code> request
                * 					to confirm that the distribution was successfully disabled.</p>
                * 			         </li>
                *             <li>
                * 				           <p>Submit a <code>GET Streaming Distribution Config</code> request to confirm that
                * 					your changes have propagated. When propagation is complete, the value of
                * 						<code>Status</code> is <code>Deployed</code>.</p>
                * 			         </li>
                *             <li>
                * 				           <p>Submit a <code>DELETE Streaming Distribution</code> request. Set the value of the
                * 					HTTP <code>If-Match</code> header to the value of the <code>ETag</code> header that CloudFront
                * 					returned when you submitted the <code>GET Streaming Distribution Config</code> request in
                * 					Step 2.</p>
                * 			         </li>
                *             <li>
                * 				           <p>Review the response to your <code>DELETE Streaming Distribution</code> request to
                * 					confirm that the distribution was successfully deleted.</p>
                * 			         </li>
                *          </ol>
                * 		       <p>For information about deleting a distribution using the CloudFront console, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/HowToDeleteDistribution.html">Deleting a Distribution</a> in the
                * 				<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            deleteStreamingDistribution(args: DeleteStreamingDistributionCommandInput, options?: __HttpHandlerOptions): Promise<DeleteStreamingDistributionCommandOutput>;
            deleteStreamingDistribution(args: DeleteStreamingDistributionCommandInput, cb: (err: any, data?: DeleteStreamingDistributionCommandOutput) => void): void;
            deleteStreamingDistribution(args: DeleteStreamingDistributionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteStreamingDistributionCommandOutput) => void): void;
            /**
                * <p>Gets configuration information and metadata about a CloudFront function, but not the function’s
                * 			code. To get a function’s code, use <code>GetFunction</code>.</p>
                * 		       <p>To get configuration information and metadata about a function, you must provide the
                * 			function’s name and stage. To get these values, you can use
                * 			<code>ListFunctions</code>.</p>
                */
            describeFunction(args: DescribeFunctionCommandInput, options?: __HttpHandlerOptions): Promise<DescribeFunctionCommandOutput>;
            describeFunction(args: DescribeFunctionCommandInput, cb: (err: any, data?: DescribeFunctionCommandOutput) => void): void;
            describeFunction(args: DescribeFunctionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeFunctionCommandOutput) => void): void;
            /**
                * <p>Gets a cache policy, including the following metadata:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>The policy’s identifier.</p>
                * 			         </li>
                *             <li>
                * 				           <p>The date and time when the policy was last modified.</p>
                * 			         </li>
                *          </ul>
                * 		       <p>To get a cache policy, you must provide the policy’s identifier. If the cache policy is
                * 			attached to a distribution’s cache behavior, you can get the policy’s identifier using
                * 			<code>ListDistributions</code> or <code>GetDistribution</code>. If the cache policy is
                * 			not attached to a cache behavior, you can get the identifier using
                * 			<code>ListCachePolicies</code>.</p>
                */
            getCachePolicy(args: GetCachePolicyCommandInput, options?: __HttpHandlerOptions): Promise<GetCachePolicyCommandOutput>;
            getCachePolicy(args: GetCachePolicyCommandInput, cb: (err: any, data?: GetCachePolicyCommandOutput) => void): void;
            getCachePolicy(args: GetCachePolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetCachePolicyCommandOutput) => void): void;
            /**
                * <p>Gets a cache policy configuration.</p>
                * 		       <p>To get a cache policy configuration, you must provide the policy’s identifier. If the cache
                * 			policy is attached to a distribution’s cache behavior, you can get the policy’s
                * 			identifier using <code>ListDistributions</code> or <code>GetDistribution</code>. If the
                * 			cache policy is not attached to a cache behavior, you can get the identifier using
                * 			<code>ListCachePolicies</code>.</p>
                */
            getCachePolicyConfig(args: GetCachePolicyConfigCommandInput, options?: __HttpHandlerOptions): Promise<GetCachePolicyConfigCommandOutput>;
            getCachePolicyConfig(args: GetCachePolicyConfigCommandInput, cb: (err: any, data?: GetCachePolicyConfigCommandOutput) => void): void;
            getCachePolicyConfig(args: GetCachePolicyConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetCachePolicyConfigCommandOutput) => void): void;
            /**
                * <p>Get the information about an origin access identity. </p>
                */
            getCloudFrontOriginAccessIdentity(args: GetCloudFrontOriginAccessIdentityCommandInput, options?: __HttpHandlerOptions): Promise<GetCloudFrontOriginAccessIdentityCommandOutput>;
            getCloudFrontOriginAccessIdentity(args: GetCloudFrontOriginAccessIdentityCommandInput, cb: (err: any, data?: GetCloudFrontOriginAccessIdentityCommandOutput) => void): void;
            getCloudFrontOriginAccessIdentity(args: GetCloudFrontOriginAccessIdentityCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetCloudFrontOriginAccessIdentityCommandOutput) => void): void;
            /**
                * <p>Get the configuration information about an origin access identity. </p>
                */
            getCloudFrontOriginAccessIdentityConfig(args: GetCloudFrontOriginAccessIdentityConfigCommandInput, options?: __HttpHandlerOptions): Promise<GetCloudFrontOriginAccessIdentityConfigCommandOutput>;
            getCloudFrontOriginAccessIdentityConfig(args: GetCloudFrontOriginAccessIdentityConfigCommandInput, cb: (err: any, data?: GetCloudFrontOriginAccessIdentityConfigCommandOutput) => void): void;
            getCloudFrontOriginAccessIdentityConfig(args: GetCloudFrontOriginAccessIdentityConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetCloudFrontOriginAccessIdentityConfigCommandOutput) => void): void;
            /**
                * <p>Get the information about a distribution.</p>
                */
            getDistribution(args: GetDistributionCommandInput, options?: __HttpHandlerOptions): Promise<GetDistributionCommandOutput>;
            getDistribution(args: GetDistributionCommandInput, cb: (err: any, data?: GetDistributionCommandOutput) => void): void;
            getDistribution(args: GetDistributionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetDistributionCommandOutput) => void): void;
            /**
                * <p>Get the configuration information about a distribution. </p>
                */
            getDistributionConfig(args: GetDistributionConfigCommandInput, options?: __HttpHandlerOptions): Promise<GetDistributionConfigCommandOutput>;
            getDistributionConfig(args: GetDistributionConfigCommandInput, cb: (err: any, data?: GetDistributionConfigCommandOutput) => void): void;
            getDistributionConfig(args: GetDistributionConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetDistributionConfigCommandOutput) => void): void;
            /**
                * <p>Get the field-level encryption configuration information.</p>
                */
            getFieldLevelEncryption(args: GetFieldLevelEncryptionCommandInput, options?: __HttpHandlerOptions): Promise<GetFieldLevelEncryptionCommandOutput>;
            getFieldLevelEncryption(args: GetFieldLevelEncryptionCommandInput, cb: (err: any, data?: GetFieldLevelEncryptionCommandOutput) => void): void;
            getFieldLevelEncryption(args: GetFieldLevelEncryptionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetFieldLevelEncryptionCommandOutput) => void): void;
            /**
                * <p>Get the field-level encryption configuration information.</p>
                */
            getFieldLevelEncryptionConfig(args: GetFieldLevelEncryptionConfigCommandInput, options?: __HttpHandlerOptions): Promise<GetFieldLevelEncryptionConfigCommandOutput>;
            getFieldLevelEncryptionConfig(args: GetFieldLevelEncryptionConfigCommandInput, cb: (err: any, data?: GetFieldLevelEncryptionConfigCommandOutput) => void): void;
            getFieldLevelEncryptionConfig(args: GetFieldLevelEncryptionConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetFieldLevelEncryptionConfigCommandOutput) => void): void;
            /**
                * <p>Get the field-level encryption profile information.</p>
                */
            getFieldLevelEncryptionProfile(args: GetFieldLevelEncryptionProfileCommandInput, options?: __HttpHandlerOptions): Promise<GetFieldLevelEncryptionProfileCommandOutput>;
            getFieldLevelEncryptionProfile(args: GetFieldLevelEncryptionProfileCommandInput, cb: (err: any, data?: GetFieldLevelEncryptionProfileCommandOutput) => void): void;
            getFieldLevelEncryptionProfile(args: GetFieldLevelEncryptionProfileCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetFieldLevelEncryptionProfileCommandOutput) => void): void;
            /**
                * <p>Get the field-level encryption profile configuration information.</p>
                */
            getFieldLevelEncryptionProfileConfig(args: GetFieldLevelEncryptionProfileConfigCommandInput, options?: __HttpHandlerOptions): Promise<GetFieldLevelEncryptionProfileConfigCommandOutput>;
            getFieldLevelEncryptionProfileConfig(args: GetFieldLevelEncryptionProfileConfigCommandInput, cb: (err: any, data?: GetFieldLevelEncryptionProfileConfigCommandOutput) => void): void;
            getFieldLevelEncryptionProfileConfig(args: GetFieldLevelEncryptionProfileConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetFieldLevelEncryptionProfileConfigCommandOutput) => void): void;
            /**
                * <p>Gets the code of a CloudFront function. To get configuration information and metadata about
                * 			a function, use <code>DescribeFunction</code>.</p>
                * 		       <p>To get a function’s code, you must provide the function’s name and stage. To get these
                * 			values, you can use <code>ListFunctions</code>.</p>
                */
            getFunction(args: GetFunctionCommandInput, options?: __HttpHandlerOptions): Promise<GetFunctionCommandOutput>;
            getFunction(args: GetFunctionCommandInput, cb: (err: any, data?: GetFunctionCommandOutput) => void): void;
            getFunction(args: GetFunctionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetFunctionCommandOutput) => void): void;
            /**
                * <p>Get the information about an invalidation. </p>
                */
            getInvalidation(args: GetInvalidationCommandInput, options?: __HttpHandlerOptions): Promise<GetInvalidationCommandOutput>;
            getInvalidation(args: GetInvalidationCommandInput, cb: (err: any, data?: GetInvalidationCommandOutput) => void): void;
            getInvalidation(args: GetInvalidationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetInvalidationCommandOutput) => void): void;
            /**
                * <p>Gets a key group, including the date and time when the key group was last modified.</p>
                * 		       <p>To get a key group, you must provide the key group’s identifier. If the key group is
                * 			referenced in a distribution’s cache behavior, you can get the key group’s identifier
                * 			using <code>ListDistributions</code> or <code>GetDistribution</code>. If the key group
                * 			is not referenced in a cache behavior, you can get the identifier using
                * 			<code>ListKeyGroups</code>.</p>
                */
            getKeyGroup(args: GetKeyGroupCommandInput, options?: __HttpHandlerOptions): Promise<GetKeyGroupCommandOutput>;
            getKeyGroup(args: GetKeyGroupCommandInput, cb: (err: any, data?: GetKeyGroupCommandOutput) => void): void;
            getKeyGroup(args: GetKeyGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetKeyGroupCommandOutput) => void): void;
            /**
                * <p>Gets a key group configuration.</p>
                * 		       <p>To get a key group configuration, you must provide the key group’s identifier. If the
                * 			key group is referenced in a distribution’s cache behavior, you can get the key group’s
                * 			identifier using <code>ListDistributions</code> or <code>GetDistribution</code>. If the
                * 			key group is not referenced in a cache behavior, you can get the identifier using
                * 			<code>ListKeyGroups</code>.</p>
                */
            getKeyGroupConfig(args: GetKeyGroupConfigCommandInput, options?: __HttpHandlerOptions): Promise<GetKeyGroupConfigCommandOutput>;
            getKeyGroupConfig(args: GetKeyGroupConfigCommandInput, cb: (err: any, data?: GetKeyGroupConfigCommandOutput) => void): void;
            getKeyGroupConfig(args: GetKeyGroupConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetKeyGroupConfigCommandOutput) => void): void;
            /**
                * <p>Gets information about whether additional CloudWatch metrics are enabled for the specified
                * 			CloudFront distribution.</p>
                */
            getMonitoringSubscription(args: GetMonitoringSubscriptionCommandInput, options?: __HttpHandlerOptions): Promise<GetMonitoringSubscriptionCommandOutput>;
            getMonitoringSubscription(args: GetMonitoringSubscriptionCommandInput, cb: (err: any, data?: GetMonitoringSubscriptionCommandOutput) => void): void;
            getMonitoringSubscription(args: GetMonitoringSubscriptionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetMonitoringSubscriptionCommandOutput) => void): void;
            /**
                * <p>Gets an origin request policy, including the following metadata:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>The policy’s identifier.</p>
                * 			         </li>
                *             <li>
                * 				           <p>The date and time when the policy was last modified.</p>
                * 			         </li>
                *          </ul>
                * 		       <p>To get an origin request policy, you must provide the policy’s identifier. If the origin
                * 			request policy is attached to a distribution’s cache behavior, you can get the policy’s
                * 			identifier using <code>ListDistributions</code> or <code>GetDistribution</code>. If the
                * 			origin request policy is not attached to a cache behavior, you can get the identifier
                * 			using <code>ListOriginRequestPolicies</code>.</p>
                */
            getOriginRequestPolicy(args: GetOriginRequestPolicyCommandInput, options?: __HttpHandlerOptions): Promise<GetOriginRequestPolicyCommandOutput>;
            getOriginRequestPolicy(args: GetOriginRequestPolicyCommandInput, cb: (err: any, data?: GetOriginRequestPolicyCommandOutput) => void): void;
            getOriginRequestPolicy(args: GetOriginRequestPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetOriginRequestPolicyCommandOutput) => void): void;
            /**
                * <p>Gets an origin request policy configuration.</p>
                * 		       <p>To get an origin request policy configuration, you must provide the policy’s identifier. If
                * 			the origin request policy is attached to a distribution’s cache behavior, you can get
                * 			the policy’s identifier using <code>ListDistributions</code> or
                * 			<code>GetDistribution</code>. If the origin request policy is not attached to a cache
                * 			behavior, you can get the identifier using
                * 			<code>ListOriginRequestPolicies</code>.</p>
                */
            getOriginRequestPolicyConfig(args: GetOriginRequestPolicyConfigCommandInput, options?: __HttpHandlerOptions): Promise<GetOriginRequestPolicyConfigCommandOutput>;
            getOriginRequestPolicyConfig(args: GetOriginRequestPolicyConfigCommandInput, cb: (err: any, data?: GetOriginRequestPolicyConfigCommandOutput) => void): void;
            getOriginRequestPolicyConfig(args: GetOriginRequestPolicyConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetOriginRequestPolicyConfigCommandOutput) => void): void;
            /**
                * <p>Gets a public key.</p>
                */
            getPublicKey(args: GetPublicKeyCommandInput, options?: __HttpHandlerOptions): Promise<GetPublicKeyCommandOutput>;
            getPublicKey(args: GetPublicKeyCommandInput, cb: (err: any, data?: GetPublicKeyCommandOutput) => void): void;
            getPublicKey(args: GetPublicKeyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetPublicKeyCommandOutput) => void): void;
            /**
                * <p>Gets a public key configuration.</p>
                */
            getPublicKeyConfig(args: GetPublicKeyConfigCommandInput, options?: __HttpHandlerOptions): Promise<GetPublicKeyConfigCommandOutput>;
            getPublicKeyConfig(args: GetPublicKeyConfigCommandInput, cb: (err: any, data?: GetPublicKeyConfigCommandOutput) => void): void;
            getPublicKeyConfig(args: GetPublicKeyConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetPublicKeyConfigCommandOutput) => void): void;
            /**
                * <p>Gets a real-time log configuration.</p>
                * 		       <p>To get a real-time log configuration, you can provide the configuration’s name or its Amazon
                * 			Resource Name (ARN). You must provide at least one. If you provide both, CloudFront uses the
                * 			name to identify the real-time log configuration to get.</p>
                */
            getRealtimeLogConfig(args: GetRealtimeLogConfigCommandInput, options?: __HttpHandlerOptions): Promise<GetRealtimeLogConfigCommandOutput>;
            getRealtimeLogConfig(args: GetRealtimeLogConfigCommandInput, cb: (err: any, data?: GetRealtimeLogConfigCommandOutput) => void): void;
            getRealtimeLogConfig(args: GetRealtimeLogConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetRealtimeLogConfigCommandOutput) => void): void;
            /**
                * <p>Gets a response headers policy, including metadata (the policy’s identifier and the date and
                * 			time when the policy was last modified).</p>
                * 		       <p>To get a response headers policy, you must provide the policy’s identifier. If the
                * 			response headers policy is attached to a distribution’s cache behavior, you can get the
                * 			policy’s identifier using <code>ListDistributions</code> or
                * 			<code>GetDistribution</code>. If the response headers policy is not attached to a cache
                * 			behavior, you can get the identifier using
                * 			<code>ListResponseHeadersPolicies</code>.</p>
                */
            getResponseHeadersPolicy(args: GetResponseHeadersPolicyCommandInput, options?: __HttpHandlerOptions): Promise<GetResponseHeadersPolicyCommandOutput>;
            getResponseHeadersPolicy(args: GetResponseHeadersPolicyCommandInput, cb: (err: any, data?: GetResponseHeadersPolicyCommandOutput) => void): void;
            getResponseHeadersPolicy(args: GetResponseHeadersPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetResponseHeadersPolicyCommandOutput) => void): void;
            /**
                * <p>Gets a response headers policy configuration.</p>
                * 		       <p>To get a response headers policy configuration, you must provide the policy’s
                * 			identifier. If the response headers policy is attached to a distribution’s cache
                * 			behavior, you can get the policy’s identifier using <code>ListDistributions</code> or
                * 			<code>GetDistribution</code>. If the response headers policy is not attached to a
                * 			cache behavior, you can get the identifier using
                * 			<code>ListResponseHeadersPolicies</code>.</p>
                */
            getResponseHeadersPolicyConfig(args: GetResponseHeadersPolicyConfigCommandInput, options?: __HttpHandlerOptions): Promise<GetResponseHeadersPolicyConfigCommandOutput>;
            getResponseHeadersPolicyConfig(args: GetResponseHeadersPolicyConfigCommandInput, cb: (err: any, data?: GetResponseHeadersPolicyConfigCommandOutput) => void): void;
            getResponseHeadersPolicyConfig(args: GetResponseHeadersPolicyConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetResponseHeadersPolicyConfigCommandOutput) => void): void;
            /**
                * <p>Gets information about a specified RTMP distribution, including the distribution configuration.</p>
                */
            getStreamingDistribution(args: GetStreamingDistributionCommandInput, options?: __HttpHandlerOptions): Promise<GetStreamingDistributionCommandOutput>;
            getStreamingDistribution(args: GetStreamingDistributionCommandInput, cb: (err: any, data?: GetStreamingDistributionCommandOutput) => void): void;
            getStreamingDistribution(args: GetStreamingDistributionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetStreamingDistributionCommandOutput) => void): void;
            /**
                * <p>Get the configuration information about a streaming distribution. </p>
                */
            getStreamingDistributionConfig(args: GetStreamingDistributionConfigCommandInput, options?: __HttpHandlerOptions): Promise<GetStreamingDistributionConfigCommandOutput>;
            getStreamingDistributionConfig(args: GetStreamingDistributionConfigCommandInput, cb: (err: any, data?: GetStreamingDistributionConfigCommandOutput) => void): void;
            getStreamingDistributionConfig(args: GetStreamingDistributionConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetStreamingDistributionConfigCommandOutput) => void): void;
            /**
                * <p>Gets a list of cache policies.</p>
                * 		       <p>You can optionally apply a filter to return only the managed policies created by Amazon Web Services, or
                * 			only the custom policies created in your Amazon Web Services account.</p>
                * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
                * 			the total number of items in the list exceeds the maximum that you specify, or the
                * 			default maximum, the response is paginated. To get the next page of items, send a
                * 			subsequent request that specifies the <code>NextMarker</code> value from the current
                * 			response as the <code>Marker</code> value in the subsequent request.</p>
                */
            listCachePolicies(args: ListCachePoliciesCommandInput, options?: __HttpHandlerOptions): Promise<ListCachePoliciesCommandOutput>;
            listCachePolicies(args: ListCachePoliciesCommandInput, cb: (err: any, data?: ListCachePoliciesCommandOutput) => void): void;
            listCachePolicies(args: ListCachePoliciesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListCachePoliciesCommandOutput) => void): void;
            /**
                * <p>Lists origin access identities.</p>
                */
            listCloudFrontOriginAccessIdentities(args: ListCloudFrontOriginAccessIdentitiesCommandInput, options?: __HttpHandlerOptions): Promise<ListCloudFrontOriginAccessIdentitiesCommandOutput>;
            listCloudFrontOriginAccessIdentities(args: ListCloudFrontOriginAccessIdentitiesCommandInput, cb: (err: any, data?: ListCloudFrontOriginAccessIdentitiesCommandOutput) => void): void;
            listCloudFrontOriginAccessIdentities(args: ListCloudFrontOriginAccessIdentitiesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListCloudFrontOriginAccessIdentitiesCommandOutput) => void): void;
            /**
                * <p>Gets a list of aliases (also called CNAMEs or alternate domain names) that conflict or
                * 			overlap with the provided alias, and the associated CloudFront distributions and Amazon Web Services
                * 			accounts for each conflicting alias. In the returned list, the distribution and account
                * 			IDs are partially hidden, which allows you to identify the distributions and accounts
                * 			that you own, but helps to protect the information of ones that you don’t own.</p>
                * 		       <p>Use this operation to find aliases that are in use in CloudFront that conflict or overlap
                * 			with the provided alias. For example, if you provide <code>www.example.com</code> as
                * 			input, the returned list can include <code>www.example.com</code> and the overlapping
                * 			wildcard alternate domain name (<code>*.example.com</code>), if they exist. If you
                * 			provide <code>*.example.com</code> as input, the returned list can include
                * 			<code>*.example.com</code> and any alternate domain names covered by that wildcard (for
                * 			example, <code>www.example.com</code>, <code>test.example.com</code>,
                * 			<code>dev.example.com</code>, and so on), if they exist.</p>
                * 		       <p>To list conflicting aliases, you provide the alias to search and the ID of a distribution in
                * 			your account that has an attached SSL/TLS certificate that includes the provided alias.
                * 			For more information, including how to set up the distribution and certificate, see
                * 			<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/CNAMEs.html#alternate-domain-names-move">Moving an alternate domain name to a different distribution</a>
                * 			in the <i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
                * 			the total number of items in the list exceeds the maximum that you specify, or the
                * 			default maximum, the response is paginated. To get the next page of items, send a
                * 			subsequent request that specifies the <code>NextMarker</code> value from the current
                * 			response as the <code>Marker</code> value in the subsequent request.</p>
                */
            listConflictingAliases(args: ListConflictingAliasesCommandInput, options?: __HttpHandlerOptions): Promise<ListConflictingAliasesCommandOutput>;
            listConflictingAliases(args: ListConflictingAliasesCommandInput, cb: (err: any, data?: ListConflictingAliasesCommandOutput) => void): void;
            listConflictingAliases(args: ListConflictingAliasesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListConflictingAliasesCommandOutput) => void): void;
            /**
                * <p>List CloudFront distributions.</p>
                */
            listDistributions(args: ListDistributionsCommandInput, options?: __HttpHandlerOptions): Promise<ListDistributionsCommandOutput>;
            listDistributions(args: ListDistributionsCommandInput, cb: (err: any, data?: ListDistributionsCommandOutput) => void): void;
            listDistributions(args: ListDistributionsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListDistributionsCommandOutput) => void): void;
            /**
                * <p>Gets a list of distribution IDs for distributions that have a cache behavior that’s
                * 			associated with the specified cache policy.</p>
                * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
                * 			the total number of items in the list exceeds the maximum that you specify, or the
                * 			default maximum, the response is paginated. To get the next page of items, send a
                * 			subsequent request that specifies the <code>NextMarker</code> value from the current
                * 			response as the <code>Marker</code> value in the subsequent request.</p>
                */
            listDistributionsByCachePolicyId(args: ListDistributionsByCachePolicyIdCommandInput, options?: __HttpHandlerOptions): Promise<ListDistributionsByCachePolicyIdCommandOutput>;
            listDistributionsByCachePolicyId(args: ListDistributionsByCachePolicyIdCommandInput, cb: (err: any, data?: ListDistributionsByCachePolicyIdCommandOutput) => void): void;
            listDistributionsByCachePolicyId(args: ListDistributionsByCachePolicyIdCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListDistributionsByCachePolicyIdCommandOutput) => void): void;
            /**
                * <p>Gets a list of distribution IDs for distributions that have a cache behavior that references
                * 			the specified key group.</p>
                * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
                * 			the total number of items in the list exceeds the maximum that you specify, or the
                * 			default maximum, the response is paginated. To get the next page of items, send a
                * 			subsequent request that specifies the <code>NextMarker</code> value from the current
                * 			response as the <code>Marker</code> value in the subsequent request.</p>
                */
            listDistributionsByKeyGroup(args: ListDistributionsByKeyGroupCommandInput, options?: __HttpHandlerOptions): Promise<ListDistributionsByKeyGroupCommandOutput>;
            listDistributionsByKeyGroup(args: ListDistributionsByKeyGroupCommandInput, cb: (err: any, data?: ListDistributionsByKeyGroupCommandOutput) => void): void;
            listDistributionsByKeyGroup(args: ListDistributionsByKeyGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListDistributionsByKeyGroupCommandOutput) => void): void;
            /**
                * <p>Gets a list of distribution IDs for distributions that have a cache behavior that’s
                * 			associated with the specified origin request policy.</p>
                * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
                * 			the total number of items in the list exceeds the maximum that you specify, or the
                * 			default maximum, the response is paginated. To get the next page of items, send a
                * 			subsequent request that specifies the <code>NextMarker</code> value from the current
                * 			response as the <code>Marker</code> value in the subsequent request.</p>
                */
            listDistributionsByOriginRequestPolicyId(args: ListDistributionsByOriginRequestPolicyIdCommandInput, options?: __HttpHandlerOptions): Promise<ListDistributionsByOriginRequestPolicyIdCommandOutput>;
            listDistributionsByOriginRequestPolicyId(args: ListDistributionsByOriginRequestPolicyIdCommandInput, cb: (err: any, data?: ListDistributionsByOriginRequestPolicyIdCommandOutput) => void): void;
            listDistributionsByOriginRequestPolicyId(args: ListDistributionsByOriginRequestPolicyIdCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListDistributionsByOriginRequestPolicyIdCommandOutput) => void): void;
            /**
                * <p>Gets a list of distributions that have a cache behavior that’s associated with the specified
                * 			real-time log configuration.</p>
                * 		       <p>You can specify the real-time log configuration by its name or its Amazon Resource Name
                * 			(ARN). You must provide at least one. If you provide both, CloudFront uses the name to
                * 			identify the real-time log configuration to list distributions for.</p>
                * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
                * 			the total number of items in the list exceeds the maximum that you specify, or the
                * 			default maximum, the response is paginated. To get the next page of items, send a
                * 			subsequent request that specifies the <code>NextMarker</code> value from the current
                * 			response as the <code>Marker</code> value in the subsequent request. </p>
                */
            listDistributionsByRealtimeLogConfig(args: ListDistributionsByRealtimeLogConfigCommandInput, options?: __HttpHandlerOptions): Promise<ListDistributionsByRealtimeLogConfigCommandOutput>;
            listDistributionsByRealtimeLogConfig(args: ListDistributionsByRealtimeLogConfigCommandInput, cb: (err: any, data?: ListDistributionsByRealtimeLogConfigCommandOutput) => void): void;
            listDistributionsByRealtimeLogConfig(args: ListDistributionsByRealtimeLogConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListDistributionsByRealtimeLogConfigCommandOutput) => void): void;
            /**
                * <p>Gets a list of distribution IDs for distributions that have a cache behavior that’s
                * 			associated with the specified response headers policy.</p>
                * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
                * 			the total number of items in the list exceeds the maximum that you specify, or the
                * 			default maximum, the response is paginated. To get the next page of items, send a
                * 			subsequent request that specifies the <code>NextMarker</code> value from the current
                * 			response as the <code>Marker</code> value in the subsequent request.</p>
                */
            listDistributionsByResponseHeadersPolicyId(args: ListDistributionsByResponseHeadersPolicyIdCommandInput, options?: __HttpHandlerOptions): Promise<ListDistributionsByResponseHeadersPolicyIdCommandOutput>;
            listDistributionsByResponseHeadersPolicyId(args: ListDistributionsByResponseHeadersPolicyIdCommandInput, cb: (err: any, data?: ListDistributionsByResponseHeadersPolicyIdCommandOutput) => void): void;
            listDistributionsByResponseHeadersPolicyId(args: ListDistributionsByResponseHeadersPolicyIdCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListDistributionsByResponseHeadersPolicyIdCommandOutput) => void): void;
            /**
                * <p>List the distributions that are associated with a specified WAF web ACL.</p>
                */
            listDistributionsByWebACLId(args: ListDistributionsByWebACLIdCommandInput, options?: __HttpHandlerOptions): Promise<ListDistributionsByWebACLIdCommandOutput>;
            listDistributionsByWebACLId(args: ListDistributionsByWebACLIdCommandInput, cb: (err: any, data?: ListDistributionsByWebACLIdCommandOutput) => void): void;
            listDistributionsByWebACLId(args: ListDistributionsByWebACLIdCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListDistributionsByWebACLIdCommandOutput) => void): void;
            /**
                * <p>List all field-level encryption configurations that have been created in CloudFront for this account.</p>
                */
            listFieldLevelEncryptionConfigs(args: ListFieldLevelEncryptionConfigsCommandInput, options?: __HttpHandlerOptions): Promise<ListFieldLevelEncryptionConfigsCommandOutput>;
            listFieldLevelEncryptionConfigs(args: ListFieldLevelEncryptionConfigsCommandInput, cb: (err: any, data?: ListFieldLevelEncryptionConfigsCommandOutput) => void): void;
            listFieldLevelEncryptionConfigs(args: ListFieldLevelEncryptionConfigsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListFieldLevelEncryptionConfigsCommandOutput) => void): void;
            /**
                * <p>Request a list of field-level encryption profiles that have been created in CloudFront for this account.</p>
                */
            listFieldLevelEncryptionProfiles(args: ListFieldLevelEncryptionProfilesCommandInput, options?: __HttpHandlerOptions): Promise<ListFieldLevelEncryptionProfilesCommandOutput>;
            listFieldLevelEncryptionProfiles(args: ListFieldLevelEncryptionProfilesCommandInput, cb: (err: any, data?: ListFieldLevelEncryptionProfilesCommandOutput) => void): void;
            listFieldLevelEncryptionProfiles(args: ListFieldLevelEncryptionProfilesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListFieldLevelEncryptionProfilesCommandOutput) => void): void;
            /**
                * <p>Gets a list of all CloudFront functions in your Amazon Web Services account.</p>
                * 		       <p>You can optionally apply a filter to return only the functions that are in the
                * 			specified stage, either <code>DEVELOPMENT</code> or <code>LIVE</code>.</p>
                * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
                * 			the total number of items in the list exceeds the maximum that you specify, or the
                * 			default maximum, the response is paginated. To get the next page of items, send a
                * 			subsequent request that specifies the <code>NextMarker</code> value from the current
                * 			response as the <code>Marker</code> value in the subsequent request.</p>
                */
            listFunctions(args: ListFunctionsCommandInput, options?: __HttpHandlerOptions): Promise<ListFunctionsCommandOutput>;
            listFunctions(args: ListFunctionsCommandInput, cb: (err: any, data?: ListFunctionsCommandOutput) => void): void;
            listFunctions(args: ListFunctionsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListFunctionsCommandOutput) => void): void;
            /**
                * <p>Lists invalidation batches. </p>
                */
            listInvalidations(args: ListInvalidationsCommandInput, options?: __HttpHandlerOptions): Promise<ListInvalidationsCommandOutput>;
            listInvalidations(args: ListInvalidationsCommandInput, cb: (err: any, data?: ListInvalidationsCommandOutput) => void): void;
            listInvalidations(args: ListInvalidationsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListInvalidationsCommandOutput) => void): void;
            /**
                * <p>Gets a list of key groups.</p>
                * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
                * 			the total number of items in the list exceeds the maximum that you specify, or the
                * 			default maximum, the response is paginated. To get the next page of items, send a
                * 			subsequent request that specifies the <code>NextMarker</code> value from the current
                * 			response as the <code>Marker</code> value in the subsequent request.</p>
                */
            listKeyGroups(args: ListKeyGroupsCommandInput, options?: __HttpHandlerOptions): Promise<ListKeyGroupsCommandOutput>;
            listKeyGroups(args: ListKeyGroupsCommandInput, cb: (err: any, data?: ListKeyGroupsCommandOutput) => void): void;
            listKeyGroups(args: ListKeyGroupsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListKeyGroupsCommandOutput) => void): void;
            /**
                * <p>Gets a list of origin request policies.</p>
                * 		       <p>You can optionally apply a filter to return only the managed policies created by Amazon Web Services, or
                * 			only the custom policies created in your Amazon Web Services account.</p>
                * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
                * 			the total number of items in the list exceeds the maximum that you specify, or the
                * 			default maximum, the response is paginated. To get the next page of items, send a
                * 			subsequent request that specifies the <code>NextMarker</code> value from the current
                * 			response as the <code>Marker</code> value in the subsequent request.</p>
                */
            listOriginRequestPolicies(args: ListOriginRequestPoliciesCommandInput, options?: __HttpHandlerOptions): Promise<ListOriginRequestPoliciesCommandOutput>;
            listOriginRequestPolicies(args: ListOriginRequestPoliciesCommandInput, cb: (err: any, data?: ListOriginRequestPoliciesCommandOutput) => void): void;
            listOriginRequestPolicies(args: ListOriginRequestPoliciesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListOriginRequestPoliciesCommandOutput) => void): void;
            /**
                * <p>List all public keys that have been added to CloudFront for this account.</p>
                */
            listPublicKeys(args: ListPublicKeysCommandInput, options?: __HttpHandlerOptions): Promise<ListPublicKeysCommandOutput>;
            listPublicKeys(args: ListPublicKeysCommandInput, cb: (err: any, data?: ListPublicKeysCommandOutput) => void): void;
            listPublicKeys(args: ListPublicKeysCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListPublicKeysCommandOutput) => void): void;
            /**
                * <p>Gets a list of real-time log configurations.</p>
                * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
                * 			the total number of items in the list exceeds the maximum that you specify, or the
                * 			default maximum, the response is paginated. To get the next page of items, send a
                * 			subsequent request that specifies the <code>NextMarker</code> value from the current
                * 			response as the <code>Marker</code> value in the subsequent request. </p>
                */
            listRealtimeLogConfigs(args: ListRealtimeLogConfigsCommandInput, options?: __HttpHandlerOptions): Promise<ListRealtimeLogConfigsCommandOutput>;
            listRealtimeLogConfigs(args: ListRealtimeLogConfigsCommandInput, cb: (err: any, data?: ListRealtimeLogConfigsCommandOutput) => void): void;
            listRealtimeLogConfigs(args: ListRealtimeLogConfigsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListRealtimeLogConfigsCommandOutput) => void): void;
            /**
                * <p>Gets a list of response headers policies.</p>
                * 		       <p>You can optionally apply a filter to get only the managed policies created by Amazon Web Services,
                * 			or only the custom policies created in your Amazon Web Services account.</p>
                * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
                * 			the total number of items in the list exceeds the maximum that you specify, or the
                * 			default maximum, the response is paginated. To get the next page of items, send a
                * 			subsequent request that specifies the <code>NextMarker</code> value from the current
                * 			response as the <code>Marker</code> value in the subsequent request.</p>
                */
            listResponseHeadersPolicies(args: ListResponseHeadersPoliciesCommandInput, options?: __HttpHandlerOptions): Promise<ListResponseHeadersPoliciesCommandOutput>;
            listResponseHeadersPolicies(args: ListResponseHeadersPoliciesCommandInput, cb: (err: any, data?: ListResponseHeadersPoliciesCommandOutput) => void): void;
            listResponseHeadersPolicies(args: ListResponseHeadersPoliciesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListResponseHeadersPoliciesCommandOutput) => void): void;
            /**
                * <p>List streaming distributions. </p>
                */
            listStreamingDistributions(args: ListStreamingDistributionsCommandInput, options?: __HttpHandlerOptions): Promise<ListStreamingDistributionsCommandOutput>;
            listStreamingDistributions(args: ListStreamingDistributionsCommandInput, cb: (err: any, data?: ListStreamingDistributionsCommandOutput) => void): void;
            listStreamingDistributions(args: ListStreamingDistributionsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListStreamingDistributionsCommandOutput) => void): void;
            /**
                * <p>List tags for a CloudFront resource.</p>
                */
            listTagsForResource(args: ListTagsForResourceCommandInput, options?: __HttpHandlerOptions): Promise<ListTagsForResourceCommandOutput>;
            listTagsForResource(args: ListTagsForResourceCommandInput, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            listTagsForResource(args: ListTagsForResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            /**
                * <p>Publishes a CloudFront function by copying the function code from the <code>DEVELOPMENT</code>
                * 			stage to <code>LIVE</code>. This automatically updates all cache behaviors that are
                * 			using this function to use the newly published copy in the <code>LIVE</code>
                * 			stage.</p>
                * 		       <p>When a function is published to the <code>LIVE</code> stage, you can attach the function to
                * 			a distribution’s cache behavior, using the function’s Amazon Resource Name (ARN).</p>
                * 		       <p>To publish a function, you must provide the function’s name and version (<code>ETag</code>
                * 			value). To get these values, you can use <code>ListFunctions</code> and
                * 			<code>DescribeFunction</code>.</p>
                */
            publishFunction(args: PublishFunctionCommandInput, options?: __HttpHandlerOptions): Promise<PublishFunctionCommandOutput>;
            publishFunction(args: PublishFunctionCommandInput, cb: (err: any, data?: PublishFunctionCommandOutput) => void): void;
            publishFunction(args: PublishFunctionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PublishFunctionCommandOutput) => void): void;
            /**
                * <p>Add tags to a CloudFront resource.</p>
                */
            tagResource(args: TagResourceCommandInput, options?: __HttpHandlerOptions): Promise<TagResourceCommandOutput>;
            tagResource(args: TagResourceCommandInput, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            tagResource(args: TagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            /**
                * <p>Tests a CloudFront function.</p>
                * 		       <p>To test a function, you provide an <i>event object</i> that represents an HTTP
                * 			request or response that your CloudFront distribution could receive in production. CloudFront runs
                * 			the function, passing it the event object that you provided, and returns the function’s
                * 			result (the modified event object) in the response. The response also contains function
                * 			logs and error messages, if any exist. For more information about testing functions, see
                * 			<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/managing-functions.html#test-function">Testing functions</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>To test a function, you provide the function’s name and version (<code>ETag</code> value)
                * 			along with the event object. To get the function’s name and version, you can use
                * 			<code>ListFunctions</code> and <code>DescribeFunction</code>.</p>
                */
            testFunction(args: TestFunctionCommandInput, options?: __HttpHandlerOptions): Promise<TestFunctionCommandOutput>;
            testFunction(args: TestFunctionCommandInput, cb: (err: any, data?: TestFunctionCommandOutput) => void): void;
            testFunction(args: TestFunctionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TestFunctionCommandOutput) => void): void;
            /**
                * <p>Remove tags from a CloudFront resource.</p>
                */
            untagResource(args: UntagResourceCommandInput, options?: __HttpHandlerOptions): Promise<UntagResourceCommandOutput>;
            untagResource(args: UntagResourceCommandInput, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            untagResource(args: UntagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            /**
                * <p>Updates a cache policy configuration.</p>
                * 		       <p>When you update a cache policy configuration, all the fields are updated with the
                * 			values provided in the request. You cannot update some fields independent of others. To
                * 			update a cache policy configuration:</p>
                * 		       <ol>
                *             <li>
                * 				           <p>Use <code>GetCachePolicyConfig</code> to get the current configuration.</p>
                * 			         </li>
                *             <li>
                * 				           <p>Locally modify the fields in the cache policy configuration that you want to
                * 					update.</p>
                * 			         </li>
                *             <li>
                * 				           <p>Call <code>UpdateCachePolicy</code> by providing the entire cache policy
                * 					configuration, including the fields that you modified and those that you
                * 					didn’t.</p>
                * 			         </li>
                *          </ol>
                */
            updateCachePolicy(args: UpdateCachePolicyCommandInput, options?: __HttpHandlerOptions): Promise<UpdateCachePolicyCommandOutput>;
            updateCachePolicy(args: UpdateCachePolicyCommandInput, cb: (err: any, data?: UpdateCachePolicyCommandOutput) => void): void;
            updateCachePolicy(args: UpdateCachePolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateCachePolicyCommandOutput) => void): void;
            /**
                * <p>Update an origin access identity. </p>
                */
            updateCloudFrontOriginAccessIdentity(args: UpdateCloudFrontOriginAccessIdentityCommandInput, options?: __HttpHandlerOptions): Promise<UpdateCloudFrontOriginAccessIdentityCommandOutput>;
            updateCloudFrontOriginAccessIdentity(args: UpdateCloudFrontOriginAccessIdentityCommandInput, cb: (err: any, data?: UpdateCloudFrontOriginAccessIdentityCommandOutput) => void): void;
            updateCloudFrontOriginAccessIdentity(args: UpdateCloudFrontOriginAccessIdentityCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateCloudFrontOriginAccessIdentityCommandOutput) => void): void;
            /**
                * <p>Updates the configuration for a web distribution. </p>
                * 		       <important>
                *             <p>When you update a distribution, there are more required fields than when you create a distribution.
                * 			When you update your distribution by using this API action, follow the steps here to get the current configuration
                * 			and then make your updates, to make sure that you include all of the required fields. To view a summary,
                * 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-overview-required-fields.html">Required
                * 				Fields for Create Distribution and Update Distribution</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                *          </important>
                * 		       <p>The update process includes getting the current distribution configuration, updating the XML document that is
                * 			returned to make your changes, and then submitting an <code>UpdateDistribution</code> request to make the updates.</p>
                * 		       <p>For information about updating a distribution using the CloudFront console instead, see
                * 			<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-creating-console.html">Creating a
                * 				Distribution</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                *
                * 		       <p>
                *             <b>To update a web distribution using the CloudFront API</b>
                *          </p>
                * 		       <ol>
                *             <li>
                *                <p>Submit a
                * 				<a href="https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_GetDistributionConfig.html">GetDistributionConfig</a>
                * 				request to get the current configuration and an <code>Etag</code> header
                * 				for the distribution.</p>
                * 				           <note>
                *                   <p>If you update the distribution again, you must get a new <code>Etag</code> header.</p>
                *                </note>
                * 			         </li>
                *             <li>
                *                <p>Update the XML document that was returned in the response to your <code>GetDistributionConfig</code> request to include
                * 				your changes. </p>
                * 				           <important>
                * 					             <p>When you edit the XML file, be aware of the following:</p>
                * 					             <ul>
                *                      <li>
                *                         <p>You must strip out the ETag parameter that is returned.</p>
                *                      </li>
                *                      <li>
                *                         <p>Additional fields are required when you update a distribution. There may be fields included in the
                * 							XML file for features that you haven't configured for your distribution. This is expected and required to
                * 							successfully update the distribution.</p>
                *                      </li>
                *                      <li>
                *                         <p>You can't change the value of <code>CallerReference</code>. If you try to change this value, CloudFront returns an
                * 							<code>IllegalUpdate</code> error. </p>
                *                      </li>
                *                      <li>
                *                         <p>The new configuration replaces the existing configuration; the values that you specify in an
                * 							<code>UpdateDistribution</code> request are not merged into your existing configuration. When you add, delete, or
                * 							replace values in an element that allows multiple values (for example, <code>CNAME</code>), you must specify all of the
                * 							values that you want to appear in the updated distribution. In addition,
                * 							you must update the corresponding <code>Quantity</code> element.</p>
                *                      </li>
                *                   </ul>
                *                </important>
                * 			         </li>
                *             <li>
                *                <p>Submit an <code>UpdateDistribution</code> request to update the configuration for your distribution:</p>
                * 				           <ul>
                *                   <li>
                *                      <p>In the request body, include the XML document that you updated in Step 2. The request body must include an
                * 						XML document with a <code>DistributionConfig</code> element.</p>
                *                   </li>
                *                   <li>
                *                      <p>Set the value of the HTTP <code>If-Match</code> header to the value of the <code>ETag</code> header that CloudFront returned
                * 						when you submitted the <code>GetDistributionConfig</code> request in Step 1.</p>
                *                   </li>
                *                </ul>
                * 			         </li>
                *             <li>
                *                <p>Review the response to the <code>UpdateDistribution</code> request to confirm that the configuration was
                * 				successfully updated.</p>
                *             </li>
                *             <li>
                *                <p>Optional: Submit a
                * 				<a href="https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_GetDistribution.html">GetDistribution</a>
                * 				request to confirm that your changes have propagated.
                * 				When propagation is complete, the value of <code>Status</code> is <code>Deployed</code>.</p>
                * 			         </li>
                *          </ol>
                */
            updateDistribution(args: UpdateDistributionCommandInput, options?: __HttpHandlerOptions): Promise<UpdateDistributionCommandOutput>;
            updateDistribution(args: UpdateDistributionCommandInput, cb: (err: any, data?: UpdateDistributionCommandOutput) => void): void;
            updateDistribution(args: UpdateDistributionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateDistributionCommandOutput) => void): void;
            /**
                * <p>Update a field-level encryption configuration. </p>
                */
            updateFieldLevelEncryptionConfig(args: UpdateFieldLevelEncryptionConfigCommandInput, options?: __HttpHandlerOptions): Promise<UpdateFieldLevelEncryptionConfigCommandOutput>;
            updateFieldLevelEncryptionConfig(args: UpdateFieldLevelEncryptionConfigCommandInput, cb: (err: any, data?: UpdateFieldLevelEncryptionConfigCommandOutput) => void): void;
            updateFieldLevelEncryptionConfig(args: UpdateFieldLevelEncryptionConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateFieldLevelEncryptionConfigCommandOutput) => void): void;
            /**
                * <p>Update a field-level encryption profile. </p>
                */
            updateFieldLevelEncryptionProfile(args: UpdateFieldLevelEncryptionProfileCommandInput, options?: __HttpHandlerOptions): Promise<UpdateFieldLevelEncryptionProfileCommandOutput>;
            updateFieldLevelEncryptionProfile(args: UpdateFieldLevelEncryptionProfileCommandInput, cb: (err: any, data?: UpdateFieldLevelEncryptionProfileCommandOutput) => void): void;
            updateFieldLevelEncryptionProfile(args: UpdateFieldLevelEncryptionProfileCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateFieldLevelEncryptionProfileCommandOutput) => void): void;
            /**
                * <p>Updates a CloudFront function.</p>
                * 		       <p>You can update a function’s code or the comment that describes the function. You
                * 			cannot update a function’s name.</p>
                * 		       <p>To update a function, you provide the function’s name and version (<code>ETag</code> value)
                * 			along with the updated function code. To get the name and version, you can use
                * 			<code>ListFunctions</code> and <code>DescribeFunction</code>.</p>
                */
            updateFunction(args: UpdateFunctionCommandInput, options?: __HttpHandlerOptions): Promise<UpdateFunctionCommandOutput>;
            updateFunction(args: UpdateFunctionCommandInput, cb: (err: any, data?: UpdateFunctionCommandOutput) => void): void;
            updateFunction(args: UpdateFunctionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateFunctionCommandOutput) => void): void;
            /**
                * <p>Updates a key group.</p>
                * 		       <p>When you update a key group, all the fields are updated with the values provided in
                * 			the request. You cannot update some fields independent of others. To update a key
                * 			group:</p>
                * 		       <ol>
                *             <li>
                * 				           <p>Get the current key group with <code>GetKeyGroup</code> or
                * 					<code>GetKeyGroupConfig</code>.</p>
                * 			         </li>
                *             <li>
                * 				           <p>Locally modify the fields in the key group that you want to update. For
                * 					example, add or remove public key IDs.</p>
                * 			         </li>
                *             <li>
                * 				           <p>Call <code>UpdateKeyGroup</code> with the entire key group object, including
                * 					the fields that you modified and those that you didn’t.</p>
                * 			         </li>
                *          </ol>
                */
            updateKeyGroup(args: UpdateKeyGroupCommandInput, options?: __HttpHandlerOptions): Promise<UpdateKeyGroupCommandOutput>;
            updateKeyGroup(args: UpdateKeyGroupCommandInput, cb: (err: any, data?: UpdateKeyGroupCommandOutput) => void): void;
            updateKeyGroup(args: UpdateKeyGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateKeyGroupCommandOutput) => void): void;
            /**
                * <p>Updates an origin request policy configuration.</p>
                * 		       <p>When you update an origin request policy configuration, all the fields are updated
                * 			with the values provided in the request. You cannot update some fields independent of
                * 			others. To update an origin request policy configuration:</p>
                * 		       <ol>
                *             <li>
                * 				           <p>Use <code>GetOriginRequestPolicyConfig</code> to get the current configuration.</p>
                * 			         </li>
                *             <li>
                * 				           <p>Locally modify the fields in the origin request policy configuration that you
                * 					want to update.</p>
                * 			         </li>
                *             <li>
                * 				           <p>Call <code>UpdateOriginRequestPolicy</code> by providing the entire origin
                * 					request policy configuration, including the fields that you modified and those
                * 					that you didn’t.</p>
                * 			         </li>
                *          </ol>
                */
            updateOriginRequestPolicy(args: UpdateOriginRequestPolicyCommandInput, options?: __HttpHandlerOptions): Promise<UpdateOriginRequestPolicyCommandOutput>;
            updateOriginRequestPolicy(args: UpdateOriginRequestPolicyCommandInput, cb: (err: any, data?: UpdateOriginRequestPolicyCommandOutput) => void): void;
            updateOriginRequestPolicy(args: UpdateOriginRequestPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateOriginRequestPolicyCommandOutput) => void): void;
            /**
                * <p>Update public key information. Note that the only value you can change is the comment.</p>
                */
            updatePublicKey(args: UpdatePublicKeyCommandInput, options?: __HttpHandlerOptions): Promise<UpdatePublicKeyCommandOutput>;
            updatePublicKey(args: UpdatePublicKeyCommandInput, cb: (err: any, data?: UpdatePublicKeyCommandOutput) => void): void;
            updatePublicKey(args: UpdatePublicKeyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdatePublicKeyCommandOutput) => void): void;
            /**
                * <p>Updates a real-time log configuration.</p>
                * 		       <p>When you update a real-time log configuration, all the parameters are updated with the
                * 			values provided in the request. You cannot update some parameters independent of others.
                * 			To update a real-time log configuration:</p>
                * 		       <ol>
                *             <li>
                * 				           <p>Call <code>GetRealtimeLogConfig</code> to get the current real-time log
                * 					configuration.</p>
                * 			         </li>
                *             <li>
                * 				           <p>Locally modify the parameters in the real-time log configuration that you want
                * 					to update.</p>
                * 			         </li>
                *             <li>
                * 				           <p>Call this API (<code>UpdateRealtimeLogConfig</code>) by providing the entire
                * 					real-time log configuration, including the parameters that you modified and
                * 					those that you didn’t.</p>
                * 			         </li>
                *          </ol>
                * 		       <p>You cannot update a real-time log configuration’s <code>Name</code> or
                * 			<code>ARN</code>.</p>
                */
            updateRealtimeLogConfig(args: UpdateRealtimeLogConfigCommandInput, options?: __HttpHandlerOptions): Promise<UpdateRealtimeLogConfigCommandOutput>;
            updateRealtimeLogConfig(args: UpdateRealtimeLogConfigCommandInput, cb: (err: any, data?: UpdateRealtimeLogConfigCommandOutput) => void): void;
            updateRealtimeLogConfig(args: UpdateRealtimeLogConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateRealtimeLogConfigCommandOutput) => void): void;
            /**
                * <p>Updates a response headers policy.</p>
                * 		       <p>When you update a response headers policy, the entire policy is replaced. You cannot
                * 			update some policy fields independent of others. To update a response headers policy
                * 			configuration:</p>
                * 		       <ol>
                *             <li>
                * 				           <p>Use <code>GetResponseHeadersPolicyConfig</code> to get the current policy’s
                * 					configuration.</p>
                * 			         </li>
                *             <li>
                * 				           <p>Modify the fields in the response headers policy configuration that you want
                * 					to update.</p>
                * 			         </li>
                *             <li>
                * 				           <p>Call <code>UpdateResponseHeadersPolicy</code>, providing the entire response
                * 					headers policy configuration, including the fields that you modified and those
                * 					that you didn’t.</p>
                * 			         </li>
                *          </ol>
                */
            updateResponseHeadersPolicy(args: UpdateResponseHeadersPolicyCommandInput, options?: __HttpHandlerOptions): Promise<UpdateResponseHeadersPolicyCommandOutput>;
            updateResponseHeadersPolicy(args: UpdateResponseHeadersPolicyCommandInput, cb: (err: any, data?: UpdateResponseHeadersPolicyCommandOutput) => void): void;
            updateResponseHeadersPolicy(args: UpdateResponseHeadersPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateResponseHeadersPolicyCommandOutput) => void): void;
            /**
                * <p>Update a streaming distribution. </p>
                */
            updateStreamingDistribution(args: UpdateStreamingDistributionCommandInput, options?: __HttpHandlerOptions): Promise<UpdateStreamingDistributionCommandOutput>;
            updateStreamingDistribution(args: UpdateStreamingDistributionCommandInput, cb: (err: any, data?: UpdateStreamingDistributionCommandOutput) => void): void;
            updateStreamingDistribution(args: UpdateStreamingDistributionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateStreamingDistributionCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { AssociateAliasCommandInput, AssociateAliasCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/AssociateAliasCommand";
    import { CreateCachePolicyCommandInput, CreateCachePolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateCachePolicyCommand";
    import { CreateCloudFrontOriginAccessIdentityCommandInput, CreateCloudFrontOriginAccessIdentityCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateCloudFrontOriginAccessIdentityCommand";
    import { CreateDistributionCommandInput, CreateDistributionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateDistributionCommand";
    import { CreateDistributionWithTagsCommandInput, CreateDistributionWithTagsCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateDistributionWithTagsCommand";
    import { CreateFieldLevelEncryptionConfigCommandInput, CreateFieldLevelEncryptionConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateFieldLevelEncryptionConfigCommand";
    import { CreateFieldLevelEncryptionProfileCommandInput, CreateFieldLevelEncryptionProfileCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateFieldLevelEncryptionProfileCommand";
    import { CreateFunctionCommandInput, CreateFunctionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateFunctionCommand";
    import { CreateInvalidationCommandInput, CreateInvalidationCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateInvalidationCommand";
    import { CreateKeyGroupCommandInput, CreateKeyGroupCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateKeyGroupCommand";
    import { CreateMonitoringSubscriptionCommandInput, CreateMonitoringSubscriptionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateMonitoringSubscriptionCommand";
    import { CreateOriginRequestPolicyCommandInput, CreateOriginRequestPolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateOriginRequestPolicyCommand";
    import { CreatePublicKeyCommandInput, CreatePublicKeyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreatePublicKeyCommand";
    import { CreateRealtimeLogConfigCommandInput, CreateRealtimeLogConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateRealtimeLogConfigCommand";
    import { CreateResponseHeadersPolicyCommandInput, CreateResponseHeadersPolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateResponseHeadersPolicyCommand";
    import { CreateStreamingDistributionCommandInput, CreateStreamingDistributionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateStreamingDistributionCommand";
    import { CreateStreamingDistributionWithTagsCommandInput, CreateStreamingDistributionWithTagsCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateStreamingDistributionWithTagsCommand";
    import { DeleteCachePolicyCommandInput, DeleteCachePolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteCachePolicyCommand";
    import { DeleteCloudFrontOriginAccessIdentityCommandInput, DeleteCloudFrontOriginAccessIdentityCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteCloudFrontOriginAccessIdentityCommand";
    import { DeleteDistributionCommandInput, DeleteDistributionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteDistributionCommand";
    import { DeleteFieldLevelEncryptionConfigCommandInput, DeleteFieldLevelEncryptionConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteFieldLevelEncryptionConfigCommand";
    import { DeleteFieldLevelEncryptionProfileCommandInput, DeleteFieldLevelEncryptionProfileCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteFieldLevelEncryptionProfileCommand";
    import { DeleteFunctionCommandInput, DeleteFunctionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteFunctionCommand";
    import { DeleteKeyGroupCommandInput, DeleteKeyGroupCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteKeyGroupCommand";
    import { DeleteMonitoringSubscriptionCommandInput, DeleteMonitoringSubscriptionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteMonitoringSubscriptionCommand";
    import { DeleteOriginRequestPolicyCommandInput, DeleteOriginRequestPolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteOriginRequestPolicyCommand";
    import { DeletePublicKeyCommandInput, DeletePublicKeyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeletePublicKeyCommand";
    import { DeleteRealtimeLogConfigCommandInput, DeleteRealtimeLogConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteRealtimeLogConfigCommand";
    import { DeleteResponseHeadersPolicyCommandInput, DeleteResponseHeadersPolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteResponseHeadersPolicyCommand";
    import { DeleteStreamingDistributionCommandInput, DeleteStreamingDistributionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteStreamingDistributionCommand";
    import { DescribeFunctionCommandInput, DescribeFunctionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DescribeFunctionCommand";
    import { GetCachePolicyCommandInput, GetCachePolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetCachePolicyCommand";
    import { GetCachePolicyConfigCommandInput, GetCachePolicyConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetCachePolicyConfigCommand";
    import { GetCloudFrontOriginAccessIdentityCommandInput, GetCloudFrontOriginAccessIdentityCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetCloudFrontOriginAccessIdentityCommand";
    import { GetCloudFrontOriginAccessIdentityConfigCommandInput, GetCloudFrontOriginAccessIdentityConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetCloudFrontOriginAccessIdentityConfigCommand";
    import { GetDistributionCommandInput, GetDistributionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetDistributionCommand";
    import { GetDistributionConfigCommandInput, GetDistributionConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetDistributionConfigCommand";
    import { GetFieldLevelEncryptionCommandInput, GetFieldLevelEncryptionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetFieldLevelEncryptionCommand";
    import { GetFieldLevelEncryptionConfigCommandInput, GetFieldLevelEncryptionConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetFieldLevelEncryptionConfigCommand";
    import { GetFieldLevelEncryptionProfileCommandInput, GetFieldLevelEncryptionProfileCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetFieldLevelEncryptionProfileCommand";
    import { GetFieldLevelEncryptionProfileConfigCommandInput, GetFieldLevelEncryptionProfileConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetFieldLevelEncryptionProfileConfigCommand";
    import { GetFunctionCommandInput, GetFunctionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetFunctionCommand";
    import { GetInvalidationCommandInput, GetInvalidationCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetInvalidationCommand";
    import { GetKeyGroupCommandInput, GetKeyGroupCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetKeyGroupCommand";
    import { GetKeyGroupConfigCommandInput, GetKeyGroupConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetKeyGroupConfigCommand";
    import { GetMonitoringSubscriptionCommandInput, GetMonitoringSubscriptionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetMonitoringSubscriptionCommand";
    import { GetOriginRequestPolicyCommandInput, GetOriginRequestPolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetOriginRequestPolicyCommand";
    import { GetOriginRequestPolicyConfigCommandInput, GetOriginRequestPolicyConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetOriginRequestPolicyConfigCommand";
    import { GetPublicKeyCommandInput, GetPublicKeyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetPublicKeyCommand";
    import { GetPublicKeyConfigCommandInput, GetPublicKeyConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetPublicKeyConfigCommand";
    import { GetRealtimeLogConfigCommandInput, GetRealtimeLogConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetRealtimeLogConfigCommand";
    import { GetResponseHeadersPolicyCommandInput, GetResponseHeadersPolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetResponseHeadersPolicyCommand";
    import { GetResponseHeadersPolicyConfigCommandInput, GetResponseHeadersPolicyConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetResponseHeadersPolicyConfigCommand";
    import { GetStreamingDistributionCommandInput, GetStreamingDistributionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetStreamingDistributionCommand";
    import { GetStreamingDistributionConfigCommandInput, GetStreamingDistributionConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetStreamingDistributionConfigCommand";
    import { ListCachePoliciesCommandInput, ListCachePoliciesCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListCachePoliciesCommand";
    import { ListCloudFrontOriginAccessIdentitiesCommandInput, ListCloudFrontOriginAccessIdentitiesCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListCloudFrontOriginAccessIdentitiesCommand";
    import { ListConflictingAliasesCommandInput, ListConflictingAliasesCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListConflictingAliasesCommand";
    import { ListDistributionsByCachePolicyIdCommandInput, ListDistributionsByCachePolicyIdCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListDistributionsByCachePolicyIdCommand";
    import { ListDistributionsByKeyGroupCommandInput, ListDistributionsByKeyGroupCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListDistributionsByKeyGroupCommand";
    import { ListDistributionsByOriginRequestPolicyIdCommandInput, ListDistributionsByOriginRequestPolicyIdCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListDistributionsByOriginRequestPolicyIdCommand";
    import { ListDistributionsByRealtimeLogConfigCommandInput, ListDistributionsByRealtimeLogConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListDistributionsByRealtimeLogConfigCommand";
    import { ListDistributionsByResponseHeadersPolicyIdCommandInput, ListDistributionsByResponseHeadersPolicyIdCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListDistributionsByResponseHeadersPolicyIdCommand";
    import { ListDistributionsByWebACLIdCommandInput, ListDistributionsByWebACLIdCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListDistributionsByWebACLIdCommand";
    import { ListDistributionsCommandInput, ListDistributionsCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListDistributionsCommand";
    import { ListFieldLevelEncryptionConfigsCommandInput, ListFieldLevelEncryptionConfigsCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListFieldLevelEncryptionConfigsCommand";
    import { ListFieldLevelEncryptionProfilesCommandInput, ListFieldLevelEncryptionProfilesCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListFieldLevelEncryptionProfilesCommand";
    import { ListFunctionsCommandInput, ListFunctionsCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListFunctionsCommand";
    import { ListInvalidationsCommandInput, ListInvalidationsCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListInvalidationsCommand";
    import { ListKeyGroupsCommandInput, ListKeyGroupsCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListKeyGroupsCommand";
    import { ListOriginRequestPoliciesCommandInput, ListOriginRequestPoliciesCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListOriginRequestPoliciesCommand";
    import { ListPublicKeysCommandInput, ListPublicKeysCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListPublicKeysCommand";
    import { ListRealtimeLogConfigsCommandInput, ListRealtimeLogConfigsCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListRealtimeLogConfigsCommand";
    import { ListResponseHeadersPoliciesCommandInput, ListResponseHeadersPoliciesCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListResponseHeadersPoliciesCommand";
    import { ListStreamingDistributionsCommandInput, ListStreamingDistributionsCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListStreamingDistributionsCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListTagsForResourceCommand";
    import { PublishFunctionCommandInput, PublishFunctionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/PublishFunctionCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/TagResourceCommand";
    import { TestFunctionCommandInput, TestFunctionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/TestFunctionCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UntagResourceCommand";
    import { UpdateCachePolicyCommandInput, UpdateCachePolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateCachePolicyCommand";
    import { UpdateCloudFrontOriginAccessIdentityCommandInput, UpdateCloudFrontOriginAccessIdentityCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateCloudFrontOriginAccessIdentityCommand";
    import { UpdateDistributionCommandInput, UpdateDistributionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateDistributionCommand";
    import { UpdateFieldLevelEncryptionConfigCommandInput, UpdateFieldLevelEncryptionConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateFieldLevelEncryptionConfigCommand";
    import { UpdateFieldLevelEncryptionProfileCommandInput, UpdateFieldLevelEncryptionProfileCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateFieldLevelEncryptionProfileCommand";
    import { UpdateFunctionCommandInput, UpdateFunctionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateFunctionCommand";
    import { UpdateKeyGroupCommandInput, UpdateKeyGroupCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateKeyGroupCommand";
    import { UpdateOriginRequestPolicyCommandInput, UpdateOriginRequestPolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateOriginRequestPolicyCommand";
    import { UpdatePublicKeyCommandInput, UpdatePublicKeyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdatePublicKeyCommand";
    import { UpdateRealtimeLogConfigCommandInput, UpdateRealtimeLogConfigCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateRealtimeLogConfigCommand";
    import { UpdateResponseHeadersPolicyCommandInput, UpdateResponseHeadersPolicyCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateResponseHeadersPolicyCommand";
    import { UpdateStreamingDistributionCommandInput, UpdateStreamingDistributionCommandOutput } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateStreamingDistributionCommand";
    export type ServiceInputTypes = AssociateAliasCommandInput | CreateCachePolicyCommandInput | CreateCloudFrontOriginAccessIdentityCommandInput | CreateDistributionCommandInput | CreateDistributionWithTagsCommandInput | CreateFieldLevelEncryptionConfigCommandInput | CreateFieldLevelEncryptionProfileCommandInput | CreateFunctionCommandInput | CreateInvalidationCommandInput | CreateKeyGroupCommandInput | CreateMonitoringSubscriptionCommandInput | CreateOriginRequestPolicyCommandInput | CreatePublicKeyCommandInput | CreateRealtimeLogConfigCommandInput | CreateResponseHeadersPolicyCommandInput | CreateStreamingDistributionCommandInput | CreateStreamingDistributionWithTagsCommandInput | DeleteCachePolicyCommandInput | DeleteCloudFrontOriginAccessIdentityCommandInput | DeleteDistributionCommandInput | DeleteFieldLevelEncryptionConfigCommandInput | DeleteFieldLevelEncryptionProfileCommandInput | DeleteFunctionCommandInput | DeleteKeyGroupCommandInput | DeleteMonitoringSubscriptionCommandInput | DeleteOriginRequestPolicyCommandInput | DeletePublicKeyCommandInput | DeleteRealtimeLogConfigCommandInput | DeleteResponseHeadersPolicyCommandInput | DeleteStreamingDistributionCommandInput | DescribeFunctionCommandInput | GetCachePolicyCommandInput | GetCachePolicyConfigCommandInput | GetCloudFrontOriginAccessIdentityCommandInput | GetCloudFrontOriginAccessIdentityConfigCommandInput | GetDistributionCommandInput | GetDistributionConfigCommandInput | GetFieldLevelEncryptionCommandInput | GetFieldLevelEncryptionConfigCommandInput | GetFieldLevelEncryptionProfileCommandInput | GetFieldLevelEncryptionProfileConfigCommandInput | GetFunctionCommandInput | GetInvalidationCommandInput | GetKeyGroupCommandInput | GetKeyGroupConfigCommandInput | GetMonitoringSubscriptionCommandInput | GetOriginRequestPolicyCommandInput | GetOriginRequestPolicyConfigCommandInput | GetPublicKeyCommandInput | GetPublicKeyConfigCommandInput | GetRealtimeLogConfigCommandInput | GetResponseHeadersPolicyCommandInput | GetResponseHeadersPolicyConfigCommandInput | GetStreamingDistributionCommandInput | GetStreamingDistributionConfigCommandInput | ListCachePoliciesCommandInput | ListCloudFrontOriginAccessIdentitiesCommandInput | ListConflictingAliasesCommandInput | ListDistributionsByCachePolicyIdCommandInput | ListDistributionsByKeyGroupCommandInput | ListDistributionsByOriginRequestPolicyIdCommandInput | ListDistributionsByRealtimeLogConfigCommandInput | ListDistributionsByResponseHeadersPolicyIdCommandInput | ListDistributionsByWebACLIdCommandInput | ListDistributionsCommandInput | ListFieldLevelEncryptionConfigsCommandInput | ListFieldLevelEncryptionProfilesCommandInput | ListFunctionsCommandInput | ListInvalidationsCommandInput | ListKeyGroupsCommandInput | ListOriginRequestPoliciesCommandInput | ListPublicKeysCommandInput | ListRealtimeLogConfigsCommandInput | ListResponseHeadersPoliciesCommandInput | ListStreamingDistributionsCommandInput | ListTagsForResourceCommandInput | PublishFunctionCommandInput | TagResourceCommandInput | TestFunctionCommandInput | UntagResourceCommandInput | UpdateCachePolicyCommandInput | UpdateCloudFrontOriginAccessIdentityCommandInput | UpdateDistributionCommandInput | UpdateFieldLevelEncryptionConfigCommandInput | UpdateFieldLevelEncryptionProfileCommandInput | UpdateFunctionCommandInput | UpdateKeyGroupCommandInput | UpdateOriginRequestPolicyCommandInput | UpdatePublicKeyCommandInput | UpdateRealtimeLogConfigCommandInput | UpdateResponseHeadersPolicyCommandInput | UpdateStreamingDistributionCommandInput;
    export type ServiceOutputTypes = AssociateAliasCommandOutput | CreateCachePolicyCommandOutput | CreateCloudFrontOriginAccessIdentityCommandOutput | CreateDistributionCommandOutput | CreateDistributionWithTagsCommandOutput | CreateFieldLevelEncryptionConfigCommandOutput | CreateFieldLevelEncryptionProfileCommandOutput | CreateFunctionCommandOutput | CreateInvalidationCommandOutput | CreateKeyGroupCommandOutput | CreateMonitoringSubscriptionCommandOutput | CreateOriginRequestPolicyCommandOutput | CreatePublicKeyCommandOutput | CreateRealtimeLogConfigCommandOutput | CreateResponseHeadersPolicyCommandOutput | CreateStreamingDistributionCommandOutput | CreateStreamingDistributionWithTagsCommandOutput | DeleteCachePolicyCommandOutput | DeleteCloudFrontOriginAccessIdentityCommandOutput | DeleteDistributionCommandOutput | DeleteFieldLevelEncryptionConfigCommandOutput | DeleteFieldLevelEncryptionProfileCommandOutput | DeleteFunctionCommandOutput | DeleteKeyGroupCommandOutput | DeleteMonitoringSubscriptionCommandOutput | DeleteOriginRequestPolicyCommandOutput | DeletePublicKeyCommandOutput | DeleteRealtimeLogConfigCommandOutput | DeleteResponseHeadersPolicyCommandOutput | DeleteStreamingDistributionCommandOutput | DescribeFunctionCommandOutput | GetCachePolicyCommandOutput | GetCachePolicyConfigCommandOutput | GetCloudFrontOriginAccessIdentityCommandOutput | GetCloudFrontOriginAccessIdentityConfigCommandOutput | GetDistributionCommandOutput | GetDistributionConfigCommandOutput | GetFieldLevelEncryptionCommandOutput | GetFieldLevelEncryptionConfigCommandOutput | GetFieldLevelEncryptionProfileCommandOutput | GetFieldLevelEncryptionProfileConfigCommandOutput | GetFunctionCommandOutput | GetInvalidationCommandOutput | GetKeyGroupCommandOutput | GetKeyGroupConfigCommandOutput | GetMonitoringSubscriptionCommandOutput | GetOriginRequestPolicyCommandOutput | GetOriginRequestPolicyConfigCommandOutput | GetPublicKeyCommandOutput | GetPublicKeyConfigCommandOutput | GetRealtimeLogConfigCommandOutput | GetResponseHeadersPolicyCommandOutput | GetResponseHeadersPolicyConfigCommandOutput | GetStreamingDistributionCommandOutput | GetStreamingDistributionConfigCommandOutput | ListCachePoliciesCommandOutput | ListCloudFrontOriginAccessIdentitiesCommandOutput | ListConflictingAliasesCommandOutput | ListDistributionsByCachePolicyIdCommandOutput | ListDistributionsByKeyGroupCommandOutput | ListDistributionsByOriginRequestPolicyIdCommandOutput | ListDistributionsByRealtimeLogConfigCommandOutput | ListDistributionsByResponseHeadersPolicyIdCommandOutput | ListDistributionsByWebACLIdCommandOutput | ListDistributionsCommandOutput | ListFieldLevelEncryptionConfigsCommandOutput | ListFieldLevelEncryptionProfilesCommandOutput | ListFunctionsCommandOutput | ListInvalidationsCommandOutput | ListKeyGroupsCommandOutput | ListOriginRequestPoliciesCommandOutput | ListPublicKeysCommandOutput | ListRealtimeLogConfigsCommandOutput | ListResponseHeadersPoliciesCommandOutput | ListStreamingDistributionsCommandOutput | ListTagsForResourceCommandOutput | PublishFunctionCommandOutput | TagResourceCommandOutput | TestFunctionCommandOutput | UntagResourceCommandOutput | UpdateCachePolicyCommandOutput | UpdateCloudFrontOriginAccessIdentityCommandOutput | UpdateDistributionCommandOutput | UpdateFieldLevelEncryptionConfigCommandOutput | UpdateFieldLevelEncryptionProfileCommandOutput | UpdateFunctionCommandOutput | UpdateKeyGroupCommandOutput | UpdateOriginRequestPolicyCommandOutput | UpdatePublicKeyCommandOutput | UpdateRealtimeLogConfigCommandOutput | UpdateResponseHeadersPolicyCommandOutput | UpdateStreamingDistributionCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type CloudFrontClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of CloudFrontClient class constructor that set the region, credentials and other options.
        */
    export interface CloudFrontClientConfig extends CloudFrontClientConfigType {
    }
    type CloudFrontClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of CloudFrontClient class. This is resolved and normalized from the {@link CloudFrontClientConfig | constructor configuration interface}.
        */
    export interface CloudFrontClientResolvedConfig extends CloudFrontClientResolvedConfigType {
    }
    /**
        * <fullname>Amazon CloudFront</fullname>
        * 		       <p>This is the <i>Amazon CloudFront API Reference</i>. This guide
        *             is for developers who need detailed information about
        * 			CloudFront API actions, data types, and errors. For detailed information about CloudFront features, see the <i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class CloudFrontClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, CloudFrontClientResolvedConfig> {
            /**
                * The resolved configuration of CloudFrontClient class. This is resolved and normalized from the {@link CloudFrontClientConfig | constructor configuration interface}.
                */
            readonly config: CloudFrontClientResolvedConfig;
            constructor(configuration: CloudFrontClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/AssociateAliasCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { AssociateAliasRequest } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface AssociateAliasCommandInput extends AssociateAliasRequest {
    }
    export interface AssociateAliasCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Associates an alias (also known as a CNAME or an alternate domain name) with a CloudFront
        * 			distribution.</p>
        * 		       <p>With this operation you can move an alias that’s already in use on a CloudFront distribution
        * 			to a different distribution in one step. This prevents the downtime that could occur if
        * 			you first remove the alias from one distribution and then separately add the alias to
        * 			another distribution.</p>
        * 		       <p>To use this operation to associate an alias with a distribution, you provide the alias
        * 			and the ID of the target distribution for the alias. For more information, including how
        * 			to set up the target distribution, prerequisites that you must complete, and other
        * 			restrictions, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/CNAMEs.html#alternate-domain-names-move">Moving an alternate domain name to a different distribution</a>
        * 			in the <i>Amazon CloudFront Developer Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, AssociateAliasCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, AssociateAliasCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new AssociateAliasCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link AssociateAliasCommandInput} for command's `input` shape.
        * @see {@link AssociateAliasCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class AssociateAliasCommand extends $Command<AssociateAliasCommandInput, AssociateAliasCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: AssociateAliasCommandInput;
            constructor(input: AssociateAliasCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<AssociateAliasCommandInput, AssociateAliasCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateCachePolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { CreateCachePolicyRequest, CreateCachePolicyResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface CreateCachePolicyCommandInput extends CreateCachePolicyRequest {
    }
    export interface CreateCachePolicyCommandOutput extends CreateCachePolicyResult, __MetadataBearer {
    }
    /**
        * <p>Creates a cache policy.</p>
        * 		       <p>After you create a cache policy, you can attach it to one or more cache behaviors. When it’s
        * 			attached to a cache behavior, the cache policy determines the following:</p>
        * 		       <ul>
        *             <li>
        * 				           <p>The values that CloudFront includes in the <i>cache key</i>. These values can
        * 					include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to
        * 					find an object in its cache that it can return to the viewer.</p>
        * 			         </li>
        *             <li>
        * 				           <p>The default, minimum, and maximum time to live (TTL) values that you want objects to stay
        * 					in the CloudFront cache.</p>
        * 			         </li>
        *          </ul>
        * 		       <p>The headers, cookies, and query strings that are included in the cache key are automatically
        * 			included in requests that CloudFront sends to the origin. CloudFront sends a request when it can’t
        * 			find an object in its cache that matches the request’s cache key. If you want to send
        * 			values to the origin but <i>not</i> include them in the cache key, use
        * 			<code>OriginRequestPolicy</code>.</p>
        * 		       <p>For more information about cache policies, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html">Controlling the cache key</a> in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, CreateCachePolicyCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, CreateCachePolicyCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new CreateCachePolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateCachePolicyCommandInput} for command's `input` shape.
        * @see {@link CreateCachePolicyCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class CreateCachePolicyCommand extends $Command<CreateCachePolicyCommandInput, CreateCachePolicyCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: CreateCachePolicyCommandInput;
            constructor(input: CreateCachePolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateCachePolicyCommandInput, CreateCachePolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateCloudFrontOriginAccessIdentityCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { CreateCloudFrontOriginAccessIdentityRequest, CreateCloudFrontOriginAccessIdentityResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface CreateCloudFrontOriginAccessIdentityCommandInput extends CreateCloudFrontOriginAccessIdentityRequest {
    }
    export interface CreateCloudFrontOriginAccessIdentityCommandOutput extends CreateCloudFrontOriginAccessIdentityResult, __MetadataBearer {
    }
    /**
        * <p>Creates a new origin access identity. If you're using Amazon S3 for your origin, you can
        * 			use an origin access identity to require users to access your content using a CloudFront URL instead
        * 			of the Amazon S3 URL. For more information about how to use origin access identities, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving Private Content through CloudFront</a> in the
        * 				<i>Amazon CloudFront Developer Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, CreateCloudFrontOriginAccessIdentityCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, CreateCloudFrontOriginAccessIdentityCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new CreateCloudFrontOriginAccessIdentityCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateCloudFrontOriginAccessIdentityCommandInput} for command's `input` shape.
        * @see {@link CreateCloudFrontOriginAccessIdentityCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class CreateCloudFrontOriginAccessIdentityCommand extends $Command<CreateCloudFrontOriginAccessIdentityCommandInput, CreateCloudFrontOriginAccessIdentityCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: CreateCloudFrontOriginAccessIdentityCommandInput;
            constructor(input: CreateCloudFrontOriginAccessIdentityCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateCloudFrontOriginAccessIdentityCommandInput, CreateCloudFrontOriginAccessIdentityCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateDistributionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { CreateDistributionRequest, CreateDistributionResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface CreateDistributionCommandInput extends CreateDistributionRequest {
    }
    export interface CreateDistributionCommandOutput extends CreateDistributionResult, __MetadataBearer {
    }
    /**
        * <p>Creates a new web distribution. You create a CloudFront distribution to tell CloudFront where you
        * 			want content to be delivered from, and the details about how to track and manage content delivery. Send a <code>POST</code> request to the
        * 			<code>/<i>CloudFront API version</i>/distribution</code>/<code>distribution ID</code> resource.</p>
        * 		       <important>
        *             <p>When you update a distribution, there are more required fields than when you create a distribution.
        * 			When you update your distribution by using
        * 			<a href="https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_UpdateDistribution.html">UpdateDistribution</a>,
        * 			follow the steps included
        * 			in the documentation to get the current configuration
        * 			and then make your updates. This helps to make sure that you include all of the required fields. To view a summary,
        * 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-overview-required-fields.html">Required
        * 				Fields for Create Distribution and Update Distribution</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        *          </important>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, CreateDistributionCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, CreateDistributionCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new CreateDistributionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateDistributionCommandInput} for command's `input` shape.
        * @see {@link CreateDistributionCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class CreateDistributionCommand extends $Command<CreateDistributionCommandInput, CreateDistributionCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: CreateDistributionCommandInput;
            constructor(input: CreateDistributionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateDistributionCommandInput, CreateDistributionCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateDistributionWithTagsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { CreateDistributionWithTagsRequest, CreateDistributionWithTagsResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface CreateDistributionWithTagsCommandInput extends CreateDistributionWithTagsRequest {
    }
    export interface CreateDistributionWithTagsCommandOutput extends CreateDistributionWithTagsResult, __MetadataBearer {
    }
    /**
        * <p>Create a new distribution with tags.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, CreateDistributionWithTagsCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, CreateDistributionWithTagsCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new CreateDistributionWithTagsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateDistributionWithTagsCommandInput} for command's `input` shape.
        * @see {@link CreateDistributionWithTagsCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class CreateDistributionWithTagsCommand extends $Command<CreateDistributionWithTagsCommandInput, CreateDistributionWithTagsCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: CreateDistributionWithTagsCommandInput;
            constructor(input: CreateDistributionWithTagsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateDistributionWithTagsCommandInput, CreateDistributionWithTagsCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateFieldLevelEncryptionConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { CreateFieldLevelEncryptionConfigRequest, CreateFieldLevelEncryptionConfigResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface CreateFieldLevelEncryptionConfigCommandInput extends CreateFieldLevelEncryptionConfigRequest {
    }
    export interface CreateFieldLevelEncryptionConfigCommandOutput extends CreateFieldLevelEncryptionConfigResult, __MetadataBearer {
    }
    /**
        * <p>Create a new field-level encryption configuration.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, CreateFieldLevelEncryptionConfigCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, CreateFieldLevelEncryptionConfigCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new CreateFieldLevelEncryptionConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateFieldLevelEncryptionConfigCommandInput} for command's `input` shape.
        * @see {@link CreateFieldLevelEncryptionConfigCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class CreateFieldLevelEncryptionConfigCommand extends $Command<CreateFieldLevelEncryptionConfigCommandInput, CreateFieldLevelEncryptionConfigCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: CreateFieldLevelEncryptionConfigCommandInput;
            constructor(input: CreateFieldLevelEncryptionConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateFieldLevelEncryptionConfigCommandInput, CreateFieldLevelEncryptionConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateFieldLevelEncryptionProfileCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { CreateFieldLevelEncryptionProfileRequest, CreateFieldLevelEncryptionProfileResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface CreateFieldLevelEncryptionProfileCommandInput extends CreateFieldLevelEncryptionProfileRequest {
    }
    export interface CreateFieldLevelEncryptionProfileCommandOutput extends CreateFieldLevelEncryptionProfileResult, __MetadataBearer {
    }
    /**
        * <p>Create a field-level encryption profile.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, CreateFieldLevelEncryptionProfileCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, CreateFieldLevelEncryptionProfileCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new CreateFieldLevelEncryptionProfileCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateFieldLevelEncryptionProfileCommandInput} for command's `input` shape.
        * @see {@link CreateFieldLevelEncryptionProfileCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class CreateFieldLevelEncryptionProfileCommand extends $Command<CreateFieldLevelEncryptionProfileCommandInput, CreateFieldLevelEncryptionProfileCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: CreateFieldLevelEncryptionProfileCommandInput;
            constructor(input: CreateFieldLevelEncryptionProfileCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateFieldLevelEncryptionProfileCommandInput, CreateFieldLevelEncryptionProfileCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateFunctionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { CreateFunctionRequest, CreateFunctionResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface CreateFunctionCommandInput extends CreateFunctionRequest {
    }
    export interface CreateFunctionCommandOutput extends CreateFunctionResult, __MetadataBearer {
    }
    /**
        * <p>Creates a CloudFront function.</p>
        * 		       <p>To create a function, you provide the function code and some configuration information
        * 			about the function. The response contains an Amazon Resource Name (ARN) that uniquely
        * 			identifies the function.</p>
        * 		       <p>When you create a function, it’s in the <code>DEVELOPMENT</code> stage. In this stage, you
        * 			can test the function with <code>TestFunction</code>, and update it with
        * 			<code>UpdateFunction</code>.</p>
        * 		       <p>When you’re ready to use your function with a CloudFront distribution, use
        * 			<code>PublishFunction</code> to copy the function from the <code>DEVELOPMENT</code>
        * 			stage to <code>LIVE</code>. When it’s live, you can attach the function to a
        * 			distribution’s cache behavior, using the function’s ARN.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, CreateFunctionCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, CreateFunctionCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new CreateFunctionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateFunctionCommandInput} for command's `input` shape.
        * @see {@link CreateFunctionCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class CreateFunctionCommand extends $Command<CreateFunctionCommandInput, CreateFunctionCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: CreateFunctionCommandInput;
            constructor(input: CreateFunctionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateFunctionCommandInput, CreateFunctionCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateInvalidationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { CreateInvalidationRequest, CreateInvalidationResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface CreateInvalidationCommandInput extends CreateInvalidationRequest {
    }
    export interface CreateInvalidationCommandOutput extends CreateInvalidationResult, __MetadataBearer {
    }
    /**
        * <p>Create a new invalidation. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, CreateInvalidationCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, CreateInvalidationCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new CreateInvalidationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateInvalidationCommandInput} for command's `input` shape.
        * @see {@link CreateInvalidationCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class CreateInvalidationCommand extends $Command<CreateInvalidationCommandInput, CreateInvalidationCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: CreateInvalidationCommandInput;
            constructor(input: CreateInvalidationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateInvalidationCommandInput, CreateInvalidationCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateKeyGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { CreateKeyGroupRequest, CreateKeyGroupResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface CreateKeyGroupCommandInput extends CreateKeyGroupRequest {
    }
    export interface CreateKeyGroupCommandOutput extends CreateKeyGroupResult, __MetadataBearer {
    }
    /**
        * <p>Creates a key group that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">CloudFront signed URLs and signed cookies</a>.</p>
        * 		       <p>To create a key group, you must specify at least one public key for the key group. After you
        * 			create a key group, you can reference it from one or more cache behaviors. When you
        * 			reference a key group in a cache behavior, CloudFront requires signed URLs or signed cookies
        * 			for all requests that match the cache behavior. The URLs or cookies must be signed with
        * 			a private key whose corresponding public key is in the key group. The signed URL or
        * 			cookie contains information about which public key CloudFront should use to verify the
        * 			signature. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving private content</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, CreateKeyGroupCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, CreateKeyGroupCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new CreateKeyGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateKeyGroupCommandInput} for command's `input` shape.
        * @see {@link CreateKeyGroupCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class CreateKeyGroupCommand extends $Command<CreateKeyGroupCommandInput, CreateKeyGroupCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: CreateKeyGroupCommandInput;
            constructor(input: CreateKeyGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateKeyGroupCommandInput, CreateKeyGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateMonitoringSubscriptionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { CreateMonitoringSubscriptionRequest, CreateMonitoringSubscriptionResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface CreateMonitoringSubscriptionCommandInput extends CreateMonitoringSubscriptionRequest {
    }
    export interface CreateMonitoringSubscriptionCommandOutput extends CreateMonitoringSubscriptionResult, __MetadataBearer {
    }
    /**
        * <p>Enables additional CloudWatch metrics for the specified CloudFront distribution. The
        * 			additional metrics incur an additional cost.</p>
        * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/viewing-cloudfront-metrics.html#monitoring-console.distributions-additional">Viewing additional CloudFront distribution metrics</a> in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, CreateMonitoringSubscriptionCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, CreateMonitoringSubscriptionCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new CreateMonitoringSubscriptionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateMonitoringSubscriptionCommandInput} for command's `input` shape.
        * @see {@link CreateMonitoringSubscriptionCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class CreateMonitoringSubscriptionCommand extends $Command<CreateMonitoringSubscriptionCommandInput, CreateMonitoringSubscriptionCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: CreateMonitoringSubscriptionCommandInput;
            constructor(input: CreateMonitoringSubscriptionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateMonitoringSubscriptionCommandInput, CreateMonitoringSubscriptionCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateOriginRequestPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { CreateOriginRequestPolicyRequest, CreateOriginRequestPolicyResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface CreateOriginRequestPolicyCommandInput extends CreateOriginRequestPolicyRequest {
    }
    export interface CreateOriginRequestPolicyCommandOutput extends CreateOriginRequestPolicyResult, __MetadataBearer {
    }
    /**
        * <p>Creates an origin request policy.</p>
        * 		       <p>After you create an origin request policy, you can attach it to one or more cache behaviors.
        * 			When it’s attached to a cache behavior, the origin request policy determines the values
        * 			that CloudFront includes in requests that it sends to the origin. Each request that CloudFront sends
        * 			to the origin includes the following:</p>
        * 		       <ul>
        *             <li>
        * 				           <p>The request body and the URL path (without the domain name) from the viewer
        * 					request.</p>
        * 			         </li>
        *             <li>
        * 				           <p>The headers that CloudFront automatically includes in every origin request, including
        * 					<code>Host</code>, <code>User-Agent</code>, and <code>X-Amz-Cf-Id</code>.</p>
        * 			         </li>
        *             <li>
        * 				           <p>All HTTP headers, cookies, and URL query strings that are specified in the cache policy or
        * 					the origin request policy. These can include items from the viewer request and,
        * 					in the case of headers, additional ones that are added by CloudFront.</p>
        * 			         </li>
        *          </ul>
        * 		       <p>CloudFront sends a request when it can’t find a valid object in its cache that matches the
        * 			request. If you want to send values to the origin and also include them in the cache
        * 			key, use <code>CachePolicy</code>.</p>
        * 		       <p>For more information about origin request policies, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html">Controlling origin requests</a> in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, CreateOriginRequestPolicyCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, CreateOriginRequestPolicyCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new CreateOriginRequestPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateOriginRequestPolicyCommandInput} for command's `input` shape.
        * @see {@link CreateOriginRequestPolicyCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class CreateOriginRequestPolicyCommand extends $Command<CreateOriginRequestPolicyCommandInput, CreateOriginRequestPolicyCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: CreateOriginRequestPolicyCommandInput;
            constructor(input: CreateOriginRequestPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateOriginRequestPolicyCommandInput, CreateOriginRequestPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreatePublicKeyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { CreatePublicKeyRequest, CreatePublicKeyResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface CreatePublicKeyCommandInput extends CreatePublicKeyRequest {
    }
    export interface CreatePublicKeyCommandOutput extends CreatePublicKeyResult, __MetadataBearer {
    }
    /**
        * <p>Uploads a public key to CloudFront that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">signed URLs and signed cookies</a>, or with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html">field-level encryption</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, CreatePublicKeyCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, CreatePublicKeyCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new CreatePublicKeyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreatePublicKeyCommandInput} for command's `input` shape.
        * @see {@link CreatePublicKeyCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class CreatePublicKeyCommand extends $Command<CreatePublicKeyCommandInput, CreatePublicKeyCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: CreatePublicKeyCommandInput;
            constructor(input: CreatePublicKeyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreatePublicKeyCommandInput, CreatePublicKeyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateRealtimeLogConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { CreateRealtimeLogConfigRequest, CreateRealtimeLogConfigResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface CreateRealtimeLogConfigCommandInput extends CreateRealtimeLogConfigRequest {
    }
    export interface CreateRealtimeLogConfigCommandOutput extends CreateRealtimeLogConfigResult, __MetadataBearer {
    }
    /**
        * <p>Creates a real-time log configuration.</p>
        * 		       <p>After you create a real-time log configuration, you can attach it to one or more cache
        * 			behaviors to send real-time log data to the specified Amazon Kinesis data stream.</p>
        * 		       <p>For more information about real-time log configurations, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html">Real-time logs</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, CreateRealtimeLogConfigCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, CreateRealtimeLogConfigCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new CreateRealtimeLogConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateRealtimeLogConfigCommandInput} for command's `input` shape.
        * @see {@link CreateRealtimeLogConfigCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class CreateRealtimeLogConfigCommand extends $Command<CreateRealtimeLogConfigCommandInput, CreateRealtimeLogConfigCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: CreateRealtimeLogConfigCommandInput;
            constructor(input: CreateRealtimeLogConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateRealtimeLogConfigCommandInput, CreateRealtimeLogConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateResponseHeadersPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { CreateResponseHeadersPolicyRequest, CreateResponseHeadersPolicyResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface CreateResponseHeadersPolicyCommandInput extends CreateResponseHeadersPolicyRequest {
    }
    export interface CreateResponseHeadersPolicyCommandOutput extends CreateResponseHeadersPolicyResult, __MetadataBearer {
    }
    /**
        * <p>Creates a response headers policy.</p>
        * 		       <p>A response headers policy contains information about a set of HTTP response headers
        * 			and their values. To create a response headers policy, you provide some metadata about
        * 			the policy, and a set of configurations that specify the response headers.</p>
        * 		       <p>After you create a response headers policy, you can use its ID to attach it to one or more
        * 			cache behaviors in a CloudFront distribution. When it’s attached to a cache behavior, CloudFront
        * 			adds the headers in the policy to HTTP responses that it sends for requests that match
        * 			the cache behavior.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, CreateResponseHeadersPolicyCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, CreateResponseHeadersPolicyCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new CreateResponseHeadersPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateResponseHeadersPolicyCommandInput} for command's `input` shape.
        * @see {@link CreateResponseHeadersPolicyCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class CreateResponseHeadersPolicyCommand extends $Command<CreateResponseHeadersPolicyCommandInput, CreateResponseHeadersPolicyCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: CreateResponseHeadersPolicyCommandInput;
            constructor(input: CreateResponseHeadersPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateResponseHeadersPolicyCommandInput, CreateResponseHeadersPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateStreamingDistributionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { CreateStreamingDistributionRequest, CreateStreamingDistributionResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface CreateStreamingDistributionCommandInput extends CreateStreamingDistributionRequest {
    }
    export interface CreateStreamingDistributionCommandOutput extends CreateStreamingDistributionResult, __MetadataBearer {
    }
    /**
        * <p>This API is deprecated.
        *             Amazon CloudFront is deprecating real-time messaging protocol (RTMP) distributions on December 31, 2020.
        *             For more information, <a href="http://forums.aws.amazon.com/ann.jspa?annID=7356">read the announcement</a> on the Amazon CloudFront discussion forum.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, CreateStreamingDistributionCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, CreateStreamingDistributionCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new CreateStreamingDistributionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateStreamingDistributionCommandInput} for command's `input` shape.
        * @see {@link CreateStreamingDistributionCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class CreateStreamingDistributionCommand extends $Command<CreateStreamingDistributionCommandInput, CreateStreamingDistributionCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: CreateStreamingDistributionCommandInput;
            constructor(input: CreateStreamingDistributionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateStreamingDistributionCommandInput, CreateStreamingDistributionCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/CreateStreamingDistributionWithTagsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { CreateStreamingDistributionWithTagsRequest, CreateStreamingDistributionWithTagsResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface CreateStreamingDistributionWithTagsCommandInput extends CreateStreamingDistributionWithTagsRequest {
    }
    export interface CreateStreamingDistributionWithTagsCommandOutput extends CreateStreamingDistributionWithTagsResult, __MetadataBearer {
    }
    /**
        * <p>This API is deprecated.
        *             Amazon CloudFront is deprecating real-time messaging protocol (RTMP) distributions on December 31, 2020.
        *             For more information, <a href="http://forums.aws.amazon.com/ann.jspa?annID=7356">read the announcement</a> on the Amazon CloudFront discussion forum.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, CreateStreamingDistributionWithTagsCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, CreateStreamingDistributionWithTagsCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new CreateStreamingDistributionWithTagsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateStreamingDistributionWithTagsCommandInput} for command's `input` shape.
        * @see {@link CreateStreamingDistributionWithTagsCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class CreateStreamingDistributionWithTagsCommand extends $Command<CreateStreamingDistributionWithTagsCommandInput, CreateStreamingDistributionWithTagsCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: CreateStreamingDistributionWithTagsCommandInput;
            constructor(input: CreateStreamingDistributionWithTagsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateStreamingDistributionWithTagsCommandInput, CreateStreamingDistributionWithTagsCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteCachePolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { DeleteCachePolicyRequest } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface DeleteCachePolicyCommandInput extends DeleteCachePolicyRequest {
    }
    export interface DeleteCachePolicyCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes a cache policy.</p>
        * 		       <p>You cannot delete a cache policy if it’s attached to a cache behavior. First update your
        * 			distributions to remove the cache policy from all cache behaviors, then delete the cache
        * 			policy.</p>
        * 		       <p>To delete a cache policy, you must provide the policy’s identifier and version. To get these
        * 			values, you can use <code>ListCachePolicies</code> or
        * 			<code>GetCachePolicy</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, DeleteCachePolicyCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, DeleteCachePolicyCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new DeleteCachePolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteCachePolicyCommandInput} for command's `input` shape.
        * @see {@link DeleteCachePolicyCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class DeleteCachePolicyCommand extends $Command<DeleteCachePolicyCommandInput, DeleteCachePolicyCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: DeleteCachePolicyCommandInput;
            constructor(input: DeleteCachePolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteCachePolicyCommandInput, DeleteCachePolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteCloudFrontOriginAccessIdentityCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { DeleteCloudFrontOriginAccessIdentityRequest } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface DeleteCloudFrontOriginAccessIdentityCommandInput extends DeleteCloudFrontOriginAccessIdentityRequest {
    }
    export interface DeleteCloudFrontOriginAccessIdentityCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Delete an origin access identity. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, DeleteCloudFrontOriginAccessIdentityCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, DeleteCloudFrontOriginAccessIdentityCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new DeleteCloudFrontOriginAccessIdentityCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteCloudFrontOriginAccessIdentityCommandInput} for command's `input` shape.
        * @see {@link DeleteCloudFrontOriginAccessIdentityCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class DeleteCloudFrontOriginAccessIdentityCommand extends $Command<DeleteCloudFrontOriginAccessIdentityCommandInput, DeleteCloudFrontOriginAccessIdentityCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: DeleteCloudFrontOriginAccessIdentityCommandInput;
            constructor(input: DeleteCloudFrontOriginAccessIdentityCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteCloudFrontOriginAccessIdentityCommandInput, DeleteCloudFrontOriginAccessIdentityCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteDistributionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { DeleteDistributionRequest } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface DeleteDistributionCommandInput extends DeleteDistributionRequest {
    }
    export interface DeleteDistributionCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Delete a distribution. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, DeleteDistributionCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, DeleteDistributionCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new DeleteDistributionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteDistributionCommandInput} for command's `input` shape.
        * @see {@link DeleteDistributionCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class DeleteDistributionCommand extends $Command<DeleteDistributionCommandInput, DeleteDistributionCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: DeleteDistributionCommandInput;
            constructor(input: DeleteDistributionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteDistributionCommandInput, DeleteDistributionCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteFieldLevelEncryptionConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { DeleteFieldLevelEncryptionConfigRequest } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface DeleteFieldLevelEncryptionConfigCommandInput extends DeleteFieldLevelEncryptionConfigRequest {
    }
    export interface DeleteFieldLevelEncryptionConfigCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Remove a field-level encryption configuration.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, DeleteFieldLevelEncryptionConfigCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, DeleteFieldLevelEncryptionConfigCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new DeleteFieldLevelEncryptionConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteFieldLevelEncryptionConfigCommandInput} for command's `input` shape.
        * @see {@link DeleteFieldLevelEncryptionConfigCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class DeleteFieldLevelEncryptionConfigCommand extends $Command<DeleteFieldLevelEncryptionConfigCommandInput, DeleteFieldLevelEncryptionConfigCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: DeleteFieldLevelEncryptionConfigCommandInput;
            constructor(input: DeleteFieldLevelEncryptionConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteFieldLevelEncryptionConfigCommandInput, DeleteFieldLevelEncryptionConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteFieldLevelEncryptionProfileCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { DeleteFieldLevelEncryptionProfileRequest } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface DeleteFieldLevelEncryptionProfileCommandInput extends DeleteFieldLevelEncryptionProfileRequest {
    }
    export interface DeleteFieldLevelEncryptionProfileCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Remove a field-level encryption profile.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, DeleteFieldLevelEncryptionProfileCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, DeleteFieldLevelEncryptionProfileCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new DeleteFieldLevelEncryptionProfileCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteFieldLevelEncryptionProfileCommandInput} for command's `input` shape.
        * @see {@link DeleteFieldLevelEncryptionProfileCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class DeleteFieldLevelEncryptionProfileCommand extends $Command<DeleteFieldLevelEncryptionProfileCommandInput, DeleteFieldLevelEncryptionProfileCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: DeleteFieldLevelEncryptionProfileCommandInput;
            constructor(input: DeleteFieldLevelEncryptionProfileCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteFieldLevelEncryptionProfileCommandInput, DeleteFieldLevelEncryptionProfileCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteFunctionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { DeleteFunctionRequest } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface DeleteFunctionCommandInput extends DeleteFunctionRequest {
    }
    export interface DeleteFunctionCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes a CloudFront function.</p>
        * 		       <p>You cannot delete a function if it’s associated with a cache behavior. First, update your
        * 			distributions to remove the function association from all cache behaviors, then delete
        * 			the function.</p>
        * 		       <p>To delete a function, you must provide the function’s name and version
        * 			(<code>ETag</code> value). To get these values, you can use <code>ListFunctions</code>
        * 			and <code>DescribeFunction</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, DeleteFunctionCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, DeleteFunctionCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new DeleteFunctionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteFunctionCommandInput} for command's `input` shape.
        * @see {@link DeleteFunctionCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class DeleteFunctionCommand extends $Command<DeleteFunctionCommandInput, DeleteFunctionCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: DeleteFunctionCommandInput;
            constructor(input: DeleteFunctionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteFunctionCommandInput, DeleteFunctionCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteKeyGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { DeleteKeyGroupRequest } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    export interface DeleteKeyGroupCommandInput extends DeleteKeyGroupRequest {
    }
    export interface DeleteKeyGroupCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes a key group.</p>
        * 		       <p>You cannot delete a key group that is referenced in a cache behavior. First update
        * 			your distributions to remove the key group from all cache behaviors, then delete the key
        * 			group.</p>
        * 		       <p>To delete a key group, you must provide the key group’s identifier and version. To get
        * 			these values, use <code>ListKeyGroups</code> followed by <code>GetKeyGroup</code> or
        * 			<code>GetKeyGroupConfig</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, DeleteKeyGroupCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, DeleteKeyGroupCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new DeleteKeyGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteKeyGroupCommandInput} for command's `input` shape.
        * @see {@link DeleteKeyGroupCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class DeleteKeyGroupCommand extends $Command<DeleteKeyGroupCommandInput, DeleteKeyGroupCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: DeleteKeyGroupCommandInput;
            constructor(input: DeleteKeyGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteKeyGroupCommandInput, DeleteKeyGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteMonitoringSubscriptionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { DeleteMonitoringSubscriptionRequest, DeleteMonitoringSubscriptionResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface DeleteMonitoringSubscriptionCommandInput extends DeleteMonitoringSubscriptionRequest {
    }
    export interface DeleteMonitoringSubscriptionCommandOutput extends DeleteMonitoringSubscriptionResult, __MetadataBearer {
    }
    /**
        * <p>Disables additional CloudWatch metrics for the specified CloudFront distribution.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, DeleteMonitoringSubscriptionCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, DeleteMonitoringSubscriptionCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new DeleteMonitoringSubscriptionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteMonitoringSubscriptionCommandInput} for command's `input` shape.
        * @see {@link DeleteMonitoringSubscriptionCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class DeleteMonitoringSubscriptionCommand extends $Command<DeleteMonitoringSubscriptionCommandInput, DeleteMonitoringSubscriptionCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: DeleteMonitoringSubscriptionCommandInput;
            constructor(input: DeleteMonitoringSubscriptionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteMonitoringSubscriptionCommandInput, DeleteMonitoringSubscriptionCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteOriginRequestPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { DeleteOriginRequestPolicyRequest } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface DeleteOriginRequestPolicyCommandInput extends DeleteOriginRequestPolicyRequest {
    }
    export interface DeleteOriginRequestPolicyCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes an origin request policy.</p>
        * 		       <p>You cannot delete an origin request policy if it’s attached to any cache behaviors. First
        * 			update your distributions to remove the origin request policy from all cache behaviors,
        * 			then delete the origin request policy.</p>
        * 		       <p>To delete an origin request policy, you must provide the policy’s identifier and version. To
        * 			get the identifier, you can use <code>ListOriginRequestPolicies</code> or
        * 			<code>GetOriginRequestPolicy</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, DeleteOriginRequestPolicyCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, DeleteOriginRequestPolicyCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new DeleteOriginRequestPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteOriginRequestPolicyCommandInput} for command's `input` shape.
        * @see {@link DeleteOriginRequestPolicyCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class DeleteOriginRequestPolicyCommand extends $Command<DeleteOriginRequestPolicyCommandInput, DeleteOriginRequestPolicyCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: DeleteOriginRequestPolicyCommandInput;
            constructor(input: DeleteOriginRequestPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteOriginRequestPolicyCommandInput, DeleteOriginRequestPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeletePublicKeyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { DeletePublicKeyRequest } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface DeletePublicKeyCommandInput extends DeletePublicKeyRequest {
    }
    export interface DeletePublicKeyCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Remove a public key you previously added to CloudFront.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, DeletePublicKeyCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, DeletePublicKeyCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new DeletePublicKeyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeletePublicKeyCommandInput} for command's `input` shape.
        * @see {@link DeletePublicKeyCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class DeletePublicKeyCommand extends $Command<DeletePublicKeyCommandInput, DeletePublicKeyCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: DeletePublicKeyCommandInput;
            constructor(input: DeletePublicKeyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeletePublicKeyCommandInput, DeletePublicKeyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteRealtimeLogConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { DeleteRealtimeLogConfigRequest } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface DeleteRealtimeLogConfigCommandInput extends DeleteRealtimeLogConfigRequest {
    }
    export interface DeleteRealtimeLogConfigCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes a real-time log configuration.</p>
        * 		       <p>You cannot delete a real-time log configuration if it’s attached to a cache behavior.
        * 			First update your distributions to remove the real-time log configuration from all cache
        * 			behaviors, then delete the real-time log configuration.</p>
        * 		       <p>To delete a real-time log configuration, you can provide the configuration’s name or its
        * 			Amazon Resource Name (ARN). You must provide at least one. If you provide both, CloudFront
        * 			uses the name to identify the real-time log configuration to delete.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, DeleteRealtimeLogConfigCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, DeleteRealtimeLogConfigCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new DeleteRealtimeLogConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteRealtimeLogConfigCommandInput} for command's `input` shape.
        * @see {@link DeleteRealtimeLogConfigCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class DeleteRealtimeLogConfigCommand extends $Command<DeleteRealtimeLogConfigCommandInput, DeleteRealtimeLogConfigCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: DeleteRealtimeLogConfigCommandInput;
            constructor(input: DeleteRealtimeLogConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteRealtimeLogConfigCommandInput, DeleteRealtimeLogConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteResponseHeadersPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { DeleteResponseHeadersPolicyRequest } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface DeleteResponseHeadersPolicyCommandInput extends DeleteResponseHeadersPolicyRequest {
    }
    export interface DeleteResponseHeadersPolicyCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes a response headers policy.</p>
        * 		       <p>You cannot delete a response headers policy if it’s attached to a cache behavior.
        * 			First update your distributions to remove the response headers policy from all cache
        * 			behaviors, then delete the response headers policy.</p>
        * 		       <p>To delete a response headers policy, you must provide the policy’s identifier and
        * 			version. To get these values, you can use <code>ListResponseHeadersPolicies</code> or
        * 				<code>GetResponseHeadersPolicy</code>. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, DeleteResponseHeadersPolicyCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, DeleteResponseHeadersPolicyCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new DeleteResponseHeadersPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteResponseHeadersPolicyCommandInput} for command's `input` shape.
        * @see {@link DeleteResponseHeadersPolicyCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class DeleteResponseHeadersPolicyCommand extends $Command<DeleteResponseHeadersPolicyCommandInput, DeleteResponseHeadersPolicyCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: DeleteResponseHeadersPolicyCommandInput;
            constructor(input: DeleteResponseHeadersPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteResponseHeadersPolicyCommandInput, DeleteResponseHeadersPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DeleteStreamingDistributionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { DeleteStreamingDistributionRequest } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface DeleteStreamingDistributionCommandInput extends DeleteStreamingDistributionRequest {
    }
    export interface DeleteStreamingDistributionCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Delete a streaming distribution. To delete an RTMP distribution using the CloudFront API,
        * 			perform the following steps.</p>
        *
        * 		       <p>
        *             <b>To delete an RTMP distribution using the CloudFront
        * 			API</b>:</p>
        * 		       <ol>
        *             <li>
        * 				           <p>Disable the RTMP distribution.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Submit a <code>GET Streaming Distribution Config</code> request to get the current
        * 					configuration and the <code>Etag</code> header for the distribution. </p>
        * 			         </li>
        *             <li>
        * 				           <p>Update the XML document that was returned in the response to your <code>GET
        * 						Streaming Distribution Config</code> request to change the value of <code>Enabled</code>
        * 					to <code>false</code>.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Submit a <code>PUT Streaming Distribution Config</code> request to update the
        * 					configuration for your distribution. In the request body, include the XML document that
        * 					you updated in Step 3. Then set the value of the HTTP <code>If-Match</code> header to the
        * 					value of the <code>ETag</code> header that CloudFront returned when you submitted the <code>GET
        * 						Streaming Distribution Config</code> request in Step 2.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Review the response to the <code>PUT Streaming Distribution Config</code> request
        * 					to confirm that the distribution was successfully disabled.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Submit a <code>GET Streaming Distribution Config</code> request to confirm that
        * 					your changes have propagated. When propagation is complete, the value of
        * 						<code>Status</code> is <code>Deployed</code>.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Submit a <code>DELETE Streaming Distribution</code> request. Set the value of the
        * 					HTTP <code>If-Match</code> header to the value of the <code>ETag</code> header that CloudFront
        * 					returned when you submitted the <code>GET Streaming Distribution Config</code> request in
        * 					Step 2.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Review the response to your <code>DELETE Streaming Distribution</code> request to
        * 					confirm that the distribution was successfully deleted.</p>
        * 			         </li>
        *          </ol>
        * 		       <p>For information about deleting a distribution using the CloudFront console, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/HowToDeleteDistribution.html">Deleting a Distribution</a> in the
        * 				<i>Amazon CloudFront Developer Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, DeleteStreamingDistributionCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, DeleteStreamingDistributionCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new DeleteStreamingDistributionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteStreamingDistributionCommandInput} for command's `input` shape.
        * @see {@link DeleteStreamingDistributionCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class DeleteStreamingDistributionCommand extends $Command<DeleteStreamingDistributionCommandInput, DeleteStreamingDistributionCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: DeleteStreamingDistributionCommandInput;
            constructor(input: DeleteStreamingDistributionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteStreamingDistributionCommandInput, DeleteStreamingDistributionCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/DescribeFunctionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { DescribeFunctionRequest, DescribeFunctionResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface DescribeFunctionCommandInput extends DescribeFunctionRequest {
    }
    export interface DescribeFunctionCommandOutput extends DescribeFunctionResult, __MetadataBearer {
    }
    /**
        * <p>Gets configuration information and metadata about a CloudFront function, but not the function’s
        * 			code. To get a function’s code, use <code>GetFunction</code>.</p>
        * 		       <p>To get configuration information and metadata about a function, you must provide the
        * 			function’s name and stage. To get these values, you can use
        * 			<code>ListFunctions</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, DescribeFunctionCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, DescribeFunctionCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new DescribeFunctionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeFunctionCommandInput} for command's `input` shape.
        * @see {@link DescribeFunctionCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class DescribeFunctionCommand extends $Command<DescribeFunctionCommandInput, DescribeFunctionCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: DescribeFunctionCommandInput;
            constructor(input: DescribeFunctionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeFunctionCommandInput, DescribeFunctionCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetCachePolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetCachePolicyRequest, GetCachePolicyResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetCachePolicyCommandInput extends GetCachePolicyRequest {
    }
    export interface GetCachePolicyCommandOutput extends GetCachePolicyResult, __MetadataBearer {
    }
    /**
        * <p>Gets a cache policy, including the following metadata:</p>
        * 		       <ul>
        *             <li>
        * 				           <p>The policy’s identifier.</p>
        * 			         </li>
        *             <li>
        * 				           <p>The date and time when the policy was last modified.</p>
        * 			         </li>
        *          </ul>
        * 		       <p>To get a cache policy, you must provide the policy’s identifier. If the cache policy is
        * 			attached to a distribution’s cache behavior, you can get the policy’s identifier using
        * 			<code>ListDistributions</code> or <code>GetDistribution</code>. If the cache policy is
        * 			not attached to a cache behavior, you can get the identifier using
        * 			<code>ListCachePolicies</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetCachePolicyCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetCachePolicyCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetCachePolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetCachePolicyCommandInput} for command's `input` shape.
        * @see {@link GetCachePolicyCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetCachePolicyCommand extends $Command<GetCachePolicyCommandInput, GetCachePolicyCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetCachePolicyCommandInput;
            constructor(input: GetCachePolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetCachePolicyCommandInput, GetCachePolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetCachePolicyConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetCachePolicyConfigRequest, GetCachePolicyConfigResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetCachePolicyConfigCommandInput extends GetCachePolicyConfigRequest {
    }
    export interface GetCachePolicyConfigCommandOutput extends GetCachePolicyConfigResult, __MetadataBearer {
    }
    /**
        * <p>Gets a cache policy configuration.</p>
        * 		       <p>To get a cache policy configuration, you must provide the policy’s identifier. If the cache
        * 			policy is attached to a distribution’s cache behavior, you can get the policy’s
        * 			identifier using <code>ListDistributions</code> or <code>GetDistribution</code>. If the
        * 			cache policy is not attached to a cache behavior, you can get the identifier using
        * 			<code>ListCachePolicies</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetCachePolicyConfigCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetCachePolicyConfigCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetCachePolicyConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetCachePolicyConfigCommandInput} for command's `input` shape.
        * @see {@link GetCachePolicyConfigCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetCachePolicyConfigCommand extends $Command<GetCachePolicyConfigCommandInput, GetCachePolicyConfigCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetCachePolicyConfigCommandInput;
            constructor(input: GetCachePolicyConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetCachePolicyConfigCommandInput, GetCachePolicyConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetCloudFrontOriginAccessIdentityCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetCloudFrontOriginAccessIdentityRequest, GetCloudFrontOriginAccessIdentityResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetCloudFrontOriginAccessIdentityCommandInput extends GetCloudFrontOriginAccessIdentityRequest {
    }
    export interface GetCloudFrontOriginAccessIdentityCommandOutput extends GetCloudFrontOriginAccessIdentityResult, __MetadataBearer {
    }
    /**
        * <p>Get the information about an origin access identity. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetCloudFrontOriginAccessIdentityCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetCloudFrontOriginAccessIdentityCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetCloudFrontOriginAccessIdentityCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetCloudFrontOriginAccessIdentityCommandInput} for command's `input` shape.
        * @see {@link GetCloudFrontOriginAccessIdentityCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetCloudFrontOriginAccessIdentityCommand extends $Command<GetCloudFrontOriginAccessIdentityCommandInput, GetCloudFrontOriginAccessIdentityCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetCloudFrontOriginAccessIdentityCommandInput;
            constructor(input: GetCloudFrontOriginAccessIdentityCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetCloudFrontOriginAccessIdentityCommandInput, GetCloudFrontOriginAccessIdentityCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetCloudFrontOriginAccessIdentityConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetCloudFrontOriginAccessIdentityConfigRequest, GetCloudFrontOriginAccessIdentityConfigResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetCloudFrontOriginAccessIdentityConfigCommandInput extends GetCloudFrontOriginAccessIdentityConfigRequest {
    }
    export interface GetCloudFrontOriginAccessIdentityConfigCommandOutput extends GetCloudFrontOriginAccessIdentityConfigResult, __MetadataBearer {
    }
    /**
        * <p>Get the configuration information about an origin access identity. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetCloudFrontOriginAccessIdentityConfigCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetCloudFrontOriginAccessIdentityConfigCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetCloudFrontOriginAccessIdentityConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetCloudFrontOriginAccessIdentityConfigCommandInput} for command's `input` shape.
        * @see {@link GetCloudFrontOriginAccessIdentityConfigCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetCloudFrontOriginAccessIdentityConfigCommand extends $Command<GetCloudFrontOriginAccessIdentityConfigCommandInput, GetCloudFrontOriginAccessIdentityConfigCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetCloudFrontOriginAccessIdentityConfigCommandInput;
            constructor(input: GetCloudFrontOriginAccessIdentityConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetCloudFrontOriginAccessIdentityConfigCommandInput, GetCloudFrontOriginAccessIdentityConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetDistributionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetDistributionRequest, GetDistributionResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetDistributionCommandInput extends GetDistributionRequest {
    }
    export interface GetDistributionCommandOutput extends GetDistributionResult, __MetadataBearer {
    }
    /**
        * <p>Get the information about a distribution.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetDistributionCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetDistributionCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetDistributionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetDistributionCommandInput} for command's `input` shape.
        * @see {@link GetDistributionCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetDistributionCommand extends $Command<GetDistributionCommandInput, GetDistributionCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetDistributionCommandInput;
            constructor(input: GetDistributionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetDistributionCommandInput, GetDistributionCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetDistributionConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetDistributionConfigRequest, GetDistributionConfigResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetDistributionConfigCommandInput extends GetDistributionConfigRequest {
    }
    export interface GetDistributionConfigCommandOutput extends GetDistributionConfigResult, __MetadataBearer {
    }
    /**
        * <p>Get the configuration information about a distribution. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetDistributionConfigCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetDistributionConfigCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetDistributionConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetDistributionConfigCommandInput} for command's `input` shape.
        * @see {@link GetDistributionConfigCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetDistributionConfigCommand extends $Command<GetDistributionConfigCommandInput, GetDistributionConfigCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetDistributionConfigCommandInput;
            constructor(input: GetDistributionConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetDistributionConfigCommandInput, GetDistributionConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetFieldLevelEncryptionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetFieldLevelEncryptionRequest, GetFieldLevelEncryptionResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetFieldLevelEncryptionCommandInput extends GetFieldLevelEncryptionRequest {
    }
    export interface GetFieldLevelEncryptionCommandOutput extends GetFieldLevelEncryptionResult, __MetadataBearer {
    }
    /**
        * <p>Get the field-level encryption configuration information.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetFieldLevelEncryptionCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetFieldLevelEncryptionCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetFieldLevelEncryptionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetFieldLevelEncryptionCommandInput} for command's `input` shape.
        * @see {@link GetFieldLevelEncryptionCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetFieldLevelEncryptionCommand extends $Command<GetFieldLevelEncryptionCommandInput, GetFieldLevelEncryptionCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetFieldLevelEncryptionCommandInput;
            constructor(input: GetFieldLevelEncryptionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetFieldLevelEncryptionCommandInput, GetFieldLevelEncryptionCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetFieldLevelEncryptionConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetFieldLevelEncryptionConfigRequest, GetFieldLevelEncryptionConfigResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetFieldLevelEncryptionConfigCommandInput extends GetFieldLevelEncryptionConfigRequest {
    }
    export interface GetFieldLevelEncryptionConfigCommandOutput extends GetFieldLevelEncryptionConfigResult, __MetadataBearer {
    }
    /**
        * <p>Get the field-level encryption configuration information.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetFieldLevelEncryptionConfigCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetFieldLevelEncryptionConfigCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetFieldLevelEncryptionConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetFieldLevelEncryptionConfigCommandInput} for command's `input` shape.
        * @see {@link GetFieldLevelEncryptionConfigCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetFieldLevelEncryptionConfigCommand extends $Command<GetFieldLevelEncryptionConfigCommandInput, GetFieldLevelEncryptionConfigCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetFieldLevelEncryptionConfigCommandInput;
            constructor(input: GetFieldLevelEncryptionConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetFieldLevelEncryptionConfigCommandInput, GetFieldLevelEncryptionConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetFieldLevelEncryptionProfileCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetFieldLevelEncryptionProfileRequest, GetFieldLevelEncryptionProfileResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetFieldLevelEncryptionProfileCommandInput extends GetFieldLevelEncryptionProfileRequest {
    }
    export interface GetFieldLevelEncryptionProfileCommandOutput extends GetFieldLevelEncryptionProfileResult, __MetadataBearer {
    }
    /**
        * <p>Get the field-level encryption profile information.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetFieldLevelEncryptionProfileCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetFieldLevelEncryptionProfileCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetFieldLevelEncryptionProfileCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetFieldLevelEncryptionProfileCommandInput} for command's `input` shape.
        * @see {@link GetFieldLevelEncryptionProfileCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetFieldLevelEncryptionProfileCommand extends $Command<GetFieldLevelEncryptionProfileCommandInput, GetFieldLevelEncryptionProfileCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetFieldLevelEncryptionProfileCommandInput;
            constructor(input: GetFieldLevelEncryptionProfileCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetFieldLevelEncryptionProfileCommandInput, GetFieldLevelEncryptionProfileCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetFieldLevelEncryptionProfileConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetFieldLevelEncryptionProfileConfigRequest, GetFieldLevelEncryptionProfileConfigResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetFieldLevelEncryptionProfileConfigCommandInput extends GetFieldLevelEncryptionProfileConfigRequest {
    }
    export interface GetFieldLevelEncryptionProfileConfigCommandOutput extends GetFieldLevelEncryptionProfileConfigResult, __MetadataBearer {
    }
    /**
        * <p>Get the field-level encryption profile configuration information.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetFieldLevelEncryptionProfileConfigCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetFieldLevelEncryptionProfileConfigCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetFieldLevelEncryptionProfileConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetFieldLevelEncryptionProfileConfigCommandInput} for command's `input` shape.
        * @see {@link GetFieldLevelEncryptionProfileConfigCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetFieldLevelEncryptionProfileConfigCommand extends $Command<GetFieldLevelEncryptionProfileConfigCommandInput, GetFieldLevelEncryptionProfileConfigCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetFieldLevelEncryptionProfileConfigCommandInput;
            constructor(input: GetFieldLevelEncryptionProfileConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetFieldLevelEncryptionProfileConfigCommandInput, GetFieldLevelEncryptionProfileConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetFunctionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetFunctionRequest, GetFunctionResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetFunctionCommandInput extends GetFunctionRequest {
    }
    export interface GetFunctionCommandOutput extends GetFunctionResult, __MetadataBearer {
    }
    /**
        * <p>Gets the code of a CloudFront function. To get configuration information and metadata about
        * 			a function, use <code>DescribeFunction</code>.</p>
        * 		       <p>To get a function’s code, you must provide the function’s name and stage. To get these
        * 			values, you can use <code>ListFunctions</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetFunctionCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetFunctionCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetFunctionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetFunctionCommandInput} for command's `input` shape.
        * @see {@link GetFunctionCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetFunctionCommand extends $Command<GetFunctionCommandInput, GetFunctionCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetFunctionCommandInput;
            constructor(input: GetFunctionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetFunctionCommandInput, GetFunctionCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetInvalidationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetInvalidationRequest, GetInvalidationResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetInvalidationCommandInput extends GetInvalidationRequest {
    }
    export interface GetInvalidationCommandOutput extends GetInvalidationResult, __MetadataBearer {
    }
    /**
        * <p>Get the information about an invalidation. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetInvalidationCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetInvalidationCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetInvalidationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetInvalidationCommandInput} for command's `input` shape.
        * @see {@link GetInvalidationCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetInvalidationCommand extends $Command<GetInvalidationCommandInput, GetInvalidationCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetInvalidationCommandInput;
            constructor(input: GetInvalidationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetInvalidationCommandInput, GetInvalidationCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetKeyGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetKeyGroupRequest, GetKeyGroupResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetKeyGroupCommandInput extends GetKeyGroupRequest {
    }
    export interface GetKeyGroupCommandOutput extends GetKeyGroupResult, __MetadataBearer {
    }
    /**
        * <p>Gets a key group, including the date and time when the key group was last modified.</p>
        * 		       <p>To get a key group, you must provide the key group’s identifier. If the key group is
        * 			referenced in a distribution’s cache behavior, you can get the key group’s identifier
        * 			using <code>ListDistributions</code> or <code>GetDistribution</code>. If the key group
        * 			is not referenced in a cache behavior, you can get the identifier using
        * 			<code>ListKeyGroups</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetKeyGroupCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetKeyGroupCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetKeyGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetKeyGroupCommandInput} for command's `input` shape.
        * @see {@link GetKeyGroupCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetKeyGroupCommand extends $Command<GetKeyGroupCommandInput, GetKeyGroupCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetKeyGroupCommandInput;
            constructor(input: GetKeyGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetKeyGroupCommandInput, GetKeyGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetKeyGroupConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetKeyGroupConfigRequest, GetKeyGroupConfigResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetKeyGroupConfigCommandInput extends GetKeyGroupConfigRequest {
    }
    export interface GetKeyGroupConfigCommandOutput extends GetKeyGroupConfigResult, __MetadataBearer {
    }
    /**
        * <p>Gets a key group configuration.</p>
        * 		       <p>To get a key group configuration, you must provide the key group’s identifier. If the
        * 			key group is referenced in a distribution’s cache behavior, you can get the key group’s
        * 			identifier using <code>ListDistributions</code> or <code>GetDistribution</code>. If the
        * 			key group is not referenced in a cache behavior, you can get the identifier using
        * 			<code>ListKeyGroups</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetKeyGroupConfigCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetKeyGroupConfigCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetKeyGroupConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetKeyGroupConfigCommandInput} for command's `input` shape.
        * @see {@link GetKeyGroupConfigCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetKeyGroupConfigCommand extends $Command<GetKeyGroupConfigCommandInput, GetKeyGroupConfigCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetKeyGroupConfigCommandInput;
            constructor(input: GetKeyGroupConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetKeyGroupConfigCommandInput, GetKeyGroupConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetMonitoringSubscriptionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetMonitoringSubscriptionRequest, GetMonitoringSubscriptionResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetMonitoringSubscriptionCommandInput extends GetMonitoringSubscriptionRequest {
    }
    export interface GetMonitoringSubscriptionCommandOutput extends GetMonitoringSubscriptionResult, __MetadataBearer {
    }
    /**
        * <p>Gets information about whether additional CloudWatch metrics are enabled for the specified
        * 			CloudFront distribution.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetMonitoringSubscriptionCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetMonitoringSubscriptionCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetMonitoringSubscriptionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetMonitoringSubscriptionCommandInput} for command's `input` shape.
        * @see {@link GetMonitoringSubscriptionCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetMonitoringSubscriptionCommand extends $Command<GetMonitoringSubscriptionCommandInput, GetMonitoringSubscriptionCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetMonitoringSubscriptionCommandInput;
            constructor(input: GetMonitoringSubscriptionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetMonitoringSubscriptionCommandInput, GetMonitoringSubscriptionCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetOriginRequestPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetOriginRequestPolicyRequest, GetOriginRequestPolicyResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetOriginRequestPolicyCommandInput extends GetOriginRequestPolicyRequest {
    }
    export interface GetOriginRequestPolicyCommandOutput extends GetOriginRequestPolicyResult, __MetadataBearer {
    }
    /**
        * <p>Gets an origin request policy, including the following metadata:</p>
        * 		       <ul>
        *             <li>
        * 				           <p>The policy’s identifier.</p>
        * 			         </li>
        *             <li>
        * 				           <p>The date and time when the policy was last modified.</p>
        * 			         </li>
        *          </ul>
        * 		       <p>To get an origin request policy, you must provide the policy’s identifier. If the origin
        * 			request policy is attached to a distribution’s cache behavior, you can get the policy’s
        * 			identifier using <code>ListDistributions</code> or <code>GetDistribution</code>. If the
        * 			origin request policy is not attached to a cache behavior, you can get the identifier
        * 			using <code>ListOriginRequestPolicies</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetOriginRequestPolicyCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetOriginRequestPolicyCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetOriginRequestPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetOriginRequestPolicyCommandInput} for command's `input` shape.
        * @see {@link GetOriginRequestPolicyCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetOriginRequestPolicyCommand extends $Command<GetOriginRequestPolicyCommandInput, GetOriginRequestPolicyCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetOriginRequestPolicyCommandInput;
            constructor(input: GetOriginRequestPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetOriginRequestPolicyCommandInput, GetOriginRequestPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetOriginRequestPolicyConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetOriginRequestPolicyConfigRequest, GetOriginRequestPolicyConfigResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetOriginRequestPolicyConfigCommandInput extends GetOriginRequestPolicyConfigRequest {
    }
    export interface GetOriginRequestPolicyConfigCommandOutput extends GetOriginRequestPolicyConfigResult, __MetadataBearer {
    }
    /**
        * <p>Gets an origin request policy configuration.</p>
        * 		       <p>To get an origin request policy configuration, you must provide the policy’s identifier. If
        * 			the origin request policy is attached to a distribution’s cache behavior, you can get
        * 			the policy’s identifier using <code>ListDistributions</code> or
        * 			<code>GetDistribution</code>. If the origin request policy is not attached to a cache
        * 			behavior, you can get the identifier using
        * 			<code>ListOriginRequestPolicies</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetOriginRequestPolicyConfigCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetOriginRequestPolicyConfigCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetOriginRequestPolicyConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetOriginRequestPolicyConfigCommandInput} for command's `input` shape.
        * @see {@link GetOriginRequestPolicyConfigCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetOriginRequestPolicyConfigCommand extends $Command<GetOriginRequestPolicyConfigCommandInput, GetOriginRequestPolicyConfigCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetOriginRequestPolicyConfigCommandInput;
            constructor(input: GetOriginRequestPolicyConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetOriginRequestPolicyConfigCommandInput, GetOriginRequestPolicyConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetPublicKeyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetPublicKeyRequest, GetPublicKeyResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetPublicKeyCommandInput extends GetPublicKeyRequest {
    }
    export interface GetPublicKeyCommandOutput extends GetPublicKeyResult, __MetadataBearer {
    }
    /**
        * <p>Gets a public key.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetPublicKeyCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetPublicKeyCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetPublicKeyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetPublicKeyCommandInput} for command's `input` shape.
        * @see {@link GetPublicKeyCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetPublicKeyCommand extends $Command<GetPublicKeyCommandInput, GetPublicKeyCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetPublicKeyCommandInput;
            constructor(input: GetPublicKeyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetPublicKeyCommandInput, GetPublicKeyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetPublicKeyConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetPublicKeyConfigRequest, GetPublicKeyConfigResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetPublicKeyConfigCommandInput extends GetPublicKeyConfigRequest {
    }
    export interface GetPublicKeyConfigCommandOutput extends GetPublicKeyConfigResult, __MetadataBearer {
    }
    /**
        * <p>Gets a public key configuration.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetPublicKeyConfigCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetPublicKeyConfigCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetPublicKeyConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetPublicKeyConfigCommandInput} for command's `input` shape.
        * @see {@link GetPublicKeyConfigCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetPublicKeyConfigCommand extends $Command<GetPublicKeyConfigCommandInput, GetPublicKeyConfigCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetPublicKeyConfigCommandInput;
            constructor(input: GetPublicKeyConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetPublicKeyConfigCommandInput, GetPublicKeyConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetRealtimeLogConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetRealtimeLogConfigRequest, GetRealtimeLogConfigResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetRealtimeLogConfigCommandInput extends GetRealtimeLogConfigRequest {
    }
    export interface GetRealtimeLogConfigCommandOutput extends GetRealtimeLogConfigResult, __MetadataBearer {
    }
    /**
        * <p>Gets a real-time log configuration.</p>
        * 		       <p>To get a real-time log configuration, you can provide the configuration’s name or its Amazon
        * 			Resource Name (ARN). You must provide at least one. If you provide both, CloudFront uses the
        * 			name to identify the real-time log configuration to get.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetRealtimeLogConfigCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetRealtimeLogConfigCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetRealtimeLogConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetRealtimeLogConfigCommandInput} for command's `input` shape.
        * @see {@link GetRealtimeLogConfigCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetRealtimeLogConfigCommand extends $Command<GetRealtimeLogConfigCommandInput, GetRealtimeLogConfigCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetRealtimeLogConfigCommandInput;
            constructor(input: GetRealtimeLogConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetRealtimeLogConfigCommandInput, GetRealtimeLogConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetResponseHeadersPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetResponseHeadersPolicyRequest, GetResponseHeadersPolicyResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetResponseHeadersPolicyCommandInput extends GetResponseHeadersPolicyRequest {
    }
    export interface GetResponseHeadersPolicyCommandOutput extends GetResponseHeadersPolicyResult, __MetadataBearer {
    }
    /**
        * <p>Gets a response headers policy, including metadata (the policy’s identifier and the date and
        * 			time when the policy was last modified).</p>
        * 		       <p>To get a response headers policy, you must provide the policy’s identifier. If the
        * 			response headers policy is attached to a distribution’s cache behavior, you can get the
        * 			policy’s identifier using <code>ListDistributions</code> or
        * 			<code>GetDistribution</code>. If the response headers policy is not attached to a cache
        * 			behavior, you can get the identifier using
        * 			<code>ListResponseHeadersPolicies</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetResponseHeadersPolicyCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetResponseHeadersPolicyCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetResponseHeadersPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetResponseHeadersPolicyCommandInput} for command's `input` shape.
        * @see {@link GetResponseHeadersPolicyCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetResponseHeadersPolicyCommand extends $Command<GetResponseHeadersPolicyCommandInput, GetResponseHeadersPolicyCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetResponseHeadersPolicyCommandInput;
            constructor(input: GetResponseHeadersPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetResponseHeadersPolicyCommandInput, GetResponseHeadersPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetResponseHeadersPolicyConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetResponseHeadersPolicyConfigRequest, GetResponseHeadersPolicyConfigResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetResponseHeadersPolicyConfigCommandInput extends GetResponseHeadersPolicyConfigRequest {
    }
    export interface GetResponseHeadersPolicyConfigCommandOutput extends GetResponseHeadersPolicyConfigResult, __MetadataBearer {
    }
    /**
        * <p>Gets a response headers policy configuration.</p>
        * 		       <p>To get a response headers policy configuration, you must provide the policy’s
        * 			identifier. If the response headers policy is attached to a distribution’s cache
        * 			behavior, you can get the policy’s identifier using <code>ListDistributions</code> or
        * 			<code>GetDistribution</code>. If the response headers policy is not attached to a
        * 			cache behavior, you can get the identifier using
        * 			<code>ListResponseHeadersPolicies</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetResponseHeadersPolicyConfigCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetResponseHeadersPolicyConfigCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetResponseHeadersPolicyConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetResponseHeadersPolicyConfigCommandInput} for command's `input` shape.
        * @see {@link GetResponseHeadersPolicyConfigCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetResponseHeadersPolicyConfigCommand extends $Command<GetResponseHeadersPolicyConfigCommandInput, GetResponseHeadersPolicyConfigCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetResponseHeadersPolicyConfigCommandInput;
            constructor(input: GetResponseHeadersPolicyConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetResponseHeadersPolicyConfigCommandInput, GetResponseHeadersPolicyConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetStreamingDistributionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetStreamingDistributionRequest, GetStreamingDistributionResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetStreamingDistributionCommandInput extends GetStreamingDistributionRequest {
    }
    export interface GetStreamingDistributionCommandOutput extends GetStreamingDistributionResult, __MetadataBearer {
    }
    /**
        * <p>Gets information about a specified RTMP distribution, including the distribution configuration.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetStreamingDistributionCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetStreamingDistributionCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetStreamingDistributionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetStreamingDistributionCommandInput} for command's `input` shape.
        * @see {@link GetStreamingDistributionCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetStreamingDistributionCommand extends $Command<GetStreamingDistributionCommandInput, GetStreamingDistributionCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetStreamingDistributionCommandInput;
            constructor(input: GetStreamingDistributionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetStreamingDistributionCommandInput, GetStreamingDistributionCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/GetStreamingDistributionConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { GetStreamingDistributionConfigRequest, GetStreamingDistributionConfigResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface GetStreamingDistributionConfigCommandInput extends GetStreamingDistributionConfigRequest {
    }
    export interface GetStreamingDistributionConfigCommandOutput extends GetStreamingDistributionConfigResult, __MetadataBearer {
    }
    /**
        * <p>Get the configuration information about a streaming distribution. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, GetStreamingDistributionConfigCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, GetStreamingDistributionConfigCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new GetStreamingDistributionConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetStreamingDistributionConfigCommandInput} for command's `input` shape.
        * @see {@link GetStreamingDistributionConfigCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class GetStreamingDistributionConfigCommand extends $Command<GetStreamingDistributionConfigCommandInput, GetStreamingDistributionConfigCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: GetStreamingDistributionConfigCommandInput;
            constructor(input: GetStreamingDistributionConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetStreamingDistributionConfigCommandInput, GetStreamingDistributionConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListCachePoliciesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { ListCachePoliciesRequest, ListCachePoliciesResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface ListCachePoliciesCommandInput extends ListCachePoliciesRequest {
    }
    export interface ListCachePoliciesCommandOutput extends ListCachePoliciesResult, __MetadataBearer {
    }
    /**
        * <p>Gets a list of cache policies.</p>
        * 		       <p>You can optionally apply a filter to return only the managed policies created by Amazon Web Services, or
        * 			only the custom policies created in your Amazon Web Services account.</p>
        * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
        * 			the total number of items in the list exceeds the maximum that you specify, or the
        * 			default maximum, the response is paginated. To get the next page of items, send a
        * 			subsequent request that specifies the <code>NextMarker</code> value from the current
        * 			response as the <code>Marker</code> value in the subsequent request.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, ListCachePoliciesCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, ListCachePoliciesCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new ListCachePoliciesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListCachePoliciesCommandInput} for command's `input` shape.
        * @see {@link ListCachePoliciesCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class ListCachePoliciesCommand extends $Command<ListCachePoliciesCommandInput, ListCachePoliciesCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: ListCachePoliciesCommandInput;
            constructor(input: ListCachePoliciesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListCachePoliciesCommandInput, ListCachePoliciesCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListCloudFrontOriginAccessIdentitiesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { ListCloudFrontOriginAccessIdentitiesRequest, ListCloudFrontOriginAccessIdentitiesResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface ListCloudFrontOriginAccessIdentitiesCommandInput extends ListCloudFrontOriginAccessIdentitiesRequest {
    }
    export interface ListCloudFrontOriginAccessIdentitiesCommandOutput extends ListCloudFrontOriginAccessIdentitiesResult, __MetadataBearer {
    }
    /**
        * <p>Lists origin access identities.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, ListCloudFrontOriginAccessIdentitiesCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, ListCloudFrontOriginAccessIdentitiesCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new ListCloudFrontOriginAccessIdentitiesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListCloudFrontOriginAccessIdentitiesCommandInput} for command's `input` shape.
        * @see {@link ListCloudFrontOriginAccessIdentitiesCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class ListCloudFrontOriginAccessIdentitiesCommand extends $Command<ListCloudFrontOriginAccessIdentitiesCommandInput, ListCloudFrontOriginAccessIdentitiesCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: ListCloudFrontOriginAccessIdentitiesCommandInput;
            constructor(input: ListCloudFrontOriginAccessIdentitiesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListCloudFrontOriginAccessIdentitiesCommandInput, ListCloudFrontOriginAccessIdentitiesCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListConflictingAliasesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { ListConflictingAliasesRequest, ListConflictingAliasesResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface ListConflictingAliasesCommandInput extends ListConflictingAliasesRequest {
    }
    export interface ListConflictingAliasesCommandOutput extends ListConflictingAliasesResult, __MetadataBearer {
    }
    /**
        * <p>Gets a list of aliases (also called CNAMEs or alternate domain names) that conflict or
        * 			overlap with the provided alias, and the associated CloudFront distributions and Amazon Web Services
        * 			accounts for each conflicting alias. In the returned list, the distribution and account
        * 			IDs are partially hidden, which allows you to identify the distributions and accounts
        * 			that you own, but helps to protect the information of ones that you don’t own.</p>
        * 		       <p>Use this operation to find aliases that are in use in CloudFront that conflict or overlap
        * 			with the provided alias. For example, if you provide <code>www.example.com</code> as
        * 			input, the returned list can include <code>www.example.com</code> and the overlapping
        * 			wildcard alternate domain name (<code>*.example.com</code>), if they exist. If you
        * 			provide <code>*.example.com</code> as input, the returned list can include
        * 			<code>*.example.com</code> and any alternate domain names covered by that wildcard (for
        * 			example, <code>www.example.com</code>, <code>test.example.com</code>,
        * 			<code>dev.example.com</code>, and so on), if they exist.</p>
        * 		       <p>To list conflicting aliases, you provide the alias to search and the ID of a distribution in
        * 			your account that has an attached SSL/TLS certificate that includes the provided alias.
        * 			For more information, including how to set up the distribution and certificate, see
        * 			<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/CNAMEs.html#alternate-domain-names-move">Moving an alternate domain name to a different distribution</a>
        * 			in the <i>Amazon CloudFront Developer Guide</i>.</p>
        * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
        * 			the total number of items in the list exceeds the maximum that you specify, or the
        * 			default maximum, the response is paginated. To get the next page of items, send a
        * 			subsequent request that specifies the <code>NextMarker</code> value from the current
        * 			response as the <code>Marker</code> value in the subsequent request.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, ListConflictingAliasesCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, ListConflictingAliasesCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new ListConflictingAliasesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListConflictingAliasesCommandInput} for command's `input` shape.
        * @see {@link ListConflictingAliasesCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class ListConflictingAliasesCommand extends $Command<ListConflictingAliasesCommandInput, ListConflictingAliasesCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: ListConflictingAliasesCommandInput;
            constructor(input: ListConflictingAliasesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListConflictingAliasesCommandInput, ListConflictingAliasesCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListDistributionsByCachePolicyIdCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { ListDistributionsByCachePolicyIdRequest, ListDistributionsByCachePolicyIdResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface ListDistributionsByCachePolicyIdCommandInput extends ListDistributionsByCachePolicyIdRequest {
    }
    export interface ListDistributionsByCachePolicyIdCommandOutput extends ListDistributionsByCachePolicyIdResult, __MetadataBearer {
    }
    /**
        * <p>Gets a list of distribution IDs for distributions that have a cache behavior that’s
        * 			associated with the specified cache policy.</p>
        * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
        * 			the total number of items in the list exceeds the maximum that you specify, or the
        * 			default maximum, the response is paginated. To get the next page of items, send a
        * 			subsequent request that specifies the <code>NextMarker</code> value from the current
        * 			response as the <code>Marker</code> value in the subsequent request.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, ListDistributionsByCachePolicyIdCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, ListDistributionsByCachePolicyIdCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new ListDistributionsByCachePolicyIdCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListDistributionsByCachePolicyIdCommandInput} for command's `input` shape.
        * @see {@link ListDistributionsByCachePolicyIdCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class ListDistributionsByCachePolicyIdCommand extends $Command<ListDistributionsByCachePolicyIdCommandInput, ListDistributionsByCachePolicyIdCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: ListDistributionsByCachePolicyIdCommandInput;
            constructor(input: ListDistributionsByCachePolicyIdCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListDistributionsByCachePolicyIdCommandInput, ListDistributionsByCachePolicyIdCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListDistributionsByKeyGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { ListDistributionsByKeyGroupRequest, ListDistributionsByKeyGroupResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface ListDistributionsByKeyGroupCommandInput extends ListDistributionsByKeyGroupRequest {
    }
    export interface ListDistributionsByKeyGroupCommandOutput extends ListDistributionsByKeyGroupResult, __MetadataBearer {
    }
    /**
        * <p>Gets a list of distribution IDs for distributions that have a cache behavior that references
        * 			the specified key group.</p>
        * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
        * 			the total number of items in the list exceeds the maximum that you specify, or the
        * 			default maximum, the response is paginated. To get the next page of items, send a
        * 			subsequent request that specifies the <code>NextMarker</code> value from the current
        * 			response as the <code>Marker</code> value in the subsequent request.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, ListDistributionsByKeyGroupCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, ListDistributionsByKeyGroupCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new ListDistributionsByKeyGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListDistributionsByKeyGroupCommandInput} for command's `input` shape.
        * @see {@link ListDistributionsByKeyGroupCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class ListDistributionsByKeyGroupCommand extends $Command<ListDistributionsByKeyGroupCommandInput, ListDistributionsByKeyGroupCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: ListDistributionsByKeyGroupCommandInput;
            constructor(input: ListDistributionsByKeyGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListDistributionsByKeyGroupCommandInput, ListDistributionsByKeyGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListDistributionsByOriginRequestPolicyIdCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { ListDistributionsByOriginRequestPolicyIdRequest, ListDistributionsByOriginRequestPolicyIdResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface ListDistributionsByOriginRequestPolicyIdCommandInput extends ListDistributionsByOriginRequestPolicyIdRequest {
    }
    export interface ListDistributionsByOriginRequestPolicyIdCommandOutput extends ListDistributionsByOriginRequestPolicyIdResult, __MetadataBearer {
    }
    /**
        * <p>Gets a list of distribution IDs for distributions that have a cache behavior that’s
        * 			associated with the specified origin request policy.</p>
        * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
        * 			the total number of items in the list exceeds the maximum that you specify, or the
        * 			default maximum, the response is paginated. To get the next page of items, send a
        * 			subsequent request that specifies the <code>NextMarker</code> value from the current
        * 			response as the <code>Marker</code> value in the subsequent request.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, ListDistributionsByOriginRequestPolicyIdCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, ListDistributionsByOriginRequestPolicyIdCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new ListDistributionsByOriginRequestPolicyIdCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListDistributionsByOriginRequestPolicyIdCommandInput} for command's `input` shape.
        * @see {@link ListDistributionsByOriginRequestPolicyIdCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class ListDistributionsByOriginRequestPolicyIdCommand extends $Command<ListDistributionsByOriginRequestPolicyIdCommandInput, ListDistributionsByOriginRequestPolicyIdCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: ListDistributionsByOriginRequestPolicyIdCommandInput;
            constructor(input: ListDistributionsByOriginRequestPolicyIdCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListDistributionsByOriginRequestPolicyIdCommandInput, ListDistributionsByOriginRequestPolicyIdCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListDistributionsByRealtimeLogConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { ListDistributionsByRealtimeLogConfigRequest, ListDistributionsByRealtimeLogConfigResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface ListDistributionsByRealtimeLogConfigCommandInput extends ListDistributionsByRealtimeLogConfigRequest {
    }
    export interface ListDistributionsByRealtimeLogConfigCommandOutput extends ListDistributionsByRealtimeLogConfigResult, __MetadataBearer {
    }
    /**
        * <p>Gets a list of distributions that have a cache behavior that’s associated with the specified
        * 			real-time log configuration.</p>
        * 		       <p>You can specify the real-time log configuration by its name or its Amazon Resource Name
        * 			(ARN). You must provide at least one. If you provide both, CloudFront uses the name to
        * 			identify the real-time log configuration to list distributions for.</p>
        * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
        * 			the total number of items in the list exceeds the maximum that you specify, or the
        * 			default maximum, the response is paginated. To get the next page of items, send a
        * 			subsequent request that specifies the <code>NextMarker</code> value from the current
        * 			response as the <code>Marker</code> value in the subsequent request. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, ListDistributionsByRealtimeLogConfigCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, ListDistributionsByRealtimeLogConfigCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new ListDistributionsByRealtimeLogConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListDistributionsByRealtimeLogConfigCommandInput} for command's `input` shape.
        * @see {@link ListDistributionsByRealtimeLogConfigCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class ListDistributionsByRealtimeLogConfigCommand extends $Command<ListDistributionsByRealtimeLogConfigCommandInput, ListDistributionsByRealtimeLogConfigCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: ListDistributionsByRealtimeLogConfigCommandInput;
            constructor(input: ListDistributionsByRealtimeLogConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListDistributionsByRealtimeLogConfigCommandInput, ListDistributionsByRealtimeLogConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListDistributionsByResponseHeadersPolicyIdCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { ListDistributionsByResponseHeadersPolicyIdRequest, ListDistributionsByResponseHeadersPolicyIdResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface ListDistributionsByResponseHeadersPolicyIdCommandInput extends ListDistributionsByResponseHeadersPolicyIdRequest {
    }
    export interface ListDistributionsByResponseHeadersPolicyIdCommandOutput extends ListDistributionsByResponseHeadersPolicyIdResult, __MetadataBearer {
    }
    /**
        * <p>Gets a list of distribution IDs for distributions that have a cache behavior that’s
        * 			associated with the specified response headers policy.</p>
        * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
        * 			the total number of items in the list exceeds the maximum that you specify, or the
        * 			default maximum, the response is paginated. To get the next page of items, send a
        * 			subsequent request that specifies the <code>NextMarker</code> value from the current
        * 			response as the <code>Marker</code> value in the subsequent request.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, ListDistributionsByResponseHeadersPolicyIdCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, ListDistributionsByResponseHeadersPolicyIdCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new ListDistributionsByResponseHeadersPolicyIdCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListDistributionsByResponseHeadersPolicyIdCommandInput} for command's `input` shape.
        * @see {@link ListDistributionsByResponseHeadersPolicyIdCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class ListDistributionsByResponseHeadersPolicyIdCommand extends $Command<ListDistributionsByResponseHeadersPolicyIdCommandInput, ListDistributionsByResponseHeadersPolicyIdCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: ListDistributionsByResponseHeadersPolicyIdCommandInput;
            constructor(input: ListDistributionsByResponseHeadersPolicyIdCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListDistributionsByResponseHeadersPolicyIdCommandInput, ListDistributionsByResponseHeadersPolicyIdCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListDistributionsByWebACLIdCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { ListDistributionsByWebACLIdRequest, ListDistributionsByWebACLIdResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface ListDistributionsByWebACLIdCommandInput extends ListDistributionsByWebACLIdRequest {
    }
    export interface ListDistributionsByWebACLIdCommandOutput extends ListDistributionsByWebACLIdResult, __MetadataBearer {
    }
    /**
        * <p>List the distributions that are associated with a specified WAF web ACL.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, ListDistributionsByWebACLIdCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, ListDistributionsByWebACLIdCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new ListDistributionsByWebACLIdCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListDistributionsByWebACLIdCommandInput} for command's `input` shape.
        * @see {@link ListDistributionsByWebACLIdCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class ListDistributionsByWebACLIdCommand extends $Command<ListDistributionsByWebACLIdCommandInput, ListDistributionsByWebACLIdCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: ListDistributionsByWebACLIdCommandInput;
            constructor(input: ListDistributionsByWebACLIdCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListDistributionsByWebACLIdCommandInput, ListDistributionsByWebACLIdCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListDistributionsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { ListDistributionsRequest, ListDistributionsResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface ListDistributionsCommandInput extends ListDistributionsRequest {
    }
    export interface ListDistributionsCommandOutput extends ListDistributionsResult, __MetadataBearer {
    }
    /**
        * <p>List CloudFront distributions.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, ListDistributionsCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, ListDistributionsCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new ListDistributionsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListDistributionsCommandInput} for command's `input` shape.
        * @see {@link ListDistributionsCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class ListDistributionsCommand extends $Command<ListDistributionsCommandInput, ListDistributionsCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: ListDistributionsCommandInput;
            constructor(input: ListDistributionsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListDistributionsCommandInput, ListDistributionsCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListFieldLevelEncryptionConfigsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { ListFieldLevelEncryptionConfigsRequest, ListFieldLevelEncryptionConfigsResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface ListFieldLevelEncryptionConfigsCommandInput extends ListFieldLevelEncryptionConfigsRequest {
    }
    export interface ListFieldLevelEncryptionConfigsCommandOutput extends ListFieldLevelEncryptionConfigsResult, __MetadataBearer {
    }
    /**
        * <p>List all field-level encryption configurations that have been created in CloudFront for this account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, ListFieldLevelEncryptionConfigsCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, ListFieldLevelEncryptionConfigsCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new ListFieldLevelEncryptionConfigsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListFieldLevelEncryptionConfigsCommandInput} for command's `input` shape.
        * @see {@link ListFieldLevelEncryptionConfigsCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class ListFieldLevelEncryptionConfigsCommand extends $Command<ListFieldLevelEncryptionConfigsCommandInput, ListFieldLevelEncryptionConfigsCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: ListFieldLevelEncryptionConfigsCommandInput;
            constructor(input: ListFieldLevelEncryptionConfigsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListFieldLevelEncryptionConfigsCommandInput, ListFieldLevelEncryptionConfigsCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListFieldLevelEncryptionProfilesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { ListFieldLevelEncryptionProfilesRequest, ListFieldLevelEncryptionProfilesResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface ListFieldLevelEncryptionProfilesCommandInput extends ListFieldLevelEncryptionProfilesRequest {
    }
    export interface ListFieldLevelEncryptionProfilesCommandOutput extends ListFieldLevelEncryptionProfilesResult, __MetadataBearer {
    }
    /**
        * <p>Request a list of field-level encryption profiles that have been created in CloudFront for this account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, ListFieldLevelEncryptionProfilesCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, ListFieldLevelEncryptionProfilesCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new ListFieldLevelEncryptionProfilesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListFieldLevelEncryptionProfilesCommandInput} for command's `input` shape.
        * @see {@link ListFieldLevelEncryptionProfilesCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class ListFieldLevelEncryptionProfilesCommand extends $Command<ListFieldLevelEncryptionProfilesCommandInput, ListFieldLevelEncryptionProfilesCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: ListFieldLevelEncryptionProfilesCommandInput;
            constructor(input: ListFieldLevelEncryptionProfilesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListFieldLevelEncryptionProfilesCommandInput, ListFieldLevelEncryptionProfilesCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListFunctionsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { ListFunctionsRequest, ListFunctionsResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface ListFunctionsCommandInput extends ListFunctionsRequest {
    }
    export interface ListFunctionsCommandOutput extends ListFunctionsResult, __MetadataBearer {
    }
    /**
        * <p>Gets a list of all CloudFront functions in your Amazon Web Services account.</p>
        * 		       <p>You can optionally apply a filter to return only the functions that are in the
        * 			specified stage, either <code>DEVELOPMENT</code> or <code>LIVE</code>.</p>
        * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
        * 			the total number of items in the list exceeds the maximum that you specify, or the
        * 			default maximum, the response is paginated. To get the next page of items, send a
        * 			subsequent request that specifies the <code>NextMarker</code> value from the current
        * 			response as the <code>Marker</code> value in the subsequent request.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, ListFunctionsCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, ListFunctionsCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new ListFunctionsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListFunctionsCommandInput} for command's `input` shape.
        * @see {@link ListFunctionsCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class ListFunctionsCommand extends $Command<ListFunctionsCommandInput, ListFunctionsCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: ListFunctionsCommandInput;
            constructor(input: ListFunctionsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListFunctionsCommandInput, ListFunctionsCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListInvalidationsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { ListInvalidationsRequest, ListInvalidationsResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface ListInvalidationsCommandInput extends ListInvalidationsRequest {
    }
    export interface ListInvalidationsCommandOutput extends ListInvalidationsResult, __MetadataBearer {
    }
    /**
        * <p>Lists invalidation batches. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, ListInvalidationsCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, ListInvalidationsCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new ListInvalidationsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListInvalidationsCommandInput} for command's `input` shape.
        * @see {@link ListInvalidationsCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class ListInvalidationsCommand extends $Command<ListInvalidationsCommandInput, ListInvalidationsCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: ListInvalidationsCommandInput;
            constructor(input: ListInvalidationsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListInvalidationsCommandInput, ListInvalidationsCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListKeyGroupsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { ListKeyGroupsRequest, ListKeyGroupsResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface ListKeyGroupsCommandInput extends ListKeyGroupsRequest {
    }
    export interface ListKeyGroupsCommandOutput extends ListKeyGroupsResult, __MetadataBearer {
    }
    /**
        * <p>Gets a list of key groups.</p>
        * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
        * 			the total number of items in the list exceeds the maximum that you specify, or the
        * 			default maximum, the response is paginated. To get the next page of items, send a
        * 			subsequent request that specifies the <code>NextMarker</code> value from the current
        * 			response as the <code>Marker</code> value in the subsequent request.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, ListKeyGroupsCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, ListKeyGroupsCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new ListKeyGroupsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListKeyGroupsCommandInput} for command's `input` shape.
        * @see {@link ListKeyGroupsCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class ListKeyGroupsCommand extends $Command<ListKeyGroupsCommandInput, ListKeyGroupsCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: ListKeyGroupsCommandInput;
            constructor(input: ListKeyGroupsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListKeyGroupsCommandInput, ListKeyGroupsCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListOriginRequestPoliciesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { ListOriginRequestPoliciesRequest, ListOriginRequestPoliciesResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface ListOriginRequestPoliciesCommandInput extends ListOriginRequestPoliciesRequest {
    }
    export interface ListOriginRequestPoliciesCommandOutput extends ListOriginRequestPoliciesResult, __MetadataBearer {
    }
    /**
        * <p>Gets a list of origin request policies.</p>
        * 		       <p>You can optionally apply a filter to return only the managed policies created by Amazon Web Services, or
        * 			only the custom policies created in your Amazon Web Services account.</p>
        * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
        * 			the total number of items in the list exceeds the maximum that you specify, or the
        * 			default maximum, the response is paginated. To get the next page of items, send a
        * 			subsequent request that specifies the <code>NextMarker</code> value from the current
        * 			response as the <code>Marker</code> value in the subsequent request.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, ListOriginRequestPoliciesCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, ListOriginRequestPoliciesCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new ListOriginRequestPoliciesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListOriginRequestPoliciesCommandInput} for command's `input` shape.
        * @see {@link ListOriginRequestPoliciesCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class ListOriginRequestPoliciesCommand extends $Command<ListOriginRequestPoliciesCommandInput, ListOriginRequestPoliciesCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: ListOriginRequestPoliciesCommandInput;
            constructor(input: ListOriginRequestPoliciesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListOriginRequestPoliciesCommandInput, ListOriginRequestPoliciesCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListPublicKeysCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { ListPublicKeysRequest, ListPublicKeysResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface ListPublicKeysCommandInput extends ListPublicKeysRequest {
    }
    export interface ListPublicKeysCommandOutput extends ListPublicKeysResult, __MetadataBearer {
    }
    /**
        * <p>List all public keys that have been added to CloudFront for this account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, ListPublicKeysCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, ListPublicKeysCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new ListPublicKeysCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListPublicKeysCommandInput} for command's `input` shape.
        * @see {@link ListPublicKeysCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class ListPublicKeysCommand extends $Command<ListPublicKeysCommandInput, ListPublicKeysCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: ListPublicKeysCommandInput;
            constructor(input: ListPublicKeysCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListPublicKeysCommandInput, ListPublicKeysCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListRealtimeLogConfigsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { ListRealtimeLogConfigsRequest, ListRealtimeLogConfigsResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface ListRealtimeLogConfigsCommandInput extends ListRealtimeLogConfigsRequest {
    }
    export interface ListRealtimeLogConfigsCommandOutput extends ListRealtimeLogConfigsResult, __MetadataBearer {
    }
    /**
        * <p>Gets a list of real-time log configurations.</p>
        * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
        * 			the total number of items in the list exceeds the maximum that you specify, or the
        * 			default maximum, the response is paginated. To get the next page of items, send a
        * 			subsequent request that specifies the <code>NextMarker</code> value from the current
        * 			response as the <code>Marker</code> value in the subsequent request. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, ListRealtimeLogConfigsCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, ListRealtimeLogConfigsCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new ListRealtimeLogConfigsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListRealtimeLogConfigsCommandInput} for command's `input` shape.
        * @see {@link ListRealtimeLogConfigsCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class ListRealtimeLogConfigsCommand extends $Command<ListRealtimeLogConfigsCommandInput, ListRealtimeLogConfigsCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: ListRealtimeLogConfigsCommandInput;
            constructor(input: ListRealtimeLogConfigsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListRealtimeLogConfigsCommandInput, ListRealtimeLogConfigsCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListResponseHeadersPoliciesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { ListResponseHeadersPoliciesRequest, ListResponseHeadersPoliciesResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface ListResponseHeadersPoliciesCommandInput extends ListResponseHeadersPoliciesRequest {
    }
    export interface ListResponseHeadersPoliciesCommandOutput extends ListResponseHeadersPoliciesResult, __MetadataBearer {
    }
    /**
        * <p>Gets a list of response headers policies.</p>
        * 		       <p>You can optionally apply a filter to get only the managed policies created by Amazon Web Services,
        * 			or only the custom policies created in your Amazon Web Services account.</p>
        * 		       <p>You can optionally specify the maximum number of items to receive in the response. If
        * 			the total number of items in the list exceeds the maximum that you specify, or the
        * 			default maximum, the response is paginated. To get the next page of items, send a
        * 			subsequent request that specifies the <code>NextMarker</code> value from the current
        * 			response as the <code>Marker</code> value in the subsequent request.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, ListResponseHeadersPoliciesCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, ListResponseHeadersPoliciesCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new ListResponseHeadersPoliciesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListResponseHeadersPoliciesCommandInput} for command's `input` shape.
        * @see {@link ListResponseHeadersPoliciesCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class ListResponseHeadersPoliciesCommand extends $Command<ListResponseHeadersPoliciesCommandInput, ListResponseHeadersPoliciesCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: ListResponseHeadersPoliciesCommandInput;
            constructor(input: ListResponseHeadersPoliciesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListResponseHeadersPoliciesCommandInput, ListResponseHeadersPoliciesCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListStreamingDistributionsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { ListStreamingDistributionsRequest, ListStreamingDistributionsResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface ListStreamingDistributionsCommandInput extends ListStreamingDistributionsRequest {
    }
    export interface ListStreamingDistributionsCommandOutput extends ListStreamingDistributionsResult, __MetadataBearer {
    }
    /**
        * <p>List streaming distributions. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, ListStreamingDistributionsCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, ListStreamingDistributionsCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new ListStreamingDistributionsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListStreamingDistributionsCommandInput} for command's `input` shape.
        * @see {@link ListStreamingDistributionsCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class ListStreamingDistributionsCommand extends $Command<ListStreamingDistributionsCommandInput, ListStreamingDistributionsCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: ListStreamingDistributionsCommandInput;
            constructor(input: ListStreamingDistributionsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListStreamingDistributionsCommandInput, ListStreamingDistributionsCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/ListTagsForResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { ListTagsForResourceRequest, ListTagsForResourceResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface ListTagsForResourceCommandInput extends ListTagsForResourceRequest {
    }
    export interface ListTagsForResourceCommandOutput extends ListTagsForResourceResult, __MetadataBearer {
    }
    /**
        * <p>List tags for a CloudFront resource.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, ListTagsForResourceCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, ListTagsForResourceCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new ListTagsForResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTagsForResourceCommandInput} for command's `input` shape.
        * @see {@link ListTagsForResourceCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class ListTagsForResourceCommand extends $Command<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: ListTagsForResourceCommandInput;
            constructor(input: ListTagsForResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/PublishFunctionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { PublishFunctionRequest, PublishFunctionResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface PublishFunctionCommandInput extends PublishFunctionRequest {
    }
    export interface PublishFunctionCommandOutput extends PublishFunctionResult, __MetadataBearer {
    }
    /**
        * <p>Publishes a CloudFront function by copying the function code from the <code>DEVELOPMENT</code>
        * 			stage to <code>LIVE</code>. This automatically updates all cache behaviors that are
        * 			using this function to use the newly published copy in the <code>LIVE</code>
        * 			stage.</p>
        * 		       <p>When a function is published to the <code>LIVE</code> stage, you can attach the function to
        * 			a distribution’s cache behavior, using the function’s Amazon Resource Name (ARN).</p>
        * 		       <p>To publish a function, you must provide the function’s name and version (<code>ETag</code>
        * 			value). To get these values, you can use <code>ListFunctions</code> and
        * 			<code>DescribeFunction</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, PublishFunctionCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, PublishFunctionCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new PublishFunctionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PublishFunctionCommandInput} for command's `input` shape.
        * @see {@link PublishFunctionCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class PublishFunctionCommand extends $Command<PublishFunctionCommandInput, PublishFunctionCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: PublishFunctionCommandInput;
            constructor(input: PublishFunctionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PublishFunctionCommandInput, PublishFunctionCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/TagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { TagResourceRequest } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface TagResourceCommandInput extends TagResourceRequest {
    }
    export interface TagResourceCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Add tags to a CloudFront resource.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, TagResourceCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, TagResourceCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new TagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TagResourceCommandInput} for command's `input` shape.
        * @see {@link TagResourceCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class TagResourceCommand extends $Command<TagResourceCommandInput, TagResourceCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: TagResourceCommandInput;
            constructor(input: TagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TagResourceCommandInput, TagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/TestFunctionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { TestFunctionRequest, TestFunctionResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface TestFunctionCommandInput extends TestFunctionRequest {
    }
    export interface TestFunctionCommandOutput extends TestFunctionResult, __MetadataBearer {
    }
    /**
        * <p>Tests a CloudFront function.</p>
        * 		       <p>To test a function, you provide an <i>event object</i> that represents an HTTP
        * 			request or response that your CloudFront distribution could receive in production. CloudFront runs
        * 			the function, passing it the event object that you provided, and returns the function’s
        * 			result (the modified event object) in the response. The response also contains function
        * 			logs and error messages, if any exist. For more information about testing functions, see
        * 			<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/managing-functions.html#test-function">Testing functions</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        * 		       <p>To test a function, you provide the function’s name and version (<code>ETag</code> value)
        * 			along with the event object. To get the function’s name and version, you can use
        * 			<code>ListFunctions</code> and <code>DescribeFunction</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, TestFunctionCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, TestFunctionCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new TestFunctionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TestFunctionCommandInput} for command's `input` shape.
        * @see {@link TestFunctionCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class TestFunctionCommand extends $Command<TestFunctionCommandInput, TestFunctionCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: TestFunctionCommandInput;
            constructor(input: TestFunctionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TestFunctionCommandInput, TestFunctionCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UntagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { UntagResourceRequest } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface UntagResourceCommandInput extends UntagResourceRequest {
    }
    export interface UntagResourceCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Remove tags from a CloudFront resource.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, UntagResourceCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, UntagResourceCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new UntagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UntagResourceCommandInput} for command's `input` shape.
        * @see {@link UntagResourceCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class UntagResourceCommand extends $Command<UntagResourceCommandInput, UntagResourceCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: UntagResourceCommandInput;
            constructor(input: UntagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UntagResourceCommandInput, UntagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateCachePolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { UpdateCachePolicyRequest, UpdateCachePolicyResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface UpdateCachePolicyCommandInput extends UpdateCachePolicyRequest {
    }
    export interface UpdateCachePolicyCommandOutput extends UpdateCachePolicyResult, __MetadataBearer {
    }
    /**
        * <p>Updates a cache policy configuration.</p>
        * 		       <p>When you update a cache policy configuration, all the fields are updated with the
        * 			values provided in the request. You cannot update some fields independent of others. To
        * 			update a cache policy configuration:</p>
        * 		       <ol>
        *             <li>
        * 				           <p>Use <code>GetCachePolicyConfig</code> to get the current configuration.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Locally modify the fields in the cache policy configuration that you want to
        * 					update.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Call <code>UpdateCachePolicy</code> by providing the entire cache policy
        * 					configuration, including the fields that you modified and those that you
        * 					didn’t.</p>
        * 			         </li>
        *          </ol>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, UpdateCachePolicyCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, UpdateCachePolicyCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new UpdateCachePolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateCachePolicyCommandInput} for command's `input` shape.
        * @see {@link UpdateCachePolicyCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class UpdateCachePolicyCommand extends $Command<UpdateCachePolicyCommandInput, UpdateCachePolicyCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: UpdateCachePolicyCommandInput;
            constructor(input: UpdateCachePolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateCachePolicyCommandInput, UpdateCachePolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateCloudFrontOriginAccessIdentityCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { UpdateCloudFrontOriginAccessIdentityRequest, UpdateCloudFrontOriginAccessIdentityResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface UpdateCloudFrontOriginAccessIdentityCommandInput extends UpdateCloudFrontOriginAccessIdentityRequest {
    }
    export interface UpdateCloudFrontOriginAccessIdentityCommandOutput extends UpdateCloudFrontOriginAccessIdentityResult, __MetadataBearer {
    }
    /**
        * <p>Update an origin access identity. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, UpdateCloudFrontOriginAccessIdentityCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, UpdateCloudFrontOriginAccessIdentityCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new UpdateCloudFrontOriginAccessIdentityCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateCloudFrontOriginAccessIdentityCommandInput} for command's `input` shape.
        * @see {@link UpdateCloudFrontOriginAccessIdentityCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class UpdateCloudFrontOriginAccessIdentityCommand extends $Command<UpdateCloudFrontOriginAccessIdentityCommandInput, UpdateCloudFrontOriginAccessIdentityCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: UpdateCloudFrontOriginAccessIdentityCommandInput;
            constructor(input: UpdateCloudFrontOriginAccessIdentityCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateCloudFrontOriginAccessIdentityCommandInput, UpdateCloudFrontOriginAccessIdentityCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateDistributionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { UpdateDistributionRequest, UpdateDistributionResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface UpdateDistributionCommandInput extends UpdateDistributionRequest {
    }
    export interface UpdateDistributionCommandOutput extends UpdateDistributionResult, __MetadataBearer {
    }
    /**
        * <p>Updates the configuration for a web distribution. </p>
        * 		       <important>
        *             <p>When you update a distribution, there are more required fields than when you create a distribution.
        * 			When you update your distribution by using this API action, follow the steps here to get the current configuration
        * 			and then make your updates, to make sure that you include all of the required fields. To view a summary,
        * 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-overview-required-fields.html">Required
        * 				Fields for Create Distribution and Update Distribution</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        *          </important>
        * 		       <p>The update process includes getting the current distribution configuration, updating the XML document that is
        * 			returned to make your changes, and then submitting an <code>UpdateDistribution</code> request to make the updates.</p>
        * 		       <p>For information about updating a distribution using the CloudFront console instead, see
        * 			<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-creating-console.html">Creating a
        * 				Distribution</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        *
        * 		       <p>
        *             <b>To update a web distribution using the CloudFront API</b>
        *          </p>
        * 		       <ol>
        *             <li>
        *                <p>Submit a
        * 				<a href="https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_GetDistributionConfig.html">GetDistributionConfig</a>
        * 				request to get the current configuration and an <code>Etag</code> header
        * 				for the distribution.</p>
        * 				           <note>
        *                   <p>If you update the distribution again, you must get a new <code>Etag</code> header.</p>
        *                </note>
        * 			         </li>
        *             <li>
        *                <p>Update the XML document that was returned in the response to your <code>GetDistributionConfig</code> request to include
        * 				your changes. </p>
        * 				           <important>
        * 					             <p>When you edit the XML file, be aware of the following:</p>
        * 					             <ul>
        *                      <li>
        *                         <p>You must strip out the ETag parameter that is returned.</p>
        *                      </li>
        *                      <li>
        *                         <p>Additional fields are required when you update a distribution. There may be fields included in the
        * 							XML file for features that you haven't configured for your distribution. This is expected and required to
        * 							successfully update the distribution.</p>
        *                      </li>
        *                      <li>
        *                         <p>You can't change the value of <code>CallerReference</code>. If you try to change this value, CloudFront returns an
        * 							<code>IllegalUpdate</code> error. </p>
        *                      </li>
        *                      <li>
        *                         <p>The new configuration replaces the existing configuration; the values that you specify in an
        * 							<code>UpdateDistribution</code> request are not merged into your existing configuration. When you add, delete, or
        * 							replace values in an element that allows multiple values (for example, <code>CNAME</code>), you must specify all of the
        * 							values that you want to appear in the updated distribution. In addition,
        * 							you must update the corresponding <code>Quantity</code> element.</p>
        *                      </li>
        *                   </ul>
        *                </important>
        * 			         </li>
        *             <li>
        *                <p>Submit an <code>UpdateDistribution</code> request to update the configuration for your distribution:</p>
        * 				           <ul>
        *                   <li>
        *                      <p>In the request body, include the XML document that you updated in Step 2. The request body must include an
        * 						XML document with a <code>DistributionConfig</code> element.</p>
        *                   </li>
        *                   <li>
        *                      <p>Set the value of the HTTP <code>If-Match</code> header to the value of the <code>ETag</code> header that CloudFront returned
        * 						when you submitted the <code>GetDistributionConfig</code> request in Step 1.</p>
        *                   </li>
        *                </ul>
        * 			         </li>
        *             <li>
        *                <p>Review the response to the <code>UpdateDistribution</code> request to confirm that the configuration was
        * 				successfully updated.</p>
        *             </li>
        *             <li>
        *                <p>Optional: Submit a
        * 				<a href="https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_GetDistribution.html">GetDistribution</a>
        * 				request to confirm that your changes have propagated.
        * 				When propagation is complete, the value of <code>Status</code> is <code>Deployed</code>.</p>
        * 			         </li>
        *          </ol>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, UpdateDistributionCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, UpdateDistributionCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new UpdateDistributionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateDistributionCommandInput} for command's `input` shape.
        * @see {@link UpdateDistributionCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class UpdateDistributionCommand extends $Command<UpdateDistributionCommandInput, UpdateDistributionCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: UpdateDistributionCommandInput;
            constructor(input: UpdateDistributionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateDistributionCommandInput, UpdateDistributionCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateFieldLevelEncryptionConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { UpdateFieldLevelEncryptionConfigRequest, UpdateFieldLevelEncryptionConfigResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface UpdateFieldLevelEncryptionConfigCommandInput extends UpdateFieldLevelEncryptionConfigRequest {
    }
    export interface UpdateFieldLevelEncryptionConfigCommandOutput extends UpdateFieldLevelEncryptionConfigResult, __MetadataBearer {
    }
    /**
        * <p>Update a field-level encryption configuration. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, UpdateFieldLevelEncryptionConfigCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, UpdateFieldLevelEncryptionConfigCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new UpdateFieldLevelEncryptionConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateFieldLevelEncryptionConfigCommandInput} for command's `input` shape.
        * @see {@link UpdateFieldLevelEncryptionConfigCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class UpdateFieldLevelEncryptionConfigCommand extends $Command<UpdateFieldLevelEncryptionConfigCommandInput, UpdateFieldLevelEncryptionConfigCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: UpdateFieldLevelEncryptionConfigCommandInput;
            constructor(input: UpdateFieldLevelEncryptionConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateFieldLevelEncryptionConfigCommandInput, UpdateFieldLevelEncryptionConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateFieldLevelEncryptionProfileCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { UpdateFieldLevelEncryptionProfileRequest, UpdateFieldLevelEncryptionProfileResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface UpdateFieldLevelEncryptionProfileCommandInput extends UpdateFieldLevelEncryptionProfileRequest {
    }
    export interface UpdateFieldLevelEncryptionProfileCommandOutput extends UpdateFieldLevelEncryptionProfileResult, __MetadataBearer {
    }
    /**
        * <p>Update a field-level encryption profile. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, UpdateFieldLevelEncryptionProfileCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, UpdateFieldLevelEncryptionProfileCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new UpdateFieldLevelEncryptionProfileCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateFieldLevelEncryptionProfileCommandInput} for command's `input` shape.
        * @see {@link UpdateFieldLevelEncryptionProfileCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class UpdateFieldLevelEncryptionProfileCommand extends $Command<UpdateFieldLevelEncryptionProfileCommandInput, UpdateFieldLevelEncryptionProfileCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: UpdateFieldLevelEncryptionProfileCommandInput;
            constructor(input: UpdateFieldLevelEncryptionProfileCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateFieldLevelEncryptionProfileCommandInput, UpdateFieldLevelEncryptionProfileCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateFunctionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { UpdateFunctionRequest, UpdateFunctionResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface UpdateFunctionCommandInput extends UpdateFunctionRequest {
    }
    export interface UpdateFunctionCommandOutput extends UpdateFunctionResult, __MetadataBearer {
    }
    /**
        * <p>Updates a CloudFront function.</p>
        * 		       <p>You can update a function’s code or the comment that describes the function. You
        * 			cannot update a function’s name.</p>
        * 		       <p>To update a function, you provide the function’s name and version (<code>ETag</code> value)
        * 			along with the updated function code. To get the name and version, you can use
        * 			<code>ListFunctions</code> and <code>DescribeFunction</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, UpdateFunctionCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, UpdateFunctionCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new UpdateFunctionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateFunctionCommandInput} for command's `input` shape.
        * @see {@link UpdateFunctionCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class UpdateFunctionCommand extends $Command<UpdateFunctionCommandInput, UpdateFunctionCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: UpdateFunctionCommandInput;
            constructor(input: UpdateFunctionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateFunctionCommandInput, UpdateFunctionCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateKeyGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { UpdateKeyGroupRequest, UpdateKeyGroupResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface UpdateKeyGroupCommandInput extends UpdateKeyGroupRequest {
    }
    export interface UpdateKeyGroupCommandOutput extends UpdateKeyGroupResult, __MetadataBearer {
    }
    /**
        * <p>Updates a key group.</p>
        * 		       <p>When you update a key group, all the fields are updated with the values provided in
        * 			the request. You cannot update some fields independent of others. To update a key
        * 			group:</p>
        * 		       <ol>
        *             <li>
        * 				           <p>Get the current key group with <code>GetKeyGroup</code> or
        * 					<code>GetKeyGroupConfig</code>.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Locally modify the fields in the key group that you want to update. For
        * 					example, add or remove public key IDs.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Call <code>UpdateKeyGroup</code> with the entire key group object, including
        * 					the fields that you modified and those that you didn’t.</p>
        * 			         </li>
        *          </ol>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, UpdateKeyGroupCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, UpdateKeyGroupCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new UpdateKeyGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateKeyGroupCommandInput} for command's `input` shape.
        * @see {@link UpdateKeyGroupCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class UpdateKeyGroupCommand extends $Command<UpdateKeyGroupCommandInput, UpdateKeyGroupCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: UpdateKeyGroupCommandInput;
            constructor(input: UpdateKeyGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateKeyGroupCommandInput, UpdateKeyGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateOriginRequestPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { UpdateOriginRequestPolicyRequest, UpdateOriginRequestPolicyResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface UpdateOriginRequestPolicyCommandInput extends UpdateOriginRequestPolicyRequest {
    }
    export interface UpdateOriginRequestPolicyCommandOutput extends UpdateOriginRequestPolicyResult, __MetadataBearer {
    }
    /**
        * <p>Updates an origin request policy configuration.</p>
        * 		       <p>When you update an origin request policy configuration, all the fields are updated
        * 			with the values provided in the request. You cannot update some fields independent of
        * 			others. To update an origin request policy configuration:</p>
        * 		       <ol>
        *             <li>
        * 				           <p>Use <code>GetOriginRequestPolicyConfig</code> to get the current configuration.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Locally modify the fields in the origin request policy configuration that you
        * 					want to update.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Call <code>UpdateOriginRequestPolicy</code> by providing the entire origin
        * 					request policy configuration, including the fields that you modified and those
        * 					that you didn’t.</p>
        * 			         </li>
        *          </ol>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, UpdateOriginRequestPolicyCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, UpdateOriginRequestPolicyCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new UpdateOriginRequestPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateOriginRequestPolicyCommandInput} for command's `input` shape.
        * @see {@link UpdateOriginRequestPolicyCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class UpdateOriginRequestPolicyCommand extends $Command<UpdateOriginRequestPolicyCommandInput, UpdateOriginRequestPolicyCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: UpdateOriginRequestPolicyCommandInput;
            constructor(input: UpdateOriginRequestPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateOriginRequestPolicyCommandInput, UpdateOriginRequestPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdatePublicKeyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { UpdatePublicKeyRequest, UpdatePublicKeyResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface UpdatePublicKeyCommandInput extends UpdatePublicKeyRequest {
    }
    export interface UpdatePublicKeyCommandOutput extends UpdatePublicKeyResult, __MetadataBearer {
    }
    /**
        * <p>Update public key information. Note that the only value you can change is the comment.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, UpdatePublicKeyCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, UpdatePublicKeyCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new UpdatePublicKeyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdatePublicKeyCommandInput} for command's `input` shape.
        * @see {@link UpdatePublicKeyCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class UpdatePublicKeyCommand extends $Command<UpdatePublicKeyCommandInput, UpdatePublicKeyCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: UpdatePublicKeyCommandInput;
            constructor(input: UpdatePublicKeyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdatePublicKeyCommandInput, UpdatePublicKeyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateRealtimeLogConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { UpdateRealtimeLogConfigRequest, UpdateRealtimeLogConfigResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface UpdateRealtimeLogConfigCommandInput extends UpdateRealtimeLogConfigRequest {
    }
    export interface UpdateRealtimeLogConfigCommandOutput extends UpdateRealtimeLogConfigResult, __MetadataBearer {
    }
    /**
        * <p>Updates a real-time log configuration.</p>
        * 		       <p>When you update a real-time log configuration, all the parameters are updated with the
        * 			values provided in the request. You cannot update some parameters independent of others.
        * 			To update a real-time log configuration:</p>
        * 		       <ol>
        *             <li>
        * 				           <p>Call <code>GetRealtimeLogConfig</code> to get the current real-time log
        * 					configuration.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Locally modify the parameters in the real-time log configuration that you want
        * 					to update.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Call this API (<code>UpdateRealtimeLogConfig</code>) by providing the entire
        * 					real-time log configuration, including the parameters that you modified and
        * 					those that you didn’t.</p>
        * 			         </li>
        *          </ol>
        * 		       <p>You cannot update a real-time log configuration’s <code>Name</code> or
        * 			<code>ARN</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, UpdateRealtimeLogConfigCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, UpdateRealtimeLogConfigCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new UpdateRealtimeLogConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateRealtimeLogConfigCommandInput} for command's `input` shape.
        * @see {@link UpdateRealtimeLogConfigCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class UpdateRealtimeLogConfigCommand extends $Command<UpdateRealtimeLogConfigCommandInput, UpdateRealtimeLogConfigCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: UpdateRealtimeLogConfigCommandInput;
            constructor(input: UpdateRealtimeLogConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateRealtimeLogConfigCommandInput, UpdateRealtimeLogConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateResponseHeadersPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { UpdateResponseHeadersPolicyRequest, UpdateResponseHeadersPolicyResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface UpdateResponseHeadersPolicyCommandInput extends UpdateResponseHeadersPolicyRequest {
    }
    export interface UpdateResponseHeadersPolicyCommandOutput extends UpdateResponseHeadersPolicyResult, __MetadataBearer {
    }
    /**
        * <p>Updates a response headers policy.</p>
        * 		       <p>When you update a response headers policy, the entire policy is replaced. You cannot
        * 			update some policy fields independent of others. To update a response headers policy
        * 			configuration:</p>
        * 		       <ol>
        *             <li>
        * 				           <p>Use <code>GetResponseHeadersPolicyConfig</code> to get the current policy’s
        * 					configuration.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Modify the fields in the response headers policy configuration that you want
        * 					to update.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Call <code>UpdateResponseHeadersPolicy</code>, providing the entire response
        * 					headers policy configuration, including the fields that you modified and those
        * 					that you didn’t.</p>
        * 			         </li>
        *          </ol>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, UpdateResponseHeadersPolicyCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, UpdateResponseHeadersPolicyCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new UpdateResponseHeadersPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateResponseHeadersPolicyCommandInput} for command's `input` shape.
        * @see {@link UpdateResponseHeadersPolicyCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class UpdateResponseHeadersPolicyCommand extends $Command<UpdateResponseHeadersPolicyCommandInput, UpdateResponseHeadersPolicyCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: UpdateResponseHeadersPolicyCommandInput;
            constructor(input: UpdateResponseHeadersPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateResponseHeadersPolicyCommandInput, UpdateResponseHeadersPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/commands/UpdateStreamingDistributionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudFrontClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/CloudFrontClient";
    import { UpdateStreamingDistributionRequest, UpdateStreamingDistributionResult } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1";
    export interface UpdateStreamingDistributionCommandInput extends UpdateStreamingDistributionRequest {
    }
    export interface UpdateStreamingDistributionCommandOutput extends UpdateStreamingDistributionResult, __MetadataBearer {
    }
    /**
        * <p>Update a streaming distribution. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudFrontClient, UpdateStreamingDistributionCommand } from "@aws-sdk/client-cloudfront"; // ES Modules import
        * // const { CloudFrontClient, UpdateStreamingDistributionCommand } = require("@aws-sdk/client-cloudfront"); // CommonJS import
        * const client = new CloudFrontClient(config);
        * const command = new UpdateStreamingDistributionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateStreamingDistributionCommandInput} for command's `input` shape.
        * @see {@link UpdateStreamingDistributionCommandOutput} for command's `response` shape.
        * @see {@link CloudFrontClientResolvedConfig | config} for CloudFrontClient's `config` shape.
        *
        */
    export class UpdateStreamingDistributionCommand extends $Command<UpdateStreamingDistributionCommandInput, UpdateStreamingDistributionCommandOutput, CloudFrontClientResolvedConfig> {
            readonly input: UpdateStreamingDistributionCommandInput;
            constructor(input: UpdateStreamingDistributionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudFrontClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateStreamingDistributionCommandInput, UpdateStreamingDistributionCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { CloudFrontServiceException as __BaseException } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/CloudFrontServiceException";
    export enum ResponseHeadersPolicyAccessControlAllowMethodsValues {
            ALL = "ALL",
            DELETE = "DELETE",
            GET = "GET",
            HEAD = "HEAD",
            OPTIONS = "OPTIONS",
            PATCH = "PATCH",
            POST = "POST",
            PUT = "PUT"
    }
    /**
        * <p>Access denied.</p>
        */
    export class AccessDenied extends __BaseException {
            readonly name: "AccessDenied";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AccessDenied, __BaseException>);
    }
    /**
        * <p>A list of CloudFront key pair identifiers.</p>
        */
    export interface KeyPairIds {
            /**
                * <p>The number of key pair identifiers in the list.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>A list of CloudFront key pair identifiers.</p>
                */
            Items?: string[];
    }
    export namespace KeyPairIds {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: KeyPairIds) => any;
    }
    /**
        * <p>A list of identifiers for the public keys that CloudFront can use to verify the
        * 			signatures of signed URLs and signed cookies.</p>
        */
    export interface KGKeyPairIds {
            /**
                * <p>The identifier of the key group that contains the public keys.</p>
                */
            KeyGroupId?: string;
            /**
                * <p>A list of CloudFront key pair identifiers.</p>
                */
            KeyPairIds?: KeyPairIds;
    }
    export namespace KGKeyPairIds {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: KGKeyPairIds) => any;
    }
    /**
        * <p>A list of key groups, and the public keys in each key group,
        * 			that CloudFront can use to verify the signatures of signed URLs and signed cookies.</p>
        */
    export interface ActiveTrustedKeyGroups {
            /**
                * <p>This field is <code>true</code> if any of the key groups have public keys that CloudFront can use
                * 			to verify the signatures of signed URLs and signed cookies. If not, this field is
                * 			<code>false</code>.</p>
                */
            Enabled: boolean | undefined;
            /**
                * <p>The number of key groups in the list.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>A list of key groups, including the identifiers of the public keys in each key group that
                * 			CloudFront can use to verify the signatures of signed URLs and signed cookies.</p>
                */
            Items?: KGKeyPairIds[];
    }
    export namespace ActiveTrustedKeyGroups {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ActiveTrustedKeyGroups) => any;
    }
    /**
        * <p>A list of Amazon Web Services accounts and the active CloudFront key pairs in each account that CloudFront can use to
        * 			verify the signatures of signed URLs and signed cookies.</p>
        */
    export interface Signer {
            /**
                * <p>An Amazon Web Services account number that contains active CloudFront key pairs that CloudFront can use to verify the
                * 			signatures of signed URLs and signed cookies. If the Amazon Web Services account that owns the key pairs
                * 			is the same account that owns the CloudFront distribution, the value of this field is
                * 			<code>self</code>.</p>
                */
            AwsAccountNumber?: string;
            /**
                * <p>A list of CloudFront key pair identifiers.</p>
                */
            KeyPairIds?: KeyPairIds;
    }
    export namespace Signer {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Signer) => any;
    }
    /**
        * <p>A list of Amazon Web Services accounts and the active CloudFront key pairs in each account that CloudFront can use
        * 			to verify the signatures of signed URLs and signed cookies.</p>
        */
    export interface ActiveTrustedSigners {
            /**
                * <p>This field is <code>true</code> if any of the Amazon Web Services accounts in the list have active CloudFront
                * 			key pairs that CloudFront can use to verify the signatures of signed URLs and signed cookies.
                * 			If not, this field is <code>false</code>.</p>
                */
            Enabled: boolean | undefined;
            /**
                * <p>The number of Amazon Web Services accounts in the list.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>A list of Amazon Web Services accounts and the identifiers of active CloudFront key pairs in each account that
                * 			CloudFront can use to verify the signatures of signed URLs and signed cookies.</p>
                */
            Items?: Signer[];
    }
    export namespace ActiveTrustedSigners {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ActiveTrustedSigners) => any;
    }
    /**
        * <p>A complex type that contains information about CNAMEs (alternate domain names), if any,
        * 			for this distribution. </p>
        */
    export interface Aliases {
            /**
                * <p>The number of CNAME aliases, if any, that you want to associate with this
                * 			distribution.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>A complex type that contains the CNAME aliases, if any, that you want to associate with
                * 			this distribution.</p>
                */
            Items?: string[];
    }
    export namespace Aliases {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Aliases) => any;
    }
    export type ICPRecordalStatus = "APPROVED" | "PENDING" | "SUSPENDED";
    /**
        * <p>Amazon Web Services services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content
        * 			publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP
        * 			recordal status for CNAMEs associated with distributions. The status is returned in the CloudFront response; you can't configure
        * 			it yourself.</p>
        * 		       <p>For more information about ICP recordals, see  <a href="https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html">
        * 			Signup, Accounts, and Credentials</a> in <i>Getting Started with Amazon Web Services services in China</i>.</p>
        */
    export interface AliasICPRecordal {
            /**
                * <p>A domain name associated with a distribution. </p>
                */
            CNAME?: string;
            /**
                * <p>The Internet Content Provider (ICP) recordal status for a CNAME. The ICPRecordalStatus is set to
                * 			APPROVED for all CNAMEs (aliases) in regions outside of China. </p>
                * 		       <p>The status values returned are the following:</p>
                * 		       <ul>
                *             <li>
                *                <p>
                *                   <b>APPROVED</b> indicates that the associated CNAME has a valid ICP recordal number.
                * 			Multiple CNAMEs can be associated with a distribution, and CNAMEs can correspond to different ICP recordals. To be marked as
                * 			APPROVED, that is, valid to use with China region, a CNAME must have one ICP recordal number associated with it.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>SUSPENDED</b> indicates that the associated CNAME does not have a valid ICP recordal
                * 				number.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>PENDING</b> indicates that CloudFront can't determine the ICP recordal status of the
                * 				CNAME associated with the distribution because there was an error in trying to determine the status. You can try again
                * 				to see if the error is resolved in which case CloudFront returns an APPROVED or SUSPENDED status.</p>
                *             </li>
                *          </ul>
                */
            ICPRecordalStatus?: ICPRecordalStatus | string;
    }
    export namespace AliasICPRecordal {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AliasICPRecordal) => any;
    }
    export type Method = "DELETE" | "GET" | "HEAD" | "OPTIONS" | "PATCH" | "POST" | "PUT";
    /**
        * <p>A complex type that controls whether CloudFront caches the response to requests using the
        * 			specified HTTP methods. There are two choices:</p>
        * 		       <ul>
        *             <li>
        * 				           <p>CloudFront caches responses to <code>GET</code> and <code>HEAD</code> requests.</p>
        * 			         </li>
        *             <li>
        * 				           <p>CloudFront caches responses to <code>GET</code>, <code>HEAD</code>, and
        * 						<code>OPTIONS</code> requests.</p>
        * 			         </li>
        *          </ul>
        * 		       <p>If you pick the second choice for your Amazon S3 Origin, you may need to forward
        * 			Access-Control-Request-Method, Access-Control-Request-Headers, and Origin headers for the
        * 			responses to be cached correctly. </p>
        */
    export interface CachedMethods {
            /**
                * <p>The number of HTTP methods for which you want CloudFront to cache responses. Valid values are
                * 				<code>2</code> (for caching responses to <code>GET</code> and <code>HEAD</code> requests)
                * 			and <code>3</code> (for caching responses to <code>GET</code>, <code>HEAD</code>, and
                * 				<code>OPTIONS</code> requests).</p>
                */
            Quantity: number | undefined;
            /**
                * <p>A complex type that contains the HTTP methods that you want CloudFront to cache responses
                * 			to.</p>
                */
            Items: (Method | string)[] | undefined;
    }
    export namespace CachedMethods {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CachedMethods) => any;
    }
    /**
        * <p>A complex type that controls which HTTP methods CloudFront processes and forwards to your
        * 			Amazon S3 bucket or your custom origin. There are three choices:</p>
        * 		       <ul>
        *             <li>
        * 				           <p>CloudFront forwards only <code>GET</code> and <code>HEAD</code> requests.</p>
        * 			         </li>
        *             <li>
        * 				           <p>CloudFront forwards only <code>GET</code>, <code>HEAD</code>, and <code>OPTIONS</code>
        * 					requests.</p>
        * 			         </li>
        *             <li>
        * 				           <p>CloudFront forwards <code>GET, HEAD, OPTIONS, PUT, PATCH, POST</code>, and
        * 						<code>DELETE</code> requests.</p>
        * 			         </li>
        *          </ul>
        * 		       <p>If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or
        * 			to your custom origin so users can't perform operations that you don't want them to. For
        * 			example, you might not want users to have permissions to delete objects from your
        * 			origin.</p>
        */
    export interface AllowedMethods {
            /**
                * <p>The number of HTTP methods that you want CloudFront to forward to your origin. Valid values
                * 			are 2 (for <code>GET</code> and <code>HEAD</code> requests), 3 (for <code>GET</code>,
                * 				<code>HEAD</code>, and <code>OPTIONS</code> requests) and 7 (for <code>GET, HEAD, OPTIONS,
                * 				PUT, PATCH, POST</code>, and <code>DELETE</code> requests).</p>
                */
            Quantity: number | undefined;
            /**
                * <p>A complex type that contains the HTTP methods that you want CloudFront to process and forward
                * 			to your origin.</p>
                */
            Items: (Method | string)[] | undefined;
            /**
                * <p>A complex type that controls whether CloudFront caches the response to requests using the
                * 			specified HTTP methods. There are two choices:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>CloudFront caches responses to <code>GET</code> and <code>HEAD</code> requests.</p>
                * 			         </li>
                *             <li>
                * 				           <p>CloudFront caches responses to <code>GET</code>, <code>HEAD</code>, and
                * 						<code>OPTIONS</code> requests.</p>
                * 			         </li>
                *          </ul>
                * 		       <p>If you pick the second choice for your Amazon S3 Origin, you may need to forward
                * 			Access-Control-Request-Method, Access-Control-Request-Headers, and Origin headers for the
                * 			responses to be cached correctly. </p>
                */
            CachedMethods?: CachedMethods;
    }
    export namespace AllowedMethods {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AllowedMethods) => any;
    }
    export interface AssociateAliasRequest {
            /**
                * <p>The ID of the distribution that you’re associating the alias with.</p>
                */
            TargetDistributionId: string | undefined;
            /**
                * <p>The alias (also known as a CNAME) to add to the target distribution.</p>
                */
            Alias: string | undefined;
    }
    export namespace AssociateAliasRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AssociateAliasRequest) => any;
    }
    /**
        * <p>The update contains modifications that are not allowed.</p>
        */
    export class IllegalUpdate extends __BaseException {
            readonly name: "IllegalUpdate";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<IllegalUpdate, __BaseException>);
    }
    /**
        * <p>An argument is invalid.</p>
        */
    export class InvalidArgument extends __BaseException {
            readonly name: "InvalidArgument";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidArgument, __BaseException>);
    }
    /**
        * <p>The specified distribution does not exist.</p>
        */
    export class NoSuchDistribution extends __BaseException {
            readonly name: "NoSuchDistribution";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NoSuchDistribution, __BaseException>);
    }
    /**
        * <p>Your request contains more CNAMEs than are allowed per distribution.</p>
        */
    export class TooManyDistributionCNAMEs extends __BaseException {
            readonly name: "TooManyDistributionCNAMEs";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyDistributionCNAMEs, __BaseException>);
    }
    /**
        * <p>Invalidation batch specified is too large.</p>
        */
    export class BatchTooLarge extends __BaseException {
            readonly name: "BatchTooLarge";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<BatchTooLarge, __BaseException>);
    }
    export type ItemSelection = "all" | "none" | "whitelist";
    /**
        * <p>Contains a list of cookie names.</p>
        */
    export interface CookieNames {
            /**
                * <p>The number of cookie names in the <code>Items</code> list.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>A list of cookie names.</p>
                */
            Items?: string[];
    }
    export namespace CookieNames {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CookieNames) => any;
    }
    /**
        * <p>This field is deprecated. We recommend that you use a cache policy or an origin
        * 			request policy instead of this field.</p>
        * 		       <p>If you want to include cookies in the cache key, use <code>CookiesConfig</code> in a
        * 			cache policy. See <code>CachePolicy</code>.</p>
        * 		       <p>If you want to send cookies to the origin but not include them in the cache key, use
        * 			<code>CookiesConfig</code> in an origin request policy. See
        * 			<code>OriginRequestPolicy</code>.</p>
        * 		       <p>A complex type that specifies whether you want CloudFront to forward cookies to the origin
        * 			and, if so, which ones. For more information about forwarding cookies to the origin, see
        * 			<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Cookies.html">Caching Content
        * 				Based on Cookies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export interface CookiePreference {
            /**
                * <p>This field is deprecated. We recommend that you use a cache policy or an origin
                * 			request policy instead of this field.</p>
                * 		       <p>If you want to include cookies in the cache key, use a cache policy. For more information,
                * 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>If you want to send cookies to the origin but not include them in the cache key, use origin
                * 			request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>Specifies which cookies to forward to the origin for this cache behavior: all, none, or
                * 			the list of cookies specified in the <code>WhitelistedNames</code> complex type.</p>
                * 		       <p>Amazon S3 doesn't process cookies. When the cache behavior is forwarding requests to an
                * 			Amazon S3 origin, specify none for the <code>Forward</code> element.</p>
                */
            Forward: ItemSelection | string | undefined;
            /**
                * <p>This field is deprecated. We recommend that you use a cache policy or an origin
                * 			request policy instead of this field.</p>
                * 		       <p>If you want to include cookies in the cache key, use a cache policy. For more information,
                * 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>If you want to send cookies to the origin but not include them in the cache key, use an
                * 			origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>Required if you specify <code>whitelist</code> for the value of <code>Forward</code>.
                * 			A complex type that specifies how many different cookies you want CloudFront to forward to the
                * 			origin for this cache behavior and, if you want to forward selected cookies, the names of
                * 			those cookies.</p>
                * 		       <p>If you specify <code>all</code> or <code>none</code> for the value of <code>Forward</code>, omit
                * 				<code>WhitelistedNames</code>. If you change the value of <code>Forward</code> from
                * 			<code>whitelist</code> to <code>all</code> or <code>none</code> and you don't delete the <code>WhitelistedNames</code>
                * 			element and its child elements, CloudFront deletes them automatically.</p>
                * 		       <p>For the current limit on the number of cookie names that you can whitelist for each
                * 			cache behavior, see <a href="https://docs.aws.amazon.com/general/latest/gr/xrefaws_service_limits.html#limits_cloudfront">
                * 				CloudFront Limits</a> in the <i>Amazon Web Services General Reference</i>.</p>
                */
            WhitelistedNames?: CookieNames;
    }
    export namespace CookiePreference {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CookiePreference) => any;
    }
    /**
        * <p>Contains a list of HTTP header names.</p>
        */
    export interface Headers {
            /**
                * <p>The number of header names in the <code>Items</code> list.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>A list of HTTP header names.</p>
                */
            Items?: string[];
    }
    export namespace Headers {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Headers) => any;
    }
    /**
        * <p>This field is deprecated. We recommend that you use a cache policy or an origin
        * 			request policy instead of this field.</p>
        * 		       <p>If you want to include query strings in the cache key, use
        * 			<code>QueryStringsConfig</code> in a cache policy. See
        * 			<code>CachePolicy</code>.</p>
        * 		       <p>If you want to send query strings to the origin but not include them in the cache key,
        * 			use <code>QueryStringsConfig</code> in an origin request policy. See
        * 			<code>OriginRequestPolicy</code>.</p>
        * 		       <p>A complex type that contains information about the query string parameters that you want
        * 			CloudFront to use for caching for a cache behavior.
        * 		</p>
        */
    export interface QueryStringCacheKeys {
            /**
                * <p>The number of <code>whitelisted</code> query string parameters for a cache
                * 			behavior.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>A list that contains the query string parameters that you want CloudFront to use
                * 			as a basis for caching for a cache behavior. If <code>Quantity</code> is 0, you can omit
                * 			<code>Items</code>. </p>
                */
            Items?: string[];
    }
    export namespace QueryStringCacheKeys {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: QueryStringCacheKeys) => any;
    }
    /**
        * <p>This field is deprecated. We recommend that you use a cache policy or an origin
        * 			request policy instead of this field.</p>
        * 		       <p>If you want to include values in the cache key, use a cache policy. For more information,
        * 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        * 		       <p>If you want to send values to the origin but not include them in the cache key, use an
        * 			origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        * 		       <p>A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.</p>
        */
    export interface ForwardedValues {
            /**
                * <p>This field is deprecated. We recommend that you use a cache policy or an origin
                * 			request policy instead of this field.</p>
                * 		       <p>If you want to include query strings in the cache key, use a cache policy. For more
                * 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>If you want to send query strings to the origin but not include them in the cache key, use
                * 			an origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>Indicates whether you want CloudFront to forward query strings to the origin that is
                * 			associated with this cache behavior and cache based on the query string parameters. CloudFront
                * 			behavior depends on the value of <code>QueryString</code> and on the values that you specify
                * 			for <code>QueryStringCacheKeys</code>, if any:</p>
                * 		       <p>If you specify true for <code>QueryString</code> and you don't specify any values for
                * 				<code>QueryStringCacheKeys</code>, CloudFront forwards all query string parameters to the origin
                * 			and caches based on all query string parameters. Depending on how many query string parameters
                * 			and values you have, this can adversely affect performance because CloudFront must forward more
                * 			requests to the origin.</p>
                * 		       <p>If you specify true for <code>QueryString</code> and you specify one or more values for
                * 				<code>QueryStringCacheKeys</code>, CloudFront forwards all query string parameters to the origin,
                * 			but it only caches based on the query string parameters that you specify.</p>
                * 		       <p>If you specify false for <code>QueryString</code>, CloudFront doesn't forward any query
                * 			string parameters to the origin, and doesn't cache based on query string parameters.</p>
                * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/QueryStringParameters.html">Configuring CloudFront to Cache Based on Query String Parameters</a> in the
                * 				<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            QueryString: boolean | undefined;
            /**
                * <p>This field is deprecated. We recommend that you use a cache policy or an origin
                * 			request policy instead of this field.</p>
                * 		       <p>If you want to include cookies in the cache key, use a cache policy. For more
                * 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>If you want to send cookies to the origin but not include them in the cache key, use an
                * 			origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>A complex type that specifies whether you want CloudFront to forward cookies to the origin
                * 			and, if so, which ones. For more information about forwarding cookies to the origin, see
                * 			<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Cookies.html">How CloudFront Forwards, Caches, and Logs Cookies</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            Cookies: CookiePreference | undefined;
            /**
                * <p>This field is deprecated. We recommend that you use a cache policy or an origin
                * 			request policy instead of this field.</p>
                * 		       <p>If you want to include headers in the cache key, use a cache policy. For more information,
                * 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>If you want to send headers to the origin but not include them in the cache key, use an
                * 			origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>A complex type that specifies the <code>Headers</code>, if any, that you want CloudFront to forward to the
                * 			origin for this cache behavior (whitelisted headers). For the headers that you specify, CloudFront also caches
                * 			separate versions of a specified object that is based on the header values in viewer requests.</p>
                * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/header-caching.html">
                * 			Caching Content Based on Request Headers</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            Headers?: Headers;
            /**
                * <p>This field is deprecated. We recommend that you use a cache policy or an origin
                * 			request policy instead of this field.</p>
                * 		       <p>If you want to include query strings in the cache key, use a cache policy. For more
                * 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>If you want to send query strings to the origin but not include them in the cache key, use
                * 			an origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>A complex type that contains information about the query string parameters that you
                * 			want CloudFront to use for caching for this cache behavior.</p>
                */
            QueryStringCacheKeys?: QueryStringCacheKeys;
    }
    export namespace ForwardedValues {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ForwardedValues) => any;
    }
    export type EventType = "origin-request" | "origin-response" | "viewer-request" | "viewer-response";
    /**
        * <p>A CloudFront function that is associated with a cache behavior in a CloudFront
        * 			distribution.</p>
        */
    export interface FunctionAssociation {
            /**
                * <p>The Amazon Resource Name (ARN) of the function.</p>
                */
            FunctionARN: string | undefined;
            /**
                * <p>The event type of the function, either <code>viewer-request</code> or
                * 			<code>viewer-response</code>. You cannot use origin-facing event types
                * 			(<code>origin-request</code> and <code>origin-response</code>) with a CloudFront
                * 			function.</p>
                */
            EventType: EventType | string | undefined;
    }
    export namespace FunctionAssociation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FunctionAssociation) => any;
    }
    /**
        * <p>A list of CloudFront functions that are associated with a cache behavior in a CloudFront distribution.
        * 			CloudFront functions must be published to the <code>LIVE</code> stage to associate them with a
        * 			cache behavior.</p>
        */
    export interface FunctionAssociations {
            /**
                * <p>The number of CloudFront functions in the list.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>The CloudFront functions that are associated with a cache behavior in a CloudFront distribution.  CloudFront
                * 			functions must be published to the <code>LIVE</code> stage to associate them with a
                * 			cache behavior.</p>
                */
            Items?: FunctionAssociation[];
    }
    export namespace FunctionAssociations {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FunctionAssociations) => any;
    }
    /**
        * <p>A complex type that contains a Lambda@Edge function association.</p>
        */
    export interface LambdaFunctionAssociation {
            /**
                * <p>The ARN of the Lambda@Edge function. You must specify the ARN of a function version; you can't specify an alias
                * 			or $LATEST.</p>
                */
            LambdaFunctionARN: string | undefined;
            /**
                * <p>Specifies the event type that triggers a Lambda@Edge function invocation. You can specify the following values:</p>
                * 		       <ul>
                *             <li>
                *                <p>
                *                   <code>viewer-request</code>: The function executes when CloudFront receives a request from a viewer
                * 				and before it checks to see whether the requested object is in the edge cache. </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>origin-request</code>: The function executes only when CloudFront sends a request to your
                * 					origin. When the requested object is in the edge cache, the function doesn't
                * 					execute.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>origin-response</code>: The function executes after CloudFront receives a response from the origin and
                * 				before it caches the object in the response. When the requested object is in the edge cache, the function doesn't execute.</p>
                * 			         </li>
                *             <li>
                *                <p>
                *                   <code>viewer-response</code>: The function executes before CloudFront returns the requested object to the viewer.
                * 				The function executes regardless of whether the object was already in the edge cache.</p>
                * 				           <p>If the origin returns an HTTP status code other than HTTP 200 (OK), the function doesn't execute.</p>
                * 			         </li>
                *          </ul>
                */
            EventType: EventType | string | undefined;
            /**
                * <p>A flag that allows a Lambda@Edge function to have read access to the body content. For more information,
                * 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-include-body-access.html">Accessing the Request Body by Choosing the
                * 				Include Body Option</a> in the Amazon CloudFront Developer Guide.</p>
                */
            IncludeBody?: boolean;
    }
    export namespace LambdaFunctionAssociation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LambdaFunctionAssociation) => any;
    }
    /**
        * <p>A complex type that specifies a list of Lambda@Edge functions associations for a cache
        * 			behavior.</p>
        *
        * 		       <p>If you want to invoke one or more Lambda@Edge functions triggered by requests that match the
        * 				<code>PathPattern</code> of the cache behavior, specify the applicable values for
        * 				<code>Quantity</code> and <code>Items</code>. Note that there can be up to 4
        * 				<code>LambdaFunctionAssociation</code> items in this list (one for each possible value of
        * 				<code>EventType</code>) and each <code>EventType</code> can be associated with only one function.</p>
        *
        * 		       <p>If you don't want to invoke any Lambda@Edge functions for the requests that match
        * 				<code>PathPattern</code>, specify <code>0</code> for <code>Quantity</code> and omit
        * 				<code>Items</code>. </p>
        */
    export interface LambdaFunctionAssociations {
            /**
                * <p>The number of Lambda@Edge function associations for this cache behavior.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>
                *             <b>Optional</b>: A complex type that contains <code>LambdaFunctionAssociation</code> items
                * 			for this cache behavior. If <code>Quantity</code> is <code>0</code>, you can omit <code>Items</code>.</p>
                */
            Items?: LambdaFunctionAssociation[];
    }
    export namespace LambdaFunctionAssociations {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LambdaFunctionAssociations) => any;
    }
    /**
        * <p>A list of key groups whose public keys CloudFront can use to verify the signatures of signed
        * 			URLs and signed cookies.</p>
        */
    export interface TrustedKeyGroups {
            /**
                * <p>This field is <code>true</code> if any of the key groups in the list have public keys that
                * 			CloudFront can use to verify the signatures of signed URLs and signed cookies. If not, this
                * 			field is <code>false</code>.</p>
                */
            Enabled: boolean | undefined;
            /**
                * <p>The number of key groups in the list.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>A list of key groups identifiers.</p>
                */
            Items?: string[];
    }
    export namespace TrustedKeyGroups {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TrustedKeyGroups) => any;
    }
    /**
        * <p>A list of Amazon Web Services accounts whose public keys CloudFront can use to verify the signatures of signed
        * 			URLs and signed cookies.</p>
        */
    export interface TrustedSigners {
            /**
                * <p>This field is <code>true</code> if any of the Amazon Web Services accounts have public keys that CloudFront can
                * 			use to verify the signatures of signed URLs and signed cookies. If not, this field is
                * 			<code>false</code>.</p>
                */
            Enabled: boolean | undefined;
            /**
                * <p>The number of Amazon Web Services accounts in the list.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>A list of Amazon Web Services account identifiers.</p>
                */
            Items?: string[];
    }
    export namespace TrustedSigners {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TrustedSigners) => any;
    }
    export type ViewerProtocolPolicy = "allow-all" | "https-only" | "redirect-to-https";
    /**
        * <p>A complex type that describes how CloudFront processes requests.</p>
        * 		       <p>You must create at least as many cache behaviors (including the default cache behavior) as
        * 			you have origins if you want CloudFront to serve objects from all of the origins. Each cache
        * 			behavior specifies the one origin from which you want CloudFront to get objects. If you have
        * 			two origins and only the default cache behavior, the default cache behavior will cause
        * 			CloudFront to get objects from one of the origins, but the other origin is never used.</p>
        * 		       <p>For the current quota (formerly known as limit) on the number of cache behaviors that you
        * 			can add to a distribution, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        * 		       <p>If you don’t want to specify any cache behaviors, include only an empty
        * 			<code>CacheBehaviors</code> element. Don’t include an empty <code>CacheBehavior</code>
        * 			element because this is invalid.</p>
        * 		       <p>To delete all cache behaviors in an existing distribution, update the distribution
        * 			configuration and include only an empty <code>CacheBehaviors</code> element.</p>
        * 		       <p>To add, change, or remove one or more cache behaviors, update the distribution
        * 			configuration and specify all of the cache behaviors that you want to include in the updated
        * 			distribution.</p>
        * 		       <p>For more information about cache behaviors, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesCacheBehavior">Cache Behavior Settings</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export interface CacheBehavior {
            /**
                * <p>The pattern (for example, <code>images/*.jpg</code>) that specifies which requests to
                * 			apply the behavior to. When CloudFront receives a viewer request, the requested path is compared
                * 			with path patterns in the order in which cache behaviors are listed in the
                * 			distribution.</p>
                * 		       <note>
                * 			         <p>You can optionally include a slash (<code>/</code>) at the beginning of the path
                * 				pattern. For example, <code>/images/*.jpg</code>. CloudFront behavior is the same with or without
                * 				the leading <code>/</code>.</p>
                * 		       </note>
                * 		       <p>The path pattern for the default cache behavior is <code>*</code> and cannot be
                * 			changed. If the request for an object does not match the path pattern for any cache behaviors,
                * 			CloudFront applies the behavior in the default cache behavior.</p>
                * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesPathPattern">Path
                * 				Pattern</a> in the <i> Amazon CloudFront Developer Guide</i>.</p>
                */
            PathPattern: string | undefined;
            /**
                * <p>The value of <code>ID</code> for the origin that you want CloudFront to route requests to
                * 			when they match this cache behavior.</p>
                */
            TargetOriginId: string | undefined;
            /**
                * <important>
                * 			         <p>We recommend using <code>TrustedKeyGroups</code> instead of
                * 				<code>TrustedSigners</code>.</p>
                * 		       </important>
                * 		       <p>A list of Amazon Web Services account IDs whose public keys CloudFront can use to validate signed URLs or signed
                * 			cookies.</p>
                * 		       <p>When a cache behavior contains trusted signers, CloudFront requires signed URLs or signed cookies
                * 			for all requests that match the cache behavior. The URLs or cookies must be signed with
                * 			the private key of a CloudFront key pair in the trusted signer’s Amazon Web Services account. The signed URL
                * 			or cookie contains information about which public key CloudFront should use to verify the
                * 			signature. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving private content</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            TrustedSigners?: TrustedSigners;
            /**
                * <p>A list of key groups that CloudFront can use to validate signed URLs or signed cookies.</p>
                * 		       <p>When a cache behavior contains trusted key groups, CloudFront requires signed URLs or signed
                * 			cookies for all requests that match the cache behavior. The URLs or cookies must be
                * 			signed with a private key whose corresponding public key is in the key group. The signed
                * 			URL or cookie contains information about which public key CloudFront should use to verify the
                * 			signature. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving private content</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            TrustedKeyGroups?: TrustedKeyGroups;
            /**
                * <p>The protocol that viewers can use to access the files in the origin specified by
                * 				<code>TargetOriginId</code> when a request matches the path pattern in
                * 				<code>PathPattern</code>. You can specify the following options:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>
                *                   <code>allow-all</code>: Viewers can use HTTP or HTTPS.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>redirect-to-https</code>: If a viewer submits an HTTP request, CloudFront returns
                * 					an HTTP status code of 301 (Moved Permanently) to the viewer along with the HTTPS URL. The
                * 					viewer then resubmits the request using the new URL. </p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>https-only</code>: If a viewer sends an HTTP request, CloudFront returns an HTTP
                * 					status code of 403 (Forbidden). </p>
                * 			         </li>
                *          </ul>
                * 		       <p>For more information about requiring the HTTPS protocol, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-viewers-to-cloudfront.html">Requiring HTTPS Between Viewers and CloudFront</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <note>
                * 			         <p>The only way to guarantee that viewers retrieve an object that was fetched from the origin
                * 				using HTTPS is never to use any other protocol to fetch the object. If you have
                * 				recently changed from HTTP to HTTPS, we recommend that you clear your objects’ cache
                * 				because cached objects are protocol agnostic. That means that an edge location will
                * 				return an object from the cache regardless of whether the current request protocol
                * 				matches the protocol used previously. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing Cache Expiration</a> in the
                * 				<i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       </note>
                */
            ViewerProtocolPolicy: ViewerProtocolPolicy | string | undefined;
            /**
                * <p>A complex type that controls which HTTP methods CloudFront processes and forwards to your
                * 			Amazon S3 bucket or your custom origin. There are three choices:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>CloudFront forwards only <code>GET</code> and <code>HEAD</code> requests.</p>
                * 			         </li>
                *             <li>
                * 				           <p>CloudFront forwards only <code>GET</code>, <code>HEAD</code>, and <code>OPTIONS</code>
                * 					requests.</p>
                * 			         </li>
                *             <li>
                * 				           <p>CloudFront forwards <code>GET, HEAD, OPTIONS, PUT, PATCH, POST</code>, and
                * 						<code>DELETE</code> requests.</p>
                * 			         </li>
                *          </ul>
                * 		       <p>If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or
                * 			to your custom origin so users can't perform operations that you don't want them to. For
                * 			example, you might not want users to have permissions to delete objects from your
                * 			origin.</p>
                */
            AllowedMethods?: AllowedMethods;
            /**
                * <p>Indicates whether you want to distribute media files in the Microsoft Smooth Streaming
                * 			format using the origin that is associated with this cache behavior. If so, specify
                * 				<code>true</code>; if not, specify <code>false</code>. If you specify <code>true</code> for
                * 				<code>SmoothStreaming</code>, you can still distribute other content using this cache
                * 			behavior if the content matches the value of <code>PathPattern</code>. </p>
                */
            SmoothStreaming?: boolean;
            /**
                * <p>Whether you want CloudFront to automatically compress certain files for this cache behavior.
                * 			If so, specify true; if not, specify false. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html">Serving Compressed Files</a> in the
                * 				<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            Compress?: boolean;
            /**
                * <p>A complex type that contains zero or more Lambda@Edge function associations for a cache
                * 			behavior.</p>
                */
            LambdaFunctionAssociations?: LambdaFunctionAssociations;
            /**
                * <p>A list of CloudFront functions that are associated with this cache behavior. CloudFront functions must
                * 			be published to the <code>LIVE</code> stage to associate them with a cache
                * 			behavior.</p>
                */
            FunctionAssociations?: FunctionAssociations;
            /**
                * <p>The value of <code>ID</code> for the field-level encryption configuration that you want CloudFront
                * 			to use for encrypting specific fields of data for this cache behavior.</p>
                */
            FieldLevelEncryptionId?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the real-time log configuration that is attached to this
                * 			cache behavior. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html">Real-time logs</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            RealtimeLogConfigArn?: string;
            /**
                * <p>The unique identifier of the cache policy that is attached to this cache behavior. For more
                * 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
                *             <i>Amazon CloudFront Developer Guide</i>.</p>
                *         <p>A <code>CacheBehavior</code> must include either a
                *             <code>CachePolicyId</code> or <code>ForwardedValues</code>. We recommend that you
                *             use a <code>CachePolicyId</code>.</p>
                */
            CachePolicyId?: string;
            /**
                * <p>The unique identifier of the origin request policy that is attached to this cache behavior.
                * 			For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html">Using the managed origin request policies</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            OriginRequestPolicyId?: string;
            /**
                * <p>The identifier for a response headers policy.</p>
                */
            ResponseHeadersPolicyId?: string;
            /**
                * @deprecated
                *
                * <p>This field is deprecated. We recommend that you use a cache policy or an origin
                * 			request policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/working-with-policies.html">Working with policies</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>If you want to include values in the cache key, use a cache policy. For more
                * 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>If you want to send values to the origin but not include them in the cache key, use an
                * 			origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html">Using the managed origin request policies</a> in the
                *             <i>Amazon CloudFront Developer Guide</i>.</p>
                *         <p>A <code>CacheBehavior</code> must include either a
                *             <code>CachePolicyId</code> or <code>ForwardedValues</code>. We recommend that you
                *             use a <code>CachePolicyId</code>.</p>
                * 		       <p>A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.</p>
                */
            ForwardedValues?: ForwardedValues;
            /**
                * @deprecated
                *
                * <p>This field is deprecated. We recommend that you use the <code>MinTTL</code> field in a cache
                * 			policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront
                * 			forwards another request to your origin to determine whether the object has been updated. For
                * 			more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">
                * 				Managing How Long Content Stays in an Edge Cache (Expiration)</a> in the <i>
                * 				Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>You must specify <code>0</code> for <code>MinTTL</code> if you configure CloudFront to
                * 			forward all headers to your origin (under <code>Headers</code>, if you specify <code>1</code>
                * 			for <code>Quantity</code> and <code>*</code> for <code>Name</code>).</p>
                */
            MinTTL?: number;
            /**
                * @deprecated
                *
                * <p>This field is deprecated. We recommend that you use the <code>DefaultTTL</code> field in a
                * 			cache policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>The default amount of time that you want objects to stay in CloudFront caches before CloudFront
                * 			forwards another request to your origin to determine whether the object has been updated. The
                * 			value that you specify applies only when your origin does not add HTTP headers such as
                * 				<code>Cache-Control max-age</code>, <code>Cache-Control s-maxage</code>, and
                * 				<code>Expires</code> to objects. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays
                * 				in an Edge Cache (Expiration)</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            DefaultTTL?: number;
            /**
                * @deprecated
                *
                * <p>This field is deprecated. We recommend that you use the <code>MaxTTL</code> field in a cache
                * 			policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>The maximum amount of time that you want objects to stay in CloudFront caches before CloudFront
                * 			forwards another request to your origin to determine whether the object has been updated. The
                * 			value that you specify applies only when your origin adds HTTP headers such as
                * 				<code>Cache-Control max-age</code>, <code>Cache-Control s-maxage</code>, and
                * 				<code>Expires</code> to objects. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays
                * 				in an Edge Cache (Expiration)</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            MaxTTL?: number;
    }
    export namespace CacheBehavior {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CacheBehavior) => any;
    }
    /**
        * <p>A complex type that contains zero or more <code>CacheBehavior</code> elements.
        * 		</p>
        */
    export interface CacheBehaviors {
            /**
                * <p>The number of cache behaviors for this distribution. </p>
                */
            Quantity: number | undefined;
            /**
                * <p>Optional: A complex type that contains cache behaviors for this distribution. If
                * 				<code>Quantity</code> is <code>0</code>, you can omit <code>Items</code>.</p>
                */
            Items?: CacheBehavior[];
    }
    export namespace CacheBehaviors {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CacheBehaviors) => any;
    }
    export type CachePolicyCookieBehavior = "all" | "allExcept" | "none" | "whitelist";
    /**
        * <p>An object that determines whether any cookies in viewer requests (and if so, which cookies)
        * 			are included in the cache key and automatically included in requests that CloudFront sends to
        * 			the origin.</p>
        */
    export interface CachePolicyCookiesConfig {
            /**
                * <p>Determines whether any cookies in viewer requests are included in the cache key and
                * 			automatically included in requests that CloudFront sends to the origin. Valid values
                * 			are:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>
                *                   <code>none</code> – Cookies in viewer requests are not included in the cache key and are
                * 					not automatically included in requests that CloudFront sends to the origin. Even when
                * 					this field is set to <code>none</code>, any cookies that are listed in an
                * 					<code>OriginRequestPolicy</code>
                *                   <i>are</i> included in origin
                * 					requests.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>whitelist</code> – The cookies in viewer requests that are listed in the
                * 					<code>CookieNames</code> type are included in the cache key and automatically
                * 					included in requests that CloudFront sends to the origin.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>allExcept</code> – All cookies in viewer requests that are <i>
                *                      <b>not</b>
                *                   </i> listed in the <code>CookieNames</code>
                * 					type are included in the cache key and automatically included in requests that
                * 					CloudFront sends to the origin.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>all</code> – All cookies in viewer requests are included in the cache key and are
                * 					automatically included in requests that CloudFront sends to the origin.</p>
                * 			         </li>
                *          </ul>
                */
            CookieBehavior: CachePolicyCookieBehavior | string | undefined;
            /**
                * <p>Contains a list of cookie names.</p>
                */
            Cookies?: CookieNames;
    }
    export namespace CachePolicyCookiesConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CachePolicyCookiesConfig) => any;
    }
    export type CachePolicyHeaderBehavior = "none" | "whitelist";
    /**
        * <p>An object that determines whether any HTTP headers (and if so, which headers) are included
        * 			in the cache key and automatically included in requests that CloudFront sends to the
        * 			origin.</p>
        */
    export interface CachePolicyHeadersConfig {
            /**
                * <p>Determines whether any HTTP headers are included in the cache key and automatically
                * 			included in requests that CloudFront sends to the origin. Valid values are:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>
                *                   <code>none</code> – HTTP headers are not included in the cache key and are not
                * 					automatically included in requests that CloudFront sends to the origin. Even when this
                * 					field is set to <code>none</code>, any headers that are listed in an
                * 					<code>OriginRequestPolicy</code>
                *                   <i>are</i> included in origin
                * 					requests.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>whitelist</code> – The HTTP headers that are listed in the <code>Headers</code> type
                * 					are included in the cache key and are automatically included in requests that
                * 					CloudFront sends to the origin.</p>
                * 			         </li>
                *          </ul>
                */
            HeaderBehavior: CachePolicyHeaderBehavior | string | undefined;
            /**
                * <p>Contains a list of HTTP header names.</p>
                */
            Headers?: Headers;
    }
    export namespace CachePolicyHeadersConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CachePolicyHeadersConfig) => any;
    }
    export type CachePolicyQueryStringBehavior = "all" | "allExcept" | "none" | "whitelist";
    /**
        * <p>Contains a list of query string names.</p>
        */
    export interface QueryStringNames {
            /**
                * <p>The number of query string names in the <code>Items</code> list.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>A list of query string names.</p>
                */
            Items?: string[];
    }
    export namespace QueryStringNames {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: QueryStringNames) => any;
    }
    /**
        * <p>An object that determines whether any URL query strings in viewer requests (and if so, which
        * 			query strings) are included in the cache key and automatically included in requests that
        * 			CloudFront sends to the origin.</p>
        */
    export interface CachePolicyQueryStringsConfig {
            /**
                * <p>Determines whether any URL query strings in viewer requests are included in the cache key
                * 			and automatically included in requests that CloudFront sends to the origin. Valid values
                * 			are:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>
                *                   <code>none</code> – Query strings in viewer requests are not included in the cache key and
                * 					are not automatically included in requests that CloudFront sends to the origin. Even
                * 					when this field is set to <code>none</code>, any query strings that are listed
                * 					in an <code>OriginRequestPolicy</code>
                *                   <i>are</i> included in
                * 					origin requests.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>whitelist</code> – The query strings in viewer requests that are listed in the
                * 					<code>QueryStringNames</code> type are included in the cache key and
                * 					automatically included in requests that CloudFront sends to the origin.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>allExcept</code> – All query strings in viewer requests that are <i>
                *                      <b>not</b>
                *                   </i> listed in the
                * 					<code>QueryStringNames</code> type are included in the cache key and
                * 					automatically included in requests that CloudFront sends to the origin.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>all</code> – All query strings in viewer requests are included in the cache key and
                * 					are automatically included in requests that CloudFront sends to the origin.</p>
                * 			         </li>
                *          </ul>
                */
            QueryStringBehavior: CachePolicyQueryStringBehavior | string | undefined;
            /**
                * <p>Contains the specific query strings in viewer requests that either <i>
                *                <b>are</b>
                *             </i> or <i>
                *                <b>are
                * 			not</b>
                *             </i> included in the cache key and automatically included in
                * 			requests that CloudFront sends to the origin. The behavior depends on whether the
                * 			<code>QueryStringBehavior</code> field in the <code>CachePolicyQueryStringsConfig</code>
                * 			type is set to <code>whitelist</code> (the listed query strings <i>
                *                <b>are</b>
                *             </i> included) or <code>allExcept</code> (the listed
                * 			query strings <i>
                *                <b>are not</b>
                *             </i> included,
                * 			but all other query strings are).</p>
                */
            QueryStrings?: QueryStringNames;
    }
    export namespace CachePolicyQueryStringsConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CachePolicyQueryStringsConfig) => any;
    }
    /**
        * <p>This object determines the values that CloudFront includes in the cache key. These values can
        * 			include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to find an
        * 			object in its cache that it can return to the viewer.</p>
        * 		       <p>The headers, cookies, and query strings that are included in the cache key are automatically
        * 			included in requests that CloudFront sends to the origin. CloudFront sends a request when it can’t
        * 			find an object in its cache that matches the request’s cache key. If you want to send
        * 			values to the origin but <i>not</i> include them in the cache key, use
        * 			<code>OriginRequestPolicy</code>.</p>
        */
    export interface ParametersInCacheKeyAndForwardedToOrigin {
            /**
                * <p>A flag that can affect whether the <code>Accept-Encoding</code> HTTP header is
                * 			included in the cache key and included in requests that CloudFront sends to the origin.</p>
                * 		       <p>This field is related to the <code>EnableAcceptEncodingBrotli</code> field. If one or
                * 			both of these fields is <code>true</code>
                *             <i>and</i> the viewer request
                * 			includes the <code>Accept-Encoding</code> header, then CloudFront does the following:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>Normalizes the value of the viewer’s <code>Accept-Encoding</code>
                * 					header</p>
                * 			         </li>
                *             <li>
                * 				           <p>Includes the normalized header in the cache key</p>
                * 			         </li>
                *             <li>
                * 				           <p>Includes the normalized header in the request to the origin, if a request is necessary</p>
                * 			         </li>
                *          </ul>
                * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-policy-compressed-objects">Compression support</a> in the
                *             <i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>If you set this value to <code>true</code>, and this cache behavior also has an origin
                * 			request policy attached, do not include the <code>Accept-Encoding</code> header in the
                * 			origin request policy. CloudFront always includes the <code>Accept-Encoding</code> header in
                * 			origin requests when the value of this field is <code>true</code>, so including this
                * 			header in an origin request policy has no effect.</p>
                * 		       <p>If both of these fields are <code>false</code>, then CloudFront treats the
                * 			<code>Accept-Encoding</code> header the same as any other HTTP header in the viewer
                * 			request. By default, it’s not included in the cache key and it’s not included in origin
                * 			requests. In this case, you can manually add <code>Accept-Encoding</code> to the headers
                * 			whitelist like any other HTTP header.</p>
                */
            EnableAcceptEncodingGzip: boolean | undefined;
            /**
                * <p>A flag that can affect whether the <code>Accept-Encoding</code> HTTP header is
                * 			included in the cache key and included in requests that CloudFront sends to the origin.</p>
                * 		       <p>This field is related to the <code>EnableAcceptEncodingGzip</code> field. If one or
                * 			both of these fields is <code>true</code>
                *             <i>and</i> the viewer request
                * 			includes the <code>Accept-Encoding</code> header, then CloudFront does the following:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>Normalizes the value of the viewer’s <code>Accept-Encoding</code>
                * 					header</p>
                * 			         </li>
                *             <li>
                * 				           <p>Includes the normalized header in the cache key</p>
                * 			         </li>
                *             <li>
                * 				           <p>Includes the normalized header in the request to the origin, if a request is necessary</p>
                * 			         </li>
                *          </ul>
                * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-policy-compressed-objects">Compression support</a> in the
                *             <i>Amazon CloudFront Developer Guide</i>.</p>
                *         <p>If you set this value to <code>true</code>, and this cache behavior also has an origin
                * 			request policy attached, do not include the <code>Accept-Encoding</code> header in the
                * 			origin request policy. CloudFront always includes the <code>Accept-Encoding</code> header in
                * 			origin requests when the value of this field is <code>true</code>, so including this
                * 			header in an origin request policy has no effect.</p>
                * 		       <p>If both of these fields are <code>false</code>, then CloudFront treats the
                * 			<code>Accept-Encoding</code> header the same as any other HTTP header in the viewer
                * 			request. By default, it’s not included in the cache key and it’s not included in origin
                * 			requests. In this case, you can manually add <code>Accept-Encoding</code> to the headers
                * 			whitelist like any other HTTP header.</p>
                */
            EnableAcceptEncodingBrotli?: boolean;
            /**
                * <p>An object that determines whether any HTTP headers (and if so, which headers) are
                * 			included in the cache key and automatically included in requests that CloudFront sends to the
                * 			origin.</p>
                */
            HeadersConfig: CachePolicyHeadersConfig | undefined;
            /**
                * <p>An object that determines whether any cookies in viewer requests (and if so, which cookies)
                * 			are included in the cache key and automatically included in requests that CloudFront sends to
                * 			the origin.</p>
                */
            CookiesConfig: CachePolicyCookiesConfig | undefined;
            /**
                * <p>An object that determines whether any URL query strings in viewer requests (and if so, which
                * 			query strings) are included in the cache key and automatically included in requests that
                * 			CloudFront sends to the origin.</p>
                */
            QueryStringsConfig: CachePolicyQueryStringsConfig | undefined;
    }
    export namespace ParametersInCacheKeyAndForwardedToOrigin {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ParametersInCacheKeyAndForwardedToOrigin) => any;
    }
    /**
        * <p>A cache policy configuration.</p>
        * 		       <p>This configuration determines the following:</p>
        * 		       <ul>
        *             <li>
        * 				           <p>The values that CloudFront includes in the cache key. These values can include HTTP headers,
        * 					cookies, and URL query strings. CloudFront uses the cache key to find an object in its
        * 					cache that it can return to the viewer.</p>
        * 			         </li>
        *             <li>
        * 				           <p>The default, minimum, and maximum time to live (TTL) values that you want objects to stay
        * 					in the CloudFront cache.</p>
        * 			         </li>
        *          </ul>
        * 		       <p>The headers, cookies, and query strings that are included in the cache key are automatically
        * 			included in requests that CloudFront sends to the origin. CloudFront sends a request when it can’t
        * 			find a valid object in its cache that matches the request’s cache key. If you want to
        * 			send values to the origin but <i>not</i> include them in the cache key,
        * 			use <code>OriginRequestPolicy</code>.</p>
        */
    export interface CachePolicyConfig {
            /**
                * <p>A comment to describe the cache policy. The comment cannot be longer than 128
                * 			characters.</p>
                */
            Comment?: string;
            /**
                * <p>A unique name to identify the cache policy.</p>
                */
            Name: string | undefined;
            /**
                * <p>The default amount of time, in seconds, that you want objects to stay in the CloudFront
                * 			cache before CloudFront sends another request to the origin to see if the object has been
                * 			updated. CloudFront uses this value as the object’s time to live (TTL) only when the origin
                * 			does <i>not</i> send <code>Cache-Control</code> or <code>Expires</code>
                * 			headers with the object. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays in an Edge Cache (Expiration)</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>The default value for this field is 86400 seconds (one day). If the value of
                * 			<code>MinTTL</code> is more than 86400 seconds, then the default value for this field is
                * 			the same as the value of <code>MinTTL</code>.</p>
                */
            DefaultTTL?: number;
            /**
                * <p>The maximum amount of time, in seconds, that objects stay in the CloudFront cache
                * 			before CloudFront sends another request to the origin to see if the object has been updated.
                * 			CloudFront uses this value only when the origin sends <code>Cache-Control</code> or
                * 			<code>Expires</code> headers with the object. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays in an Edge Cache (Expiration)</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>The default value for this field is 31536000 seconds (one year). If the value of
                * 			<code>MinTTL</code> or <code>DefaultTTL</code> is more than 31536000 seconds, then the
                * 			default value for this field is the same as the value of <code>DefaultTTL</code>.</p>
                */
            MaxTTL?: number;
            /**
                * <p>The minimum amount of time, in seconds, that you want objects to stay in the CloudFront
                * 			cache before CloudFront sends another request to the origin to see if the object has been
                * 			updated. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays in an Edge Cache (Expiration)</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            MinTTL: number | undefined;
            /**
                * <p>The HTTP headers, cookies, and URL query strings to include in the cache key. The
                * 			values included in the cache key are automatically included in requests that CloudFront sends
                * 			to the origin.</p>
                */
            ParametersInCacheKeyAndForwardedToOrigin?: ParametersInCacheKeyAndForwardedToOrigin;
    }
    export namespace CachePolicyConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CachePolicyConfig) => any;
    }
    /**
        * <p>A cache policy.</p>
        * 		       <p>When it’s attached to a cache behavior, the cache policy determines the
        * 			following:</p>
        * 		       <ul>
        *             <li>
        * 				           <p>The values that CloudFront includes in the cache key. These values can include HTTP headers,
        * 					cookies, and URL query strings. CloudFront uses the cache key to find an object in its
        * 					cache that it can return to the viewer.</p>
        * 			         </li>
        *             <li>
        * 				           <p>The default, minimum, and maximum time to live (TTL) values that you want objects to stay
        * 					in the CloudFront cache.</p>
        * 			         </li>
        *          </ul>
        * 		       <p>The headers, cookies, and query strings that are included in the cache key are automatically
        * 			included in requests that CloudFront sends to the origin. CloudFront sends a request when it can’t
        * 			find a valid object in its cache that matches the request’s cache key. If you want to
        * 			send values to the origin but <i>not</i> include them in the cache key,
        * 			use <code>OriginRequestPolicy</code>.</p>
        */
    export interface CachePolicy {
            /**
                * <p>The unique identifier for the cache policy.</p>
                */
            Id: string | undefined;
            /**
                * <p>The date and time when the cache policy was last modified.</p>
                */
            LastModifiedTime: Date | undefined;
            /**
                * <p>The cache policy configuration.</p>
                */
            CachePolicyConfig: CachePolicyConfig | undefined;
    }
    export namespace CachePolicy {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CachePolicy) => any;
    }
    /**
        * <p>A cache policy with this name already exists. You must provide a unique name. To
        * 			modify an existing cache policy, use <code>UpdateCachePolicy</code>.</p>
        */
    export class CachePolicyAlreadyExists extends __BaseException {
            readonly name: "CachePolicyAlreadyExists";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<CachePolicyAlreadyExists, __BaseException>);
    }
    /**
        * <p>Cannot delete the cache policy because it is attached to one or more cache
        * 			behaviors.</p>
        */
    export class CachePolicyInUse extends __BaseException {
            readonly name: "CachePolicyInUse";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<CachePolicyInUse, __BaseException>);
    }
    export type CachePolicyType = "custom" | "managed";
    /**
        * <p>Contains a cache policy.</p>
        */
    export interface CachePolicySummary {
            /**
                * <p>The type of cache policy, either <code>managed</code> (created by Amazon Web Services) or
                * 			<code>custom</code> (created in this Amazon Web Services account).</p>
                */
            Type: CachePolicyType | string | undefined;
            /**
                * <p>The cache policy.</p>
                */
            CachePolicy: CachePolicy | undefined;
    }
    export namespace CachePolicySummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CachePolicySummary) => any;
    }
    /**
        * <p>A list of cache policies.</p>
        */
    export interface CachePolicyList {
            /**
                * <p>If there are more items in the list than are in this response, this element is
                * 			present. It contains the value that you should use in the <code>Marker</code> field of a
                * 			subsequent request to continue listing cache policies where you left off.</p>
                */
            NextMarker?: string;
            /**
                * <p>The maximum number of cache policies requested.</p>
                */
            MaxItems: number | undefined;
            /**
                * <p>The total number of cache policies returned in the response.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>Contains the cache policies in the list.</p>
                */
            Items?: CachePolicySummary[];
    }
    export namespace CachePolicyList {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CachePolicyList) => any;
    }
    /**
        * <p>You can't change the value of a public key.</p>
        */
    export class CannotChangeImmutablePublicKeyFields extends __BaseException {
            readonly name: "CannotChangeImmutablePublicKeyFields";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<CannotChangeImmutablePublicKeyFields, __BaseException>);
    }
    export type CertificateSource = "acm" | "cloudfront" | "iam";
    export interface CreateCachePolicyRequest {
            /**
                * <p>A cache policy configuration.</p>
                */
            CachePolicyConfig: CachePolicyConfig | undefined;
    }
    export namespace CreateCachePolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateCachePolicyRequest) => any;
    }
    export interface CreateCachePolicyResult {
            /**
                * <p>A cache policy.</p>
                */
            CachePolicy?: CachePolicy;
            /**
                * <p>The fully qualified URI of the cache policy just created.</p>
                */
            Location?: string;
            /**
                * <p>The current version of the cache policy.</p>
                */
            ETag?: string;
    }
    export namespace CreateCachePolicyResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateCachePolicyResult) => any;
    }
    /**
        * <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
        */
    export class InconsistentQuantities extends __BaseException {
            readonly name: "InconsistentQuantities";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InconsistentQuantities, __BaseException>);
    }
    /**
        * <p>You have reached the maximum number of cache policies for this Amazon Web Services account. For more
        * 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class TooManyCachePolicies extends __BaseException {
            readonly name: "TooManyCachePolicies";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyCachePolicies, __BaseException>);
    }
    /**
        * <p>The number of cookies in the cache policy exceeds the maximum. For more information,
        * 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class TooManyCookiesInCachePolicy extends __BaseException {
            readonly name: "TooManyCookiesInCachePolicy";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyCookiesInCachePolicy, __BaseException>);
    }
    /**
        * <p>The number of headers in the cache policy exceeds the maximum. For more information,
        * 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class TooManyHeadersInCachePolicy extends __BaseException {
            readonly name: "TooManyHeadersInCachePolicy";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyHeadersInCachePolicy, __BaseException>);
    }
    /**
        * <p>The number of query strings in the cache policy exceeds the maximum. For more
        * 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class TooManyQueryStringsInCachePolicy extends __BaseException {
            readonly name: "TooManyQueryStringsInCachePolicy";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyQueryStringsInCachePolicy, __BaseException>);
    }
    /**
        * <p>If the <code>CallerReference</code> is a value you already sent in a previous request to create an identity but the content
        * 			of the <code>CloudFrontOriginAccessIdentityConfig</code> is different from the original request, CloudFront returns a
        * 			<code>CloudFrontOriginAccessIdentityAlreadyExists</code> error. </p>
        */
    export class CloudFrontOriginAccessIdentityAlreadyExists extends __BaseException {
            readonly name: "CloudFrontOriginAccessIdentityAlreadyExists";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<CloudFrontOriginAccessIdentityAlreadyExists, __BaseException>);
    }
    /**
        * <p>Origin access identity configuration. Send a <code>GET</code> request to the
        * 					<code>/<i>CloudFront API version</i>/CloudFront/identity ID/config</code> resource.
        * 		</p>
        */
    export interface CloudFrontOriginAccessIdentityConfig {
            /**
                * <p>A unique value (for example, a date-time stamp) that ensures that the request can't be replayed.</p>
                * 		       <p>If the value of <code>CallerReference</code> is new (regardless of the content of the
                * 			<code>CloudFrontOriginAccessIdentityConfig</code> object), a new origin access identity is
                * 			created.</p>
                * 		       <p>If the <code>CallerReference</code> is a value already sent in a previous identity
                * 			request, and the content of the <code>CloudFrontOriginAccessIdentityConfig</code> is identical
                * 			to the original request (ignoring white space), the response includes the same information
                * 			returned to the original request. </p>
                * 		       <p>If the <code>CallerReference</code> is a value you already sent in a previous request
                * 			to create an identity, but the content of the
                * 			<code>CloudFrontOriginAccessIdentityConfig</code> is different from the original request,
                * 			CloudFront returns a <code>CloudFrontOriginAccessIdentityAlreadyExists</code> error. </p>
                */
            CallerReference: string | undefined;
            /**
                * <p>A comment to describe the origin access identity. The comment cannot be longer
                * 			than 128 characters.</p>
                */
            Comment: string | undefined;
    }
    export namespace CloudFrontOriginAccessIdentityConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CloudFrontOriginAccessIdentityConfig) => any;
    }
    /**
        * <p>The request to create a new origin access identity (OAI). An origin access identity is a
        * 			special CloudFront user that you can associate with Amazon S3 origins, so that you can secure all or
        * 			just some of your Amazon S3 content. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html">
        * 			Restricting Access to Amazon S3 Content by Using an Origin Access Identity</a> in the
        * 			<i>Amazon CloudFront Developer Guide</i>. </p>
        */
    export interface CreateCloudFrontOriginAccessIdentityRequest {
            /**
                * <p>The current configuration information for the identity.</p>
                */
            CloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig | undefined;
    }
    export namespace CreateCloudFrontOriginAccessIdentityRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateCloudFrontOriginAccessIdentityRequest) => any;
    }
    /**
        * <p>CloudFront origin access identity.</p>
        */
    export interface CloudFrontOriginAccessIdentity {
            /**
                * <p>The ID for the origin access identity, for example, <code>E74FTE3AJFJ256A</code>.
                * 		</p>
                */
            Id: string | undefined;
            /**
                * <p>The Amazon S3 canonical user ID for the origin access identity, used when giving the origin
                * 			access identity read permission to an object in Amazon S3. </p>
                */
            S3CanonicalUserId: string | undefined;
            /**
                * <p>The current configuration information for the identity. </p>
                */
            CloudFrontOriginAccessIdentityConfig?: CloudFrontOriginAccessIdentityConfig;
    }
    export namespace CloudFrontOriginAccessIdentity {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CloudFrontOriginAccessIdentity) => any;
    }
    /**
        * <p>The returned result of the corresponding request.</p>
        */
    export interface CreateCloudFrontOriginAccessIdentityResult {
            /**
                * <p>The origin access identity's information.</p>
                */
            CloudFrontOriginAccessIdentity?: CloudFrontOriginAccessIdentity;
            /**
                * <p>The fully qualified URI of the new origin access identity just created.</p>
                */
            Location?: string;
            /**
                * <p>The current version of the origin access identity created.</p>
                */
            ETag?: string;
    }
    export namespace CreateCloudFrontOriginAccessIdentityResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateCloudFrontOriginAccessIdentityResult) => any;
    }
    /**
        * <p>This operation requires a body. Ensure that the body is present and the <code>Content-Type</code> header is set.</p>
        */
    export class MissingBody extends __BaseException {
            readonly name: "MissingBody";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<MissingBody, __BaseException>);
    }
    /**
        * <p>Processing your request would cause you to exceed the maximum number of origin access identities allowed.</p>
        */
    export class TooManyCloudFrontOriginAccessIdentities extends __BaseException {
            readonly name: "TooManyCloudFrontOriginAccessIdentities";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyCloudFrontOriginAccessIdentities, __BaseException>);
    }
    /**
        * <p>The CNAME specified is already defined for CloudFront.</p>
        */
    export class CNAMEAlreadyExists extends __BaseException {
            readonly name: "CNAMEAlreadyExists";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<CNAMEAlreadyExists, __BaseException>);
    }
    /**
        * <p>A complex type that controls:</p>
        * 		       <ul>
        *             <li>
        * 				           <p>Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error
        * 					messages before returning the response to the viewer. </p>
        * 			         </li>
        *             <li>
        * 				           <p>How long CloudFront caches HTTP status codes in the 4xx and 5xx range.</p>
        * 			         </li>
        *          </ul>
        * 		       <p>For more information about custom error pages, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html">Customizing Error Responses</a> in the
        * 				<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export interface CustomErrorResponse {
            /**
                * <p>The HTTP status code for which you want to specify a custom error page and/or a caching
                * 			duration.</p>
                */
            ErrorCode: number | undefined;
            /**
                * <p>The path to the custom error page that you want CloudFront to return to a viewer when your
                * 			origin returns the HTTP status code specified by <code>ErrorCode</code>, for example,
                * 				<code>/4xx-errors/403-forbidden.html</code>. If you want to store your objects and your
                * 			custom error pages in different locations, your distribution must include a cache behavior for
                * 			which the following is true:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>The value of <code>PathPattern</code> matches the path to your custom error
                * 					messages. For example, suppose you saved custom error pages for 4xx errors in an Amazon S3
                * 					bucket in a directory named <code>/4xx-errors</code>. Your distribution must include a
                * 					cache behavior for which the path pattern routes requests for your custom error pages to
                * 					that location, for example, <code>/4xx-errors/*</code>. </p>
                * 			         </li>
                *             <li>
                * 				           <p>The value of <code>TargetOriginId</code> specifies the value of the <code>ID</code>
                * 					element for the origin that contains your custom error pages.</p>
                * 			         </li>
                *          </ul>
                * 		       <p>If you specify a value for <code>ResponsePagePath</code>, you must also specify a value
                * 			for <code>ResponseCode</code>.</p>
                * 		       <p>We recommend that you store custom error pages in an Amazon S3 bucket. If you store custom
                * 			error pages on an HTTP server and the server starts to return 5xx errors, CloudFront can't get the
                * 			files that you want to return to viewers because the origin server is unavailable.</p>
                */
            ResponsePagePath?: string;
            /**
                * <p>The HTTP status code that you want CloudFront to return to the viewer along with the custom
                * 			error page. There are a variety of reasons that you might want CloudFront to return a status code
                * 			different from the status code that your origin returned to CloudFront, for example:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>Some Internet devices (some firewalls and corporate proxies, for example) intercept
                * 					HTTP 4xx and 5xx and prevent the response from being returned to the viewer. If you
                * 					substitute <code>200</code>, the response typically won't be intercepted.</p>
                * 			         </li>
                *             <li>
                * 				           <p>If you don't care about distinguishing among different client errors or server
                * 					errors, you can specify <code>400</code> or <code>500</code> as the
                * 						<code>ResponseCode</code> for all 4xx or 5xx errors.</p>
                * 			         </li>
                *             <li>
                * 				           <p>You might want to return a <code>200</code> status code (OK) and static website so
                * 					your customers don't know that your website is down.</p>
                * 			         </li>
                *          </ul>
                * 		       <p>If you specify a value for <code>ResponseCode</code>, you must also specify a value for
                * 			<code>ResponsePagePath</code>.</p>
                */
            ResponseCode?: string;
            /**
                * <p>The minimum amount of time, in seconds, that you want CloudFront to cache the HTTP status
                * 			code specified in <code>ErrorCode</code>. When this time period has elapsed, CloudFront queries your
                * 			origin to see whether the problem that caused the error has been resolved and the requested
                * 			object is now available.</p>
                * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html">Customizing
                * 				Error Responses</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            ErrorCachingMinTTL?: number;
    }
    export namespace CustomErrorResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CustomErrorResponse) => any;
    }
    /**
        * <p>A complex type that controls:</p>
        * 		       <ul>
        *             <li>
        * 				           <p>Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error
        * 					messages before returning the response to the viewer.</p>
        * 			         </li>
        *             <li>
        * 				           <p>How long CloudFront caches HTTP status codes in the 4xx and 5xx range.</p>
        * 			         </li>
        *          </ul>
        * 		       <p>For more information about custom error pages, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html">Customizing Error Responses</a> in the
        * 				<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export interface CustomErrorResponses {
            /**
                * <p>The number of HTTP status codes for which you want to specify a custom error page
                * 			and/or a caching duration. If <code>Quantity</code> is <code>0</code>, you can omit
                * 				<code>Items</code>.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>A complex type that contains a <code>CustomErrorResponse</code> element for each HTTP
                * 			status code for which you want to specify a custom error page and/or a caching duration.
                * 		</p>
                */
            Items?: CustomErrorResponse[];
    }
    export namespace CustomErrorResponses {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CustomErrorResponses) => any;
    }
    /**
        * <p>A complex type that describes the default cache behavior if you don’t specify a
        * 			<code>CacheBehavior</code> element or if request URLs don’t match any of the values of
        * 			<code>PathPattern</code> in <code>CacheBehavior</code> elements. You must create exactly
        * 			one default cache behavior.</p>
        */
    export interface DefaultCacheBehavior {
            /**
                * <p>The value of <code>ID</code> for the origin that you want CloudFront to route requests to when
                * 			they use the default cache behavior.</p>
                */
            TargetOriginId: string | undefined;
            /**
                * <important>
                * 			         <p>We recommend using <code>TrustedKeyGroups</code> instead of
                * 				<code>TrustedSigners</code>.</p>
                * 		       </important>
                * 		       <p>A list of Amazon Web Services account IDs whose public keys CloudFront can use to validate signed URLs or signed
                * 			cookies.</p>
                * 		       <p>When a cache behavior contains trusted signers, CloudFront requires signed URLs or signed cookies
                * 			for all requests that match the cache behavior. The URLs or cookies must be signed with
                * 			the private key of a CloudFront key pair in a trusted signer’s Amazon Web Services account. The signed URL or
                * 			cookie contains information about which public key CloudFront should use to verify the
                * 			signature. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving private content</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            TrustedSigners?: TrustedSigners;
            /**
                * <p>A list of key groups that CloudFront can use to validate signed URLs or signed cookies.</p>
                * 		       <p>When a cache behavior contains trusted key groups, CloudFront requires signed URLs or signed
                * 			cookies for all requests that match the cache behavior. The URLs or cookies must be
                * 			signed with a private key whose corresponding public key is in the key group. The signed
                * 			URL or cookie contains information about which public key CloudFront should use to verify the
                * 			signature. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving private content</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            TrustedKeyGroups?: TrustedKeyGroups;
            /**
                * <p>The protocol that viewers can use to access the files in the origin specified by
                * 				<code>TargetOriginId</code> when a request matches the path pattern in
                * 				<code>PathPattern</code>. You can specify the following options:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>
                *                   <code>allow-all</code>: Viewers can use HTTP or HTTPS.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>redirect-to-https</code>: If a viewer submits an HTTP request, CloudFront returns
                * 					an HTTP status code of 301 (Moved Permanently) to the viewer along with the HTTPS URL. The
                * 					viewer then resubmits the request using the new URL.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>https-only</code>: If a viewer sends an HTTP request, CloudFront returns an HTTP
                * 					status code of 403 (Forbidden).</p>
                * 			         </li>
                *          </ul>
                * 		       <p>For more information about requiring the HTTPS protocol, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-viewers-to-cloudfront.html">Requiring HTTPS Between Viewers and CloudFront</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <note>
                * 			         <p>The only way to guarantee that viewers retrieve an object that was fetched from
                * 				the origin using HTTPS is never to use any other protocol to fetch the object. If
                * 				you have recently changed from HTTP to HTTPS, we recommend that you clear your
                * 				objects’ cache because cached objects are protocol agnostic. That means that an edge
                * 				location will return an object from the cache regardless of whether the current
                * 				request protocol matches the protocol used previously. For more information, see
                * 				<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing Cache
                * 				Expiration</a> in the
                * 					<i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       </note>
                */
            ViewerProtocolPolicy: ViewerProtocolPolicy | string | undefined;
            /**
                * <p>A complex type that controls which HTTP methods CloudFront processes and forwards to your
                * 			Amazon S3 bucket or your custom origin. There are three choices:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>CloudFront forwards only <code>GET</code> and <code>HEAD</code> requests.</p>
                * 			         </li>
                *             <li>
                * 				           <p>CloudFront forwards only <code>GET</code>, <code>HEAD</code>, and <code>OPTIONS</code>
                * 					requests.</p>
                * 			         </li>
                *             <li>
                * 				           <p>CloudFront forwards <code>GET, HEAD, OPTIONS, PUT, PATCH, POST</code>, and
                * 						<code>DELETE</code> requests.</p>
                * 			         </li>
                *          </ul>
                * 		       <p>If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or
                * 			to your custom origin so users can't perform operations that you don't want them to. For
                * 			example, you might not want users to have permissions to delete objects from your
                * 			origin.</p>
                */
            AllowedMethods?: AllowedMethods;
            /**
                * <p>Indicates whether you want to distribute media files in the Microsoft Smooth Streaming
                * 			format using the origin that is associated with this cache behavior. If so, specify
                * 				<code>true</code>; if not, specify <code>false</code>. If you specify <code>true</code> for
                * 				<code>SmoothStreaming</code>, you can still distribute other content using this cache
                * 			behavior if the content matches the value of <code>PathPattern</code>. </p>
                */
            SmoothStreaming?: boolean;
            /**
                * <p>Whether you want CloudFront to automatically compress certain files for this cache behavior.
                * 			If so, specify <code>true</code>; if not, specify <code>false</code>. For more information,
                * 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html">Serving Compressed Files</a> in
                * 			the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            Compress?: boolean;
            /**
                * <p>A complex type that contains zero or more Lambda@Edge function associations for a cache
                * 			behavior.</p>
                */
            LambdaFunctionAssociations?: LambdaFunctionAssociations;
            /**
                * <p>A list of CloudFront functions that are associated with this cache behavior. CloudFront functions must
                * 			be published to the <code>LIVE</code> stage to associate them with a cache
                * 			behavior.</p>
                */
            FunctionAssociations?: FunctionAssociations;
            /**
                * <p>The value of <code>ID</code> for the field-level encryption configuration that you want CloudFront
                * 			to use for encrypting specific fields of data for the default cache behavior.</p>
                */
            FieldLevelEncryptionId?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the real-time log configuration that is attached to this
                * 			cache behavior. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html">Real-time logs</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            RealtimeLogConfigArn?: string;
            /**
                * <p>The unique identifier of the cache policy that is attached to the default cache behavior.
                * 			For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
                *             <i>Amazon CloudFront Developer Guide</i>.</p>
                *         <p>A <code>DefaultCacheBehavior</code> must include either a
                *             <code>CachePolicyId</code> or <code>ForwardedValues</code>. We recommend that you
                *             use a <code>CachePolicyId</code>.</p>
                */
            CachePolicyId?: string;
            /**
                * <p>The unique identifier of the origin request policy that is attached to the default cache
                * 			behavior. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html">Using the managed origin request policies</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            OriginRequestPolicyId?: string;
            /**
                * <p>The identifier for a response headers policy.</p>
                */
            ResponseHeadersPolicyId?: string;
            /**
                * @deprecated
                *
                * <p>This field is deprecated. We recommend that you use a cache policy or an origin request
                * 			policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/working-with-policies.html">Working with policies</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>If you want to include values in the cache key, use a cache policy. For more information,
                * 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>If you want to send values to the origin but not include them in the cache key, use an
                * 			origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html">Using the managed origin request policies</a> in the
                *             <i>Amazon CloudFront Developer Guide</i>.</p>
                *         <p>A <code>DefaultCacheBehavior</code> must include either a
                *             <code>CachePolicyId</code> or <code>ForwardedValues</code>. We recommend that you
                *             use a <code>CachePolicyId</code>.</p>
                * 		       <p>A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.</p>
                */
            ForwardedValues?: ForwardedValues;
            /**
                * @deprecated
                *
                * <p>This field is deprecated. We recommend that you use the <code>MinTTL</code> field in a cache
                * 			policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront
                * 			forwards another request to your origin to determine whether the object has been updated. For
                * 			more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays
                * 				in an Edge Cache (Expiration)</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>You must specify <code>0</code> for <code>MinTTL</code> if you configure CloudFront to
                * 			forward all headers to your origin (under <code>Headers</code>, if you specify <code>1</code>
                * 			for <code>Quantity</code> and <code>*</code> for <code>Name</code>).</p>
                */
            MinTTL?: number;
            /**
                * @deprecated
                *
                * <p>This field is deprecated. We recommend that you use the <code>DefaultTTL</code> field in a
                * 			cache policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>The default amount of time that you want objects to stay in CloudFront caches before CloudFront
                * 			forwards another request to your origin to determine whether the object has been updated. The
                * 			value that you specify applies only when your origin does not add HTTP headers such as
                * 				<code>Cache-Control max-age</code>, <code>Cache-Control s-maxage</code>, and
                * 				<code>Expires</code> to objects. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays
                * 					in an Edge Cache (Expiration)</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            DefaultTTL?: number;
            /**
                * @deprecated
                *
                * <p>This field is deprecated. We recommend that you use the <code>MaxTTL</code> field in a cache
                * 			policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>The maximum amount of time that you want objects to stay in CloudFront caches before CloudFront
                * 			forwards another request to your origin to determine whether the object has been updated. The
                * 			value that you specify applies only when your origin adds HTTP headers such as
                * 			<code>Cache-Control max-age</code>, <code>Cache-Control s-maxage</code>, and
                * 			<code>Expires</code> to objects. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays
                * 				in an Edge Cache (Expiration)</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            MaxTTL?: number;
    }
    export namespace DefaultCacheBehavior {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DefaultCacheBehavior) => any;
    }
    export type HttpVersion = "http1.1" | "http2";
    /**
        * <p>A complex type that controls whether access logs are written for the
        * 			distribution.</p>
        */
    export interface LoggingConfig {
            /**
                * <p>Specifies whether you want CloudFront to save access logs to an Amazon S3 bucket. If you don't
                * 			want to enable logging when you create a distribution or if you want to disable logging for an
                * 			existing distribution, specify <code>false</code> for <code>Enabled</code>, and specify empty
                * 				<code>Bucket</code> and <code>Prefix</code> elements. If you specify <code>false</code> for
                * 				<code>Enabled</code> but you specify values for <code>Bucket</code>, <code>prefix</code>,
                * 			and <code>IncludeCookies</code>, the values are automatically deleted.</p>
                */
            Enabled: boolean | undefined;
            /**
                * <p>Specifies whether you want CloudFront to include cookies in access logs, specify
                * 				<code>true</code> for <code>IncludeCookies</code>. If you choose to include cookies in logs,
                * 			CloudFront logs all cookies regardless of how you configure the cache behaviors for this
                * 			distribution. If you don't want to include cookies when you create a distribution or if you
                * 			want to disable include cookies for an existing distribution, specify <code>false</code> for
                * 				<code>IncludeCookies</code>.</p>
                */
            IncludeCookies: boolean | undefined;
            /**
                * <p>The Amazon S3 bucket to store the access logs in, for example,
                * 				<code>myawslogbucket.s3.amazonaws.com</code>.</p>
                */
            Bucket: string | undefined;
            /**
                * <p>An optional string that you want CloudFront to prefix to the access log
                * 				<code>filenames</code> for this distribution, for example, <code>myprefix/</code>. If you
                * 			want to enable logging, but you don't want to specify a prefix, you still must include an
                * 			empty <code>Prefix</code> element in the <code>Logging</code> element.</p>
                */
            Prefix: string | undefined;
    }
    export namespace LoggingConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LoggingConfig) => any;
    }
    /**
        * <p>A complex data type for the status codes that you specify that, when returned by a primary origin, trigger
        * 		CloudFront to failover to a second origin.</p>
        */
    export interface StatusCodes {
            /**
                * <p>The number of status codes.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>The items (status codes) for an origin group.</p>
                */
            Items: number[] | undefined;
    }
    export namespace StatusCodes {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StatusCodes) => any;
    }
    /**
        * <p>A complex data type that includes information about the failover criteria for an origin group, including
        * 		the status codes for which CloudFront will failover from the primary origin to the second origin.</p>
        */
    export interface OriginGroupFailoverCriteria {
            /**
                * <p>The status codes that, when returned from the primary origin, will trigger CloudFront to failover
                * 		to the second origin.</p>
                */
            StatusCodes: StatusCodes | undefined;
    }
    export namespace OriginGroupFailoverCriteria {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OriginGroupFailoverCriteria) => any;
    }
    /**
        * <p>An origin in an origin group.</p>
        */
    export interface OriginGroupMember {
            /**
                * <p>The ID for an origin in an origin group.</p>
                */
            OriginId: string | undefined;
    }
    export namespace OriginGroupMember {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OriginGroupMember) => any;
    }
    /**
        * <p>A complex data type for the origins included in an origin group.</p>
        */
    export interface OriginGroupMembers {
            /**
                * <p>The number of origins in an origin group.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>Items (origins) in an origin group.</p>
                */
            Items: OriginGroupMember[] | undefined;
    }
    export namespace OriginGroupMembers {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OriginGroupMembers) => any;
    }
    /**
        * <p>An origin group includes two origins (a primary origin and a second origin to failover to) and a failover criteria that you specify.
        * 		You create an origin group to support origin failover in CloudFront. When you create or update a distribution, you can specifiy
        * 		the origin group instead of a single origin, and CloudFront will failover from the primary origin to the second origin
        * 		under the failover conditions that you've chosen.</p>
        */
    export interface OriginGroup {
            /**
                * <p>The origin group's ID.</p>
                */
            Id: string | undefined;
            /**
                * <p>A complex type that contains information about the failover criteria for an origin group.</p>
                */
            FailoverCriteria: OriginGroupFailoverCriteria | undefined;
            /**
                * <p>A complex type that contains information about the origins in an origin group.</p>
                */
            Members: OriginGroupMembers | undefined;
    }
    export namespace OriginGroup {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OriginGroup) => any;
    }
    /**
        * <p>A complex data type for the origin groups specified for a distribution.</p>
        */
    export interface OriginGroups {
            /**
                * <p>The number of origin groups.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>The items (origin groups) in a distribution.</p>
                */
            Items?: OriginGroup[];
    }
    export namespace OriginGroups {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OriginGroups) => any;
    }
    /**
        * <p>A complex type that contains <code>HeaderName</code> and <code>HeaderValue</code>
        * 			elements, if any, for this distribution. </p>
        */
    export interface OriginCustomHeader {
            /**
                * <p>The name of a header that you want CloudFront to send to your origin. For more information, see
                * 			<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/forward-custom-headers.html">Adding Custom
                * 			Headers to Origin Requests</a> in the <i> Amazon CloudFront Developer Guide</i>.</p>
                */
            HeaderName: string | undefined;
            /**
                * <p>The value for the header that you specified in the <code>HeaderName</code>
                * 			field.</p>
                */
            HeaderValue: string | undefined;
    }
    export namespace OriginCustomHeader {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OriginCustomHeader) => any;
    }
    /**
        * <p>A complex type that contains the list of Custom Headers for each origin. </p>
        */
    export interface CustomHeaders {
            /**
                * <p>The number of custom headers, if any, for this distribution.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>
                *             <b>Optional</b>: A list that contains one
                * 				<code>OriginCustomHeader</code> element for each custom header that you want CloudFront to forward
                * 			to the origin. If Quantity is <code>0</code>, omit <code>Items</code>.</p>
                */
            Items?: OriginCustomHeader[];
    }
    export namespace CustomHeaders {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CustomHeaders) => any;
    }
    export type OriginProtocolPolicy = "http-only" | "https-only" | "match-viewer";
    export type SslProtocol = "SSLv3" | "TLSv1" | "TLSv1.1" | "TLSv1.2";
    /**
        * <p>A complex type that contains information about the SSL/TLS protocols that CloudFront can use
        * 			when establishing an HTTPS connection with your origin. </p>
        */
    export interface OriginSslProtocols {
            /**
                * <p>The number of SSL/TLS protocols that you want to allow CloudFront to use when establishing an
                * 			HTTPS connection with this origin. </p>
                */
            Quantity: number | undefined;
            /**
                * <p>A list that contains allowed SSL/TLS protocols for this distribution.</p>
                */
            Items: (SslProtocol | string)[] | undefined;
    }
    export namespace OriginSslProtocols {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OriginSslProtocols) => any;
    }
    /**
        * <p>A custom origin. A custom origin is any origin that is <i>not</i> an Amazon S3
        * 			bucket, with one exception. An Amazon S3 bucket that is <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html">configured with
        * 			static website hosting</a>
        *             <i>is</i> a custom origin.</p>
        */
    export interface CustomOriginConfig {
            /**
                * <p>The HTTP port that CloudFront uses to connect to the origin. Specify the HTTP port that the origin
                * 			listens on.</p>
                */
            HTTPPort: number | undefined;
            /**
                * <p>The HTTPS port that CloudFront uses to connect to the origin. Specify the HTTPS port that the
                * 			origin listens on.</p>
                */
            HTTPSPort: number | undefined;
            /**
                * <p>Specifies the protocol (HTTP or HTTPS) that CloudFront uses to connect to the origin. Valid values
                * 			are:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>
                *                   <code>http-only</code> – CloudFront always uses HTTP to connect to the
                * 					origin.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>match-viewer</code> – CloudFront connects to the origin using the same
                * 					protocol that the viewer used to connect to CloudFront.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>https-only</code> – CloudFront always uses HTTPS to connect to the
                * 					origin.</p>
                * 			         </li>
                *          </ul>
                */
            OriginProtocolPolicy: OriginProtocolPolicy | string | undefined;
            /**
                * <p>Specifies the minimum SSL/TLS protocol that CloudFront uses when connecting to your origin over
                * 			HTTPS. Valid values include <code>SSLv3</code>, <code>TLSv1</code>,
                * 			<code>TLSv1.1</code>, and <code>TLSv1.2</code>.</p>
                * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginSSLProtocols">Minimum Origin SSL Protocol</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            OriginSslProtocols?: OriginSslProtocols;
            /**
                * <p>Specifies how long, in seconds, CloudFront waits for a response from the origin. This is also
                * 			known as the <i>origin response timeout</i>. The minimum timeout is 1
                * 			second, the maximum is 60 seconds, and the default (if you don’t specify otherwise) is
                * 			30 seconds.</p>
                * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginResponseTimeout">Origin Response Timeout</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            OriginReadTimeout?: number;
            /**
                * <p>Specifies how long, in seconds, CloudFront persists its connection to the origin. The minimum
                * 			timeout is 1 second, the maximum is 60 seconds, and the default (if you don’t specify
                * 			otherwise) is 5 seconds.</p>
                * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginKeepaliveTimeout">Origin Keep-alive Timeout</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            OriginKeepaliveTimeout?: number;
    }
    export namespace CustomOriginConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CustomOriginConfig) => any;
    }
    /**
        * <p>CloudFront Origin Shield.</p>
        * 		       <p>Using Origin Shield can help reduce the load on your origin. For more
        *             information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html">Using Origin Shield</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export interface OriginShield {
            /**
                * <p>A flag that specifies whether Origin Shield is enabled.</p>
                * 		       <p>When it’s enabled, CloudFront routes all requests through Origin Shield, which can
                *             help protect your origin. When it’s disabled, CloudFront might send requests directly to
                *             your origin from multiple edge locations or regional edge caches.</p>
                */
            Enabled: boolean | undefined;
            /**
                * <p>The Amazon Web Services Region for Origin Shield.</p>
                * 		       <p>Specify the Amazon Web Services Region that has the lowest latency to your origin.
                *             To specify a region, use the region code, not the region name.
                *             For example, specify the US East (Ohio) region as <code>us-east-2</code>.</p>
                *         <p>When you enable CloudFront Origin Shield, you must specify the Amazon Web Services Region for Origin
                *             Shield. For the list of Amazon Web Services Regions that you can specify, and for help choosing the best
                *             Region for your origin, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html#choose-origin-shield-region">Choosing the Amazon Web Services Region for Origin Shield</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            OriginShieldRegion?: string;
    }
    export namespace OriginShield {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OriginShield) => any;
    }
    /**
        * <p>A complex type that contains information about the Amazon S3 origin. If the origin is a
        * 			custom origin or an S3 bucket that is configured as a website endpoint, use the
        *             <code>CustomOriginConfig</code> element instead.</p>
        */
    export interface S3OriginConfig {
            /**
                * <p>The CloudFront origin access identity to associate with the origin. Use an origin access
                * 			identity to configure the origin so that viewers can <i>only</i> access objects
                * 			in an Amazon S3 bucket through CloudFront. The format of the value is:</p>
                * 		       <p>origin-access-identity/cloudfront/<i>ID-of-origin-access-identity</i>
                *          </p>
                * 		       <p>where <code>
                *                <i>ID-of-origin-access-identity</i>
                *             </code> is the value that
                * 			CloudFront returned in the <code>ID</code> element when you created the origin access
                * 			identity.</p>
                * 		       <p>If you want viewers to be able to access objects using either the CloudFront URL or the Amazon S3
                * 			URL, specify an empty <code>OriginAccessIdentity</code> element.</p>
                * 		       <p>To delete the origin access identity from an existing distribution, update the
                * 			distribution configuration and include an empty <code>OriginAccessIdentity</code>
                * 			element.</p>
                * 		       <p>To replace the origin access identity, update the distribution configuration and
                * 			specify the new origin access identity.</p>
                * 		       <p>For more information about the origin access identity, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving Private Content through CloudFront</a> in the
                * 				<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            OriginAccessIdentity: string | undefined;
    }
    export namespace S3OriginConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: S3OriginConfig) => any;
    }
    /**
        * <p>An origin.</p>
        * 		       <p>An origin is the location where content is stored, and from which CloudFront gets content to
        * 			serve to viewers. To specify an origin:</p>
        * 		       <ul>
        *             <li>
        *                 <p>Use <code>S3OriginConfig</code> to specify an Amazon S3 bucket that is not
        * 					configured with static website hosting.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Use <code>CustomOriginConfig</code> to specify all other kinds of origins,
        * 					including:</p>
        * 				           <ul>
        *                   <li>
        * 						               <p>An Amazon S3 bucket that is configured with static website hosting</p>
        * 					             </li>
        *                   <li>
        * 						               <p>An Elastic Load Balancing load balancer</p>
        * 					             </li>
        *                   <li>
        * 						               <p>An AWS Elemental MediaPackage endpoint</p>
        * 					             </li>
        *                   <li>
        * 						               <p>An AWS Elemental MediaStore container</p>
        * 					             </li>
        *                   <li>
        * 						               <p>Any other HTTP server, running on an Amazon EC2 instance or any other
        * 							kind of host</p>
        * 					             </li>
        *                </ul>
        * 			         </li>
        *          </ul>
        * 		       <p>For the current maximum number of origins that you can specify per distribution, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html#limits-web-distributions">General Quotas on Web Distributions</a> in the <i>Amazon CloudFront Developer Guide</i>
        * 			(quotas were formerly referred to as limits).</p>
        */
    export interface Origin {
            /**
                * <p>A unique identifier for the origin. This value must be unique within the
                * 			distribution.</p>
                *         <p>Use this value to specify the <code>TargetOriginId</code> in a
                *             <code>CacheBehavior</code> or <code>DefaultCacheBehavior</code>.</p>
                */
            Id: string | undefined;
            /**
                * <p>The domain name for the origin.</p>
                * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesDomainName">Origin Domain Name</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            DomainName: string | undefined;
            /**
                * <p>An optional path that CloudFront appends to the origin domain name when CloudFront requests content from
                * 			the origin.</p>
                * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginPath">Origin Path</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            OriginPath?: string;
            /**
                * <p>A list of HTTP header names and values that CloudFront adds to the requests that it sends to
                *             the origin.</p>
                * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/add-origin-custom-headers.html">Adding Custom Headers to Origin Requests</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            CustomHeaders?: CustomHeaders;
            /**
                * <p>Use this type to specify an origin that is an Amazon S3 bucket that is not configured with static
                * 			website hosting. To specify any other type of origin, including an Amazon S3 bucket that is
                * 			configured with static website hosting, use the <code>CustomOriginConfig</code> type
                * 			instead.</p>
                */
            S3OriginConfig?: S3OriginConfig;
            /**
                * <p>Use this type to specify an origin that is not an Amazon S3 bucket, with one exception. If the
                * 			Amazon S3 bucket is configured with static website hosting, use this type. If the Amazon S3 bucket
                * 			is not configured with static website hosting, use the <code>S3OriginConfig</code> type
                * 			instead.</p>
                */
            CustomOriginConfig?: CustomOriginConfig;
            /**
                * <p>The number of times that CloudFront attempts to connect to the origin. The minimum number
                *             is 1, the maximum is 3, and the default (if you don’t specify otherwise) is 3.</p>
                *         <p>For a custom origin (including an Amazon S3 bucket that’s configured with static
                *             website hosting), this value also specifies the number of times that CloudFront attempts to
                *             get a response from the origin, in the case of an <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginResponseTimeout">Origin Response Timeout</a>.</p>
                *         <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#origin-connection-attempts">Origin Connection Attempts</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            ConnectionAttempts?: number;
            /**
                * <p>The number of seconds that CloudFront waits when trying to establish a connection to the origin.
                * 			The minimum timeout is 1 second, the maximum is 10 seconds, and the default (if you
                * 			don’t specify otherwise) is 10 seconds.</p>
                * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#origin-connection-timeout">Origin Connection Timeout</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            ConnectionTimeout?: number;
            /**
                * <p>CloudFront Origin Shield. Using Origin Shield can help reduce the load on your
                *             origin.</p>
                * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html">Using Origin Shield</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            OriginShield?: OriginShield;
    }
    export namespace Origin {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Origin) => any;
    }
    /**
        * <p>Contains information about the origins for this distribution.</p>
        */
    export interface Origins {
            /**
                * <p>The number of origins for this distribution.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>A list of origins.</p>
                */
            Items: Origin[] | undefined;
    }
    export namespace Origins {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Origins) => any;
    }
    export type PriceClass = "PriceClass_100" | "PriceClass_200" | "PriceClass_All";
    export type GeoRestrictionType = "blacklist" | "none" | "whitelist";
    /**
        * <p>A complex type that controls the countries in which your content is distributed. CloudFront
        * 			determines the location of your users using <code>MaxMind</code> GeoIP databases. </p>
        */
    export interface GeoRestriction {
            /**
                * <p>The method that you want to use to restrict distribution of your content by
                * 			country:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>
                *                   <code>none</code>: No geo restriction is enabled, meaning access to content is not
                * 					restricted by client geo location.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>blacklist</code>: The <code>Location</code> elements specify the countries in
                * 					which you don't want CloudFront to distribute your content.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>whitelist</code>: The <code>Location</code> elements specify the countries in
                * 					which you want CloudFront to distribute your content.</p>
                * 			         </li>
                *          </ul>
                */
            RestrictionType: GeoRestrictionType | string | undefined;
            /**
                * <p>When geo restriction is <code>enabled</code>, this is the number of countries in your
                * 				<code>whitelist</code> or <code>blacklist</code>. Otherwise, when it is not enabled,
                * 				<code>Quantity</code> is <code>0</code>, and you can omit <code>Items</code>.</p>
                */
            Quantity: number | undefined;
            /**
                * <p> A complex type that contains a <code>Location</code> element for each country in which
                * 			you want CloudFront either to distribute your content (<code>whitelist</code>) or not distribute
                * 			your content (<code>blacklist</code>).</p>
                * 		       <p>The <code>Location</code> element is a two-letter, uppercase country code for a country
                * 			that you want to include in your <code>blacklist</code> or <code>whitelist</code>. Include one
                * 				<code>Location</code> element for each country.</p>
                * 		       <p>CloudFront and <code>MaxMind</code> both use <code>ISO 3166</code> country codes. For the
                * 			current list of countries and the corresponding codes, see <code>ISO 3166-1-alpha-2</code>
                * 			code on the <i>International Organization for Standardization</i> website. You
                * 			can also refer to the country list on the CloudFront console, which includes both country names and
                * 			codes.</p>
                */
            Items?: string[];
    }
    export namespace GeoRestriction {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GeoRestriction) => any;
    }
    /**
        * <p>A complex type that identifies ways in which you want to restrict distribution of your
        * 			content.</p>
        */
    export interface Restrictions {
            /**
                * <p>A complex type that controls the countries in which your content is distributed. CloudFront
                * 			determines the location of your users using <code>MaxMind</code> GeoIP databases.</p>
                */
            GeoRestriction: GeoRestriction | undefined;
    }
    export namespace Restrictions {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Restrictions) => any;
    }
    export type MinimumProtocolVersion = "SSLv3" | "TLSv1" | "TLSv1.1_2016" | "TLSv1.2_2018" | "TLSv1.2_2019" | "TLSv1.2_2021" | "TLSv1_2016";
    export type SSLSupportMethod = "sni-only" | "static-ip" | "vip";
    /**
        * <p>A complex type that determines the distribution’s SSL/TLS configuration for communicating
        * 			with viewers.</p>
        * 		       <p>If the distribution doesn’t use <code>Aliases</code> (also known as alternate domain
        * 			names or CNAMEs)—that is, if the distribution uses the CloudFront domain name such as
        * 			<code>d111111abcdef8.cloudfront.net</code>—set <code>CloudFrontDefaultCertificate</code>
        * 			to <code>true</code> and leave all other fields empty.</p>
        * 		       <p>If the distribution uses <code>Aliases</code> (alternate domain names or CNAMEs), use
        * 			the fields in this type to specify the following settings:</p>
        * 		       <ul>
        *             <li>
        * 				           <p>Which viewers the distribution accepts HTTPS connections from: only viewers that support
        * 					<a href="https://en.wikipedia.org/wiki/Server_Name_Indication">server name
        * 					indication (SNI)</a> (recommended), or all viewers including those that
        * 					don’t support SNI.</p>
        * 				           <ul>
        *                   <li>
        * 						               <p>To accept HTTPS connections from only viewers that support SNI, set
        * 							<code>SSLSupportMethod</code> to <code>sni-only</code>. This is
        * 							recommended. Most browsers and clients support
        *                             SNI.
        *                             </p>
        * 					             </li>
        *                   <li>
        * 						               <p>To accept HTTPS connections from all viewers, including those that don’t support SNI,
        * 							set <code>SSLSupportMethod</code> to <code>vip</code>. This is not
        * 							recommended, and results in additional monthly charges from
        * 							CloudFront.</p>
        * 					             </li>
        *                </ul>
        * 			         </li>
        *             <li>
        * 				           <p>The minimum SSL/TLS protocol version that the distribution can use to
        * 					communicate with viewers. To specify a minimum version, choose a value for
        * 					<code>MinimumProtocolVersion</code>. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValues-security-policy">Security Policy</a> in the
        * 					<i>Amazon CloudFront Developer Guide</i>.</p>
        * 			         </li>
        *             <li>
        * 				           <p>The location of the SSL/TLS certificate, <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html">Certificate Manager (ACM)</a> (recommended) or <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_server-certs.html">Identity and Access Management (IAM)</a>. You specify the location
        * 					by setting a value in one of the following fields (not both):</p>
        * 				           <ul>
        *                   <li>
        * 						               <p>
        *                         <code>ACMCertificateArn</code>
        *                      </p>
        * 					             </li>
        *                   <li>
        * 						               <p>
        *                         <code>IAMCertificateId</code>
        *                      </p>
        * 					             </li>
        *                </ul>
        * 			         </li>
        *          </ul>
        * 		       <p>All distributions support HTTPS connections from viewers. To require viewers to use
        * 			HTTPS only, or to redirect them from HTTP to HTTPS, use
        * 			<code>ViewerProtocolPolicy</code> in the <code>CacheBehavior</code> or
        * 			<code>DefaultCacheBehavior</code>. To specify how CloudFront should use SSL/TLS to
        * 			communicate with your custom origin, use <code>CustomOriginConfig</code>.</p>
        * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https.html">Using
        * 			HTTPS with CloudFront</a> and <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-alternate-domain-names.html">
        * 			Using Alternate Domain Names and HTTPS</a> in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export interface ViewerCertificate {
            /**
                * <p>If the distribution uses the CloudFront domain name such as
                * 			<code>d111111abcdef8.cloudfront.net</code>, set this field to <code>true</code>.</p>
                * 		       <p>If the distribution uses <code>Aliases</code> (alternate domain names or CNAMEs), set
                * 			this field to <code>false</code> and specify values for the following fields:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>
                *                   <code>ACMCertificateArn</code> or <code>IAMCertificateId</code> (specify a value for one,
                * 					not both)</p>
                *
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>MinimumProtocolVersion</code>
                *                </p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>SSLSupportMethod</code>
                *                </p>
                * 			         </li>
                *          </ul>
                */
            CloudFrontDefaultCertificate?: boolean;
            /**
                * <p>If the distribution uses <code>Aliases</code> (alternate domain names or CNAMEs) and
                * 			the SSL/TLS certificate is stored in <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_server-certs.html">Identity and Access Management (IAM)</a>, provide the ID of the IAM
                * 			certificate.</p>
                * 		       <p>If you specify an IAM certificate ID, you must also specify values for
                * 			<code>MinimumProtocolVersion</code> and <code>SSLSupportMethod</code>. </p>
                */
            IAMCertificateId?: string;
            /**
                * <p>If the distribution uses <code>Aliases</code> (alternate domain names or CNAMEs) and
                * 			the SSL/TLS certificate is stored in <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html">Certificate Manager (ACM)</a>, provide the Amazon Resource
                * 			Name (ARN) of the ACM certificate. CloudFront only supports ACM certificates in the US
                * 			East (N. Virginia) Region (<code>us-east-1</code>).</p>
                * 		       <p>If you specify an ACM certificate ARN, you must also specify values for
                * 			<code>MinimumProtocolVersion</code> and <code>SSLSupportMethod</code>.</p>
                */
            ACMCertificateArn?: string;
            /**
                * <p>If the distribution uses <code>Aliases</code> (alternate domain names or CNAMEs), specify
                * 			which viewers the distribution accepts HTTPS connections from.</p>
                * 		       <ul>
                *             <li>
                * 				           <p>
                *                   <code>sni-only</code> – The distribution accepts HTTPS connections from only viewers that
                * 					support <a href="https://en.wikipedia.org/wiki/Server_Name_Indication">server
                * 					name indication (SNI)</a>. This is recommended. Most browsers and clients support SNI.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>vip</code> – The distribution accepts HTTPS connections from all viewers including
                * 					those that don’t support SNI. This is not recommended, and results in additional
                * 					monthly charges from CloudFront.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>static-ip</code> - Do not specify this value unless your distribution
                * 					has been enabled for this feature by the CloudFront team. If you have a use case
                * 					that requires static IP addresses for a distribution, contact CloudFront through
                * 					the <a href="https://console.aws.amazon.com/support/home">Amazon Web Services Support Center</a>.</p>
                * 			         </li>
                *          </ul>
                * 		       <p>If the distribution uses the CloudFront domain name such as
                * 			<code>d111111abcdef8.cloudfront.net</code>, don’t set a value for this field.</p>
                */
            SSLSupportMethod?: SSLSupportMethod | string;
            /**
                * <p>If the distribution uses <code>Aliases</code> (alternate domain names or CNAMEs),
                * 			specify the security policy that you want CloudFront to use for HTTPS connections with
                * 			viewers. The security policy determines two settings:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>The minimum SSL/TLS protocol that CloudFront can use to communicate with
                * 					viewers.</p>
                * 			         </li>
                *             <li>
                * 				           <p>The ciphers that CloudFront can use to encrypt the content that it returns to
                * 					viewers.</p>
                * 			         </li>
                *          </ul>
                * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValues-security-policy">Security Policy</a> and <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/secure-connections-supported-viewer-protocols-ciphers.html#secure-connections-supported-ciphers">Supported Protocols and Ciphers Between Viewers and
                * 			CloudFront</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <note>
                * 			         <p>On the CloudFront console, this setting is called <b>Security
                * 				Policy</b>.</p>
                * 		       </note>
                * 		       <p>When you’re using SNI only (you set <code>SSLSupportMethod</code> to <code>sni-only</code>),
                * 			you must specify <code>TLSv1</code> or higher.</p>
                * 		       <p>If the distribution uses the CloudFront domain name such as
                * 			<code>d111111abcdef8.cloudfront.net</code> (you set
                * 			<code>CloudFrontDefaultCertificate</code> to <code>true</code>), CloudFront automatically sets
                * 			the security policy to <code>TLSv1</code> regardless of the value that you set
                * 			here.</p>
                */
            MinimumProtocolVersion?: MinimumProtocolVersion | string;
            /**
                * @deprecated
                *
                * <p>This field is deprecated. Use one of the following fields instead:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>
                *                   <code>ACMCertificateArn</code>
                *                </p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>IAMCertificateId</code>
                *                </p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>CloudFrontDefaultCertificate</code>
                *                </p>
                * 			         </li>
                *          </ul>
                */
            Certificate?: string;
            /**
                * @deprecated
                *
                * <p>This field is deprecated. Use one of the following fields instead:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>
                *                   <code>ACMCertificateArn</code>
                *                </p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>IAMCertificateId</code>
                *                </p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>CloudFrontDefaultCertificate</code>
                *                </p>
                * 			         </li>
                *          </ul>
                */
            CertificateSource?: CertificateSource | string;
    }
    export namespace ViewerCertificate {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ViewerCertificate) => any;
    }
    /**
        * <p>A distribution configuration.</p>
        */
    export interface DistributionConfig {
            /**
                * <p>A unique value (for example, a date-time stamp) that ensures that the request can't be
                * 			replayed.</p>
                * 		       <p>If the value of <code>CallerReference</code> is new (regardless of the content of the
                * 				<code>DistributionConfig</code> object), CloudFront creates a new distribution.</p>
                * 		       <p>If <code>CallerReference</code> is a value that you already sent in a previous request to
                * 			create a distribution, CloudFront returns a <code>DistributionAlreadyExists</code> error.</p>
                */
            CallerReference: string | undefined;
            /**
                * <p>A complex type that contains information about CNAMEs (alternate domain names), if any,
                * 			for this distribution.</p>
                */
            Aliases?: Aliases;
            /**
                * <p>The object that you want CloudFront to request from your origin (for example,
                * 				<code>index.html</code>) when a viewer requests the root URL for your distribution
                * 				(<code>http://www.example.com</code>) instead of an object in your distribution
                * 				(<code>http://www.example.com/product-description.html</code>). Specifying a default root
                * 			object avoids exposing the contents of your distribution.</p>
                * 		       <p>Specify only the object name, for example, <code>index.html</code>. Don't add a
                * 				<code>/</code> before the object name.</p>
                * 		       <p>If you don't want to specify a default root object when you create a distribution,
                * 			include an empty <code>DefaultRootObject</code> element.</p>
                * 		       <p>To delete the default root object from an existing distribution, update the
                * 			distribution configuration and include an empty <code>DefaultRootObject</code>
                * 			element.</p>
                * 		       <p>To replace the default root object, update the distribution configuration and specify
                * 			the new object.</p>
                * 		       <p>For more information about the default root object, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/DefaultRootObject.html">Creating a Default Root Object</a> in the
                * 				<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            DefaultRootObject?: string;
            /**
                * <p>A complex type that contains information about origins for this distribution.
                * 		</p>
                */
            Origins: Origins | undefined;
            /**
                * <p> A complex type that contains information about origin groups for this
                * 			distribution.</p>
                */
            OriginGroups?: OriginGroups;
            /**
                * <p>A complex type that describes the default cache behavior if you don't specify a
                * 				<code>CacheBehavior</code> element or if files don't match any of the values of
                * 				<code>PathPattern</code> in <code>CacheBehavior</code> elements. You must create exactly one
                * 			default cache behavior.</p>
                */
            DefaultCacheBehavior: DefaultCacheBehavior | undefined;
            /**
                * <p>A complex type that contains zero or more <code>CacheBehavior</code> elements.
                * 		</p>
                */
            CacheBehaviors?: CacheBehaviors;
            /**
                * <p>A complex type that controls the following:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error
                * 					messages before returning the response to the viewer.</p>
                * 			         </li>
                *             <li>
                * 				           <p>How long CloudFront caches HTTP status codes in the 4xx and 5xx range.</p>
                * 			         </li>
                *          </ul>
                * 		       <p>For more information about custom error pages, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html">Customizing Error Responses</a> in the
                * 				<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            CustomErrorResponses?: CustomErrorResponses;
            /**
                * <p>An optional comment to describe the distribution. The comment cannot be longer than 128
                * 			characters.</p>
                */
            Comment: string | undefined;
            /**
                * <p>A complex type that controls whether access logs are written for the
                * 			distribution.</p>
                * 		       <p>For more information about logging, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/AccessLogs.html">Access
                * 				Logs</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            Logging?: LoggingConfig;
            /**
                * <p>The price class that corresponds with the maximum price that you want to pay for CloudFront
                * 			service. If you specify <code>PriceClass_All</code>, CloudFront responds to requests for your
                * 			objects from all CloudFront edge locations.</p>
                * 		       <p>If you specify a price class other than <code>PriceClass_All</code>, CloudFront serves your
                * 			objects from the CloudFront edge location that has the lowest latency among the edge locations in
                * 			your price class. Viewers who are in or near regions that are excluded from your specified
                * 			price class may encounter slower performance.</p>
                * 		       <p>For more information about price classes, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PriceClass.html">Choosing the Price Class
                * 			for a CloudFront Distribution</a> in the <i>Amazon CloudFront Developer Guide</i>. For
                * 			information about CloudFront pricing, including how price classes (such as Price Class 100)
                * 			map to CloudFront regions, see <a href="http://aws.amazon.com/cloudfront/pricing/">Amazon CloudFront
                * 			Pricing</a>.</p>
                */
            PriceClass?: PriceClass | string;
            /**
                * <p>From this field, you can enable or disable the selected distribution.</p>
                */
            Enabled: boolean | undefined;
            /**
                * <p>A complex type that determines the distribution’s SSL/TLS configuration for
                * 			communicating with viewers.</p>
                */
            ViewerCertificate?: ViewerCertificate;
            /**
                * <p>A complex type that identifies ways in which you want to restrict distribution of your
                * 			content.</p>
                */
            Restrictions?: Restrictions;
            /**
                * <p>A unique identifier that specifies the WAF web ACL, if any, to associate
                * 			with this distribution. To specify a web ACL created using the latest version of
                *             WAF, use the ACL ARN, for example
                * 			<code>arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a</code>.
                * 			To specify a web ACL created using WAF Classic, use the ACL ID, for example
                * 			<code>473e64fd-f30b-4765-81a0-62ad96dd167a</code>.</p>
                * 		       <p>WAF is a web application firewall that lets you monitor the HTTP and HTTPS
                * 			requests that are forwarded to CloudFront, and lets you control access to your content. Based on
                * 			conditions that you specify, such as the IP addresses that requests originate from or the
                * 			values of query strings, CloudFront responds to requests either with the requested content or with
                * 			an HTTP 403 status code (Forbidden). You can also configure CloudFront to return a custom error page
                * 			when a request is blocked. For more information about WAF, see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/what-is-aws-waf.html">WAF
                * 				Developer Guide</a>. </p>
                */
            WebACLId?: string;
            /**
                * <p>(Optional) Specify the maximum HTTP version that you want viewers to use to communicate
                * 			with CloudFront. The default value for new web distributions is http2. Viewers that don't support
                * 			HTTP/2 automatically use an earlier HTTP version.</p>
                * 		       <p>For viewers and CloudFront to use HTTP/2, viewers must support TLS 1.2 or later, and must
                * 			support Server Name Identification (SNI).</p>
                * 		       <p>In general, configuring CloudFront to communicate with viewers using HTTP/2 reduces latency.
                * 			You can improve performance by optimizing for HTTP/2. For more information, do an Internet
                * 			search for "http/2 optimization." </p>
                */
            HttpVersion?: HttpVersion | string;
            /**
                * <p>If you want CloudFront to respond to IPv6 DNS requests with an IPv6 address for your
                * 			distribution, specify <code>true</code>. If you specify <code>false</code>, CloudFront responds to
                * 			IPv6 DNS requests with the DNS response code <code>NOERROR</code> and with no IP addresses.
                * 			This allows viewers to submit a second request, for an IPv4 address for your distribution. </p>
                * 		       <p>In general, you should enable IPv6 if you have users on IPv6 networks who want to
                * 			access your content. However, if you're using signed URLs or signed cookies to restrict access
                * 			to your content, and if you're using a custom policy that includes the <code>IpAddress</code>
                * 			parameter to restrict the IP addresses that can access your content, don't enable IPv6. If
                * 			you want to restrict access to some content by IP address and not restrict access to other
                * 			content (or restrict access but not by IP address), you can create two distributions. For more
                * 			information, see
                * 			<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-creating-signed-url-custom-policy.html">Creating a Signed URL Using a Custom Policy</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                * 		       <p>If you're using an Route 53 Amazon Web Services Integration alias resource record set to route traffic to your CloudFront
                * 			distribution, you need to create a second alias resource record set when both of the following
                * 			are true:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>You enable IPv6 for the distribution</p>
                * 			         </li>
                *             <li>
                * 				           <p>You're using alternate domain names in the URLs for your objects</p>
                * 			         </li>
                *          </ul>
                * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-to-cloudfront-distribution.html">Routing Traffic
                * 				to an Amazon CloudFront Web Distribution by Using Your Domain Name</a> in the <i>Route 53 Amazon Web Services Integration
                * 				Developer Guide</i>.</p>
                * 		       <p>If you created a CNAME resource record set, either with Route 53 Amazon Web Services Integration or with another DNS
                * 			service, you don't need to make any changes. A CNAME record will route traffic to your
                * 			distribution regardless of the IP address format of the viewer request.</p>
                */
            IsIPV6Enabled?: boolean;
    }
    export namespace DistributionConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DistributionConfig) => any;
    }
    /**
        * <p>The request to create a new distribution.</p>
        */
    export interface CreateDistributionRequest {
            /**
                * <p>The distribution's configuration information.</p>
                */
            DistributionConfig: DistributionConfig | undefined;
    }
    export namespace CreateDistributionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateDistributionRequest) => any;
    }
    /**
        * <p>A distribution tells CloudFront where you want content to be delivered from, and the details about how to
        * 			track and manage content delivery.</p>
        */
    export interface Distribution {
            /**
                * <p>The identifier for the distribution. For example: <code>EDFDVBD632BHDS5</code>.
                * 		</p>
                */
            Id: string | undefined;
            /**
                * <p>The ARN (Amazon Resource Name) for the distribution. For example:
                * 				<code>arn:aws:cloudfront::123456789012:distribution/EDFDVBD632BHDS5</code>, where
                * 				<code>123456789012</code> is your Amazon Web Services account ID.</p>
                */
            ARN: string | undefined;
            /**
                * <p>This response element indicates the current status of the distribution. When the status
                * 			is <code>Deployed</code>, the distribution's information is fully propagated to all CloudFront edge
                * 			locations. </p>
                */
            Status: string | undefined;
            /**
                * <p>The date and time the distribution was last modified. </p>
                */
            LastModifiedTime: Date | undefined;
            /**
                * <p>The number of invalidation batches currently in progress. </p>
                */
            InProgressInvalidationBatches: number | undefined;
            /**
                * <p>The domain name corresponding to the distribution, for example, <code>d111111abcdef8.cloudfront.net</code>. </p>
                */
            DomainName: string | undefined;
            /**
                * <important>
                * 			         <p>We recommend using <code>TrustedKeyGroups</code> instead of
                * 				<code>TrustedSigners</code>.</p>
                * 		       </important>
                * 		       <p>CloudFront automatically adds this field to the response if you’ve configured a cache behavior in
                * 			this distribution to serve private content using trusted signers. This field contains a
                * 			list of Amazon Web Services account IDs and the active CloudFront key pairs in each account that CloudFront can use
                * 			to verify the signatures of signed URLs or signed cookies.</p>
                */
            ActiveTrustedSigners?: ActiveTrustedSigners;
            /**
                * <p>CloudFront automatically adds this field to the response if you’ve configured a cache
                * 			behavior in this distribution to serve private content using key groups. This field
                * 			contains a list of key groups and the public keys in each key group that CloudFront can use to
                * 			verify the signatures of signed URLs or signed cookies.</p>
                */
            ActiveTrustedKeyGroups?: ActiveTrustedKeyGroups;
            /**
                * <p>The current configuration information for the distribution. Send a <code>GET</code>
                * 			request to the <code>/<i>CloudFront API version</i>/distribution ID/config</code>
                * 			resource.</p>
                */
            DistributionConfig: DistributionConfig | undefined;
            /**
                * <p>Amazon Web Services services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content
                * 			publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP
                * 			recordal status for CNAMEs associated with distributions.</p>
                * 		       <p>For more information about ICP recordals, see  <a href="https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html">
                * 			Signup, Accounts, and Credentials</a> in <i>Getting Started with Amazon Web Services services in China</i>.</p>
                */
            AliasICPRecordals?: AliasICPRecordal[];
    }
    export namespace Distribution {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Distribution) => any;
    }
    /**
        * <p>The returned result of the corresponding request.</p>
        */
    export interface CreateDistributionResult {
            /**
                * <p>The distribution's information.</p>
                */
            Distribution?: Distribution;
            /**
                * <p>The fully qualified URI of the new distribution resource just created.</p>
                */
            Location?: string;
            /**
                * <p>The current version of the distribution created.</p>
                */
            ETag?: string;
    }
    export namespace CreateDistributionResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateDistributionResult) => any;
    }
    /**
        * <p>The caller reference you attempted to create the distribution with is associated with another distribution.</p>
        */
    export class DistributionAlreadyExists extends __BaseException {
            readonly name: "DistributionAlreadyExists";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DistributionAlreadyExists, __BaseException>);
    }
    /**
        * <p>The specified configuration for field-level encryption can't be associated with the specified cache behavior.</p>
        */
    export class IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior extends __BaseException {
            readonly name: "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior, __BaseException>);
    }
    /**
        * <p>The default root object file name is too big or contains an invalid character.</p>
        */
    export class InvalidDefaultRootObject extends __BaseException {
            readonly name: "InvalidDefaultRootObject";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidDefaultRootObject, __BaseException>);
    }
    /**
        * <p>An invalid error code was specified.</p>
        */
    export class InvalidErrorCode extends __BaseException {
            readonly name: "InvalidErrorCode";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidErrorCode, __BaseException>);
    }
    /**
        * <p>Your request contains forward cookies option which doesn't match with the expectation for the <code>whitelisted</code>
        * 			list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected.</p>
        */
    export class InvalidForwardCookies extends __BaseException {
            readonly name: "InvalidForwardCookies";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidForwardCookies, __BaseException>);
    }
    /**
        * <p>A CloudFront function association is invalid.</p>
        */
    export class InvalidFunctionAssociation extends __BaseException {
            readonly name: "InvalidFunctionAssociation";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidFunctionAssociation, __BaseException>);
    }
    /**
        * <p>The specified geo restriction parameter is not valid.</p>
        */
    export class InvalidGeoRestrictionParameter extends __BaseException {
            readonly name: "InvalidGeoRestrictionParameter";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidGeoRestrictionParameter, __BaseException>);
    }
    /**
        * <p>The headers specified are not valid for an Amazon S3 origin.</p>
        */
    export class InvalidHeadersForS3Origin extends __BaseException {
            readonly name: "InvalidHeadersForS3Origin";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidHeadersForS3Origin, __BaseException>);
    }
    /**
        * <p>The specified Lambda@Edge function association is invalid.</p>
        */
    export class InvalidLambdaFunctionAssociation extends __BaseException {
            readonly name: "InvalidLambdaFunctionAssociation";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidLambdaFunctionAssociation, __BaseException>);
    }
    /**
        * <p>The location code specified is not valid.</p>
        */
    export class InvalidLocationCode extends __BaseException {
            readonly name: "InvalidLocationCode";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidLocationCode, __BaseException>);
    }
    /**
        * <p>The minimum protocol version specified is not valid.</p>
        */
    export class InvalidMinimumProtocolVersion extends __BaseException {
            readonly name: "InvalidMinimumProtocolVersion";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidMinimumProtocolVersion, __BaseException>);
    }
    /**
        * <p>The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket.</p>
        */
    export class InvalidOrigin extends __BaseException {
            readonly name: "InvalidOrigin";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidOrigin, __BaseException>);
    }
    /**
        * <p>The origin access identity is not valid or doesn't exist.</p>
        */
    export class InvalidOriginAccessIdentity extends __BaseException {
            readonly name: "InvalidOriginAccessIdentity";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidOriginAccessIdentity, __BaseException>);
    }
    /**
        * <p>The keep alive timeout specified for the origin is not valid.</p>
        */
    export class InvalidOriginKeepaliveTimeout extends __BaseException {
            readonly name: "InvalidOriginKeepaliveTimeout";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidOriginKeepaliveTimeout, __BaseException>);
    }
    /**
        * <p>The read timeout specified for the origin is not valid.</p>
        */
    export class InvalidOriginReadTimeout extends __BaseException {
            readonly name: "InvalidOriginReadTimeout";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidOriginReadTimeout, __BaseException>);
    }
    /**
        * <p>You cannot specify SSLv3 as the minimum protocol version if you only want to support only clients that support
        * 			Server Name Indication (SNI).</p>
        */
    export class InvalidProtocolSettings extends __BaseException {
            readonly name: "InvalidProtocolSettings";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidProtocolSettings, __BaseException>);
    }
    /**
        * <p>The query string parameters specified are not valid.</p>
        */
    export class InvalidQueryStringParameters extends __BaseException {
            readonly name: "InvalidQueryStringParameters";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidQueryStringParameters, __BaseException>);
    }
    /**
        * <p>The relative path is too big, is not URL-encoded, or does not begin with a slash (/).</p>
        */
    export class InvalidRelativePath extends __BaseException {
            readonly name: "InvalidRelativePath";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidRelativePath, __BaseException>);
    }
    /**
        * <p>This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the
        * 			<code>RequiredProtocols</code> element from your distribution configuration.</p>
        */
    export class InvalidRequiredProtocol extends __BaseException {
            readonly name: "InvalidRequiredProtocol";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidRequiredProtocol, __BaseException>);
    }
    /**
        * <p>A response code is not valid.</p>
        */
    export class InvalidResponseCode extends __BaseException {
            readonly name: "InvalidResponseCode";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidResponseCode, __BaseException>);
    }
    /**
        * <p>The TTL order specified is not valid.</p>
        */
    export class InvalidTTLOrder extends __BaseException {
            readonly name: "InvalidTTLOrder";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidTTLOrder, __BaseException>);
    }
    /**
        * <p>A viewer certificate specified is not valid.</p>
        */
    export class InvalidViewerCertificate extends __BaseException {
            readonly name: "InvalidViewerCertificate";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidViewerCertificate, __BaseException>);
    }
    /**
        * <p>A web ACL ID specified is not valid. To specify a web ACL created using the latest
        * 			version of WAF, use the ACL ARN, for example
        * 			<code>arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a</code>.
        * 			To specify a web ACL created using WAF Classic, use the ACL ID, for example
        * 			<code>473e64fd-f30b-4765-81a0-62ad96dd167a</code>.</p>
        */
    export class InvalidWebACLId extends __BaseException {
            readonly name: "InvalidWebACLId";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidWebACLId, __BaseException>);
    }
    /**
        * <p>The cache policy does not exist.</p>
        */
    export class NoSuchCachePolicy extends __BaseException {
            readonly name: "NoSuchCachePolicy";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NoSuchCachePolicy, __BaseException>);
    }
    /**
        * <p>The specified configuration for field-level encryption doesn't exist.</p>
        */
    export class NoSuchFieldLevelEncryptionConfig extends __BaseException {
            readonly name: "NoSuchFieldLevelEncryptionConfig";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NoSuchFieldLevelEncryptionConfig, __BaseException>);
    }
    /**
        * <p>No origin exists with the specified <code>Origin Id</code>. </p>
        */
    export class NoSuchOrigin extends __BaseException {
            readonly name: "NoSuchOrigin";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NoSuchOrigin, __BaseException>);
    }
    /**
        * <p>The origin request policy does not exist.</p>
        */
    export class NoSuchOriginRequestPolicy extends __BaseException {
            readonly name: "NoSuchOriginRequestPolicy";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NoSuchOriginRequestPolicy, __BaseException>);
    }
    /**
        * <p>The real-time log configuration does not exist.</p>
        */
    export class NoSuchRealtimeLogConfig extends __BaseException {
            readonly name: "NoSuchRealtimeLogConfig";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NoSuchRealtimeLogConfig, __BaseException>);
    }
    /**
        * <p>The response headers policy does not exist.</p>
        */
    export class NoSuchResponseHeadersPolicy extends __BaseException {
            readonly name: "NoSuchResponseHeadersPolicy";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NoSuchResponseHeadersPolicy, __BaseException>);
    }
    /**
        * <p>The specified real-time log configuration belongs to a different Amazon Web Services account.</p>
        */
    export class RealtimeLogConfigOwnerMismatch extends __BaseException {
            readonly name: "RealtimeLogConfigOwnerMismatch";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<RealtimeLogConfigOwnerMismatch, __BaseException>);
    }
    /**
        * <p>You cannot create more cache behaviors for the distribution.</p>
        */
    export class TooManyCacheBehaviors extends __BaseException {
            readonly name: "TooManyCacheBehaviors";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyCacheBehaviors, __BaseException>);
    }
    /**
        * <p>You cannot create anymore custom SSL/TLS certificates.</p>
        */
    export class TooManyCertificates extends __BaseException {
            readonly name: "TooManyCertificates";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyCertificates, __BaseException>);
    }
    /**
        * <p>Your request contains more cookie names in the whitelist than are allowed per cache behavior.</p>
        */
    export class TooManyCookieNamesInWhiteList extends __BaseException {
            readonly name: "TooManyCookieNamesInWhiteList";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyCookieNamesInWhiteList, __BaseException>);
    }
    /**
        * <p>Processing your request would cause you to exceed the maximum number of distributions allowed.</p>
        */
    export class TooManyDistributions extends __BaseException {
            readonly name: "TooManyDistributions";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyDistributions, __BaseException>);
    }
    /**
        * <p>The maximum number of distributions have been associated with the specified cache
        * 			policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class TooManyDistributionsAssociatedToCachePolicy extends __BaseException {
            readonly name: "TooManyDistributionsAssociatedToCachePolicy";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyDistributionsAssociatedToCachePolicy, __BaseException>);
    }
    /**
        * <p>The maximum number of distributions have been associated with the specified configuration for field-level encryption.</p>
        */
    export class TooManyDistributionsAssociatedToFieldLevelEncryptionConfig extends __BaseException {
            readonly name: "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyDistributionsAssociatedToFieldLevelEncryptionConfig, __BaseException>);
    }
    /**
        * <p>The number of distributions that reference this key group is more than the maximum
        * 			allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class TooManyDistributionsAssociatedToKeyGroup extends __BaseException {
            readonly name: "TooManyDistributionsAssociatedToKeyGroup";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyDistributionsAssociatedToKeyGroup, __BaseException>);
    }
    /**
        * <p>The maximum number of distributions have been associated with the specified origin
        * 			request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class TooManyDistributionsAssociatedToOriginRequestPolicy extends __BaseException {
            readonly name: "TooManyDistributionsAssociatedToOriginRequestPolicy";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyDistributionsAssociatedToOriginRequestPolicy, __BaseException>);
    }
    /**
        * <p>The maximum number of distributions have been associated with the specified response headers
        * 			policy.</p>
        * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 				<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class TooManyDistributionsAssociatedToResponseHeadersPolicy extends __BaseException {
            readonly name: "TooManyDistributionsAssociatedToResponseHeadersPolicy";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyDistributionsAssociatedToResponseHeadersPolicy, __BaseException>);
    }
    /**
        * <p>You have reached the maximum number of distributions that are associated with a CloudFront
        * 			function. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class TooManyDistributionsWithFunctionAssociations extends __BaseException {
            readonly name: "TooManyDistributionsWithFunctionAssociations";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyDistributionsWithFunctionAssociations, __BaseException>);
    }
    /**
        * <p>Processing your request would cause the maximum number of distributions with Lambda@Edge function associations per owner
        * 			to be exceeded.</p>
        */
    export class TooManyDistributionsWithLambdaAssociations extends __BaseException {
            readonly name: "TooManyDistributionsWithLambdaAssociations";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyDistributionsWithLambdaAssociations, __BaseException>);
    }
    /**
        * <p>The maximum number of distributions have been associated with the specified Lambda@Edge
        * 			function.</p>
        */
    export class TooManyDistributionsWithSingleFunctionARN extends __BaseException {
            readonly name: "TooManyDistributionsWithSingleFunctionARN";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyDistributionsWithSingleFunctionARN, __BaseException>);
    }
    /**
        * <p>You have reached the maximum number of CloudFront function associations for this
        * 			distribution. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class TooManyFunctionAssociations extends __BaseException {
            readonly name: "TooManyFunctionAssociations";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyFunctionAssociations, __BaseException>);
    }
    /**
        * <p>Your request contains too many headers in forwarded values.</p>
        */
    export class TooManyHeadersInForwardedValues extends __BaseException {
            readonly name: "TooManyHeadersInForwardedValues";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyHeadersInForwardedValues, __BaseException>);
    }
    /**
        * <p>The number of key groups referenced by this distribution is more than the maximum
        * 			allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class TooManyKeyGroupsAssociatedToDistribution extends __BaseException {
            readonly name: "TooManyKeyGroupsAssociatedToDistribution";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyKeyGroupsAssociatedToDistribution, __BaseException>);
    }
    /**
        * <p>Your request contains more Lambda@Edge function associations than are allowed per distribution.</p>
        */
    export class TooManyLambdaFunctionAssociations extends __BaseException {
            readonly name: "TooManyLambdaFunctionAssociations";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyLambdaFunctionAssociations, __BaseException>);
    }
    /**
        * <p>Your request contains too many origin custom headers.</p>
        */
    export class TooManyOriginCustomHeaders extends __BaseException {
            readonly name: "TooManyOriginCustomHeaders";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyOriginCustomHeaders, __BaseException>);
    }
    /**
        * <p>Processing your request would cause you to exceed the maximum number of origin groups allowed.</p>
        */
    export class TooManyOriginGroupsPerDistribution extends __BaseException {
            readonly name: "TooManyOriginGroupsPerDistribution";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyOriginGroupsPerDistribution, __BaseException>);
    }
    /**
        * <p>You cannot create more origins for the distribution.</p>
        */
    export class TooManyOrigins extends __BaseException {
            readonly name: "TooManyOrigins";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyOrigins, __BaseException>);
    }
    /**
        * <p>Your request contains too many query string parameters.</p>
        */
    export class TooManyQueryStringParameters extends __BaseException {
            readonly name: "TooManyQueryStringParameters";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyQueryStringParameters, __BaseException>);
    }
    /**
        * <p>Your request contains more trusted signers than are allowed per distribution.</p>
        */
    export class TooManyTrustedSigners extends __BaseException {
            readonly name: "TooManyTrustedSigners";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyTrustedSigners, __BaseException>);
    }
    /**
        * <p>The specified key group does not exist.</p>
        */
    export class TrustedKeyGroupDoesNotExist extends __BaseException {
            readonly name: "TrustedKeyGroupDoesNotExist";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TrustedKeyGroupDoesNotExist, __BaseException>);
    }
    /**
        * <p>One or more of your trusted signers don't exist.</p>
        */
    export class TrustedSignerDoesNotExist extends __BaseException {
            readonly name: "TrustedSignerDoesNotExist";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TrustedSignerDoesNotExist, __BaseException>);
    }
    /**
        * <p> A complex type that contains <code>Tag</code> key and <code>Tag</code> value.</p>
        */
    export interface Tag {
            /**
                * <p> A string that contains <code>Tag</code> key.</p>
                * 		       <p>The string length should be between 1 and 128 characters. Valid characters include
                * 				<code>a-z</code>, <code>A-Z</code>, <code>0-9</code>, space, and the special characters
                * 				<code>_ - . : / = + @</code>.</p>
                */
            Key: string | undefined;
            /**
                * <p> A string that contains an optional <code>Tag</code> value.</p>
                * 		       <p>The string length should be between 0 and 256 characters. Valid characters include
                * 				<code>a-z</code>, <code>A-Z</code>, <code>0-9</code>, space, and the special characters
                * 				<code>_ - . : / = + @</code>.</p>
                */
            Value?: string;
    }
    export namespace Tag {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Tag) => any;
    }
    /**
        * <p> A complex type that contains zero or more <code>Tag</code> elements.</p>
        */
    export interface Tags {
            /**
                * <p> A complex type that contains <code>Tag</code> elements.</p>
                */
            Items?: Tag[];
    }
    export namespace Tags {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Tags) => any;
    }
    /**
        * <p>A distribution Configuration and a list of tags to be associated with the
        * 			distribution.</p>
        */
    export interface DistributionConfigWithTags {
            /**
                * <p>A distribution configuration.</p>
                */
            DistributionConfig: DistributionConfig | undefined;
            /**
                * <p>A complex type that contains zero or more <code>Tag</code> elements.</p>
                */
            Tags: Tags | undefined;
    }
    export namespace DistributionConfigWithTags {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DistributionConfigWithTags) => any;
    }
    /**
        * <p>The request to create a new distribution with tags. </p>
        */
    export interface CreateDistributionWithTagsRequest {
            /**
                * <p>The distribution's configuration information. </p>
                */
            DistributionConfigWithTags: DistributionConfigWithTags | undefined;
    }
    export namespace CreateDistributionWithTagsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateDistributionWithTagsRequest) => any;
    }
    /**
        * <p>The returned result of the corresponding request. </p>
        */
    export interface CreateDistributionWithTagsResult {
            /**
                * <p>The distribution's information. </p>
                */
            Distribution?: Distribution;
            /**
                * <p>The fully qualified URI of the new distribution resource just created.</p>
                */
            Location?: string;
            /**
                * <p>The current version of the distribution created.</p>
                */
            ETag?: string;
    }
    export namespace CreateDistributionWithTagsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateDistributionWithTagsResult) => any;
    }
    /**
        * <p>The tagging specified is not valid.</p>
        */
    export class InvalidTagging extends __BaseException {
            readonly name: "InvalidTagging";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidTagging, __BaseException>);
    }
    export type Format = "URLEncoded";
    /**
        * <p>A field-level encryption content type profile. </p>
        */
    export interface ContentTypeProfile {
            /**
                * <p>The format for a field-level encryption content type-profile mapping. </p>
                */
            Format: Format | string | undefined;
            /**
                * <p>The profile ID for a field-level encryption content type-profile mapping. </p>
                */
            ProfileId?: string;
            /**
                * <p>The content type for a field-level encryption content type-profile mapping. </p>
                */
            ContentType: string | undefined;
    }
    export namespace ContentTypeProfile {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ContentTypeProfile) => any;
    }
    /**
        * <p>Field-level encryption content type-profile. </p>
        */
    export interface ContentTypeProfiles {
            /**
                * <p>The number of field-level encryption content type-profile mappings. </p>
                */
            Quantity: number | undefined;
            /**
                * <p>Items in a field-level encryption content type-profile mapping. </p>
                */
            Items?: ContentTypeProfile[];
    }
    export namespace ContentTypeProfiles {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ContentTypeProfiles) => any;
    }
    /**
        * <p>The configuration for a field-level encryption content type-profile mapping. </p>
        */
    export interface ContentTypeProfileConfig {
            /**
                * <p>The setting in a field-level encryption content type-profile mapping that specifies what to do
                * 			when an unknown content type is provided for the profile. If true, content is
                * 			forwarded without being encrypted when the content type is unknown. If false (the
                * 			default), an error is returned when the content type is unknown. </p>
                */
            ForwardWhenContentTypeIsUnknown: boolean | undefined;
            /**
                * <p>The configuration for a field-level encryption content type-profile. </p>
                */
            ContentTypeProfiles?: ContentTypeProfiles;
    }
    export namespace ContentTypeProfileConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ContentTypeProfileConfig) => any;
    }
    /**
        * <p>Query argument-profile mapping for field-level encryption.</p>
        */
    export interface QueryArgProfile {
            /**
                * <p>Query argument for field-level encryption query argument-profile mapping.</p>
                */
            QueryArg: string | undefined;
            /**
                * <p>ID of profile to use for field-level encryption query argument-profile mapping</p>
                */
            ProfileId: string | undefined;
    }
    export namespace QueryArgProfile {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: QueryArgProfile) => any;
    }
    /**
        * <p>Query argument-profile mapping for field-level encryption.</p>
        */
    export interface QueryArgProfiles {
            /**
                * <p>Number of profiles for query argument-profile mapping for field-level encryption.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>Number of items for query argument-profile mapping for field-level encryption.</p>
                */
            Items?: QueryArgProfile[];
    }
    export namespace QueryArgProfiles {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: QueryArgProfiles) => any;
    }
    /**
        * <p>Configuration for query argument-profile mapping for field-level encryption.</p>
        */
    export interface QueryArgProfileConfig {
            /**
                * <p>Flag to set if you want a request to be forwarded to the origin even if the profile specified by the field-level encryption query argument,
                * 			fle-profile, is unknown.</p>
                */
            ForwardWhenQueryArgProfileIsUnknown: boolean | undefined;
            /**
                * <p>Profiles specified for query argument-profile mapping for field-level encryption.</p>
                */
            QueryArgProfiles?: QueryArgProfiles;
    }
    export namespace QueryArgProfileConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: QueryArgProfileConfig) => any;
    }
    /**
        * <p>A complex data type that includes the profile configurations specified for field-level encryption. </p>
        */
    export interface FieldLevelEncryptionConfig {
            /**
                * <p>A unique number that ensures the request can't be replayed.</p>
                */
            CallerReference: string | undefined;
            /**
                * <p>An optional comment about the configuration. The comment cannot be longer than 128
                * 			characters.</p>
                */
            Comment?: string;
            /**
                * <p>A complex data type that specifies when to forward content if a profile isn't found and the profile that can be provided as a
                * 			query argument in a request.</p>
                */
            QueryArgProfileConfig?: QueryArgProfileConfig;
            /**
                * <p>A complex data type that specifies when to forward content if a content type isn't recognized and profiles to use as by default
                * 			in a request if a query argument doesn't specify a profile to use.</p>
                */
            ContentTypeProfileConfig?: ContentTypeProfileConfig;
    }
    export namespace FieldLevelEncryptionConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FieldLevelEncryptionConfig) => any;
    }
    export interface CreateFieldLevelEncryptionConfigRequest {
            /**
                * <p>The request to create a new field-level encryption configuration.</p>
                */
            FieldLevelEncryptionConfig: FieldLevelEncryptionConfig | undefined;
    }
    export namespace CreateFieldLevelEncryptionConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateFieldLevelEncryptionConfigRequest) => any;
    }
    /**
        * <p>A complex data type that includes the profile configurations and other options specified for field-level encryption. </p>
        */
    export interface FieldLevelEncryption {
            /**
                * <p>The configuration ID for a field-level encryption configuration which includes a set of profiles that specify certain
                * 		selected data fields to be encrypted by specific public keys.</p>
                */
            Id: string | undefined;
            /**
                * <p>The last time the field-level encryption configuration was changed. </p>
                */
            LastModifiedTime: Date | undefined;
            /**
                * <p>A complex data type that includes the profile configurations specified for field-level encryption. </p>
                */
            FieldLevelEncryptionConfig: FieldLevelEncryptionConfig | undefined;
    }
    export namespace FieldLevelEncryption {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FieldLevelEncryption) => any;
    }
    export interface CreateFieldLevelEncryptionConfigResult {
            /**
                * <p>Returned when you create a new field-level encryption configuration.</p>
                */
            FieldLevelEncryption?: FieldLevelEncryption;
            /**
                * <p>The fully qualified URI of the new configuration resource just created.</p>
                */
            Location?: string;
            /**
                * <p>The current version of the field level encryption configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
                */
            ETag?: string;
    }
    export namespace CreateFieldLevelEncryptionConfigResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateFieldLevelEncryptionConfigResult) => any;
    }
    /**
        * <p>The specified configuration for field-level encryption already exists.</p>
        */
    export class FieldLevelEncryptionConfigAlreadyExists extends __BaseException {
            readonly name: "FieldLevelEncryptionConfigAlreadyExists";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<FieldLevelEncryptionConfigAlreadyExists, __BaseException>);
    }
    /**
        * <p>The specified profile for field-level encryption doesn't exist.</p>
        */
    export class NoSuchFieldLevelEncryptionProfile extends __BaseException {
            readonly name: "NoSuchFieldLevelEncryptionProfile";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NoSuchFieldLevelEncryptionProfile, __BaseException>);
    }
    /**
        * <p>No profile specified for the field-level encryption query argument.</p>
        */
    export class QueryArgProfileEmpty extends __BaseException {
            readonly name: "QueryArgProfileEmpty";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<QueryArgProfileEmpty, __BaseException>);
    }
    /**
        * <p>The maximum number of configurations for field-level encryption have been created.</p>
        */
    export class TooManyFieldLevelEncryptionConfigs extends __BaseException {
            readonly name: "TooManyFieldLevelEncryptionConfigs";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyFieldLevelEncryptionConfigs, __BaseException>);
    }
    /**
        * <p>The maximum number of content type profiles for field-level encryption have been created.</p>
        */
    export class TooManyFieldLevelEncryptionContentTypeProfiles extends __BaseException {
            readonly name: "TooManyFieldLevelEncryptionContentTypeProfiles";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyFieldLevelEncryptionContentTypeProfiles, __BaseException>);
    }
    /**
        * <p>The maximum number of query arg profiles for field-level encryption have been created.</p>
        */
    export class TooManyFieldLevelEncryptionQueryArgProfiles extends __BaseException {
            readonly name: "TooManyFieldLevelEncryptionQueryArgProfiles";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyFieldLevelEncryptionQueryArgProfiles, __BaseException>);
    }
    /**
        * <p>A complex data type that includes the field patterns to match for field-level encryption.</p>
        */
    export interface FieldPatterns {
            /**
                * <p>The number of field-level encryption field patterns.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>An array of the field-level encryption field patterns.</p>
                */
            Items?: string[];
    }
    export namespace FieldPatterns {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FieldPatterns) => any;
    }
    /**
        * <p>Complex data type for field-level encryption profiles that includes the encryption key and field pattern specifications. </p>
        */
    export interface EncryptionEntity {
            /**
                * <p>The public key associated with a set of field-level encryption patterns, to be used when encrypting the fields that match
                * 			the patterns. </p>
                */
            PublicKeyId: string | undefined;
            /**
                * <p>The provider associated with the public key being used for encryption. This value must also be provided with the private key
                * 		for applications to be able to decrypt data.</p>
                */
            ProviderId: string | undefined;
            /**
                * <p>Field patterns in a field-level encryption content type profile specify the fields that you want to be encrypted. You can provide the
                * 			full field name, or any beginning characters followed by a wildcard (*). You can't overlap field patterns. For example, you can't have
                * 			both ABC* and AB*. Note that field patterns are case-sensitive. </p>
                */
            FieldPatterns: FieldPatterns | undefined;
    }
    export namespace EncryptionEntity {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EncryptionEntity) => any;
    }
    /**
        * <p>Complex data type for field-level encryption profiles that includes all of the encryption entities. </p>
        */
    export interface EncryptionEntities {
            /**
                * <p>Number of field pattern items in a field-level encryption content type-profile mapping. </p>
                */
            Quantity: number | undefined;
            /**
                * <p>An array of field patterns in a field-level encryption content type-profile mapping. </p>
                */
            Items?: EncryptionEntity[];
    }
    export namespace EncryptionEntities {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EncryptionEntities) => any;
    }
    /**
        * <p>A complex data type of profiles for the field-level encryption.</p>
        */
    export interface FieldLevelEncryptionProfileConfig {
            /**
                * <p>Profile name for the field-level encryption profile.</p>
                */
            Name: string | undefined;
            /**
                * <p>A unique number that ensures that the request can't be replayed.</p>
                */
            CallerReference: string | undefined;
            /**
                * <p>An optional comment for the field-level encryption profile. The comment cannot be longer
                * 			than 128 characters.</p>
                */
            Comment?: string;
            /**
                * <p>A complex data type of encryption entities for the field-level encryption profile that include the public key ID, provider, and
                * 			field patterns for specifying which fields to encrypt with this key.</p>
                */
            EncryptionEntities: EncryptionEntities | undefined;
    }
    export namespace FieldLevelEncryptionProfileConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FieldLevelEncryptionProfileConfig) => any;
    }
    export interface CreateFieldLevelEncryptionProfileRequest {
            /**
                * <p>The request to create a field-level encryption profile.</p>
                */
            FieldLevelEncryptionProfileConfig: FieldLevelEncryptionProfileConfig | undefined;
    }
    export namespace CreateFieldLevelEncryptionProfileRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateFieldLevelEncryptionProfileRequest) => any;
    }
    /**
        * <p>A complex data type for field-level encryption profiles.</p>
        */
    export interface FieldLevelEncryptionProfile {
            /**
                * <p>The ID for a field-level encryption profile configuration which includes a set of profiles that specify certain
                * 			selected data fields to be encrypted by specific public keys.</p>
                */
            Id: string | undefined;
            /**
                * <p>The last time the field-level encryption profile was updated.</p>
                */
            LastModifiedTime: Date | undefined;
            /**
                * <p>A complex data type that includes the profile name and the encryption entities for the field-level encryption profile.</p>
                */
            FieldLevelEncryptionProfileConfig: FieldLevelEncryptionProfileConfig | undefined;
    }
    export namespace FieldLevelEncryptionProfile {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FieldLevelEncryptionProfile) => any;
    }
    export interface CreateFieldLevelEncryptionProfileResult {
            /**
                * <p>Returned when you create a new field-level encryption profile.</p>
                */
            FieldLevelEncryptionProfile?: FieldLevelEncryptionProfile;
            /**
                * <p>The fully qualified URI of the new profile resource just created.</p>
                */
            Location?: string;
            /**
                * <p>The current version of the field level encryption profile. For example: <code>E2QWRUHAPOMQZL</code>.</p>
                */
            ETag?: string;
    }
    export namespace CreateFieldLevelEncryptionProfileResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateFieldLevelEncryptionProfileResult) => any;
    }
    /**
        * <p>The specified profile for field-level encryption already exists.</p>
        */
    export class FieldLevelEncryptionProfileAlreadyExists extends __BaseException {
            readonly name: "FieldLevelEncryptionProfileAlreadyExists";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<FieldLevelEncryptionProfileAlreadyExists, __BaseException>);
    }
    /**
        * <p>The maximum size of a profile for field-level encryption was exceeded.</p>
        */
    export class FieldLevelEncryptionProfileSizeExceeded extends __BaseException {
            readonly name: "FieldLevelEncryptionProfileSizeExceeded";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<FieldLevelEncryptionProfileSizeExceeded, __BaseException>);
    }
    /**
        * <p>The specified public key doesn't exist.</p>
        */
    export class NoSuchPublicKey extends __BaseException {
            readonly name: "NoSuchPublicKey";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NoSuchPublicKey, __BaseException>);
    }
    /**
        * <p>The maximum number of encryption entities for field-level encryption have been created.</p>
        */
    export class TooManyFieldLevelEncryptionEncryptionEntities extends __BaseException {
            readonly name: "TooManyFieldLevelEncryptionEncryptionEntities";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyFieldLevelEncryptionEncryptionEntities, __BaseException>);
    }
    /**
        * <p>The maximum number of field patterns for field-level encryption have been created.</p>
        */
    export class TooManyFieldLevelEncryptionFieldPatterns extends __BaseException {
            readonly name: "TooManyFieldLevelEncryptionFieldPatterns";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyFieldLevelEncryptionFieldPatterns, __BaseException>);
    }
    /**
        * <p>The maximum number of profiles for field-level encryption have been created.</p>
        */
    export class TooManyFieldLevelEncryptionProfiles extends __BaseException {
            readonly name: "TooManyFieldLevelEncryptionProfiles";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyFieldLevelEncryptionProfiles, __BaseException>);
    }
    export enum FunctionRuntime {
            cloudfront_js_1_0 = "cloudfront-js-1.0"
    }
    /**
        * <p>Contains configuration information about a CloudFront function.</p>
        */
    export interface FunctionConfig {
            /**
                * <p>A comment to describe the function.</p>
                */
            Comment: string | undefined;
            /**
                * <p>The function’s runtime environment. The only valid value is
                * 			<code>cloudfront-js-1.0</code>.</p>
                */
            Runtime: FunctionRuntime | string | undefined;
    }
    export namespace FunctionConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FunctionConfig) => any;
    }
    export interface CreateFunctionRequest {
            /**
                * <p>A name to identify the function.</p>
                */
            Name: string | undefined;
            /**
                * <p>Configuration information about the function, including an optional comment and the
                * 			function’s runtime.</p>
                */
            FunctionConfig: FunctionConfig | undefined;
            /**
                * <p>The function code. For more information about writing a CloudFront function, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/writing-function-code.html">Writing function
                * 			code for CloudFront Functions</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            FunctionCode: Uint8Array | undefined;
    }
    export namespace CreateFunctionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateFunctionRequest) => any;
    }
    export enum FunctionStage {
            DEVELOPMENT = "DEVELOPMENT",
            LIVE = "LIVE"
    }
    /**
        * <p>Contains metadata about a CloudFront function.</p>
        */
    export interface FunctionMetadata {
            /**
                * <p>The Amazon Resource Name (ARN) of the function. The ARN uniquely identifies the
                * 			function.</p>
                */
            FunctionARN: string | undefined;
            /**
                * <p>The stage that the function is in, either <code>DEVELOPMENT</code> or
                * 			<code>LIVE</code>.</p>
                * 		       <p>When a function is in the <code>DEVELOPMENT</code> stage, you can test the function with
                * 				<code>TestFunction</code>, and update it with <code>UpdateFunction</code>.</p>
                * 		       <p>When a function is in the <code>LIVE</code> stage, you can attach the function to a
                * 			distribution’s cache behavior, using the function’s ARN.</p>
                */
            Stage?: FunctionStage | string;
            /**
                * <p>The date and time when the function was created.</p>
                */
            CreatedTime?: Date;
            /**
                * <p>The date and time when the function was most recently updated.</p>
                */
            LastModifiedTime: Date | undefined;
    }
    export namespace FunctionMetadata {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FunctionMetadata) => any;
    }
    /**
        * <p>Contains configuration information and metadata about a CloudFront function.</p>
        */
    export interface FunctionSummary {
            /**
                * <p>The name of the CloudFront function.</p>
                */
            Name: string | undefined;
            /**
                * <p>The status of the CloudFront function.</p>
                */
            Status?: string;
            /**
                * <p>Contains configuration information about a CloudFront function.</p>
                */
            FunctionConfig: FunctionConfig | undefined;
            /**
                * <p>Contains metadata about a CloudFront function.</p>
                */
            FunctionMetadata: FunctionMetadata | undefined;
    }
    export namespace FunctionSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FunctionSummary) => any;
    }
    export interface CreateFunctionResult {
            /**
                * <p>Contains configuration information and metadata about a CloudFront function.</p>
                */
            FunctionSummary?: FunctionSummary;
            /**
                * <p>The URL of the CloudFront function. Use the URL to manage the function with the CloudFront
                * 			API.</p>
                */
            Location?: string;
            /**
                * <p>The version identifier for the current version of the CloudFront function.</p>
                */
            ETag?: string;
    }
    export namespace CreateFunctionResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateFunctionResult) => any;
    }
    /**
        * <p>A function with the same name already exists in this Amazon Web Services account. To create a
        * 			function, you must provide a unique name. To update an existing function, use
        * 			<code>UpdateFunction</code>.</p>
        */
    export class FunctionAlreadyExists extends __BaseException {
            readonly name: "FunctionAlreadyExists";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<FunctionAlreadyExists, __BaseException>);
    }
    /**
        * <p>The function is too large. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class FunctionSizeLimitExceeded extends __BaseException {
            readonly name: "FunctionSizeLimitExceeded";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<FunctionSizeLimitExceeded, __BaseException>);
    }
    /**
        * <p>You have reached the maximum number of CloudFront functions for this Amazon Web Services account. For more
        * 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class TooManyFunctions extends __BaseException {
            readonly name: "TooManyFunctions";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyFunctions, __BaseException>);
    }
    /**
        * <p>This operation is not supported in this region.</p>
        */
    export class UnsupportedOperation extends __BaseException {
            readonly name: "UnsupportedOperation";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UnsupportedOperation, __BaseException>);
    }
    /**
        * <p>A complex type that contains information about the objects that you want to invalidate.
        * 			For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html#invalidation-specifying-objects">Specifying the Objects
        * 				to Invalidate</a> in the <i>Amazon CloudFront Developer Guide</i>. </p>
        */
    export interface Paths {
            /**
                * <p>The number of invalidation paths specified for the objects that you want to invalidate.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>A complex type that contains a list of the paths that you want to invalidate.</p>
                */
            Items?: string[];
    }
    export namespace Paths {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Paths) => any;
    }
    /**
        * <p>An invalidation batch.</p>
        */
    export interface InvalidationBatch {
            /**
                * <p>A complex type that contains information about the objects that you want to invalidate.
                * 			For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html#invalidation-specifying-objects">Specifying the Objects
                * 				to Invalidate</a> in the <i>Amazon CloudFront Developer Guide</i>. </p>
                */
            Paths: Paths | undefined;
            /**
                * <p>A value that you specify to uniquely identify an invalidation request. CloudFront uses the
                * 			value to prevent you from accidentally resubmitting an identical request. Whenever you create
                * 			a new invalidation request, you must specify a new value for <code>CallerReference</code> and
                * 			change other values in the request as applicable. One way to ensure that the value of
                * 				<code>CallerReference</code> is unique is to use a <code>timestamp</code>, for example,
                * 				<code>20120301090000</code>.</p>
                * 		       <p>If you make a second invalidation request with the same value for
                * 				<code>CallerReference</code>, and if the rest of the request is the same, CloudFront doesn't
                * 			create a new invalidation request. Instead, CloudFront returns information about the invalidation
                * 			request that you previously created with the same <code>CallerReference</code>.</p>
                * 		       <p>If <code>CallerReference</code> is a value you already sent in a previous invalidation
                * 			batch request but the content of any <code>Path</code> is different from the original request,
                * 			CloudFront returns an <code>InvalidationBatchAlreadyExists</code> error.</p>
                */
            CallerReference: string | undefined;
    }
    export namespace InvalidationBatch {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InvalidationBatch) => any;
    }
    /**
        * <p>The request to create an invalidation.</p>
        */
    export interface CreateInvalidationRequest {
            /**
                * <p>The distribution's id.</p>
                */
            DistributionId: string | undefined;
            /**
                * <p>The batch information for the invalidation.</p>
                */
            InvalidationBatch: InvalidationBatch | undefined;
    }
    export namespace CreateInvalidationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateInvalidationRequest) => any;
    }
    /**
        * <p>An invalidation. </p>
        */
    export interface Invalidation {
            /**
                * <p>The identifier for the invalidation request. For example:
                * 			<code>IDFDVBD632BHDS5</code>.</p>
                */
            Id: string | undefined;
            /**
                * <p>The status of the invalidation request. When the invalidation batch is finished, the
                * 			status is <code>Completed</code>.</p>
                */
            Status: string | undefined;
            /**
                * <p>The date and time the invalidation request was first made. </p>
                */
            CreateTime: Date | undefined;
            /**
                * <p>The current invalidation information for the batch request. </p>
                */
            InvalidationBatch: InvalidationBatch | undefined;
    }
    export namespace Invalidation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Invalidation) => any;
    }
    /**
        * <p>The returned result of the corresponding request.</p>
        */
    export interface CreateInvalidationResult {
            /**
                * <p>The fully qualified URI of the distribution and invalidation batch request, including
                * 			the <code>Invalidation ID</code>.</p>
                */
            Location?: string;
            /**
                * <p>The invalidation's information.</p>
                */
            Invalidation?: Invalidation;
    }
    export namespace CreateInvalidationResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateInvalidationResult) => any;
    }
    /**
        * <p>You have exceeded the maximum number of allowable InProgress invalidation batch requests, or invalidation objects.</p>
        */
    export class TooManyInvalidationsInProgress extends __BaseException {
            readonly name: "TooManyInvalidationsInProgress";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyInvalidationsInProgress, __BaseException>);
    }
    /**
        * <p>A key group configuration.</p>
        * 		       <p>A key group contains a list of public keys that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">CloudFront signed URLs and signed cookies</a>.</p>
        */
    export interface KeyGroupConfig {
            /**
                * <p>A name to identify the key group.</p>
                */
            Name: string | undefined;
            /**
                * <p>A list of the identifiers of the public keys in the key group.</p>
                */
            Items: string[] | undefined;
            /**
                * <p>A comment to describe the key group. The comment cannot be longer than 128
                * 			characters.</p>
                */
            Comment?: string;
    }
    export namespace KeyGroupConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: KeyGroupConfig) => any;
    }
    export interface CreateKeyGroupRequest {
            /**
                * <p>A key group configuration.</p>
                */
            KeyGroupConfig: KeyGroupConfig | undefined;
    }
    export namespace CreateKeyGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateKeyGroupRequest) => any;
    }
    /**
        * <p>A key group.</p>
        * 		       <p>A key group contains a list of public keys that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">CloudFront signed URLs and signed cookies</a>.</p>
        */
    export interface KeyGroup {
            /**
                * <p>The identifier for the key group.</p>
                */
            Id: string | undefined;
            /**
                * <p>The date and time when the key group was last modified.</p>
                */
            LastModifiedTime: Date | undefined;
            /**
                * <p>The key group configuration.</p>
                */
            KeyGroupConfig: KeyGroupConfig | undefined;
    }
    export namespace KeyGroup {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: KeyGroup) => any;
    }
    export interface CreateKeyGroupResult {
            /**
                * <p>The key group that was just created.</p>
                */
            KeyGroup?: KeyGroup;
            /**
                * <p>The URL of the key group.</p>
                */
            Location?: string;
            /**
                * <p>The identifier for this version of the key group.</p>
                */
            ETag?: string;
    }
    export namespace CreateKeyGroupResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateKeyGroupResult) => any;
    }
    /**
        * <p>A key group with this name already exists. You must provide a unique name. To modify an
        * 			existing key group, use <code>UpdateKeyGroup</code>.</p>
        */
    export class KeyGroupAlreadyExists extends __BaseException {
            readonly name: "KeyGroupAlreadyExists";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<KeyGroupAlreadyExists, __BaseException>);
    }
    /**
        * <p>You have reached the maximum number of key groups for this Amazon Web Services account. For more
        * 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class TooManyKeyGroups extends __BaseException {
            readonly name: "TooManyKeyGroups";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyKeyGroups, __BaseException>);
    }
    /**
        * <p>The number of public keys in this key group is more than the maximum allowed. For more
        * 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class TooManyPublicKeysInKeyGroup extends __BaseException {
            readonly name: "TooManyPublicKeysInKeyGroup";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyPublicKeysInKeyGroup, __BaseException>);
    }
    export enum RealtimeMetricsSubscriptionStatus {
            Disabled = "Disabled",
            Enabled = "Enabled"
    }
    /**
        * <p>A subscription configuration for additional CloudWatch metrics.</p>
        */
    export interface RealtimeMetricsSubscriptionConfig {
            /**
                * <p>A flag that indicates whether additional CloudWatch metrics are enabled for a given
                * 			CloudFront distribution.</p>
                */
            RealtimeMetricsSubscriptionStatus: RealtimeMetricsSubscriptionStatus | string | undefined;
    }
    export namespace RealtimeMetricsSubscriptionConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RealtimeMetricsSubscriptionConfig) => any;
    }
    /**
        * <p>A monitoring subscription. This structure contains information about whether additional
        * 			CloudWatch metrics are enabled for a given CloudFront distribution.</p>
        */
    export interface MonitoringSubscription {
            /**
                * <p>A subscription configuration for additional CloudWatch metrics.</p>
                */
            RealtimeMetricsSubscriptionConfig?: RealtimeMetricsSubscriptionConfig;
    }
    export namespace MonitoringSubscription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: MonitoringSubscription) => any;
    }
    export interface CreateMonitoringSubscriptionRequest {
            /**
                * <p>The ID of the distribution that you are enabling metrics for.</p>
                */
            DistributionId: string | undefined;
            /**
                * <p>A monitoring subscription. This structure contains information about whether additional
                * 			CloudWatch metrics are enabled for a given CloudFront distribution.</p>
                */
            MonitoringSubscription: MonitoringSubscription | undefined;
    }
    export namespace CreateMonitoringSubscriptionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateMonitoringSubscriptionRequest) => any;
    }
    export interface CreateMonitoringSubscriptionResult {
            /**
                * <p>A monitoring subscription. This structure contains information about whether additional
                * 			CloudWatch metrics are enabled for a given CloudFront distribution.</p>
                */
            MonitoringSubscription?: MonitoringSubscription;
    }
    export namespace CreateMonitoringSubscriptionResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateMonitoringSubscriptionResult) => any;
    }
    export type OriginRequestPolicyCookieBehavior = "all" | "none" | "whitelist";
    /**
        * <p>An object that determines whether any cookies in viewer requests (and if so, which cookies)
        * 			are included in requests that CloudFront sends to the origin.</p>
        */
    export interface OriginRequestPolicyCookiesConfig {
            /**
                * <p>Determines whether cookies in viewer requests are included in requests that CloudFront sends to
                * 			the origin. Valid values are:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>
                *                   <code>none</code> – Cookies in viewer requests are not included in requests that CloudFront
                * 					sends to the origin. Even when this field is set to <code>none</code>, any
                * 					cookies that are listed in a <code>CachePolicy</code>
                *                   <i>are</i>
                * 					included in origin requests.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>whitelist</code> – The cookies in viewer requests that are listed in the
                * 					<code>CookieNames</code> type are included in requests that CloudFront sends to the
                * 					origin.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>all</code> – All cookies in viewer requests are included in requests that CloudFront sends
                * 					to the origin.</p>
                * 			         </li>
                *          </ul>
                */
            CookieBehavior: OriginRequestPolicyCookieBehavior | string | undefined;
            /**
                * <p>Contains a list of cookie names.</p>
                */
            Cookies?: CookieNames;
    }
    export namespace OriginRequestPolicyCookiesConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OriginRequestPolicyCookiesConfig) => any;
    }
    export type OriginRequestPolicyHeaderBehavior = "allViewer" | "allViewerAndWhitelistCloudFront" | "none" | "whitelist";
    /**
        * <p>An object that determines whether any HTTP headers (and if so, which headers) are included
        * 			in requests that CloudFront sends to the origin.</p>
        */
    export interface OriginRequestPolicyHeadersConfig {
            /**
                * <p>Determines whether any HTTP headers are included in requests that CloudFront sends to the origin.
                * 			Valid values are:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>
                *                   <code>none</code> – HTTP headers are not included in requests that CloudFront sends to the
                * 					origin. Even when this field is set to <code>none</code>, any headers that are
                * 					listed in a <code>CachePolicy</code>
                *                   <i>are</i> included in origin
                * 					requests.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>whitelist</code> – The HTTP headers that are listed in the <code>Headers</code> type
                * 					are included in requests that CloudFront sends to the origin.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>allViewer</code> – All HTTP headers in viewer requests are included in requests that
                * 					CloudFront sends to the origin.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>allViewerAndWhitelistCloudFront</code> – All HTTP headers in viewer requests and the
                * 					additional CloudFront headers that are listed in the <code>Headers</code> type are
                * 					included in requests that CloudFront sends to the origin. The additional headers are
                * 					added by CloudFront.</p>
                * 			         </li>
                *          </ul>
                */
            HeaderBehavior: OriginRequestPolicyHeaderBehavior | string | undefined;
            /**
                * <p>Contains a list of HTTP header names.</p>
                */
            Headers?: Headers;
    }
    export namespace OriginRequestPolicyHeadersConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OriginRequestPolicyHeadersConfig) => any;
    }
    export type OriginRequestPolicyQueryStringBehavior = "all" | "none" | "whitelist";
    /**
        * <p>An object that determines whether any URL query strings in viewer requests (and if so, which
        * 			query strings) are included in requests that CloudFront sends to the origin.</p>
        */
    export interface OriginRequestPolicyQueryStringsConfig {
            /**
                * <p>Determines whether any URL query strings in viewer requests are included in requests that
                * 			CloudFront sends to the origin. Valid values are:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>
                *                   <code>none</code> – Query strings in viewer requests are not included in requests that
                * 					CloudFront sends to the origin. Even when this field is set to <code>none</code>, any
                * 					query strings that are listed in a <code>CachePolicy</code>
                * 					             <i>are</i> included in origin requests.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>whitelist</code> – The query strings in viewer requests that are listed in the
                * 					<code>QueryStringNames</code> type are included in requests that CloudFront sends to
                * 					the origin.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>all</code> – All query strings in viewer requests are included in requests that CloudFront
                * 					sends to the origin.</p>
                * 			         </li>
                *          </ul>
                */
            QueryStringBehavior: OriginRequestPolicyQueryStringBehavior | string | undefined;
            /**
                * <p>Contains a list of the query strings in viewer requests that are included in requests that
                * 			CloudFront sends to the origin.</p>
                */
            QueryStrings?: QueryStringNames;
    }
    export namespace OriginRequestPolicyQueryStringsConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OriginRequestPolicyQueryStringsConfig) => any;
    }
    /**
        * <p>An origin request policy configuration.</p>
        * 		       <p>This configuration determines the values that CloudFront includes in requests that it sends to the
        * 			origin. Each request that CloudFront sends to the origin includes the following:</p>
        * 		       <ul>
        *             <li>
        * 				           <p>The request body and the URL path (without the domain name) from the viewer
        * 					request.</p>
        * 			         </li>
        *             <li>
        * 				           <p>The headers that CloudFront automatically includes in every origin request, including
        * 					<code>Host</code>, <code>User-Agent</code>, and <code>X-Amz-Cf-Id</code>.</p>
        * 			         </li>
        *             <li>
        * 				           <p>All HTTP headers, cookies, and URL query strings that are specified in the
        * 					cache policy or the origin request policy. These can include items from the
        * 					viewer request and, in the case of headers, additional ones that are added by
        * 					CloudFront.</p>
        * 			         </li>
        *          </ul>
        * 		       <p>CloudFront sends a request when it can’t find an object in its cache that matches the request. If
        * 			you want to send values to the origin and also include them in the cache key, use
        * 			<code>CachePolicy</code>.</p>
        */
    export interface OriginRequestPolicyConfig {
            /**
                * <p>A comment to describe the origin request policy. The comment cannot be longer than 128
                * 			characters.</p>
                */
            Comment?: string;
            /**
                * <p>A unique name to identify the origin request policy.</p>
                */
            Name: string | undefined;
            /**
                * <p>The HTTP headers to include in origin requests. These can include headers from viewer
                * 			requests and additional headers added by CloudFront.</p>
                */
            HeadersConfig: OriginRequestPolicyHeadersConfig | undefined;
            /**
                * <p>The cookies from viewer requests to include in origin requests.</p>
                */
            CookiesConfig: OriginRequestPolicyCookiesConfig | undefined;
            /**
                * <p>The URL query strings from viewer requests to include in origin requests.</p>
                */
            QueryStringsConfig: OriginRequestPolicyQueryStringsConfig | undefined;
    }
    export namespace OriginRequestPolicyConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OriginRequestPolicyConfig) => any;
    }
    export interface CreateOriginRequestPolicyRequest {
            /**
                * <p>An origin request policy configuration.</p>
                */
            OriginRequestPolicyConfig: OriginRequestPolicyConfig | undefined;
    }
    export namespace CreateOriginRequestPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateOriginRequestPolicyRequest) => any;
    }
    /**
        * <p>An origin request policy.</p>
        * 		       <p>When it’s attached to a cache behavior, the origin request policy determines the values that
        * 			CloudFront includes in requests that it sends to the origin. Each request that CloudFront sends to
        * 			the origin includes the following:</p>
        * 		       <ul>
        *             <li>
        * 				           <p>The request body and the URL path (without the domain name) from the viewer
        * 					request.</p>
        * 			         </li>
        *             <li>
        * 				           <p>The headers that CloudFront automatically includes in every origin request, including
        * 					<code>Host</code>, <code>User-Agent</code>, and <code>X-Amz-Cf-Id</code>.</p>
        * 			         </li>
        *             <li>
        * 				           <p>All HTTP headers, cookies, and URL query strings that are specified in the
        * 					cache policy or the origin request policy. These can include items from the
        * 					viewer request and, in the case of headers, additional ones that are added by
        * 					CloudFront.</p>
        * 			         </li>
        *          </ul>
        * 		       <p>CloudFront sends a request when it can’t find an object in its cache that matches the request. If
        * 			you want to send values to the origin and also include them in the cache key, use
        * 			<code>CachePolicy</code>.</p>
        */
    export interface OriginRequestPolicy {
            /**
                * <p>The unique identifier for the origin request policy.</p>
                */
            Id: string | undefined;
            /**
                * <p>The date and time when the origin request policy was last modified.</p>
                */
            LastModifiedTime: Date | undefined;
            /**
                * <p>The origin request policy configuration.</p>
                */
            OriginRequestPolicyConfig: OriginRequestPolicyConfig | undefined;
    }
    export namespace OriginRequestPolicy {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OriginRequestPolicy) => any;
    }
    export interface CreateOriginRequestPolicyResult {
            /**
                * <p>An origin request policy.</p>
                */
            OriginRequestPolicy?: OriginRequestPolicy;
            /**
                * <p>The fully qualified URI of the origin request policy just created.</p>
                */
            Location?: string;
            /**
                * <p>The current version of the origin request policy.</p>
                */
            ETag?: string;
    }
    export namespace CreateOriginRequestPolicyResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateOriginRequestPolicyResult) => any;
    }
    /**
        * <p>An origin request policy with this name already exists. You must provide a unique
        * 			name. To modify an existing origin request policy, use
        * 			<code>UpdateOriginRequestPolicy</code>.</p>
        */
    export class OriginRequestPolicyAlreadyExists extends __BaseException {
            readonly name: "OriginRequestPolicyAlreadyExists";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<OriginRequestPolicyAlreadyExists, __BaseException>);
    }
    /**
        * <p>The number of cookies in the origin request policy exceeds the maximum. For more
        * 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class TooManyCookiesInOriginRequestPolicy extends __BaseException {
            readonly name: "TooManyCookiesInOriginRequestPolicy";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyCookiesInOriginRequestPolicy, __BaseException>);
    }
    /**
        * <p>The number of headers in the origin request policy exceeds the maximum. For more
        * 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class TooManyHeadersInOriginRequestPolicy extends __BaseException {
            readonly name: "TooManyHeadersInOriginRequestPolicy";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyHeadersInOriginRequestPolicy, __BaseException>);
    }
    /**
        * <p>You have reached the maximum number of origin request policies for this Amazon Web Services account.
        * 			For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class TooManyOriginRequestPolicies extends __BaseException {
            readonly name: "TooManyOriginRequestPolicies";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyOriginRequestPolicies, __BaseException>);
    }
    /**
        * <p>The number of query strings in the origin request policy exceeds the maximum. For more
        * 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class TooManyQueryStringsInOriginRequestPolicy extends __BaseException {
            readonly name: "TooManyQueryStringsInOriginRequestPolicy";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyQueryStringsInOriginRequestPolicy, __BaseException>);
    }
    /**
        * <p>Configuration information about a public key that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">signed URLs and signed cookies</a>, or with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html">field-level encryption</a>.</p>
        */
    export interface PublicKeyConfig {
            /**
                * <p>A string included in the request to help make sure that the request can’t be
                * 			replayed.</p>
                */
            CallerReference: string | undefined;
            /**
                * <p>A name to help identify the public key.</p>
                */
            Name: string | undefined;
            /**
                * <p>The public key that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">signed URLs and signed cookies</a>, or with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html">field-level encryption</a>.</p>
                */
            EncodedKey: string | undefined;
            /**
                * <p>A comment to describe the public key. The comment cannot be longer than 128
                * 			characters.</p>
                */
            Comment?: string;
    }
    export namespace PublicKeyConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PublicKeyConfig) => any;
    }
    export interface CreatePublicKeyRequest {
            /**
                * <p>A CloudFront public key configuration.</p>
                */
            PublicKeyConfig: PublicKeyConfig | undefined;
    }
    export namespace CreatePublicKeyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreatePublicKeyRequest) => any;
    }
    /**
        * <p>A public key that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">signed URLs and signed cookies</a>, or with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html">field-level encryption</a>.</p>
        */
    export interface PublicKey {
            /**
                * <p>The identifier of the public key.</p>
                */
            Id: string | undefined;
            /**
                * <p>The date and time when the public key was uploaded.</p>
                */
            CreatedTime: Date | undefined;
            /**
                * <p>Configuration information about a public key that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">signed URLs and signed cookies</a>, or with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html">field-level encryption</a>.</p>
                */
            PublicKeyConfig: PublicKeyConfig | undefined;
    }
    export namespace PublicKey {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PublicKey) => any;
    }
    export interface CreatePublicKeyResult {
            /**
                * <p>The public key.</p>
                */
            PublicKey?: PublicKey;
            /**
                * <p>The URL of the public key.</p>
                */
            Location?: string;
            /**
                * <p>The identifier for this version of the public key.</p>
                */
            ETag?: string;
    }
    export namespace CreatePublicKeyResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreatePublicKeyResult) => any;
    }
    /**
        * <p>The specified public key already exists.</p>
        */
    export class PublicKeyAlreadyExists extends __BaseException {
            readonly name: "PublicKeyAlreadyExists";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<PublicKeyAlreadyExists, __BaseException>);
    }
    /**
        * <p>The maximum number of public keys for field-level encryption have been created. To create a new public key, delete one of the existing keys.</p>
        */
    export class TooManyPublicKeys extends __BaseException {
            readonly name: "TooManyPublicKeys";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyPublicKeys, __BaseException>);
    }
    /**
        * <p>Contains information about the Amazon Kinesis data stream where you are sending
        * 			real-time log data.</p>
        */
    export interface KinesisStreamConfig {
            /**
                * <p>The Amazon Resource Name (ARN) of an Identity and Access Management (IAM) role that
                * 			CloudFront can use to send real-time log data to your Kinesis data stream.</p>
                * 		       <p>For more information the IAM role, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-iam-role">Real-time log configuration IAM role</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            RoleARN: string | undefined;
            /**
                * <p>The Amazon Resource Name (ARN) of the Kinesis data stream where you are sending real-time
                * 			log data.</p>
                */
            StreamARN: string | undefined;
    }
    export namespace KinesisStreamConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: KinesisStreamConfig) => any;
    }
    /**
        * <p>Contains information about the Amazon Kinesis data stream where you are sending real-time
        * 			log data in a real-time log configuration.</p>
        */
    export interface EndPoint {
            /**
                * <p>The type of data stream where you are sending real-time log data. The only valid value is
                * 			<code>Kinesis</code>.</p>
                */
            StreamType: string | undefined;
            /**
                * <p>Contains information about the Amazon Kinesis data stream where you are sending
                * 			real-time log data.</p>
                */
            KinesisStreamConfig?: KinesisStreamConfig;
    }
    export namespace EndPoint {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EndPoint) => any;
    }
    export interface CreateRealtimeLogConfigRequest {
            /**
                * <p>Contains information about the Amazon Kinesis data stream where you are sending real-time
                * 			log data.</p>
                */
            EndPoints: EndPoint[] | undefined;
            /**
                * <p>A list of fields to include in each real-time log record.</p>
                * 		       <p>For more information about fields, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields">Real-time log configuration fields</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            Fields: string[] | undefined;
            /**
                * <p>A unique name to identify this real-time log configuration.</p>
                */
            Name: string | undefined;
            /**
                * <p>The sampling rate for this real-time log configuration. The sampling rate determines the
                * 			percentage of viewer requests that are represented in the real-time log data. You must
                * 			provide an integer between 1 and 100, inclusive.</p>
                */
            SamplingRate: number | undefined;
    }
    export namespace CreateRealtimeLogConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateRealtimeLogConfigRequest) => any;
    }
    /**
        * <p>A real-time log configuration.</p>
        */
    export interface RealtimeLogConfig {
            /**
                * <p>The Amazon Resource Name (ARN) of this real-time log configuration.</p>
                */
            ARN: string | undefined;
            /**
                * <p>The unique name of this real-time log configuration.</p>
                */
            Name: string | undefined;
            /**
                * <p>The sampling rate for this real-time log configuration. The sampling rate determines the
                * 			percentage of viewer requests that are represented in the real-time log data. The
                * 			sampling rate is an integer between 1 and 100, inclusive.</p>
                */
            SamplingRate: number | undefined;
            /**
                * <p>Contains information about the Amazon Kinesis data stream where you are sending real-time
                * 			log data for this real-time log configuration.</p>
                */
            EndPoints: EndPoint[] | undefined;
            /**
                * <p>A list of fields that are included in each real-time log record. In an API response, the
                * 			fields are provided in the same order in which they are sent to the Amazon Kinesis data
                * 			stream.</p>
                * 		       <p>For more information about fields, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields">Real-time log configuration fields</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            Fields: string[] | undefined;
    }
    export namespace RealtimeLogConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RealtimeLogConfig) => any;
    }
    export interface CreateRealtimeLogConfigResult {
            /**
                * <p>A real-time log configuration.</p>
                */
            RealtimeLogConfig?: RealtimeLogConfig;
    }
    export namespace CreateRealtimeLogConfigResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateRealtimeLogConfigResult) => any;
    }
    /**
        * <p>A real-time log configuration with this name already exists. You must provide a unique name.
        * 			To modify an existing real-time log configuration, use
        * 			<code>UpdateRealtimeLogConfig</code>.</p>
        */
    export class RealtimeLogConfigAlreadyExists extends __BaseException {
            readonly name: "RealtimeLogConfigAlreadyExists";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<RealtimeLogConfigAlreadyExists, __BaseException>);
    }
    /**
        * <p>You have reached the maximum number of real-time log configurations for this Amazon Web Services account.
        * 			For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class TooManyRealtimeLogConfigs extends __BaseException {
            readonly name: "TooManyRealtimeLogConfigs";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyRealtimeLogConfigs, __BaseException>);
    }
    /**
        * <p>A list of HTTP header names that CloudFront includes as values for the
        * 				<code>Access-Control-Allow-Headers</code> HTTP response header.</p>
        * 		       <p>For more information about the <code>Access-Control-Allow-Headers</code> HTTP response
        * 			header, see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers">Access-Control-Allow-Headers</a> in the MDN Web Docs.</p>
        */
    export interface ResponseHeadersPolicyAccessControlAllowHeaders {
            /**
                * <p>The number of HTTP header names in the list.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>The list of HTTP header names. You can specify <code>*</code> to allow all headers.</p>
                */
            Items: string[] | undefined;
    }
    export namespace ResponseHeadersPolicyAccessControlAllowHeaders {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseHeadersPolicyAccessControlAllowHeaders) => any;
    }
    /**
        * <p>A list of HTTP methods that CloudFront includes as values for the
        * 				<code>Access-Control-Allow-Methods</code> HTTP response header.</p>
        * 		       <p>For more information about the <code>Access-Control-Allow-Methods</code> HTTP response
        * 			header, see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods">Access-Control-Allow-Methods</a> in the MDN Web Docs.</p>
        */
    export interface ResponseHeadersPolicyAccessControlAllowMethods {
            /**
                * <p>The number of HTTP methods in the list.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>The list of HTTP methods. Valid values are:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>
                *                   <code>GET</code>
                *                </p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>DELETE</code>
                *                </p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>HEAD</code>
                *                </p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>OPTIONS</code>
                *                </p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>PATCH</code>
                *                </p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>POST</code>
                *                </p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>PUT</code>
                *                </p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>ALL</code>
                *                </p>
                * 			         </li>
                *          </ul>
                * 		       <p>
                *             <code>ALL</code> is a special value that includes all of the listed HTTP
                * 			methods.</p>
                */
            Items: (ResponseHeadersPolicyAccessControlAllowMethodsValues | string)[] | undefined;
    }
    export namespace ResponseHeadersPolicyAccessControlAllowMethods {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseHeadersPolicyAccessControlAllowMethods) => any;
    }
    /**
        * <p>A list of origins (domain names) that CloudFront can use as the value for the
        * 			<code>Access-Control-Allow-Origin</code> HTTP response header.</p>
        * 		       <p>For more information about the <code>Access-Control-Allow-Origin</code> HTTP response
        * 			header, see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin">Access-Control-Allow-Origin</a> in the MDN Web Docs.</p>
        */
    export interface ResponseHeadersPolicyAccessControlAllowOrigins {
            /**
                * <p>The number of origins in the list.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>The list of origins (domain names). You can specify <code>*</code> to allow all
                * 			origins.</p>
                */
            Items: string[] | undefined;
    }
    export namespace ResponseHeadersPolicyAccessControlAllowOrigins {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseHeadersPolicyAccessControlAllowOrigins) => any;
    }
    /**
        * <p>A list of HTTP headers that CloudFront includes as values for the
        * 				<code>Access-Control-Expose-Headers</code> HTTP response header.</p>
        * 		       <p>For more information about the <code>Access-Control-Expose-Headers</code> HTTP
        * 			response header, see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers">Access-Control-Expose-Headers</a> in the MDN Web Docs.</p>
        */
    export interface ResponseHeadersPolicyAccessControlExposeHeaders {
            /**
                * <p>The number of HTTP headers in the list.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>The list of HTTP headers. You can specify <code>*</code> to expose all headers.</p>
                */
            Items?: string[];
    }
    export namespace ResponseHeadersPolicyAccessControlExposeHeaders {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseHeadersPolicyAccessControlExposeHeaders) => any;
    }
    /**
        * <p>A configuration for a set of HTTP response headers that are used for cross-origin resource
        * 			sharing (CORS). CloudFront adds these headers to HTTP responses that it sends for CORS
        * 			requests that match a cache behavior associated with this response headers
        * 			policy.</p>
        * 		       <p>For more information about CORS, see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">Cross-Origin Resource
        * 				Sharing (CORS)</a> in the MDN Web Docs.</p>
        */
    export interface ResponseHeadersPolicyCorsConfig {
            /**
                * <p>A list of origins (domain names) that CloudFront can use as the value for the
                * 			<code>Access-Control-Allow-Origin</code> HTTP response header.</p>
                * 		       <p>For more information about the <code>Access-Control-Allow-Origin</code> HTTP response
                * 			header, see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin">Access-Control-Allow-Origin</a> in the MDN Web Docs.</p>
                */
            AccessControlAllowOrigins: ResponseHeadersPolicyAccessControlAllowOrigins | undefined;
            /**
                * <p>A list of HTTP header names that CloudFront includes as values for the
                * 				<code>Access-Control-Allow-Headers</code> HTTP response header.</p>
                * 		       <p>For more information about the <code>Access-Control-Allow-Headers</code> HTTP response
                * 			header, see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers">Access-Control-Allow-Headers</a> in the MDN Web Docs.</p>
                */
            AccessControlAllowHeaders: ResponseHeadersPolicyAccessControlAllowHeaders | undefined;
            /**
                * <p>A list of HTTP methods that CloudFront includes as values for the
                * 				<code>Access-Control-Allow-Methods</code> HTTP response header.</p>
                * 		       <p>For more information about the <code>Access-Control-Allow-Methods</code> HTTP response
                * 			header, see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods">Access-Control-Allow-Methods</a> in the MDN Web Docs.</p>
                */
            AccessControlAllowMethods: ResponseHeadersPolicyAccessControlAllowMethods | undefined;
            /**
                * <p>A Boolean that CloudFront uses as the value for the <code>Access-Control-Allow-Credentials</code>
                * 			HTTP response header.</p>
                * 		       <p>For more information about the <code>Access-Control-Allow-Credentials</code> HTTP
                * 			response header, see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials">Access-Control-Allow-Credentials</a> in the MDN Web Docs.</p>
                */
            AccessControlAllowCredentials: boolean | undefined;
            /**
                * <p>A list of HTTP headers that CloudFront includes as values for the
                * 				<code>Access-Control-Expose-Headers</code> HTTP response header.</p>
                * 		       <p>For more information about the <code>Access-Control-Expose-Headers</code> HTTP
                * 			response header, see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers">Access-Control-Expose-Headers</a> in the MDN Web Docs.</p>
                */
            AccessControlExposeHeaders?: ResponseHeadersPolicyAccessControlExposeHeaders;
            /**
                * <p>A number that CloudFront uses as the value for the <code>Access-Control-Max-Age</code> HTTP
                * 			response header.</p>
                * 		       <p>For more information about the <code>Access-Control-Max-Age</code> HTTP response
                * 			header, see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Max-Age">Access-Control-Max-Age</a> in the MDN Web Docs.</p>
                */
            AccessControlMaxAgeSec?: number;
            /**
                * <p>A Boolean that determines whether CloudFront overrides HTTP response headers received from the
                * 			origin with the ones specified in this response headers policy.</p>
                */
            OriginOverride: boolean | undefined;
    }
    export namespace ResponseHeadersPolicyCorsConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseHeadersPolicyCorsConfig) => any;
    }
    /**
        * <p>An HTTP response header name and its value. CloudFront includes this header in HTTP responses that
        * 			it sends for requests that match a cache behavior that’s associated with this response
        * 			headers policy.</p>
        */
    export interface ResponseHeadersPolicyCustomHeader {
            /**
                * <p>The HTTP response header name.</p>
                */
            Header: string | undefined;
            /**
                * <p>The value for the HTTP response header.</p>
                */
            Value: string | undefined;
            /**
                * <p>A Boolean that determines whether CloudFront overrides a response header with the same name
                * 			received from the origin with the header specified here.</p>
                */
            Override: boolean | undefined;
    }
    export namespace ResponseHeadersPolicyCustomHeader {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseHeadersPolicyCustomHeader) => any;
    }
    /**
        * <p>A list of HTTP response header names and their values. CloudFront includes these headers in HTTP
        * 			responses that it sends for requests that match a cache behavior that’s associated with
        * 			this response headers policy.</p>
        */
    export interface ResponseHeadersPolicyCustomHeadersConfig {
            /**
                * <p>The number of HTTP response headers in the list.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>The list of HTTP response headers and their values.</p>
                */
            Items?: ResponseHeadersPolicyCustomHeader[];
    }
    export namespace ResponseHeadersPolicyCustomHeadersConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseHeadersPolicyCustomHeadersConfig) => any;
    }
    /**
        * <p>The policy directives and their values that CloudFront includes as values for the
        * 				<code>Content-Security-Policy</code> HTTP response header.</p>
        * 		       <p>For more information about the <code>Content-Security-Policy</code> HTTP response
        * 			header, see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy">Content-Security-Policy</a> in the MDN Web Docs.</p>
        */
    export interface ResponseHeadersPolicyContentSecurityPolicy {
            /**
                * <p>A Boolean that determines whether CloudFront overrides the <code>Content-Security-Policy</code>
                * 			HTTP response header received from the origin with the one specified in this response
                * 			headers policy.</p>
                */
            Override: boolean | undefined;
            /**
                * <p>The policy directives and their values that CloudFront includes as values for the
                * 				<code>Content-Security-Policy</code> HTTP response header.</p>
                */
            ContentSecurityPolicy: string | undefined;
    }
    export namespace ResponseHeadersPolicyContentSecurityPolicy {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseHeadersPolicyContentSecurityPolicy) => any;
    }
    /**
        * <p>Determines whether CloudFront includes the <code>X-Content-Type-Options</code> HTTP response
        * 			header with its value set to <code>nosniff</code>.</p>
        * 		       <p>For more information about the <code>X-Content-Type-Options</code> HTTP response
        * 			header, see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options">X-Content-Type-Options</a> in the MDN Web Docs.</p>
        */
    export interface ResponseHeadersPolicyContentTypeOptions {
            /**
                * <p>A Boolean that determines whether CloudFront overrides the <code>X-Content-Type-Options</code>
                * 			HTTP response header received from the origin with the one specified in this response
                * 			headers policy.</p>
                */
            Override: boolean | undefined;
    }
    export namespace ResponseHeadersPolicyContentTypeOptions {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseHeadersPolicyContentTypeOptions) => any;
    }
    export enum FrameOptionsList {
            DENY = "DENY",
            SAMEORIGIN = "SAMEORIGIN"
    }
    /**
        * <p>Determines whether CloudFront includes the <code>X-Frame-Options</code> HTTP response header and
        * 			the header’s value.</p>
        * 		       <p>For more information about the <code>X-Frame-Options</code> HTTP response header, see
        * 				<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options">X-Frame-Options</a> in the MDN Web Docs.</p>
        */
    export interface ResponseHeadersPolicyFrameOptions {
            /**
                * <p>A Boolean that determines whether CloudFront overrides the <code>X-Frame-Options</code> HTTP
                * 			response header received from the origin with the one specified in this response headers
                * 			policy.</p>
                */
            Override: boolean | undefined;
            /**
                * <p>The value of the <code>X-Frame-Options</code> HTTP response header. Valid values are
                * 				<code>DENY</code> and <code>SAMEORIGIN</code>. </p>
                * 		       <p>For more information about these values, see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options">X-Frame-Options</a> in the MDN Web Docs.</p>
                */
            FrameOption: FrameOptionsList | string | undefined;
    }
    export namespace ResponseHeadersPolicyFrameOptions {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseHeadersPolicyFrameOptions) => any;
    }
    export enum ReferrerPolicyList {
            no_referrer = "no-referrer",
            no_referrer_when_downgrade = "no-referrer-when-downgrade",
            origin = "origin",
            origin_when_cross_origin = "origin-when-cross-origin",
            same_origin = "same-origin",
            strict_origin = "strict-origin",
            strict_origin_when_cross_origin = "strict-origin-when-cross-origin",
            unsafe_url = "unsafe-url"
    }
    /**
        * <p>Determines whether CloudFront includes the <code>Referrer-Policy</code> HTTP response header and
        * 			the header’s value.</p>
        * 		       <p>For more information about the <code>Referrer-Policy</code> HTTP response header, see
        * 				<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy">Referrer-Policy</a> in the MDN Web Docs.</p>
        */
    export interface ResponseHeadersPolicyReferrerPolicy {
            /**
                * <p>A Boolean that determines whether CloudFront overrides the <code>Referrer-Policy</code> HTTP
                * 			response header received from the origin with the one specified in this response headers
                * 			policy.</p>
                */
            Override: boolean | undefined;
            /**
                * <p>The value of the <code>Referrer-Policy</code> HTTP response header. Valid values
                * 			are:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>
                *                   <code>no-referrer</code>
                *                </p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>no-referrer-when-downgrade</code>
                *                </p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>origin</code>
                *                </p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>origin-when-cross-origin</code>
                *                </p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>same-origin</code>
                *                </p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>strict-origin</code>
                *                </p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>strict-origin-when-cross-origin</code>
                *                </p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>unsafe-url</code>
                *                </p>
                * 			         </li>
                *          </ul>
                * 		       <p>For more information about these values, see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy">Referrer-Policy</a> in the MDN Web Docs.</p>
                */
            ReferrerPolicy: ReferrerPolicyList | string | undefined;
    }
    export namespace ResponseHeadersPolicyReferrerPolicy {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseHeadersPolicyReferrerPolicy) => any;
    }
    /**
        * <p>Determines whether CloudFront includes the <code>Strict-Transport-Security</code> HTTP response
        * 			header and the header’s value.</p>
        * 		       <p>For more information about the <code>Strict-Transport-Security</code> HTTP response
        * 			header, see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security">Strict-Transport-Security</a> in the MDN Web Docs.</p>
        */
    export interface ResponseHeadersPolicyStrictTransportSecurity {
            /**
                * <p>A Boolean that determines whether CloudFront overrides the <code>Strict-Transport-Security</code>
                * 			HTTP response header received from the origin with the one specified in this response
                * 			headers policy.</p>
                */
            Override: boolean | undefined;
            /**
                * <p>A Boolean that determines whether CloudFront includes the <code>includeSubDomains</code> directive
                * 			in the <code>Strict-Transport-Security</code> HTTP response header.</p>
                */
            IncludeSubdomains?: boolean;
            /**
                * <p>A Boolean that determines whether CloudFront includes the <code>preload</code> directive in the
                * 			<code>Strict-Transport-Security</code> HTTP response header.</p>
                */
            Preload?: boolean;
            /**
                * <p>A number that CloudFront uses as the value for the <code>max-age</code> directive in the
                * 				<code>Strict-Transport-Security</code> HTTP response header.</p>
                */
            AccessControlMaxAgeSec: number | undefined;
    }
    export namespace ResponseHeadersPolicyStrictTransportSecurity {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseHeadersPolicyStrictTransportSecurity) => any;
    }
    /**
        * <p>Determines whether CloudFront includes the <code>X-XSS-Protection</code> HTTP response header and
        * 			the header’s value.</p>
        * 		       <p>For more information about the <code>X-XSS-Protection</code> HTTP response header, see
        * 				<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection">X-XSS-Protection</a> in the MDN Web Docs.</p>
        */
    export interface ResponseHeadersPolicyXSSProtection {
            /**
                * <p>A Boolean that determines whether CloudFront overrides the <code>X-XSS-Protection</code> HTTP
                * 			response header received from the origin with the one specified in this response headers
                * 			policy.</p>
                */
            Override: boolean | undefined;
            /**
                * <p>A Boolean that determines the value of the <code>X-XSS-Protection</code> HTTP response
                * 			header. When this setting is <code>true</code>, the value of the
                * 			<code>X-XSS-Protection</code> header is <code>1</code>. When this setting is
                * 			<code>false</code>, the value of the <code>X-XSS-Protection</code> header is
                * 			<code>0</code>.</p>
                * 		       <p>For more information about these settings, see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection">X-XSS-Protection</a> in the MDN Web Docs.</p>
                */
            Protection: boolean | undefined;
            /**
                * <p>A Boolean that determines whether CloudFront includes the <code>mode=block</code> directive in the
                * 			<code>X-XSS-Protection</code> header.</p>
                * 		       <p>For more information about this directive, see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection">X-XSS-Protection</a> in the MDN Web Docs.</p>
                */
            ModeBlock?: boolean;
            /**
                * <p>A reporting URI, which CloudFront uses as the value of the <code>report</code> directive in the
                * 			<code>X-XSS-Protection</code> header.</p>
                * 		       <p>You cannot specify a <code>ReportUri</code> when <code>ModeBlock</code> is
                * 			<code>true</code>.</p>
                * 		       <p>For more information about using a reporting URL, see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection">X-XSS-Protection</a> in the MDN Web Docs.</p>
                */
            ReportUri?: string;
    }
    export namespace ResponseHeadersPolicyXSSProtection {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseHeadersPolicyXSSProtection) => any;
    }
    /**
        * <p>A configuration for a set of security-related HTTP response headers. CloudFront adds these headers
        * 			to HTTP responses that it sends for requests that match a cache behavior associated with
        * 			this response headers policy.</p>
        */
    export interface ResponseHeadersPolicySecurityHeadersConfig {
            /**
                * <p>Determines whether CloudFront includes the <code>X-XSS-Protection</code> HTTP response header and
                * 			the header’s value.</p>
                * 		       <p>For more information about the <code>X-XSS-Protection</code> HTTP response header, see
                * 			<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection">X-XSS-Protection</a> in the MDN Web Docs.</p>
                */
            XSSProtection?: ResponseHeadersPolicyXSSProtection;
            /**
                * <p>Determines whether CloudFront includes the <code>X-Frame-Options</code> HTTP response header and
                * 			the header’s value.</p>
                * 		       <p>For more information about the <code>X-Frame-Options</code> HTTP response header, see
                * 			<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options">X-Frame-Options</a> in the MDN Web Docs.</p>
                */
            FrameOptions?: ResponseHeadersPolicyFrameOptions;
            /**
                * <p>Determines whether CloudFront includes the <code>Referrer-Policy</code> HTTP response header and
                * 			the header’s value.</p>
                * 		       <p>For more information about the <code>Referrer-Policy</code> HTTP response header, see
                * 			<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy">Referrer-Policy</a> in the MDN Web Docs.</p>
                */
            ReferrerPolicy?: ResponseHeadersPolicyReferrerPolicy;
            /**
                * <p>The policy directives and their values that CloudFront includes as values for the
                * 				<code>Content-Security-Policy</code> HTTP response header.</p>
                * 		       <p>For more information about the <code>Content-Security-Policy</code> HTTP response
                * 			header, see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy">Content-Security-Policy</a> in the MDN Web Docs.</p>
                */
            ContentSecurityPolicy?: ResponseHeadersPolicyContentSecurityPolicy;
            /**
                * <p>Determines whether CloudFront includes the <code>X-Content-Type-Options</code> HTTP response
                * 			header with its value set to <code>nosniff</code>.</p>
                * 		       <p>For more information about the <code>X-Content-Type-Options</code> HTTP response
                * 			header, see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options">X-Content-Type-Options</a> in the MDN Web Docs.</p>
                */
            ContentTypeOptions?: ResponseHeadersPolicyContentTypeOptions;
            /**
                * <p>Determines whether CloudFront includes the <code>Strict-Transport-Security</code> HTTP response
                * 			header and the header’s value.</p>
                * 		       <p>For more information about the <code>Strict-Transport-Security</code> HTTP response
                * 			header, see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security">Strict-Transport-Security</a> in the MDN Web Docs.</p>
                */
            StrictTransportSecurity?: ResponseHeadersPolicyStrictTransportSecurity;
    }
    export namespace ResponseHeadersPolicySecurityHeadersConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseHeadersPolicySecurityHeadersConfig) => any;
    }
    /**
        * <p>A configuration for enabling the <code>Server-Timing</code> header in HTTP responses sent
        * 			from CloudFront. CloudFront adds this header to HTTP responses that it sends in response to requests
        * 			that match a cache behavior that's associated with this response headers policy.</p>
        * 		       <p>You can use the <code>Server-Timing</code> header to view metrics that can help you gain
        * 			insights about the behavior and performance of CloudFront. For example, you can see which
        * 			cache layer served a cache hit, or the first byte latency from the origin when there was
        * 			a cache miss. You can use the metrics in the <code>Server-Timing</code> header to
        * 			troubleshoot issues or test the efficiency of your CloudFront configuration. For more
        * 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/understanding-response-headers-policies.html#server-timing-header">Server-Timing header</a> in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export interface ResponseHeadersPolicyServerTimingHeadersConfig {
            /**
                * <p>A Boolean that determines whether CloudFront adds the <code>Server-Timing</code> header to HTTP
                * 			responses that it sends in response to requests that match a cache behavior that's
                * 			associated with this response headers policy.</p>
                */
            Enabled: boolean | undefined;
            /**
                * <p>A number 0–100 (inclusive) that specifies the percentage of responses that you want CloudFront to
                * 			add the <code>Server-Timing</code> header to. When you set the sampling rate to 100,
                * 			CloudFront adds the <code>Server-Timing</code> header to the HTTP response for every request
                * 			that matches the cache behavior that this response headers policy is attached to. When
                * 			you set it to 50, CloudFront adds the header to 50% of the responses for requests that match
                * 			the cache behavior. You can set the sampling rate to any number 0–100 with up to four
                * 			decimal places.</p>
                */
            SamplingRate?: number;
    }
    export namespace ResponseHeadersPolicyServerTimingHeadersConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseHeadersPolicyServerTimingHeadersConfig) => any;
    }
    /**
        * <p>A response headers policy configuration.</p>
        * 		       <p>A response headers policy configuration contains metadata about the response headers policy,
        * 			and configurations for sets of HTTP response headers and their values. CloudFront adds the
        * 			headers in the policy to HTTP responses that it sends for requests that match a cache
        * 			behavior associated with the policy.</p>
        */
    export interface ResponseHeadersPolicyConfig {
            /**
                * <p>A comment to describe the response headers policy.</p>
                * 		       <p>The comment cannot be longer than 128 characters.</p>
                */
            Comment?: string;
            /**
                * <p>A name to identify the response headers policy.</p>
                * 		       <p>The name must be unique for response headers policies in this Amazon Web Services account.</p>
                */
            Name: string | undefined;
            /**
                * <p>A configuration for a set of HTTP response headers that are used for cross-origin
                * 			resource sharing (CORS).</p>
                */
            CorsConfig?: ResponseHeadersPolicyCorsConfig;
            /**
                * <p>A configuration for a set of security-related HTTP response headers.</p>
                */
            SecurityHeadersConfig?: ResponseHeadersPolicySecurityHeadersConfig;
            /**
                * <p>A configuration for a set of custom HTTP response headers.</p>
                */
            CustomHeadersConfig?: ResponseHeadersPolicyCustomHeadersConfig;
            /**
                * <p>A configuration for enabling the <code>Server-Timing</code> header in HTTP responses
                * 			sent from CloudFront.</p>
                */
            ServerTimingHeadersConfig?: ResponseHeadersPolicyServerTimingHeadersConfig;
    }
    export namespace ResponseHeadersPolicyConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseHeadersPolicyConfig) => any;
    }
    export interface CreateResponseHeadersPolicyRequest {
            /**
                * <p>Contains metadata about the response headers policy, and a set of configurations that
                * 			specify the response headers.</p>
                */
            ResponseHeadersPolicyConfig: ResponseHeadersPolicyConfig | undefined;
    }
    export namespace CreateResponseHeadersPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateResponseHeadersPolicyRequest) => any;
    }
    /**
        * <p>A response headers policy.</p>
        * 		       <p>A response headers policy contains information about a set of HTTP response headers
        * 			and their values.</p>
        * 		       <p>After you create a response headers policy, you can use its ID to attach it to one or more
        * 			cache behaviors in a CloudFront distribution. When it’s attached to a cache behavior, CloudFront
        * 			adds the headers in the policy to HTTP responses that it sends for requests that match
        * 			the cache behavior.</p>
        * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/adding-response-headers.html">Adding HTTP headers to CloudFront responses</a> in the
        * 			<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export interface ResponseHeadersPolicy {
            /**
                * <p>The identifier for the response headers policy.</p>
                */
            Id: string | undefined;
            /**
                * <p>The date and time when the response headers policy was last modified.</p>
                */
            LastModifiedTime: Date | undefined;
            /**
                * <p>A response headers policy configuration.</p>
                * 		       <p>A response headers policy contains information about a set of HTTP response headers and
                * 			their values. CloudFront adds the headers in the policy to HTTP responses that it sends for
                * 			requests that match a cache behavior that’s associated with the policy.</p>
                */
            ResponseHeadersPolicyConfig: ResponseHeadersPolicyConfig | undefined;
    }
    export namespace ResponseHeadersPolicy {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseHeadersPolicy) => any;
    }
    export interface CreateResponseHeadersPolicyResult {
            /**
                * <p>Contains a response headers policy.</p>
                */
            ResponseHeadersPolicy?: ResponseHeadersPolicy;
            /**
                * <p>The URL of the response headers policy.</p>
                */
            Location?: string;
            /**
                * <p>The version identifier for the current version of the response headers policy.</p>
                */
            ETag?: string;
    }
    export namespace CreateResponseHeadersPolicyResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateResponseHeadersPolicyResult) => any;
    }
    /**
        * <p>A response headers policy with this name already exists. You must provide a unique name. To
        * 			modify an existing response headers policy, use
        * 			<code>UpdateResponseHeadersPolicy</code>.</p>
        */
    export class ResponseHeadersPolicyAlreadyExists extends __BaseException {
            readonly name: "ResponseHeadersPolicyAlreadyExists";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResponseHeadersPolicyAlreadyExists, __BaseException>);
    }
    /**
        * <p>The length of the <code>Content-Security-Policy</code> header value in the response headers
        * 			policy exceeds the maximum.</p>
        * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 				<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class TooLongCSPInResponseHeadersPolicy extends __BaseException {
            readonly name: "TooLongCSPInResponseHeadersPolicy";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooLongCSPInResponseHeadersPolicy, __BaseException>);
    }
    /**
        * <p>The number of custom headers in the response headers policy exceeds the maximum.</p>
        * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 				<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class TooManyCustomHeadersInResponseHeadersPolicy extends __BaseException {
            readonly name: "TooManyCustomHeadersInResponseHeadersPolicy";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyCustomHeadersInResponseHeadersPolicy, __BaseException>);
    }
    /**
        * <p>You have reached the maximum number of response headers policies for this
        * 			Amazon Web Services account.</p>
        * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
        * 				<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export class TooManyResponseHeadersPolicies extends __BaseException {
            readonly name: "TooManyResponseHeadersPolicies";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyResponseHeadersPolicies, __BaseException>);
    }
    /**
        * <p>A complex type that controls whether access logs are written for this streaming distribution.</p>
        */
    export interface StreamingLoggingConfig {
            /**
                * <p>Specifies whether you want CloudFront to save access logs to an Amazon S3 bucket. If you don't
                * 			want to enable logging when you create a streaming distribution or if you want to disable
                * 			logging for an existing streaming distribution, specify <code>false</code> for
                * 				<code>Enabled</code>, and specify <code>empty Bucket</code> and <code>Prefix</code>
                * 			elements. If you specify <code>false</code> for <code>Enabled</code> but you specify values
                * 			for <code>Bucket</code> and <code>Prefix</code>, the values are automatically deleted.
                * 		</p>
                */
            Enabled: boolean | undefined;
            /**
                * <p>The Amazon S3 bucket to store the access logs in, for example, <code>myawslogbucket.s3.amazonaws.com</code>.</p>
                */
            Bucket: string | undefined;
            /**
                * <p>An optional string that you want CloudFront to prefix to the access log filenames for this streaming distribution, for example,
                * 			<code>myprefix/</code>. If you want to enable logging, but you don't want to specify a prefix, you still must include
                * 			an empty <code>Prefix</code> element in the <code>Logging</code> element.</p>
                */
            Prefix: string | undefined;
    }
    export namespace StreamingLoggingConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StreamingLoggingConfig) => any;
    }
    /**
        * <p>A complex type that contains information about the Amazon S3 bucket from which you want
        * 			CloudFront to get your media files for distribution.</p>
        */
    export interface S3Origin {
            /**
                * <p>The DNS name of the Amazon S3 origin. </p>
                */
            DomainName: string | undefined;
            /**
                * <p>The CloudFront origin access identity to associate with the distribution. Use an origin
                * 			access identity to configure the distribution so that end users can only access objects in an
                * 			Amazon S3 bucket through CloudFront.</p>
                * 		       <p>If you want end users to be able to access objects using either the CloudFront URL or the
                * 			Amazon S3 URL, specify an empty <code>OriginAccessIdentity</code> element.</p>
                * 		       <p>To delete the origin access identity from an existing distribution, update the
                * 			distribution configuration and include an empty <code>OriginAccessIdentity</code>
                * 			element.</p>
                * 		       <p>To replace the origin access identity, update the distribution configuration and
                * 			specify the new origin access identity.</p>
                * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html">Using an Origin Access
                * 				Identity to Restrict Access to Your Amazon S3 Content</a> in the <i>
                * 				Amazon CloudFront Developer Guide</i>.</p>
                */
            OriginAccessIdentity: string | undefined;
    }
    export namespace S3Origin {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: S3Origin) => any;
    }
    /**
        * <p>The RTMP distribution's configuration information.</p>
        */
    export interface StreamingDistributionConfig {
            /**
                * <p>A unique value (for example, a date-time stamp) that ensures that the request can't be
                * 			replayed.</p>
                * 		       <p>If the value of <code>CallerReference</code> is new (regardless of the content of the
                * 			<code>StreamingDistributionConfig</code> object), CloudFront creates a new distribution.</p>
                * 		       <p>If <code>CallerReference</code> is a value that you already sent in a previous request to
                * 			create a distribution, CloudFront returns a <code>DistributionAlreadyExists</code> error.</p>
                */
            CallerReference: string | undefined;
            /**
                * <p>A complex type that contains information about the Amazon S3 bucket from which you want
                * 			CloudFront to get your media files for distribution. </p>
                */
            S3Origin: S3Origin | undefined;
            /**
                * <p>A complex type that contains information about CNAMEs (alternate domain names), if any,
                * 			for this streaming distribution. </p>
                */
            Aliases?: Aliases;
            /**
                * <p>Any comments you want to include about the streaming distribution. </p>
                */
            Comment: string | undefined;
            /**
                * <p>A complex type that controls whether access logs are written for the streaming
                * 			distribution. </p>
                */
            Logging?: StreamingLoggingConfig;
            /**
                * <p>A complex type that specifies any Amazon Web Services accounts that you want to permit to create signed
                * 			URLs for private content. If you want the distribution to use signed URLs, include this
                * 			element; if you want the distribution to use public URLs, remove this element. For more
                * 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving Private Content through
                * 				CloudFront</a> in the <i>Amazon CloudFront Developer Guide</i>. </p>
                */
            TrustedSigners: TrustedSigners | undefined;
            /**
                * <p>A complex type that contains information about price class for this streaming
                * 			distribution. </p>
                */
            PriceClass?: PriceClass | string;
            /**
                * <p>Whether the streaming distribution is enabled to accept user requests for
                * 			content.</p>
                */
            Enabled: boolean | undefined;
    }
    export namespace StreamingDistributionConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StreamingDistributionConfig) => any;
    }
    /**
        * <p>The request to create a new streaming distribution.</p>
        */
    export interface CreateStreamingDistributionRequest {
            /**
                * <p>The streaming distribution's configuration information.</p>
                */
            StreamingDistributionConfig: StreamingDistributionConfig | undefined;
    }
    export namespace CreateStreamingDistributionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateStreamingDistributionRequest) => any;
    }
    /**
        * <p>A streaming distribution tells CloudFront where you want RTMP content to be delivered from, and the details about how to
        * 			track and manage content delivery.</p>
        */
    export interface StreamingDistribution {
            /**
                * <p>The identifier for the RTMP distribution. For example:
                * 			<code>EGTXBD79EXAMPLE</code>.</p>
                */
            Id: string | undefined;
            /**
                * <p>The ARN (Amazon Resource Name) for the distribution. For example:
                * 			<code>arn:aws:cloudfront::123456789012:distribution/EDFDVBD632BHDS5</code>, where
                * 			<code>123456789012</code> is your Amazon Web Services account ID.</p>
                */
            ARN: string | undefined;
            /**
                * <p>The current status of the RTMP distribution. When the status is <code>Deployed</code>,
                * 			the distribution's information is propagated to all CloudFront edge locations.</p>
                */
            Status: string | undefined;
            /**
                * <p>The date and time that the distribution was last modified. </p>
                */
            LastModifiedTime?: Date;
            /**
                * <p>The domain name that corresponds to the streaming distribution, for example, <code>s5c39gqb8ow64r.cloudfront.net</code>. </p>
                */
            DomainName: string | undefined;
            /**
                * <p>A complex type that lists the Amazon Web Services accounts, if any, that you included in the
                * 				<code>TrustedSigners</code> complex type for this distribution. These are the accounts that
                * 			you want to allow to create signed URLs for private content.</p>
                * 		       <p>The <code>Signer</code> complex type lists the Amazon Web Services account number of the trusted
                * 			signer or <code>self</code> if the signer is the Amazon Web Services account that created the distribution.
                * 			The <code>Signer</code> element also includes the IDs of any active CloudFront key pairs that are
                * 			associated with the trusted signer's Amazon Web Services account. If no <code>KeyPairId</code> element
                * 			appears for a <code>Signer</code>, that signer can't create signed URLs.</p>
                * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving Private
                * 				Content through CloudFront</a> in the <i>Amazon CloudFront Developer Guide</i>. </p>
                */
            ActiveTrustedSigners: ActiveTrustedSigners | undefined;
            /**
                * <p>The current configuration information for the RTMP distribution.</p>
                */
            StreamingDistributionConfig: StreamingDistributionConfig | undefined;
    }
    export namespace StreamingDistribution {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StreamingDistribution) => any;
    }
    /**
        * <p>The returned result of the corresponding request.</p>
        */
    export interface CreateStreamingDistributionResult {
            /**
                * <p>The streaming distribution's information.</p>
                */
            StreamingDistribution?: StreamingDistribution;
            /**
                * <p>The fully qualified URI of the new streaming distribution resource just created.</p>
                */
            Location?: string;
            /**
                * <p>The current version of the streaming distribution created.</p>
                */
            ETag?: string;
    }
    export namespace CreateStreamingDistributionResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateStreamingDistributionResult) => any;
    }
    /**
        * <p>The caller reference you attempted to create the streaming distribution with
        * 			is associated with another distribution</p>
        */
    export class StreamingDistributionAlreadyExists extends __BaseException {
            readonly name: "StreamingDistributionAlreadyExists";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<StreamingDistributionAlreadyExists, __BaseException>);
    }
    /**
        * <p>Your request contains more CNAMEs than are allowed per distribution.</p>
        */
    export class TooManyStreamingDistributionCNAMEs extends __BaseException {
            readonly name: "TooManyStreamingDistributionCNAMEs";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyStreamingDistributionCNAMEs, __BaseException>);
    }
    /**
        * <p>Processing your request would cause you to exceed the maximum number of streaming distributions allowed.</p>
        */
    export class TooManyStreamingDistributions extends __BaseException {
            readonly name: "TooManyStreamingDistributions";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyStreamingDistributions, __BaseException>);
    }
    /**
        * <p>A streaming distribution Configuration and a list of tags to be associated with the
        * 			streaming distribution.</p>
        */
    export interface StreamingDistributionConfigWithTags {
            /**
                * <p>A streaming distribution Configuration.</p>
                */
            StreamingDistributionConfig: StreamingDistributionConfig | undefined;
            /**
                * <p>A complex type that contains zero or more <code>Tag</code> elements.</p>
                */
            Tags: Tags | undefined;
    }
    export namespace StreamingDistributionConfigWithTags {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StreamingDistributionConfigWithTags) => any;
    }
    /**
        * <p>The request to create a new streaming distribution with tags.</p>
        */
    export interface CreateStreamingDistributionWithTagsRequest {
            /**
                * <p> The streaming distribution's configuration information. </p>
                */
            StreamingDistributionConfigWithTags: StreamingDistributionConfigWithTags | undefined;
    }
    export namespace CreateStreamingDistributionWithTagsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateStreamingDistributionWithTagsRequest) => any;
    }
    /**
        * <p>The returned result of the corresponding request. </p>
        */
    export interface CreateStreamingDistributionWithTagsResult {
            /**
                * <p>The streaming distribution's information. </p>
                */
            StreamingDistribution?: StreamingDistribution;
            /**
                * <p>The fully qualified URI of the new streaming distribution resource just created.</p>
                */
            Location?: string;
            /**
                * <p>The current version of the distribution created.</p>
                */
            ETag?: string;
    }
    export namespace CreateStreamingDistributionWithTagsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateStreamingDistributionWithTagsResult) => any;
    }
    export interface DeleteCachePolicyRequest {
            /**
                * <p>The unique identifier for the cache policy that you are deleting. To get the
                * 			identifier, you can use <code>ListCachePolicies</code>.</p>
                */
            Id: string | undefined;
            /**
                * <p>The version of the cache policy that you are deleting. The version is the cache
                * 			policy’s <code>ETag</code> value, which you can get using
                * 			<code>ListCachePolicies</code>, <code>GetCachePolicy</code>, or
                * 			<code>GetCachePolicyConfig</code>.</p>
                */
            IfMatch?: string;
    }
    export namespace DeleteCachePolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteCachePolicyRequest) => any;
    }
    /**
        * <p>You cannot delete a managed policy.</p>
        */
    export class IllegalDelete extends __BaseException {
            readonly name: "IllegalDelete";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<IllegalDelete, __BaseException>);
    }
    /**
        * <p>The <code>If-Match</code> version is missing or not valid.</p>
        */
    export class InvalidIfMatchVersion extends __BaseException {
            readonly name: "InvalidIfMatchVersion";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidIfMatchVersion, __BaseException>);
    }
    /**
        * <p>The precondition in one or more of the request fields evaluated to
        * 			<code>false</code>.</p>
        */
    export class PreconditionFailed extends __BaseException {
            readonly name: "PreconditionFailed";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<PreconditionFailed, __BaseException>);
    }
    /**
        * <p>The Origin Access Identity specified is already in use.</p>
        */
    export class CloudFrontOriginAccessIdentityInUse extends __BaseException {
            readonly name: "CloudFrontOriginAccessIdentityInUse";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<CloudFrontOriginAccessIdentityInUse, __BaseException>);
    }
    /**
        * <p>Deletes a origin access identity.</p>
        */
    export interface DeleteCloudFrontOriginAccessIdentityRequest {
            /**
                * <p>The origin access identity's ID.</p>
                */
            Id: string | undefined;
            /**
                * <p>The value of the <code>ETag</code> header you received from a previous <code>GET</code>
                * 			or <code>PUT</code> request. For example: <code>E2QWRUHAPOMQZL</code>.</p>
                */
            IfMatch?: string;
    }
    export namespace DeleteCloudFrontOriginAccessIdentityRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteCloudFrontOriginAccessIdentityRequest) => any;
    }
    /**
        * <p>The specified origin access identity does not exist.</p>
        */
    export class NoSuchCloudFrontOriginAccessIdentity extends __BaseException {
            readonly name: "NoSuchCloudFrontOriginAccessIdentity";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NoSuchCloudFrontOriginAccessIdentity, __BaseException>);
    }
    /**
        * <p>This action deletes a web distribution. To delete a web distribution using the CloudFront
        * 			API, perform the following steps.</p>
        * 		       <p>
        * 			         <b>To delete a web distribution using the CloudFront API:</b>
        * 		       </p>
        * 		       <ol>
        *             <li>
        * 				           <p>Disable the web distribution </p>
        * 			         </li>
        *             <li>
        * 				           <p>Submit a <code>GET Distribution Config</code> request to get the current
        * 					configuration and the <code>Etag</code> header for the distribution.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Update the XML document that was returned in the response to your <code>GET
        * 						Distribution Config</code> request to change the value of <code>Enabled</code> to
        * 						<code>false</code>.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Submit a <code>PUT Distribution Config</code> request to update the configuration
        * 					for your distribution. In the request body, include the XML document that you updated in
        * 					Step 3. Set the value of the HTTP <code>If-Match</code> header to the value of the
        * 						<code>ETag</code> header that CloudFront returned when you submitted the <code>GET
        * 						Distribution Config</code> request in Step 2.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Review the response to the <code>PUT Distribution Config</code> request to confirm
        * 					that the distribution was successfully disabled.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Submit a <code>GET Distribution</code> request to confirm that your changes have
        * 					propagated. When propagation is complete, the value of <code>Status</code> is
        * 						<code>Deployed</code>.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Submit a <code>DELETE Distribution</code> request. Set the value of the HTTP
        * 						<code>If-Match</code> header to the value of the <code>ETag</code> header that CloudFront
        * 					returned when you submitted the <code>GET Distribution Config</code> request in Step
        * 					6.</p>
        * 			         </li>
        *             <li>
        * 				           <p>Review the response to your <code>DELETE Distribution</code> request to confirm
        * 					that the distribution was successfully deleted.</p>
        * 			         </li>
        *          </ol>
        * 		       <p>For information about deleting a distribution using the CloudFront console, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/HowToDeleteDistribution.html">Deleting a Distribution</a> in the
        * 				<i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export interface DeleteDistributionRequest {
            /**
                * <p>The distribution ID. </p>
                */
            Id: string | undefined;
            /**
                * <p>The value of the <code>ETag</code> header that you received when you disabled the
                * 			distribution. For example: <code>E2QWRUHAPOMQZL</code>. </p>
                */
            IfMatch?: string;
    }
    export namespace DeleteDistributionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteDistributionRequest) => any;
    }
    /**
        * <p>The specified CloudFront distribution is not disabled. You must disable
        * 			the distribution before you can delete it.</p>
        */
    export class DistributionNotDisabled extends __BaseException {
            readonly name: "DistributionNotDisabled";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DistributionNotDisabled, __BaseException>);
    }
    export interface DeleteFieldLevelEncryptionConfigRequest {
            /**
                * <p>The ID of the configuration you want to delete from CloudFront.</p>
                */
            Id: string | undefined;
            /**
                * <p>The value of the <code>ETag</code> header that you received when retrieving the
                * 			configuration identity to delete. For example: <code>E2QWRUHAPOMQZL</code>.</p>
                */
            IfMatch?: string;
    }
    export namespace DeleteFieldLevelEncryptionConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteFieldLevelEncryptionConfigRequest) => any;
    }
    /**
        * <p>The specified configuration for field-level encryption is in use.</p>
        */
    export class FieldLevelEncryptionConfigInUse extends __BaseException {
            readonly name: "FieldLevelEncryptionConfigInUse";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<FieldLevelEncryptionConfigInUse, __BaseException>);
    }
    export interface DeleteFieldLevelEncryptionProfileRequest {
            /**
                * <p>Request the ID of the profile you want to delete from CloudFront.</p>
                */
            Id: string | undefined;
            /**
                * <p>The value of the <code>ETag</code> header that you received when retrieving the
                * 			profile to delete. For example: <code>E2QWRUHAPOMQZL</code>.</p>
                */
            IfMatch?: string;
    }
    export namespace DeleteFieldLevelEncryptionProfileRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteFieldLevelEncryptionProfileRequest) => any;
    }
    /**
        * <p>The specified profile for field-level encryption is in use.</p>
        */
    export class FieldLevelEncryptionProfileInUse extends __BaseException {
            readonly name: "FieldLevelEncryptionProfileInUse";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<FieldLevelEncryptionProfileInUse, __BaseException>);
    }
    export interface DeleteFunctionRequest {
            /**
                * <p>The name of the function that you are deleting.</p>
                */
            Name: string | undefined;
            /**
                * <p>The current version (<code>ETag</code> value) of the function that you are deleting, which
                * 			you can get using <code>DescribeFunction</code>.</p>
                */
            IfMatch: string | undefined;
    }
    export namespace DeleteFunctionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteFunctionRequest) => any;
    }
    /**
        * <p>Cannot delete the function because it’s attached to one or more cache
        * 			behaviors.</p>
        */
    export class FunctionInUse extends __BaseException {
            readonly name: "FunctionInUse";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<FunctionInUse, __BaseException>);
    }
    /**
        * <p>The function does not exist.</p>
        */
    export class NoSuchFunctionExists extends __BaseException {
            readonly name: "NoSuchFunctionExists";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NoSuchFunctionExists, __BaseException>);
    }
    export interface DeleteKeyGroupRequest {
            /**
                * <p>The identifier of the key group that you are deleting. To get the identifier, use
                * 			<code>ListKeyGroups</code>.</p>
                */
            Id: string | undefined;
            /**
                * <p>The version of the key group that you are deleting. The version is the key group’s
                * 			<code>ETag</code> value. To get the <code>ETag</code>, use <code>GetKeyGroup</code> or
                * 			<code>GetKeyGroupConfig</code>.</p>
                */
            IfMatch?: string;
    }
    export namespace DeleteKeyGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteKeyGroupRequest) => any;
    }
    /**
        * <p>A resource that was specified is not valid.</p>
        */
    export class NoSuchResource extends __BaseException {
            readonly name: "NoSuchResource";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NoSuchResource, __BaseException>);
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_1' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { CloudFrontServiceException as __BaseException } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/CloudFrontServiceException";
    import { Aliases, AliasICPRecordal, CacheBehaviors, CachePolicy, CachePolicyConfig, CachePolicyList, CachePolicyType, CloudFrontOriginAccessIdentity, CloudFrontOriginAccessIdentityConfig, ContentTypeProfileConfig, CustomErrorResponses, DefaultCacheBehavior, Distribution, DistributionConfig, EncryptionEntities, EndPoint, FieldLevelEncryption, FieldLevelEncryptionConfig, FieldLevelEncryptionProfile, FieldLevelEncryptionProfileConfig, FunctionConfig, FunctionStage, FunctionSummary, HttpVersion, Invalidation, KeyGroup, KeyGroupConfig, MonitoringSubscription, OriginGroups, OriginRequestPolicy, OriginRequestPolicyConfig, Origins, PriceClass, PublicKey, PublicKeyConfig, QueryArgProfileConfig, RealtimeLogConfig, ResponseHeadersPolicy, ResponseHeadersPolicyConfig, Restrictions, S3Origin, StreamingDistribution, StreamingDistributionConfig, Tags, TrustedSigners, ViewerCertificate } from "@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/models_0";
    /**
        * <p>Cannot delete this resource because it is in use.</p>
        */
    export class ResourceInUse extends __BaseException {
            readonly name: "ResourceInUse";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceInUse, __BaseException>);
    }
    export interface DeleteMonitoringSubscriptionRequest {
            /**
                * <p>The ID of the distribution that you are disabling metrics for.</p>
                */
            DistributionId: string | undefined;
    }
    export namespace DeleteMonitoringSubscriptionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteMonitoringSubscriptionRequest) => any;
    }
    export interface DeleteMonitoringSubscriptionResult {
    }
    export namespace DeleteMonitoringSubscriptionResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteMonitoringSubscriptionResult) => any;
    }
    export interface DeleteOriginRequestPolicyRequest {
            /**
                * <p>The unique identifier for the origin request policy that you are deleting. To get the
                * 			identifier, you can use <code>ListOriginRequestPolicies</code>.</p>
                */
            Id: string | undefined;
            /**
                * <p>The version of the origin request policy that you are deleting. The version is the origin
                * 			request policy’s <code>ETag</code> value, which you can get using
                * 			<code>ListOriginRequestPolicies</code>, <code>GetOriginRequestPolicy</code>, or
                * 			<code>GetOriginRequestPolicyConfig</code>.</p>
                */
            IfMatch?: string;
    }
    export namespace DeleteOriginRequestPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteOriginRequestPolicyRequest) => any;
    }
    /**
        * <p>Cannot delete the origin request policy because it is attached to one or more cache
        * 			behaviors.</p>
        */
    export class OriginRequestPolicyInUse extends __BaseException {
            readonly name: "OriginRequestPolicyInUse";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<OriginRequestPolicyInUse, __BaseException>);
    }
    export interface DeletePublicKeyRequest {
            /**
                * <p>The ID of the public key you want to remove from CloudFront.</p>
                */
            Id: string | undefined;
            /**
                * <p>The value of the <code>ETag</code> header that you received when retrieving the
                * 			public key identity to delete. For example: <code>E2QWRUHAPOMQZL</code>.</p>
                */
            IfMatch?: string;
    }
    export namespace DeletePublicKeyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeletePublicKeyRequest) => any;
    }
    /**
        * <p>The specified public key is in use. </p>
        */
    export class PublicKeyInUse extends __BaseException {
            readonly name: "PublicKeyInUse";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<PublicKeyInUse, __BaseException>);
    }
    export interface DeleteRealtimeLogConfigRequest {
            /**
                * <p>The name of the real-time log configuration to delete.</p>
                */
            Name?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the real-time log configuration to delete.</p>
                */
            ARN?: string;
    }
    export namespace DeleteRealtimeLogConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteRealtimeLogConfigRequest) => any;
    }
    /**
        * <p>Cannot delete the real-time log configuration because it is attached to one or more cache
        * 			behaviors.</p>
        */
    export class RealtimeLogConfigInUse extends __BaseException {
            readonly name: "RealtimeLogConfigInUse";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<RealtimeLogConfigInUse, __BaseException>);
    }
    export interface DeleteResponseHeadersPolicyRequest {
            /**
                * <p>The identifier for the response headers policy that you are deleting.</p>
                * 		       <p>To get the identifier, you can use <code>ListResponseHeadersPolicies</code>.</p>
                */
            Id: string | undefined;
            /**
                * <p>The version of the response headers policy that you are deleting.</p>
                * 		       <p>The version is the response headers policy’s <code>ETag</code> value, which you can
                * 			get using <code>ListResponseHeadersPolicies</code>,
                * 				<code>GetResponseHeadersPolicy</code>, or
                * 				<code>GetResponseHeadersPolicyConfig</code>.</p>
                */
            IfMatch?: string;
    }
    export namespace DeleteResponseHeadersPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteResponseHeadersPolicyRequest) => any;
    }
    /**
        * <p>Cannot delete the response headers policy because it is attached to one or more cache
        * 			behaviors in a CloudFront distribution. </p>
        */
    export class ResponseHeadersPolicyInUse extends __BaseException {
            readonly name: "ResponseHeadersPolicyInUse";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResponseHeadersPolicyInUse, __BaseException>);
    }
    /**
        * <p>The request to delete a streaming distribution.</p>
        */
    export interface DeleteStreamingDistributionRequest {
            /**
                * <p>The distribution ID. </p>
                */
            Id: string | undefined;
            /**
                * <p>The value of the <code>ETag</code> header that you received when you disabled the
                * 			streaming distribution. For example: <code>E2QWRUHAPOMQZL</code>.</p>
                */
            IfMatch?: string;
    }
    export namespace DeleteStreamingDistributionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteStreamingDistributionRequest) => any;
    }
    /**
        * <p>The specified streaming distribution does not exist.</p>
        */
    export class NoSuchStreamingDistribution extends __BaseException {
            readonly name: "NoSuchStreamingDistribution";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NoSuchStreamingDistribution, __BaseException>);
    }
    /**
        * <p>The specified CloudFront distribution is not disabled. You must disable
        * 			the distribution before you can delete it.</p>
        */
    export class StreamingDistributionNotDisabled extends __BaseException {
            readonly name: "StreamingDistributionNotDisabled";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<StreamingDistributionNotDisabled, __BaseException>);
    }
    export interface DescribeFunctionRequest {
            /**
                * <p>The name of the function that you are getting information about.</p>
                */
            Name: string | undefined;
            /**
                * <p>The function’s stage, either <code>DEVELOPMENT</code> or <code>LIVE</code>.</p>
                */
            Stage?: FunctionStage | string;
    }
    export namespace DescribeFunctionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeFunctionRequest) => any;
    }
    export interface DescribeFunctionResult {
            /**
                * <p>Contains configuration information and metadata about a CloudFront function.</p>
                */
            FunctionSummary?: FunctionSummary;
            /**
                * <p>The version identifier for the current version of the CloudFront function.</p>
                */
            ETag?: string;
    }
    export namespace DescribeFunctionResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeFunctionResult) => any;
    }
    export interface GetCachePolicyRequest {
            /**
                * <p>The unique identifier for the cache policy. If the cache policy is attached to a
                * 			distribution’s cache behavior, you can get the policy’s identifier using
                * 			<code>ListDistributions</code> or <code>GetDistribution</code>. If the cache policy is
                * 			not attached to a cache behavior, you can get the identifier using
                * 			<code>ListCachePolicies</code>.</p>
                */
            Id: string | undefined;
    }
    export namespace GetCachePolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetCachePolicyRequest) => any;
    }
    export interface GetCachePolicyResult {
            /**
                * <p>The cache policy.</p>
                */
            CachePolicy?: CachePolicy;
            /**
                * <p>The current version of the cache policy.</p>
                */
            ETag?: string;
    }
    export namespace GetCachePolicyResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetCachePolicyResult) => any;
    }
    export interface GetCachePolicyConfigRequest {
            /**
                * <p>The unique identifier for the cache policy. If the cache policy is attached to a
                * 			distribution’s cache behavior, you can get the policy’s identifier using
                * 			<code>ListDistributions</code> or <code>GetDistribution</code>. If the cache policy is
                * 			not attached to a cache behavior, you can get the identifier using
                * 			<code>ListCachePolicies</code>.</p>
                */
            Id: string | undefined;
    }
    export namespace GetCachePolicyConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetCachePolicyConfigRequest) => any;
    }
    export interface GetCachePolicyConfigResult {
            /**
                * <p>The cache policy configuration.</p>
                */
            CachePolicyConfig?: CachePolicyConfig;
            /**
                * <p>The current version of the cache policy.</p>
                */
            ETag?: string;
    }
    export namespace GetCachePolicyConfigResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetCachePolicyConfigResult) => any;
    }
    /**
        * <p>The request to get an origin access identity's information.</p>
        */
    export interface GetCloudFrontOriginAccessIdentityRequest {
            /**
                * <p>The identity's ID.</p>
                */
            Id: string | undefined;
    }
    export namespace GetCloudFrontOriginAccessIdentityRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetCloudFrontOriginAccessIdentityRequest) => any;
    }
    /**
        * <p>The returned result of the corresponding request.</p>
        */
    export interface GetCloudFrontOriginAccessIdentityResult {
            /**
                * <p>The origin access identity's information.</p>
                */
            CloudFrontOriginAccessIdentity?: CloudFrontOriginAccessIdentity;
            /**
                * <p>The current version of the origin access identity's information. For example:
                * 				<code>E2QWRUHAPOMQZL</code>.</p>
                */
            ETag?: string;
    }
    export namespace GetCloudFrontOriginAccessIdentityResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetCloudFrontOriginAccessIdentityResult) => any;
    }
    /**
        * <p>The origin access identity's configuration information. For more information, see
        * 			<a href="https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_CloudFrontOriginAccessIdentityConfig.html">CloudFrontOriginAccessIdentityConfig</a>.</p>
        */
    export interface GetCloudFrontOriginAccessIdentityConfigRequest {
            /**
                * <p>The identity's ID. </p>
                */
            Id: string | undefined;
    }
    export namespace GetCloudFrontOriginAccessIdentityConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetCloudFrontOriginAccessIdentityConfigRequest) => any;
    }
    /**
        * <p>The returned result of the corresponding request.</p>
        */
    export interface GetCloudFrontOriginAccessIdentityConfigResult {
            /**
                * <p>The origin access identity's configuration information. </p>
                */
            CloudFrontOriginAccessIdentityConfig?: CloudFrontOriginAccessIdentityConfig;
            /**
                * <p>The current version of the configuration. For example:
                * 			<code>E2QWRUHAPOMQZL</code>.</p>
                */
            ETag?: string;
    }
    export namespace GetCloudFrontOriginAccessIdentityConfigResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetCloudFrontOriginAccessIdentityConfigResult) => any;
    }
    /**
        * <p>The request to get a distribution's information.</p>
        */
    export interface GetDistributionRequest {
            /**
                * <p>The distribution's ID. If the ID is empty, an empty distribution configuration is returned.</p>
                */
            Id: string | undefined;
    }
    export namespace GetDistributionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetDistributionRequest) => any;
    }
    /**
        * <p>The returned result of the corresponding request.</p>
        */
    export interface GetDistributionResult {
            /**
                * <p>The distribution's information.</p>
                */
            Distribution?: Distribution;
            /**
                * <p>The current version of the distribution's information. For example:
                * 				<code>E2QWRUHAPOMQZL</code>.</p>
                */
            ETag?: string;
    }
    export namespace GetDistributionResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetDistributionResult) => any;
    }
    /**
        * <p>The request to get a distribution configuration.</p>
        */
    export interface GetDistributionConfigRequest {
            /**
                * <p>The distribution's ID. If the ID is empty, an empty distribution configuration is returned.</p>
                */
            Id: string | undefined;
    }
    export namespace GetDistributionConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetDistributionConfigRequest) => any;
    }
    /**
        * <p>The returned result of the corresponding request.</p>
        */
    export interface GetDistributionConfigResult {
            /**
                * <p>The distribution's configuration information.</p>
                */
            DistributionConfig?: DistributionConfig;
            /**
                * <p>The current version of the configuration. For example:
                * 			<code>E2QWRUHAPOMQZL</code>.</p>
                */
            ETag?: string;
    }
    export namespace GetDistributionConfigResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetDistributionConfigResult) => any;
    }
    export interface GetFieldLevelEncryptionRequest {
            /**
                * <p>Request the ID for the field-level encryption configuration information.</p>
                */
            Id: string | undefined;
    }
    export namespace GetFieldLevelEncryptionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetFieldLevelEncryptionRequest) => any;
    }
    export interface GetFieldLevelEncryptionResult {
            /**
                * <p>Return the field-level encryption configuration information.</p>
                */
            FieldLevelEncryption?: FieldLevelEncryption;
            /**
                * <p>The current version of the field level encryption configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
                */
            ETag?: string;
    }
    export namespace GetFieldLevelEncryptionResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetFieldLevelEncryptionResult) => any;
    }
    export interface GetFieldLevelEncryptionConfigRequest {
            /**
                * <p>Request the ID for the field-level encryption configuration information.</p>
                */
            Id: string | undefined;
    }
    export namespace GetFieldLevelEncryptionConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetFieldLevelEncryptionConfigRequest) => any;
    }
    export interface GetFieldLevelEncryptionConfigResult {
            /**
                * <p>Return the field-level encryption configuration information.</p>
                */
            FieldLevelEncryptionConfig?: FieldLevelEncryptionConfig;
            /**
                * <p>The current version of the field level encryption configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
                */
            ETag?: string;
    }
    export namespace GetFieldLevelEncryptionConfigResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetFieldLevelEncryptionConfigResult) => any;
    }
    export interface GetFieldLevelEncryptionProfileRequest {
            /**
                * <p>Get the ID for the field-level encryption profile information.</p>
                */
            Id: string | undefined;
    }
    export namespace GetFieldLevelEncryptionProfileRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetFieldLevelEncryptionProfileRequest) => any;
    }
    export interface GetFieldLevelEncryptionProfileResult {
            /**
                * <p>Return the field-level encryption profile information.</p>
                */
            FieldLevelEncryptionProfile?: FieldLevelEncryptionProfile;
            /**
                * <p>The current version of the field level encryption profile. For example: <code>E2QWRUHAPOMQZL</code>.</p>
                */
            ETag?: string;
    }
    export namespace GetFieldLevelEncryptionProfileResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetFieldLevelEncryptionProfileResult) => any;
    }
    export interface GetFieldLevelEncryptionProfileConfigRequest {
            /**
                * <p>Get the ID for the field-level encryption profile configuration information.</p>
                */
            Id: string | undefined;
    }
    export namespace GetFieldLevelEncryptionProfileConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetFieldLevelEncryptionProfileConfigRequest) => any;
    }
    export interface GetFieldLevelEncryptionProfileConfigResult {
            /**
                * <p>Return the field-level encryption profile configuration information.</p>
                */
            FieldLevelEncryptionProfileConfig?: FieldLevelEncryptionProfileConfig;
            /**
                * <p>The current version of the field-level encryption profile configuration result. For example: <code>E2QWRUHAPOMQZL</code>.</p>
                */
            ETag?: string;
    }
    export namespace GetFieldLevelEncryptionProfileConfigResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetFieldLevelEncryptionProfileConfigResult) => any;
    }
    export interface GetFunctionRequest {
            /**
                * <p>The name of the function whose code you are getting.</p>
                */
            Name: string | undefined;
            /**
                * <p>The function’s stage, either <code>DEVELOPMENT</code> or <code>LIVE</code>.</p>
                */
            Stage?: FunctionStage | string;
    }
    export namespace GetFunctionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetFunctionRequest) => any;
    }
    export interface GetFunctionResult {
            /**
                * <p>The function code of a CloudFront function.</p>
                */
            FunctionCode?: Uint8Array;
            /**
                * <p>The version identifier for the current version of the CloudFront function.</p>
                */
            ETag?: string;
            /**
                * <p>The content type (media type) of the response.</p>
                */
            ContentType?: string;
    }
    export namespace GetFunctionResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetFunctionResult) => any;
    }
    /**
        * <p>The request to get an invalidation's information. </p>
        */
    export interface GetInvalidationRequest {
            /**
                * <p>The distribution's ID.</p>
                */
            DistributionId: string | undefined;
            /**
                * <p>The identifier for the invalidation request, for example,
                * 			<code>IDFDVBD632BHDS5</code>.</p>
                */
            Id: string | undefined;
    }
    export namespace GetInvalidationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetInvalidationRequest) => any;
    }
    /**
        * <p>The returned result of the corresponding request.</p>
        */
    export interface GetInvalidationResult {
            /**
                * <p>The invalidation's information. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/InvalidationDatatype.html">Invalidation Complex Type</a>. </p>
                */
            Invalidation?: Invalidation;
    }
    export namespace GetInvalidationResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetInvalidationResult) => any;
    }
    /**
        * <p>The specified invalidation does not exist.</p>
        */
    export class NoSuchInvalidation extends __BaseException {
            readonly name: "NoSuchInvalidation";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NoSuchInvalidation, __BaseException>);
    }
    export interface GetKeyGroupRequest {
            /**
                * <p>The identifier of the key group that you are getting. To get the identifier, use
                * 			<code>ListKeyGroups</code>.</p>
                */
            Id: string | undefined;
    }
    export namespace GetKeyGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetKeyGroupRequest) => any;
    }
    export interface GetKeyGroupResult {
            /**
                * <p>The key group.</p>
                */
            KeyGroup?: KeyGroup;
            /**
                * <p>The identifier for this version of the key group.</p>
                */
            ETag?: string;
    }
    export namespace GetKeyGroupResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetKeyGroupResult) => any;
    }
    export interface GetKeyGroupConfigRequest {
            /**
                * <p>The identifier of the key group whose configuration you are getting. To get the
                * 			identifier, use <code>ListKeyGroups</code>.</p>
                */
            Id: string | undefined;
    }
    export namespace GetKeyGroupConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetKeyGroupConfigRequest) => any;
    }
    export interface GetKeyGroupConfigResult {
            /**
                * <p>The key group configuration.</p>
                */
            KeyGroupConfig?: KeyGroupConfig;
            /**
                * <p>The identifier for this version of the key group.</p>
                */
            ETag?: string;
    }
    export namespace GetKeyGroupConfigResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetKeyGroupConfigResult) => any;
    }
    export interface GetMonitoringSubscriptionRequest {
            /**
                * <p>The ID of the distribution that you are getting metrics information for.</p>
                */
            DistributionId: string | undefined;
    }
    export namespace GetMonitoringSubscriptionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetMonitoringSubscriptionRequest) => any;
    }
    export interface GetMonitoringSubscriptionResult {
            /**
                * <p>A monitoring subscription. This structure contains information about whether additional
                * 			CloudWatch metrics are enabled for a given CloudFront distribution.</p>
                */
            MonitoringSubscription?: MonitoringSubscription;
    }
    export namespace GetMonitoringSubscriptionResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetMonitoringSubscriptionResult) => any;
    }
    export interface GetOriginRequestPolicyRequest {
            /**
                * <p>The unique identifier for the origin request policy. If the origin request policy is
                * 			attached to a distribution’s cache behavior, you can get the policy’s identifier using
                * 			<code>ListDistributions</code> or <code>GetDistribution</code>. If the origin request
                * 			policy is not attached to a cache behavior, you can get the identifier using
                * 			<code>ListOriginRequestPolicies</code>.</p>
                */
            Id: string | undefined;
    }
    export namespace GetOriginRequestPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetOriginRequestPolicyRequest) => any;
    }
    export interface GetOriginRequestPolicyResult {
            /**
                * <p>The origin request policy.</p>
                */
            OriginRequestPolicy?: OriginRequestPolicy;
            /**
                * <p>The current version of the origin request policy.</p>
                */
            ETag?: string;
    }
    export namespace GetOriginRequestPolicyResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetOriginRequestPolicyResult) => any;
    }
    export interface GetOriginRequestPolicyConfigRequest {
            /**
                * <p>The unique identifier for the origin request policy. If the origin request policy is
                * 			attached to a distribution’s cache behavior, you can get the policy’s identifier using
                * 			<code>ListDistributions</code> or <code>GetDistribution</code>. If the origin request
                * 			policy is not attached to a cache behavior, you can get the identifier using
                * 			<code>ListOriginRequestPolicies</code>.</p>
                */
            Id: string | undefined;
    }
    export namespace GetOriginRequestPolicyConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetOriginRequestPolicyConfigRequest) => any;
    }
    export interface GetOriginRequestPolicyConfigResult {
            /**
                * <p>The origin request policy configuration.</p>
                */
            OriginRequestPolicyConfig?: OriginRequestPolicyConfig;
            /**
                * <p>The current version of the origin request policy.</p>
                */
            ETag?: string;
    }
    export namespace GetOriginRequestPolicyConfigResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetOriginRequestPolicyConfigResult) => any;
    }
    export interface GetPublicKeyRequest {
            /**
                * <p>The identifier of the public key you are getting.</p>
                */
            Id: string | undefined;
    }
    export namespace GetPublicKeyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetPublicKeyRequest) => any;
    }
    export interface GetPublicKeyResult {
            /**
                * <p>The public key.</p>
                */
            PublicKey?: PublicKey;
            /**
                * <p>The identifier for this version of the public key.</p>
                */
            ETag?: string;
    }
    export namespace GetPublicKeyResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetPublicKeyResult) => any;
    }
    export interface GetPublicKeyConfigRequest {
            /**
                * <p>The identifier of the public key whose configuration you are getting.</p>
                */
            Id: string | undefined;
    }
    export namespace GetPublicKeyConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetPublicKeyConfigRequest) => any;
    }
    export interface GetPublicKeyConfigResult {
            /**
                * <p>A public key configuration.</p>
                */
            PublicKeyConfig?: PublicKeyConfig;
            /**
                * <p>The identifier for this version of the public key configuration.</p>
                */
            ETag?: string;
    }
    export namespace GetPublicKeyConfigResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetPublicKeyConfigResult) => any;
    }
    export interface GetRealtimeLogConfigRequest {
            /**
                * <p>The name of the real-time log configuration to get.</p>
                */
            Name?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the real-time log configuration to get.</p>
                */
            ARN?: string;
    }
    export namespace GetRealtimeLogConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetRealtimeLogConfigRequest) => any;
    }
    export interface GetRealtimeLogConfigResult {
            /**
                * <p>A real-time log configuration.</p>
                */
            RealtimeLogConfig?: RealtimeLogConfig;
    }
    export namespace GetRealtimeLogConfigResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetRealtimeLogConfigResult) => any;
    }
    export interface GetResponseHeadersPolicyRequest {
            /**
                * <p>The identifier for the response headers policy.</p>
                * 		       <p>If the response headers policy is attached to a distribution’s cache behavior, you can
                * 			get the policy’s identifier using <code>ListDistributions</code> or
                * 				<code>GetDistribution</code>. If the response headers policy is not attached to a
                * 			cache behavior, you can get the identifier using
                * 				<code>ListResponseHeadersPolicies</code>.</p>
                */
            Id: string | undefined;
    }
    export namespace GetResponseHeadersPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetResponseHeadersPolicyRequest) => any;
    }
    export interface GetResponseHeadersPolicyResult {
            /**
                * <p>Contains a response headers policy.</p>
                */
            ResponseHeadersPolicy?: ResponseHeadersPolicy;
            /**
                * <p>The version identifier for the current version of the response headers policy.</p>
                */
            ETag?: string;
    }
    export namespace GetResponseHeadersPolicyResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetResponseHeadersPolicyResult) => any;
    }
    export interface GetResponseHeadersPolicyConfigRequest {
            /**
                * <p>The identifier for the response headers policy.</p>
                * 		       <p>If the response headers policy is attached to a distribution’s cache behavior, you can
                * 			get the policy’s identifier using <code>ListDistributions</code> or
                * 				<code>GetDistribution</code>. If the response headers policy is not attached to a
                * 			cache behavior, you can get the identifier using
                * 				<code>ListResponseHeadersPolicies</code>.</p>
                */
            Id: string | undefined;
    }
    export namespace GetResponseHeadersPolicyConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetResponseHeadersPolicyConfigRequest) => any;
    }
    export interface GetResponseHeadersPolicyConfigResult {
            /**
                * <p>Contains a response headers policy.</p>
                */
            ResponseHeadersPolicyConfig?: ResponseHeadersPolicyConfig;
            /**
                * <p>The version identifier for the current version of the response headers policy.</p>
                */
            ETag?: string;
    }
    export namespace GetResponseHeadersPolicyConfigResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetResponseHeadersPolicyConfigResult) => any;
    }
    /**
        * <p>The request to get a streaming distribution's information.</p>
        */
    export interface GetStreamingDistributionRequest {
            /**
                * <p>The streaming distribution's ID.</p>
                */
            Id: string | undefined;
    }
    export namespace GetStreamingDistributionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetStreamingDistributionRequest) => any;
    }
    /**
        * <p>The returned result of the corresponding request.</p>
        */
    export interface GetStreamingDistributionResult {
            /**
                * <p>The streaming distribution's information.</p>
                */
            StreamingDistribution?: StreamingDistribution;
            /**
                * <p>The current version of the streaming distribution's information. For example:
                * 				<code>E2QWRUHAPOMQZL</code>.</p>
                */
            ETag?: string;
    }
    export namespace GetStreamingDistributionResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetStreamingDistributionResult) => any;
    }
    /**
        * <p>To request to get a streaming distribution configuration.</p>
        */
    export interface GetStreamingDistributionConfigRequest {
            /**
                * <p>The streaming distribution's ID.</p>
                */
            Id: string | undefined;
    }
    export namespace GetStreamingDistributionConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetStreamingDistributionConfigRequest) => any;
    }
    /**
        * <p>The returned result of the corresponding request.</p>
        */
    export interface GetStreamingDistributionConfigResult {
            /**
                * <p>The streaming distribution's configuration information.</p>
                */
            StreamingDistributionConfig?: StreamingDistributionConfig;
            /**
                * <p>The current version of the configuration. For example: <code>E2QWRUHAPOMQZL</code>.
                * 		</p>
                */
            ETag?: string;
    }
    export namespace GetStreamingDistributionConfigResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetStreamingDistributionConfigResult) => any;
    }
    export interface ListCachePoliciesRequest {
            /**
                * <p>A filter to return only the specified kinds of cache policies. Valid values
                * 			are:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>
                *                   <code>managed</code> – Returns only the managed policies created by Amazon Web Services.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>custom</code> – Returns only the custom policies created in your Amazon Web Services account.</p>
                * 			         </li>
                *          </ul>
                */
            Type?: CachePolicyType | string;
            /**
                * <p>Use this field when paginating results to indicate where to begin in your list of
                * 			cache policies. The response includes cache policies in the list that occur after the
                * 			marker. To get the next page of the list, set this field’s value to the value of
                * 			<code>NextMarker</code> from the current page’s response.</p>
                */
            Marker?: string;
            /**
                * <p>The maximum number of cache policies that you want in the response.</p>
                */
            MaxItems?: number;
    }
    export namespace ListCachePoliciesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListCachePoliciesRequest) => any;
    }
    export interface ListCachePoliciesResult {
            /**
                * <p>A list of cache policies.</p>
                */
            CachePolicyList?: CachePolicyList;
    }
    export namespace ListCachePoliciesResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListCachePoliciesResult) => any;
    }
    /**
        * <p>The request to list origin access identities. </p>
        */
    export interface ListCloudFrontOriginAccessIdentitiesRequest {
            /**
                * <p>Use this when paginating results to indicate where to begin in your list of origin
                * 			access identities. The results include identities in the list that occur after the marker. To
                * 			get the next page of results, set the <code>Marker</code> to the value of the
                * 				<code>NextMarker</code> from the current page's response (which is also the ID of the last
                * 			identity on that page).</p>
                */
            Marker?: string;
            /**
                * <p>The maximum number of origin access identities you want in the response body.
                * 		</p>
                */
            MaxItems?: number;
    }
    export namespace ListCloudFrontOriginAccessIdentitiesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListCloudFrontOriginAccessIdentitiesRequest) => any;
    }
    /**
        * <p>Summary of the information about a CloudFront origin access identity.</p>
        */
    export interface CloudFrontOriginAccessIdentitySummary {
            /**
                * <p>The ID for the origin access identity. For example:
                * 			<code>E74FTE3AJFJ256A</code>.</p>
                */
            Id: string | undefined;
            /**
                * <p>The Amazon S3 canonical user ID for the origin access identity, which you use when giving
                * 			the origin access identity read permission to an object in Amazon S3.</p>
                */
            S3CanonicalUserId: string | undefined;
            /**
                * <p>The comment for this origin access identity, as originally specified when
                * 			created.</p>
                */
            Comment: string | undefined;
    }
    export namespace CloudFrontOriginAccessIdentitySummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CloudFrontOriginAccessIdentitySummary) => any;
    }
    /**
        * <p>Lists the origin access identities for CloudFront.Send a <code>GET</code> request to the
        * 					<code>/<i>CloudFront API version</i>/origin-access-identity/cloudfront</code>
        * 			resource. The response includes a <code>CloudFrontOriginAccessIdentityList</code> element with
        * 			zero or more <code>CloudFrontOriginAccessIdentitySummary</code> child elements. By default,
        * 			your entire list of origin access identities is returned in one single page. If the list is
        * 			long, you can paginate it using the <code>MaxItems</code> and <code>Marker</code>
        * 			parameters.</p>
        */
    export interface CloudFrontOriginAccessIdentityList {
            /**
                * <p>Use this when paginating results to indicate where to begin in your list of origin
                * 			access identities. The results include identities in the list that occur after the marker. To
                * 			get the next page of results, set the <code>Marker</code> to the value of the
                * 				<code>NextMarker</code> from the current page's response (which is also the ID of the last
                * 			identity on that page). </p>
                */
            Marker: string | undefined;
            /**
                * <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains
                * 			the value you can use for the <code>Marker</code> request parameter to continue listing your
                * 			origin access identities where they left off. </p>
                */
            NextMarker?: string;
            /**
                * <p>The maximum number of origin access identities you want in the response body.
                * 		</p>
                */
            MaxItems: number | undefined;
            /**
                * <p>A flag that indicates whether more origin access identities remain to be listed. If
                * 			your results were truncated, you can make a follow-up pagination request using the
                * 				<code>Marker</code> request parameter to retrieve more items in the list.</p>
                */
            IsTruncated: boolean | undefined;
            /**
                * <p>The number of CloudFront origin access identities that were created by the current Amazon Web Services account.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>A complex type that contains one <code>CloudFrontOriginAccessIdentitySummary</code>
                * 			element for each origin access identity that was created by the current Amazon Web Services account.</p>
                */
            Items?: CloudFrontOriginAccessIdentitySummary[];
    }
    export namespace CloudFrontOriginAccessIdentityList {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CloudFrontOriginAccessIdentityList) => any;
    }
    /**
        * <p>The returned result of the corresponding request. </p>
        */
    export interface ListCloudFrontOriginAccessIdentitiesResult {
            /**
                * <p>The <code>CloudFrontOriginAccessIdentityList</code> type. </p>
                */
            CloudFrontOriginAccessIdentityList?: CloudFrontOriginAccessIdentityList;
    }
    export namespace ListCloudFrontOriginAccessIdentitiesResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListCloudFrontOriginAccessIdentitiesResult) => any;
    }
    export interface ListConflictingAliasesRequest {
            /**
                * <p>The ID of a distribution in your account that has an attached SSL/TLS certificate that
                * 			includes the provided alias.</p>
                */
            DistributionId: string | undefined;
            /**
                * <p>The alias (also called a CNAME) to search for conflicting aliases.</p>
                */
            Alias: string | undefined;
            /**
                * <p>Use this field when paginating results to indicate where to begin in the list of
                * 			conflicting aliases. The response includes conflicting aliases in the list that occur
                * 			after the marker. To get the next page of the list, set this field’s value to the value
                * 			of <code>NextMarker</code> from the current page’s response.</p>
                */
            Marker?: string;
            /**
                * <p>The maximum number of conflicting aliases that you want in the response.</p>
                */
            MaxItems?: number;
    }
    export namespace ListConflictingAliasesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListConflictingAliasesRequest) => any;
    }
    /**
        * <p>An alias (also called a CNAME) and the CloudFront distribution and Amazon Web Services account ID that it’s
        * 			associated with. The distribution and account IDs are partially hidden, which allows you
        * 			to identify the distributions and accounts that you own, but helps to protect the
        * 			information of ones that you don’t own.</p>
        */
    export interface ConflictingAlias {
            /**
                * <p>An alias (also called a CNAME).</p>
                */
            Alias?: string;
            /**
                * <p>The (partially hidden) ID of the CloudFront distribution associated with the alias.</p>
                */
            DistributionId?: string;
            /**
                * <p>The (partially hidden) ID of the Amazon Web Services account that owns the distribution that’s
                * 			associated with the alias.</p>
                */
            AccountId?: string;
    }
    export namespace ConflictingAlias {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ConflictingAlias) => any;
    }
    /**
        * <p>A list of aliases (also called CNAMEs) and the CloudFront distributions and Amazon Web Services accounts that
        * 			they are associated with. In the list, the distribution and account IDs are partially
        * 			hidden, which allows you to identify the distributions and accounts that you own, but
        * 			helps to protect the information of ones that you don’t own.</p>
        */
    export interface ConflictingAliasesList {
            /**
                * <p>If there are more items in the list than are in this response, this element is present. It
                * 			contains the value that you should use in the <code>Marker</code> field of a subsequent
                * 			request to continue listing conflicting aliases where you left off.</p>
                */
            NextMarker?: string;
            /**
                * <p>The maximum number of conflicting aliases requested.</p>
                */
            MaxItems?: number;
            /**
                * <p>The number of conflicting aliases returned in the response.</p>
                */
            Quantity?: number;
            /**
                * <p>Contains the conflicting aliases in the list.</p>
                */
            Items?: ConflictingAlias[];
    }
    export namespace ConflictingAliasesList {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ConflictingAliasesList) => any;
    }
    export interface ListConflictingAliasesResult {
            /**
                * <p>A list of conflicting aliases.</p>
                */
            ConflictingAliasesList?: ConflictingAliasesList;
    }
    export namespace ListConflictingAliasesResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListConflictingAliasesResult) => any;
    }
    /**
        * <p>The request to list your distributions. </p>
        */
    export interface ListDistributionsRequest {
            /**
                * <p>Use this when paginating results to indicate where to begin in your list of
                * 			distributions. The results include distributions in the list that occur after the marker. To
                * 			get the next page of results, set the <code>Marker</code> to the value of the
                * 				<code>NextMarker</code> from the current page's response (which is also the ID of the last
                * 			distribution on that page).</p>
                */
            Marker?: string;
            /**
                * <p>The maximum number of distributions you want in the response body.</p>
                */
            MaxItems?: number;
    }
    export namespace ListDistributionsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDistributionsRequest) => any;
    }
    /**
        * <p>A summary of the information about a CloudFront distribution.</p>
        */
    export interface DistributionSummary {
            /**
                * <p>The identifier for the distribution. For example:
                * 			<code>EDFDVBD632BHDS5</code>.</p>
                */
            Id: string | undefined;
            /**
                * <p>The ARN (Amazon Resource Name) for the distribution. For example:
                * 				<code>arn:aws:cloudfront::123456789012:distribution/EDFDVBD632BHDS5</code>, where
                * 				<code>123456789012</code> is your Amazon Web Services account ID.</p>
                */
            ARN: string | undefined;
            /**
                * <p>The current status of the distribution. When the status is <code>Deployed</code>, the
                * 			distribution's information is propagated to all CloudFront edge locations.</p>
                */
            Status: string | undefined;
            /**
                * <p>The date and time the distribution was last modified.</p>
                */
            LastModifiedTime: Date | undefined;
            /**
                * <p>The domain name that corresponds to the distribution, for example, <code>d111111abcdef8.cloudfront.net</code>.</p>
                */
            DomainName: string | undefined;
            /**
                * <p>A complex type that contains information about CNAMEs (alternate domain names), if any,
                * 			for this distribution.</p>
                */
            Aliases: Aliases | undefined;
            /**
                * <p>A complex type that contains information about origins for this distribution.</p>
                */
            Origins: Origins | undefined;
            /**
                * <p> A complex type that contains information about origin groups for this
                * 			distribution.</p>
                */
            OriginGroups?: OriginGroups;
            /**
                * <p>A complex type that describes the default cache behavior if you don't specify a
                * 				<code>CacheBehavior</code> element or if files don't match any of the values of
                * 				<code>PathPattern</code> in <code>CacheBehavior</code> elements. You must create exactly one
                * 			default cache behavior.</p>
                */
            DefaultCacheBehavior: DefaultCacheBehavior | undefined;
            /**
                * <p>A complex type that contains zero or more <code>CacheBehavior</code>
                * 			elements.</p>
                */
            CacheBehaviors: CacheBehaviors | undefined;
            /**
                * <p>A complex type that contains zero or more <code>CustomErrorResponses</code>
                * 			elements.</p>
                */
            CustomErrorResponses: CustomErrorResponses | undefined;
            /**
                * <p>The comment originally specified when this distribution was created.</p>
                */
            Comment: string | undefined;
            /**
                * <p>A complex type that contains information about price class for this streaming
                * 			distribution. </p>
                */
            PriceClass: PriceClass | string | undefined;
            /**
                * <p>Whether the distribution is enabled to accept user requests for content.</p>
                */
            Enabled: boolean | undefined;
            /**
                * <p>A complex type that determines the distribution’s SSL/TLS configuration for
                * 			communicating with viewers.</p>
                */
            ViewerCertificate: ViewerCertificate | undefined;
            /**
                * <p>A complex type that identifies ways in which you want to restrict distribution of your
                * 			content.</p>
                */
            Restrictions: Restrictions | undefined;
            /**
                * <p>The Web ACL Id (if any) associated with the distribution.</p>
                */
            WebACLId: string | undefined;
            /**
                * <p> Specify the maximum HTTP version that you want viewers to use to communicate with
                * 			CloudFront. The default value for new web distributions is <code>http2</code>. Viewers that don't
                * 			support <code>HTTP/2</code> will automatically use an earlier version.</p>
                */
            HttpVersion: HttpVersion | string | undefined;
            /**
                * <p>Whether CloudFront responds to IPv6 DNS requests with an IPv6 address for your
                * 			distribution.</p>
                */
            IsIPV6Enabled: boolean | undefined;
            /**
                * <p>Amazon Web Services services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content
                * 			publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP
                * 			recordal status for CNAMEs associated with distributions.</p>
                * 		       <p>For more information about ICP recordals, see  <a href="https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html">
                * 			Signup, Accounts, and Credentials</a> in <i>Getting Started with Amazon Web Services services in China</i>.</p>
                */
            AliasICPRecordals?: AliasICPRecordal[];
    }
    export namespace DistributionSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DistributionSummary) => any;
    }
    /**
        * <p>A distribution list.</p>
        */
    export interface DistributionList {
            /**
                * <p>The value you provided for the <code>Marker</code> request parameter.</p>
                */
            Marker: string | undefined;
            /**
                * <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains
                * 			the value you can use for the <code>Marker</code> request parameter to continue listing your
                * 			distributions where they left off. </p>
                */
            NextMarker?: string;
            /**
                * <p>The value you provided for the <code>MaxItems</code> request parameter.</p>
                */
            MaxItems: number | undefined;
            /**
                * <p>A flag that indicates whether more distributions remain to be listed. If your results
                * 			were truncated, you can make a follow-up pagination request using the <code>Marker</code>
                * 			request parameter to retrieve more distributions in the list.</p>
                */
            IsTruncated: boolean | undefined;
            /**
                * <p>The number of distributions that were created by the current Amazon Web Services account.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>A complex type that contains one <code>DistributionSummary</code> element for each
                * 			distribution that was created by the current Amazon Web Services account.</p>
                */
            Items?: DistributionSummary[];
    }
    export namespace DistributionList {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DistributionList) => any;
    }
    /**
        * <p>The returned result of the corresponding request. </p>
        */
    export interface ListDistributionsResult {
            /**
                * <p>The <code>DistributionList</code> type. </p>
                */
            DistributionList?: DistributionList;
    }
    export namespace ListDistributionsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDistributionsResult) => any;
    }
    export interface ListDistributionsByCachePolicyIdRequest {
            /**
                * <p>Use this field when paginating results to indicate where to begin in your list of
                * 			distribution IDs. The response includes distribution IDs in the list that occur after
                * 			the marker. To get the next page of the list, set this field’s value to the value of
                * 			<code>NextMarker</code> from the current page’s response.</p>
                */
            Marker?: string;
            /**
                * <p>The maximum number of distribution IDs that you want in the response.</p>
                */
            MaxItems?: number;
            /**
                * <p>The ID of the cache policy whose associated distribution IDs you want to list.</p>
                */
            CachePolicyId: string | undefined;
    }
    export namespace ListDistributionsByCachePolicyIdRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDistributionsByCachePolicyIdRequest) => any;
    }
    /**
        * <p>A list of distribution IDs.</p>
        */
    export interface DistributionIdList {
            /**
                * <p>The value provided in the <code>Marker</code> request field.</p>
                */
            Marker: string | undefined;
            /**
                * <p>Contains the value that you should use in the <code>Marker</code> field of a
                * 			subsequent request to continue listing distribution IDs where you left off.</p>
                */
            NextMarker?: string;
            /**
                * <p>The maximum number of distribution IDs requested.</p>
                */
            MaxItems: number | undefined;
            /**
                * <p>A flag that indicates whether more distribution IDs remain to be listed. If your
                * 			results were truncated, you can make a subsequent request using the <code>Marker</code>
                * 			request field to retrieve more distribution IDs in the list.</p>
                */
            IsTruncated: boolean | undefined;
            /**
                * <p>The total number of distribution IDs returned in the response.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>Contains the distribution IDs in the list.</p>
                */
            Items?: string[];
    }
    export namespace DistributionIdList {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DistributionIdList) => any;
    }
    export interface ListDistributionsByCachePolicyIdResult {
            /**
                * <p>A list of distribution IDs.</p>
                */
            DistributionIdList?: DistributionIdList;
    }
    export namespace ListDistributionsByCachePolicyIdResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDistributionsByCachePolicyIdResult) => any;
    }
    export interface ListDistributionsByKeyGroupRequest {
            /**
                * <p>Use this field when paginating results to indicate where to begin in your list of
                * 			distribution IDs. The response includes distribution IDs in the list that occur after
                * 			the marker. To get the next page of the list, set this field’s value to the value of
                * 			<code>NextMarker</code> from the current page’s response.</p>
                */
            Marker?: string;
            /**
                * <p>The maximum number of distribution IDs that you want in the response.</p>
                */
            MaxItems?: number;
            /**
                * <p>The ID of the key group whose associated distribution IDs you are listing.</p>
                */
            KeyGroupId: string | undefined;
    }
    export namespace ListDistributionsByKeyGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDistributionsByKeyGroupRequest) => any;
    }
    export interface ListDistributionsByKeyGroupResult {
            /**
                * <p>A list of distribution IDs.</p>
                */
            DistributionIdList?: DistributionIdList;
    }
    export namespace ListDistributionsByKeyGroupResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDistributionsByKeyGroupResult) => any;
    }
    export interface ListDistributionsByOriginRequestPolicyIdRequest {
            /**
                * <p>Use this field when paginating results to indicate where to begin in your list of
                * 			distribution IDs. The response includes distribution IDs in the list that occur after
                * 			the marker. To get the next page of the list, set this field’s value to the value of
                * 			<code>NextMarker</code> from the current page’s response.</p>
                */
            Marker?: string;
            /**
                * <p>The maximum number of distribution IDs that you want in the response.</p>
                */
            MaxItems?: number;
            /**
                * <p>The ID of the origin request policy whose associated distribution IDs you want to
                * 			list.</p>
                */
            OriginRequestPolicyId: string | undefined;
    }
    export namespace ListDistributionsByOriginRequestPolicyIdRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDistributionsByOriginRequestPolicyIdRequest) => any;
    }
    export interface ListDistributionsByOriginRequestPolicyIdResult {
            /**
                * <p>A list of distribution IDs.</p>
                */
            DistributionIdList?: DistributionIdList;
    }
    export namespace ListDistributionsByOriginRequestPolicyIdResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDistributionsByOriginRequestPolicyIdResult) => any;
    }
    export interface ListDistributionsByRealtimeLogConfigRequest {
            /**
                * <p>Use this field when paginating results to indicate where to begin in your list of
                * 			distributions. The response includes distributions in the list that occur after the
                * 			marker. To get the next page of the list, set this field’s value to the value of
                * 			<code>NextMarker</code> from the current page’s response.</p>
                */
            Marker?: string;
            /**
                * <p>The maximum number of distributions that you want in the response.</p>
                */
            MaxItems?: number;
            /**
                * <p>The name of the real-time log configuration whose associated distributions you want to
                * 			list.</p>
                */
            RealtimeLogConfigName?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the real-time log configuration whose associated
                * 			distributions you want to list.</p>
                */
            RealtimeLogConfigArn?: string;
    }
    export namespace ListDistributionsByRealtimeLogConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDistributionsByRealtimeLogConfigRequest) => any;
    }
    export interface ListDistributionsByRealtimeLogConfigResult {
            /**
                * <p>A distribution list.</p>
                */
            DistributionList?: DistributionList;
    }
    export namespace ListDistributionsByRealtimeLogConfigResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDistributionsByRealtimeLogConfigResult) => any;
    }
    export interface ListDistributionsByResponseHeadersPolicyIdRequest {
            /**
                * <p>Use this field when paginating results to indicate where to begin in your list of
                * 			distribution IDs. The response includes distribution IDs in the list that occur after
                * 			the marker. To get the next page of the list, set this field’s value to the value of
                * 				<code>NextMarker</code> from the current page’s response.</p>
                */
            Marker?: string;
            /**
                * <p>The maximum number of distribution IDs that you want to get in the response.</p>
                */
            MaxItems?: number;
            /**
                * <p>The ID of the response headers policy whose associated distribution IDs you want to
                * 			list.</p>
                */
            ResponseHeadersPolicyId: string | undefined;
    }
    export namespace ListDistributionsByResponseHeadersPolicyIdRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDistributionsByResponseHeadersPolicyIdRequest) => any;
    }
    export interface ListDistributionsByResponseHeadersPolicyIdResult {
            /**
                * <p>A list of distribution IDs.</p>
                */
            DistributionIdList?: DistributionIdList;
    }
    export namespace ListDistributionsByResponseHeadersPolicyIdResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDistributionsByResponseHeadersPolicyIdResult) => any;
    }
    /**
        * <p>The request to list distributions that are associated with a specified WAF web
        * 			ACL.</p>
        */
    export interface ListDistributionsByWebACLIdRequest {
            /**
                * <p>Use <code>Marker</code> and <code>MaxItems</code> to control pagination of results. If
                * 			you have more than <code>MaxItems</code> distributions that satisfy the request, the response
                * 			includes a <code>NextMarker</code> element. To get the next page of results, submit another
                * 			request. For the value of <code>Marker</code>, specify the value of <code>NextMarker</code>
                * 			from the last response. (For the first request, omit <code>Marker</code>.) </p>
                */
            Marker?: string;
            /**
                * <p>The maximum number of distributions that you want CloudFront to return in the response body.
                * 			The maximum and default values are both 100.</p>
                */
            MaxItems?: number;
            /**
                * <p>The ID of the WAF web ACL that you want to list the associated distributions.
                * 			If you specify "null" for the ID, the request returns a list of the distributions that aren't
                * 			associated with a web ACL.</p>
                */
            WebACLId: string | undefined;
    }
    export namespace ListDistributionsByWebACLIdRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDistributionsByWebACLIdRequest) => any;
    }
    /**
        * <p>The response to a request to list the distributions that are associated with a
        * 			specified WAF web ACL.</p>
        */
    export interface ListDistributionsByWebACLIdResult {
            /**
                * <p>The <code>DistributionList</code> type. </p>
                */
            DistributionList?: DistributionList;
    }
    export namespace ListDistributionsByWebACLIdResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDistributionsByWebACLIdResult) => any;
    }
    export interface ListFieldLevelEncryptionConfigsRequest {
            /**
                * <p>Use this when paginating results to indicate where to begin in your list of configurations. The results include configurations in the list that
                * 			occur after the marker. To get the next page of results, set the <code>Marker</code> to the value of the
                * 			<code>NextMarker</code> from the current page's response (which is also the ID of the last configuration on that page). </p>
                */
            Marker?: string;
            /**
                * <p>The maximum number of field-level encryption configurations you want in the response body. </p>
                */
            MaxItems?: number;
    }
    export namespace ListFieldLevelEncryptionConfigsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListFieldLevelEncryptionConfigsRequest) => any;
    }
    /**
        * <p>A summary of a field-level encryption item.</p>
        */
    export interface FieldLevelEncryptionSummary {
            /**
                * <p>The unique ID of a field-level encryption item.</p>
                */
            Id: string | undefined;
            /**
                * <p>The last time that the summary of field-level encryption items was modified.</p>
                */
            LastModifiedTime: Date | undefined;
            /**
                * <p>An optional comment about the field-level encryption item. The comment cannot be longer than
                * 			128 characters.</p>
                */
            Comment?: string;
            /**
                * <p>
                * 			A summary of a query argument-profile mapping.
                * 		</p>
                */
            QueryArgProfileConfig?: QueryArgProfileConfig;
            /**
                * <p>
                * 			A summary of a content type-profile mapping.
                * 		</p>
                */
            ContentTypeProfileConfig?: ContentTypeProfileConfig;
    }
    export namespace FieldLevelEncryptionSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FieldLevelEncryptionSummary) => any;
    }
    /**
        * <p>List of field-level encrpytion configurations.</p>
        */
    export interface FieldLevelEncryptionList {
            /**
                * <p>If there are more elements to be listed, this element is present and contains
                * 			the value that you can use for the <code>Marker</code> request parameter to continue
                * 			listing your configurations where you left off.</p>
                */
            NextMarker?: string;
            /**
                * <p>The maximum number of elements you want in the response body. </p>
                */
            MaxItems: number | undefined;
            /**
                * <p>The number of field-level encryption items.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>An array of field-level encryption items.</p>
                */
            Items?: FieldLevelEncryptionSummary[];
    }
    export namespace FieldLevelEncryptionList {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FieldLevelEncryptionList) => any;
    }
    export interface ListFieldLevelEncryptionConfigsResult {
            /**
                * <p>Returns a list of all field-level encryption configurations that have been created in CloudFront for this account.</p>
                */
            FieldLevelEncryptionList?: FieldLevelEncryptionList;
    }
    export namespace ListFieldLevelEncryptionConfigsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListFieldLevelEncryptionConfigsResult) => any;
    }
    export interface ListFieldLevelEncryptionProfilesRequest {
            /**
                * <p>Use this when paginating results to indicate where to begin in your list of profiles. The results include profiles in the list that
                * 			occur after the marker. To get the next page of results, set the <code>Marker</code> to the value of the
                * 			<code>NextMarker</code> from the current page's response (which is also the ID of the last profile on that page). </p>
                */
            Marker?: string;
            /**
                * <p>The maximum number of field-level encryption profiles you want in the response body. </p>
                */
            MaxItems?: number;
    }
    export namespace ListFieldLevelEncryptionProfilesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListFieldLevelEncryptionProfilesRequest) => any;
    }
    /**
        * <p>The field-level encryption profile summary.</p>
        */
    export interface FieldLevelEncryptionProfileSummary {
            /**
                * <p>ID for the field-level encryption profile summary.</p>
                */
            Id: string | undefined;
            /**
                * <p>The time when the the field-level encryption profile summary was last updated.</p>
                */
            LastModifiedTime: Date | undefined;
            /**
                * <p>Name for the field-level encryption profile summary.</p>
                */
            Name: string | undefined;
            /**
                * <p>A complex data type of encryption entities for the field-level encryption profile that include the public key ID, provider, and
                * 			field patterns for specifying which fields to encrypt with this key.</p>
                */
            EncryptionEntities: EncryptionEntities | undefined;
            /**
                * <p>An optional comment for the field-level encryption profile summary. The comment cannot be
                * 			longer than 128 characters.</p>
                */
            Comment?: string;
    }
    export namespace FieldLevelEncryptionProfileSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FieldLevelEncryptionProfileSummary) => any;
    }
    /**
        * <p>List of field-level encryption profiles.</p>
        */
    export interface FieldLevelEncryptionProfileList {
            /**
                * <p>If there are more elements to be listed, this element is present and contains
                * 			the value that you can use for the <code>Marker</code> request parameter to continue
                * 			listing your profiles where you left off.</p>
                */
            NextMarker?: string;
            /**
                * <p>The maximum number of field-level encryption profiles you want in the response body. </p>
                */
            MaxItems: number | undefined;
            /**
                * <p>The number of field-level encryption profiles.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>The field-level encryption profile items.</p>
                */
            Items?: FieldLevelEncryptionProfileSummary[];
    }
    export namespace FieldLevelEncryptionProfileList {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FieldLevelEncryptionProfileList) => any;
    }
    export interface ListFieldLevelEncryptionProfilesResult {
            /**
                * <p>Returns a list of the field-level encryption profiles that have been created in CloudFront for this account.</p>
                */
            FieldLevelEncryptionProfileList?: FieldLevelEncryptionProfileList;
    }
    export namespace ListFieldLevelEncryptionProfilesResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListFieldLevelEncryptionProfilesResult) => any;
    }
    export interface ListFunctionsRequest {
            /**
                * <p>Use this field when paginating results to indicate where to begin in your list of
                * 			functions. The response includes functions in the list that occur after the marker. To
                * 			get the next page of the list, set this field’s value to the value of
                * 			<code>NextMarker</code> from the current page’s response.</p>
                */
            Marker?: string;
            /**
                * <p>The maximum number of functions that you want in the response.</p>
                */
            MaxItems?: number;
            /**
                * <p>An optional filter to return only the functions that are in the specified stage,
                * 			either <code>DEVELOPMENT</code> or <code>LIVE</code>.</p>
                */
            Stage?: FunctionStage | string;
    }
    export namespace ListFunctionsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListFunctionsRequest) => any;
    }
    /**
        * <p>A list of CloudFront functions.</p>
        */
    export interface FunctionList {
            /**
                * <p>If there are more items in the list than are in this response, this element is
                * 			present. It contains the value that you should use in the <code>Marker</code> field of a
                * 			subsequent request to continue listing functions where you left off.</p>
                */
            NextMarker?: string;
            /**
                * <p>The maximum number of functions requested.</p>
                */
            MaxItems: number | undefined;
            /**
                * <p>The number of functions returned in the response.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>Contains the functions in the list.</p>
                */
            Items?: FunctionSummary[];
    }
    export namespace FunctionList {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FunctionList) => any;
    }
    export interface ListFunctionsResult {
            /**
                * <p>A list of CloudFront functions.</p>
                */
            FunctionList?: FunctionList;
    }
    export namespace ListFunctionsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListFunctionsResult) => any;
    }
    /**
        * <p>The request to list invalidations. </p>
        */
    export interface ListInvalidationsRequest {
            /**
                * <p>The distribution's ID.</p>
                */
            DistributionId: string | undefined;
            /**
                * <p>Use this parameter when paginating results to indicate where to begin in your list of
                * 			invalidation batches. Because the results are returned in decreasing order from most recent to
                * 			oldest, the most recent results are on the first page, the second page will contain earlier
                * 			results, and so on. To get the next page of results, set <code>Marker</code> to the value of
                * 			the <code>NextMarker</code> from the current page's response. This value is the same as the ID
                * 			of the last invalidation batch on that page. </p>
                */
            Marker?: string;
            /**
                * <p>The maximum number of invalidation batches that you want in the response
                * 			body.</p>
                */
            MaxItems?: number;
    }
    export namespace ListInvalidationsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListInvalidationsRequest) => any;
    }
    /**
        * <p>A summary of an invalidation request.</p>
        */
    export interface InvalidationSummary {
            /**
                * <p>The unique ID for an invalidation request.</p>
                */
            Id: string | undefined;
            /**
                * <p>The time that an invalidation request was created.</p>
                */
            CreateTime: Date | undefined;
            /**
                * <p>The status of an invalidation request.</p>
                */
            Status: string | undefined;
    }
    export namespace InvalidationSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InvalidationSummary) => any;
    }
    /**
        * <p>The <code>InvalidationList</code> complex type describes the list of invalidation
        * 			objects. For more information about invalidation, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html">Invalidating Objects (Web Distributions Only)</a> in
        * 			the <i>Amazon CloudFront Developer Guide</i>.</p>
        */
    export interface InvalidationList {
            /**
                * <p>The value that you provided for the <code>Marker</code> request parameter.</p>
                */
            Marker: string | undefined;
            /**
                * <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains
                * 			the value that you can use for the <code>Marker</code> request parameter to continue listing
                * 			your invalidation batches where they left off.</p>
                */
            NextMarker?: string;
            /**
                * <p>The value that you provided for the <code>MaxItems</code> request parameter.</p>
                */
            MaxItems: number | undefined;
            /**
                * <p>A flag that indicates whether more invalidation batch requests remain to be listed. If
                * 			your results were truncated, you can make a follow-up pagination request using the
                * 				<code>Marker</code> request parameter to retrieve more invalidation batches in the
                * 			list.</p>
                */
            IsTruncated: boolean | undefined;
            /**
                * <p>The number of invalidation batches that were created by the current Amazon Web Services account.
                * 		</p>
                */
            Quantity: number | undefined;
            /**
                * <p>A complex type that contains one <code>InvalidationSummary</code> element for each
                * 			invalidation batch created by the current Amazon Web Services account.</p>
                */
            Items?: InvalidationSummary[];
    }
    export namespace InvalidationList {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InvalidationList) => any;
    }
    /**
        * <p>The returned result of the corresponding request. </p>
        */
    export interface ListInvalidationsResult {
            /**
                * <p>Information about invalidation batches. </p>
                */
            InvalidationList?: InvalidationList;
    }
    export namespace ListInvalidationsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListInvalidationsResult) => any;
    }
    export interface ListKeyGroupsRequest {
            /**
                * <p>Use this field when paginating results to indicate where to begin in your list of key
                * 			groups. The response includes key groups in the list that occur after the marker. To get
                * 			the next page of the list, set this field’s value to the value of
                * 			<code>NextMarker</code> from the current page’s response.</p>
                */
            Marker?: string;
            /**
                * <p>The maximum number of key groups that you want in the response.</p>
                */
            MaxItems?: number;
    }
    export namespace ListKeyGroupsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListKeyGroupsRequest) => any;
    }
    /**
        * <p>Contains information about a key group.</p>
        */
    export interface KeyGroupSummary {
            /**
                * <p>A key group.</p>
                */
            KeyGroup: KeyGroup | undefined;
    }
    export namespace KeyGroupSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: KeyGroupSummary) => any;
    }
    /**
        * <p>A list of key groups.</p>
        */
    export interface KeyGroupList {
            /**
                * <p>If there are more items in the list than are in this response, this element is present. It
                * 			contains the value that you should use in the <code>Marker</code> field of a subsequent
                * 			request to continue listing key groups.</p>
                */
            NextMarker?: string;
            /**
                * <p>The maximum number of key groups requested.</p>
                */
            MaxItems: number | undefined;
            /**
                * <p>The number of key groups returned in the response.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>A list of key groups.</p>
                */
            Items?: KeyGroupSummary[];
    }
    export namespace KeyGroupList {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: KeyGroupList) => any;
    }
    export interface ListKeyGroupsResult {
            /**
                * <p>A list of key groups.</p>
                */
            KeyGroupList?: KeyGroupList;
    }
    export namespace ListKeyGroupsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListKeyGroupsResult) => any;
    }
    export type OriginRequestPolicyType = "custom" | "managed";
    export interface ListOriginRequestPoliciesRequest {
            /**
                * <p>A filter to return only the specified kinds of origin request policies. Valid values
                * 			are:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>
                *                   <code>managed</code> – Returns only the managed policies created by Amazon Web Services.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>custom</code> – Returns only the custom policies created in your Amazon Web Services account.</p>
                * 			         </li>
                *          </ul>
                */
            Type?: OriginRequestPolicyType | string;
            /**
                * <p>Use this field when paginating results to indicate where to begin in your list of
                * 			origin request policies. The response includes origin request policies in the list that
                * 			occur after the marker. To get the next page of the list, set this field’s value to the
                * 			value of <code>NextMarker</code> from the current page’s response.</p>
                */
            Marker?: string;
            /**
                * <p>The maximum number of origin request policies that you want in the response.</p>
                */
            MaxItems?: number;
    }
    export namespace ListOriginRequestPoliciesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListOriginRequestPoliciesRequest) => any;
    }
    /**
        * <p>Contains an origin request policy.</p>
        */
    export interface OriginRequestPolicySummary {
            /**
                * <p>The type of origin request policy, either <code>managed</code> (created by Amazon Web Services) or
                * 			<code>custom</code> (created in this Amazon Web Services account).</p>
                */
            Type: OriginRequestPolicyType | string | undefined;
            /**
                * <p>The origin request policy.</p>
                */
            OriginRequestPolicy: OriginRequestPolicy | undefined;
    }
    export namespace OriginRequestPolicySummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OriginRequestPolicySummary) => any;
    }
    /**
        * <p>A list of origin request policies.</p>
        */
    export interface OriginRequestPolicyList {
            /**
                * <p>If there are more items in the list than are in this response, this element is
                * 			present. It contains the value that you should use in the <code>Marker</code> field of a
                * 			subsequent request to continue listing origin request policies where you left
                * 			off.</p>
                */
            NextMarker?: string;
            /**
                * <p>The maximum number of origin request policies requested.</p>
                */
            MaxItems: number | undefined;
            /**
                * <p>The total number of origin request policies returned in the response.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>Contains the origin request policies in the list.</p>
                */
            Items?: OriginRequestPolicySummary[];
    }
    export namespace OriginRequestPolicyList {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OriginRequestPolicyList) => any;
    }
    export interface ListOriginRequestPoliciesResult {
            /**
                * <p>A list of origin request policies.</p>
                */
            OriginRequestPolicyList?: OriginRequestPolicyList;
    }
    export namespace ListOriginRequestPoliciesResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListOriginRequestPoliciesResult) => any;
    }
    export interface ListPublicKeysRequest {
            /**
                * <p>Use this when paginating results to indicate where to begin in your list of public keys. The results include public keys in the list that
                * 			occur after the marker. To get the next page of results, set the <code>Marker</code> to the value of the
                * 			<code>NextMarker</code> from the current page's response (which is also the ID of the last public key on that page). </p>
                */
            Marker?: string;
            /**
                * <p>The maximum number of public keys you want in the response body. </p>
                */
            MaxItems?: number;
    }
    export namespace ListPublicKeysRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListPublicKeysRequest) => any;
    }
    /**
        * <p>Contains information about a public key.</p>
        */
    export interface PublicKeySummary {
            /**
                * <p>The identifier of the public key.</p>
                */
            Id: string | undefined;
            /**
                * <p>A name to help identify the public key.</p>
                */
            Name: string | undefined;
            /**
                * <p>The date and time when the public key was uploaded.</p>
                */
            CreatedTime: Date | undefined;
            /**
                * <p>The public key.</p>
                */
            EncodedKey: string | undefined;
            /**
                * <p>A comment to describe the public key. The comment cannot be longer than 128
                * 			characters.</p>
                */
            Comment?: string;
    }
    export namespace PublicKeySummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PublicKeySummary) => any;
    }
    /**
        * <p>A list of public keys that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">signed URLs and signed cookies</a>, or with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html">field-level encryption</a>.</p>
        */
    export interface PublicKeyList {
            /**
                * <p>If there are more elements to be listed, this element is present and contains
                * 			the value that you can use for the <code>Marker</code> request parameter to continue
                * 			listing your public keys where you left off.</p>
                */
            NextMarker?: string;
            /**
                * <p>The maximum number of public keys you want in the response.</p>
                */
            MaxItems: number | undefined;
            /**
                * <p>The number of public keys in the list.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>A list of public keys.</p>
                */
            Items?: PublicKeySummary[];
    }
    export namespace PublicKeyList {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PublicKeyList) => any;
    }
    export interface ListPublicKeysResult {
            /**
                * <p>Returns a list of all public keys that have been added to CloudFront for this account.</p>
                */
            PublicKeyList?: PublicKeyList;
    }
    export namespace ListPublicKeysResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListPublicKeysResult) => any;
    }
    export interface ListRealtimeLogConfigsRequest {
            /**
                * <p>The maximum number of real-time log configurations that you want in the response.</p>
                */
            MaxItems?: number;
            /**
                * <p>Use this field when paginating results to indicate where to begin in your list of real-time
                * 			log configurations. The response includes real-time log configurations in the list that
                * 			occur after the marker. To get the next page of the list, set this field’s value to the
                * 			value of <code>NextMarker</code> from the current page’s response.</p>
                */
            Marker?: string;
    }
    export namespace ListRealtimeLogConfigsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListRealtimeLogConfigsRequest) => any;
    }
    /**
        * <p>A list of real-time log configurations.</p>
        */
    export interface RealtimeLogConfigs {
            /**
                * <p>The maximum number of real-time log configurations requested.</p>
                */
            MaxItems: number | undefined;
            /**
                * <p>Contains the list of real-time log configurations.</p>
                */
            Items?: RealtimeLogConfig[];
            /**
                * <p>A flag that indicates whether there are more real-time log configurations than are contained
                * 			in this list.</p>
                */
            IsTruncated: boolean | undefined;
            /**
                * <p>This parameter indicates where this list of real-time log configurations begins. This list
                * 			includes real-time log configurations that occur after the marker.</p>
                */
            Marker: string | undefined;
            /**
                * <p>If there are more items in the list than are in this response, this element is present. It
                * 			contains the value that you should use in the <code>Marker</code> field of a subsequent
                * 			request to continue listing real-time log configurations where you left off. </p>
                */
            NextMarker?: string;
    }
    export namespace RealtimeLogConfigs {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RealtimeLogConfigs) => any;
    }
    export interface ListRealtimeLogConfigsResult {
            /**
                * <p>A list of real-time log configurations.</p>
                */
            RealtimeLogConfigs?: RealtimeLogConfigs;
    }
    export namespace ListRealtimeLogConfigsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListRealtimeLogConfigsResult) => any;
    }
    export enum ResponseHeadersPolicyType {
            custom = "custom",
            managed = "managed"
    }
    export interface ListResponseHeadersPoliciesRequest {
            /**
                * <p>A filter to get only the specified kind of response headers policies. Valid values
                * 			are:</p>
                * 		       <ul>
                *             <li>
                * 				           <p>
                *                   <code>managed</code> – Gets only the managed policies created by Amazon Web Services.</p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <code>custom</code> – Gets only the custom policies created in your
                * 					Amazon Web Services account.</p>
                * 			         </li>
                *          </ul>
                */
            Type?: ResponseHeadersPolicyType | string;
            /**
                * <p>Use this field when paginating results to indicate where to begin in your list of response
                * 			headers policies. The response includes response headers policies in the list that occur
                * 			after the marker. To get the next page of the list, set this field’s value to the value
                * 			of <code>NextMarker</code> from the current page’s response. </p>
                */
            Marker?: string;
            /**
                * <p>The maximum number of response headers policies that you want to get in the response.</p>
                */
            MaxItems?: number;
    }
    export namespace ListResponseHeadersPoliciesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListResponseHeadersPoliciesRequest) => any;
    }
    /**
        * <p>Contains a response headers policy.</p>
        */
    export interface ResponseHeadersPolicySummary {
            /**
                * <p>The type of response headers policy, either <code>managed</code> (created by Amazon Web Services) or
                * 				<code>custom</code> (created in this Amazon Web Services account).</p>
                */
            Type: ResponseHeadersPolicyType | string | undefined;
            /**
                * <p>The response headers policy.</p>
                */
            ResponseHeadersPolicy: ResponseHeadersPolicy | undefined;
    }
    export namespace ResponseHeadersPolicySummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseHeadersPolicySummary) => any;
    }
    /**
        * <p>A list of response headers policies.</p>
        */
    export interface ResponseHeadersPolicyList {
            /**
                * <p>If there are more items in the list than are in this response, this element is present. It
                * 			contains the value that you should use in the <code>Marker</code> field of a subsequent
                * 			request to continue listing response headers policies where you left off.</p>
                */
            NextMarker?: string;
            /**
                * <p>The maximum number of response headers policies requested.</p>
                */
            MaxItems: number | undefined;
            /**
                * <p>The number of response headers policies returned.</p>
                */
            Quantity: number | undefined;
            /**
                * <p>The response headers policies in the list.</p>
                */
            Items?: ResponseHeadersPolicySummary[];
    }
    export namespace ResponseHeadersPolicyList {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseHeadersPolicyList) => any;
    }
    export interface ListResponseHeadersPoliciesResult {
            /**
                * <p>A list of response headers policies.</p>
                */
            ResponseHeadersPolicyList?: ResponseHeadersPolicyList;
    }
    export namespace ListResponseHeadersPoliciesResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListResponseHeadersPoliciesResult) => any;
    }
    /**
        * <p>The request to list your streaming distributions. </p>
        */
    export interface ListStreamingDistributionsRequest {
            /**
                * <p>The value that you provided for the <code>Marker</code> request parameter.</p>
                */
            Marker?: string;
            /**
                * <p>The value that you provided for the <code>MaxItems</code> request parameter.</p>
                */
            MaxItems?: number;
    }
    export namespace ListStreamingDistributionsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListStreamingDistributionsRequest) => any;
    }
    /**
        * <p> A summary of the information for a CloudFront streaming distribution.</p>
        */
    export interface StreamingDistributionSummary {
            /**
                * <p>The identifier for the distribution, for example, <code>EDFDVBD632BHDS5</code>.</p>
                */
            Id: string | undefined;
            /**
                * <p> The ARN (Amazon Resource Name) for the streaming distribution. For example:
                * 				<code>arn:aws:cloudfront::123456789012:streaming-distribution/EDFDVBD632BHDS5</code>, where
                * 				<code>123456789012</code> is your Amazon Web Services account ID.</p>
                */
            ARN: string | undefined;
            /**
                * <p> Indicates the current status of the distribution. When the status is
                * 			<code>Deployed</code>, the distribution's information is fully propagated throughout the
                * 			Amazon CloudFront system.</p>
                */
            Status: string | undefined;
            /**
                * <p>The date and time the distribution was last modified.</p>
                */
            LastModifiedTime: Date | undefined;
            /**
                * <p>The domain name corresponding to the distribution, for example, <code>d111111abcdef8.cloudfront.net</code>.</p>
                */
            DomainName: string | undefined;
            /**
                * <p>A complex type that contains information about the Amazon S3 bucket from which you want
                * 			CloudFront to get your media files for distribution.</p>
                */
            S3Origin: S3Origin | undefined;
            /**
                * <p>A complex type that contains information about CNAMEs (alternate domain names), if any,
                * 			for this streaming distribution.</p>
                */
            Aliases: Aliases | undefined;
            /**
                * <p>A complex type that specifies the Amazon Web Services accounts, if any, that you want to allow to
                * 			create signed URLs for private content. If you want to require signed URLs in requests for
                * 			objects in the target origin that match the <code>PathPattern</code> for this cache behavior,
                * 			specify <code>true</code> for <code>Enabled</code>, and specify the applicable values for
                * 				<code>Quantity</code> and <code>Items</code>.If you don't want to require signed URLs in
                * 			requests for objects that match <code>PathPattern</code>, specify <code>false</code> for
                * 				<code>Enabled</code> and <code>0</code> for <code>Quantity</code>. Omit <code>Items</code>.
                * 			To add, change, or remove one or more trusted signers, change <code>Enabled</code> to
                * 				<code>true</code> (if it's currently <code>false</code>), change <code>Quantity</code> as
                * 			applicable, and specify all of the trusted signers that you want to include in the updated
                * 			distribution.</p>
                * 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving Private
                * 			Content through CloudFront</a> in the <i>Amazon CloudFront Developer Guide</i>. </p>
                */
            TrustedSigners: TrustedSigners | undefined;
            /**
                * <p>The comment originally specified when this distribution was created.</p>
                */
            Comment: string | undefined;
            /**
                * <p>A complex type that contains information about price class for this streaming
                * 			distribution. </p>
                */
            PriceClass: PriceClass | string | undefined;
            /**
                * <p>Whether the distribution is enabled to accept end user requests for content.</p>
                */
            Enabled: boolean | undefined;
    }
    export namespace StreamingDistributionSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StreamingDistributionSummary) => any;
    }
    /**
        * <p>A streaming distribution list. </p>
        */
    export interface StreamingDistributionList {
            /**
                * <p>The value you provided for the <code>Marker</code> request parameter. </p>
                */
            Marker: string | undefined;
            /**
                * <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains
                * 			the value you can use for the <code>Marker</code> request parameter to continue listing your
                * 			RTMP distributions where they left off. </p>
                */
            NextMarker?: string;
            /**
                * <p>The value you provided for the <code>MaxItems</code> request parameter. </p>
                */
            MaxItems: number | undefined;
            /**
                * <p>A flag that indicates whether more streaming distributions remain to be listed. If your
                * 			results were truncated, you can make a follow-up pagination request using the
                * 				<code>Marker</code> request parameter to retrieve more distributions in the list. </p>
                */
            IsTruncated: boolean | undefined;
            /**
                * <p>The number of streaming distributions that were created by the current Amazon Web Services account.
                * 		</p>
                */
            Quantity: number | undefined;
            /**
                * <p>A complex type that contains one <code>StreamingDistributionSummary</code> element for
                * 			each distribution that was created by the current Amazon Web Services account.</p>
                */
            Items?: StreamingDistributionSummary[];
    }
    export namespace StreamingDistributionList {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StreamingDistributionList) => any;
    }
    /**
        * <p>The returned result of the corresponding request. </p>
        */
    export interface ListStreamingDistributionsResult {
            /**
                * <p>The <code>StreamingDistributionList</code> type. </p>
                */
            StreamingDistributionList?: StreamingDistributionList;
    }
    export namespace ListStreamingDistributionsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListStreamingDistributionsResult) => any;
    }
    /**
        * <p> The request to list tags for a CloudFront resource.</p>
        */
    export interface ListTagsForResourceRequest {
            /**
                * <p> An ARN of a CloudFront resource.</p>
                */
            Resource: string | undefined;
    }
    export namespace ListTagsForResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceRequest) => any;
    }
    /**
        * <p> The returned result of the corresponding request.</p>
        */
    export interface ListTagsForResourceResult {
            /**
                * <p> A complex type that contains zero or more <code>Tag</code> elements.</p>
                */
            Tags: Tags | undefined;
    }
    export namespace ListTagsForResourceResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceResult) => any;
    }
    export interface PublishFunctionRequest {
            /**
                * <p>The name of the function that you are publishing.</p>
                */
            Name: string | undefined;
            /**
                * <p>The current version (<code>ETag</code> value) of the function that you are publishing, which
                * 			you can get using <code>DescribeFunction</code>.</p>
                */
            IfMatch: string | undefined;
    }
    export namespace PublishFunctionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PublishFunctionRequest) => any;
    }
    export interface PublishFunctionResult {
            /**
                * <p>Contains configuration information and metadata about a CloudFront function.</p>
                */
            FunctionSummary?: FunctionSummary;
    }
    export namespace PublishFunctionResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PublishFunctionResult) => any;
    }
    /**
        * <p> The request to add tags to a CloudFront resource.</p>
        */
    export interface TagResourceRequest {
            /**
                * <p> An ARN of a CloudFront resource.</p>
                */
            Resource: string | undefined;
            /**
                * <p> A complex type that contains zero or more <code>Tag</code> elements.</p>
                */
            Tags: Tags | undefined;
    }
    export namespace TagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceRequest) => any;
    }
    /**
        * <p>The CloudFront function failed.</p>
        */
    export class TestFunctionFailed extends __BaseException {
            readonly name: "TestFunctionFailed";
            readonly $fault: "server";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TestFunctionFailed, __BaseException>);
    }
    export interface TestFunctionRequest {
            /**
                * <p>The name of the function that you are testing.</p>
                */
            Name: string | undefined;
            /**
                * <p>The current version (<code>ETag</code> value) of the function that you are testing, which
                * 			you can get using <code>DescribeFunction</code>.</p>
                */
            IfMatch: string | undefined;
            /**
                * <p>The stage of the function that you are testing, either <code>DEVELOPMENT</code> or
                * 			<code>LIVE</code>.</p>
                */
            Stage?: FunctionStage | string;
            /**
                * <p>The event object to test the function with. For more information about the structure of the
                * 			event object, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/managing-functions.html#test-function">Testing functions</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            EventObject: Uint8Array | undefined;
    }
    export namespace TestFunctionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TestFunctionRequest) => any;
    }
    /**
        * <p>Contains the result of testing a CloudFront function with <code>TestFunction</code>.</p>
        */
    export interface TestResult {
            /**
                * <p>Contains configuration information and metadata about the CloudFront function that was
                * 			tested.</p>
                */
            FunctionSummary?: FunctionSummary;
            /**
                * <p>The amount of time that the function took to run as a percentage of the maximum
                * 			allowed time. For example, a compute utilization of 35 means that the function completed
                * 			in 35% of the maximum allowed time.</p>
                */
            ComputeUtilization?: string;
            /**
                * <p>Contains the log lines that the function wrote (if any) when running the test.</p>
                */
            FunctionExecutionLogs?: string[];
            /**
                * <p>If the result of testing the function was an error, this field contains the error
                * 			message.</p>
                */
            FunctionErrorMessage?: string;
            /**
                * <p>The event object returned by the function. For more information about the structure of the
                * 			event object, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/functions-event-structure.html">Event object
                * 			structure</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            FunctionOutput?: string;
    }
    export namespace TestResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TestResult) => any;
    }
    export interface TestFunctionResult {
            /**
                * <p>An object that represents the result of running the function with the provided event
                * 			object.</p>
                */
            TestResult?: TestResult;
    }
    export namespace TestFunctionResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TestFunctionResult) => any;
    }
    /**
        * <p> A complex type that contains zero or more <code>Tag</code> elements.</p>
        */
    export interface TagKeys {
            /**
                * <p> A complex type that contains <code>Tag</code> key elements.</p>
                */
            Items?: string[];
    }
    export namespace TagKeys {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagKeys) => any;
    }
    /**
        * <p> The request to remove tags from a CloudFront resource.</p>
        */
    export interface UntagResourceRequest {
            /**
                * <p> An ARN of a CloudFront resource.</p>
                */
            Resource: string | undefined;
            /**
                * <p> A complex type that contains zero or more <code>Tag</code> key elements.</p>
                */
            TagKeys: TagKeys | undefined;
    }
    export namespace UntagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceRequest) => any;
    }
    export interface UpdateCachePolicyRequest {
            /**
                * <p>A cache policy configuration.</p>
                */
            CachePolicyConfig: CachePolicyConfig | undefined;
            /**
                * <p>The unique identifier for the cache policy that you are updating. The identifier is returned
                * 			in a cache behavior’s <code>CachePolicyId</code> field in the response to
                * 			<code>GetDistributionConfig</code>.</p>
                */
            Id: string | undefined;
            /**
                * <p>The version of the cache policy that you are updating. The version is returned in the cache
                * 			policy’s <code>ETag</code> field in the response to
                * 			<code>GetCachePolicyConfig</code>.</p>
                */
            IfMatch?: string;
    }
    export namespace UpdateCachePolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateCachePolicyRequest) => any;
    }
    export interface UpdateCachePolicyResult {
            /**
                * <p>A cache policy.</p>
                */
            CachePolicy?: CachePolicy;
            /**
                * <p>The current version of the cache policy.</p>
                */
            ETag?: string;
    }
    export namespace UpdateCachePolicyResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateCachePolicyResult) => any;
    }
    /**
        * <p>The request to update an origin access identity.</p>
        */
    export interface UpdateCloudFrontOriginAccessIdentityRequest {
            /**
                * <p>The identity's configuration information.</p>
                */
            CloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig | undefined;
            /**
                * <p>The identity's id.</p>
                */
            Id: string | undefined;
            /**
                * <p>The value of the <code>ETag</code> header that you received when retrieving the
                * 			identity's configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
                */
            IfMatch?: string;
    }
    export namespace UpdateCloudFrontOriginAccessIdentityRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateCloudFrontOriginAccessIdentityRequest) => any;
    }
    /**
        * <p>The returned result of the corresponding request.</p>
        */
    export interface UpdateCloudFrontOriginAccessIdentityResult {
            /**
                * <p>The origin access identity's information.</p>
                */
            CloudFrontOriginAccessIdentity?: CloudFrontOriginAccessIdentity;
            /**
                * <p>The current version of the configuration. For example:
                * 			<code>E2QWRUHAPOMQZL</code>.</p>
                */
            ETag?: string;
    }
    export namespace UpdateCloudFrontOriginAccessIdentityResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateCloudFrontOriginAccessIdentityResult) => any;
    }
    /**
        * <p>The request to update a distribution.</p>
        */
    export interface UpdateDistributionRequest {
            /**
                * <p>The distribution's configuration information.</p>
                */
            DistributionConfig: DistributionConfig | undefined;
            /**
                * <p>The distribution's id.</p>
                */
            Id: string | undefined;
            /**
                * <p>The value of the <code>ETag</code> header that you received when retrieving the
                * 			distribution's configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
                */
            IfMatch?: string;
    }
    export namespace UpdateDistributionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateDistributionRequest) => any;
    }
    /**
        * <p>The returned result of the corresponding request.</p>
        */
    export interface UpdateDistributionResult {
            /**
                * <p>The distribution's information.</p>
                */
            Distribution?: Distribution;
            /**
                * <p>The current version of the configuration. For example:
                * 			<code>E2QWRUHAPOMQZL</code>.</p>
                */
            ETag?: string;
    }
    export namespace UpdateDistributionResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateDistributionResult) => any;
    }
    export interface UpdateFieldLevelEncryptionConfigRequest {
            /**
                * <p>Request to update a field-level encryption configuration. </p>
                */
            FieldLevelEncryptionConfig: FieldLevelEncryptionConfig | undefined;
            /**
                * <p>The ID of the configuration you want to update.</p>
                */
            Id: string | undefined;
            /**
                * <p>The value of the <code>ETag</code> header that you received when retrieving the configuration identity to update.
                * 			For example: <code>E2QWRUHAPOMQZL</code>.</p>
                */
            IfMatch?: string;
    }
    export namespace UpdateFieldLevelEncryptionConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateFieldLevelEncryptionConfigRequest) => any;
    }
    export interface UpdateFieldLevelEncryptionConfigResult {
            /**
                * <p>Return the results of updating the configuration.</p>
                */
            FieldLevelEncryption?: FieldLevelEncryption;
            /**
                * <p>The value of the <code>ETag</code> header that you received when updating the configuration.
                * 			For example: <code>E2QWRUHAPOMQZL</code>.</p>
                */
            ETag?: string;
    }
    export namespace UpdateFieldLevelEncryptionConfigResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateFieldLevelEncryptionConfigResult) => any;
    }
    export interface UpdateFieldLevelEncryptionProfileRequest {
            /**
                * <p>Request to update a field-level encryption profile. </p>
                */
            FieldLevelEncryptionProfileConfig: FieldLevelEncryptionProfileConfig | undefined;
            /**
                * <p>The ID of the field-level encryption profile request. </p>
                */
            Id: string | undefined;
            /**
                * <p>The value of the <code>ETag</code> header that you received when retrieving the profile identity to update.
                * 			For example: <code>E2QWRUHAPOMQZL</code>.</p>
                */
            IfMatch?: string;
    }
    export namespace UpdateFieldLevelEncryptionProfileRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateFieldLevelEncryptionProfileRequest) => any;
    }
    export interface UpdateFieldLevelEncryptionProfileResult {
            /**
                * <p>Return the results of updating the profile.</p>
                */
            FieldLevelEncryptionProfile?: FieldLevelEncryptionProfile;
            /**
                * <p>The result of the field-level encryption profile request. </p>
                */
            ETag?: string;
    }
    export namespace UpdateFieldLevelEncryptionProfileResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateFieldLevelEncryptionProfileResult) => any;
    }
    export interface UpdateFunctionRequest {
            /**
                * <p>The name of the function that you are updating.</p>
                */
            Name: string | undefined;
            /**
                * <p>The current version (<code>ETag</code> value) of the function that you are updating, which
                * 			you can get using <code>DescribeFunction</code>.</p>
                */
            IfMatch: string | undefined;
            /**
                * <p>Configuration information about the function.</p>
                */
            FunctionConfig: FunctionConfig | undefined;
            /**
                * <p>The function code. For more information about writing a CloudFront function, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/writing-function-code.html">Writing function
                * 			code for CloudFront Functions</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
                */
            FunctionCode: Uint8Array | undefined;
    }
    export namespace UpdateFunctionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateFunctionRequest) => any;
    }
    export interface UpdateFunctionResult {
            /**
                * <p>Contains configuration information and metadata about a CloudFront function.</p>
                */
            FunctionSummary?: FunctionSummary;
            /**
                * <p>The version identifier for the current version of the CloudFront function.</p>
                */
            ETag?: string;
    }
    export namespace UpdateFunctionResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateFunctionResult) => any;
    }
    export interface UpdateKeyGroupRequest {
            /**
                * <p>The key group configuration.</p>
                */
            KeyGroupConfig: KeyGroupConfig | undefined;
            /**
                * <p>The identifier of the key group that you are updating.</p>
                */
            Id: string | undefined;
            /**
                * <p>The version of the key group that you are updating. The version is the key group’s
                * 			<code>ETag</code> value.</p>
                */
            IfMatch?: string;
    }
    export namespace UpdateKeyGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateKeyGroupRequest) => any;
    }
    export interface UpdateKeyGroupResult {
            /**
                * <p>The key group that was just updated.</p>
                */
            KeyGroup?: KeyGroup;
            /**
                * <p>The identifier for this version of the key group.</p>
                */
            ETag?: string;
    }
    export namespace UpdateKeyGroupResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateKeyGroupResult) => any;
    }
    export interface UpdateOriginRequestPolicyRequest {
            /**
                * <p>An origin request policy configuration.</p>
                */
            OriginRequestPolicyConfig: OriginRequestPolicyConfig | undefined;
            /**
                * <p>The unique identifier for the origin request policy that you are updating. The identifier is
                * 			returned in a cache behavior’s <code>OriginRequestPolicyId</code> field in the response
                * 			to <code>GetDistributionConfig</code>.</p>
                */
            Id: string | undefined;
            /**
                * <p>The version of the origin request policy that you are updating. The version is returned in
                * 			the origin request policy’s <code>ETag</code> field in the response to
                * 			<code>GetOriginRequestPolicyConfig</code>.</p>
                */
            IfMatch?: string;
    }
    export namespace UpdateOriginRequestPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateOriginRequestPolicyRequest) => any;
    }
    export interface UpdateOriginRequestPolicyResult {
            /**
                * <p>An origin request policy.</p>
                */
            OriginRequestPolicy?: OriginRequestPolicy;
            /**
                * <p>The current version of the origin request policy.</p>
                */
            ETag?: string;
    }
    export namespace UpdateOriginRequestPolicyResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateOriginRequestPolicyResult) => any;
    }
    export interface UpdatePublicKeyRequest {
            /**
                * <p>A public key configuration.</p>
                */
            PublicKeyConfig: PublicKeyConfig | undefined;
            /**
                * <p>The identifier of the public key that you are updating.</p>
                */
            Id: string | undefined;
            /**
                * <p>The value of the <code>ETag</code> header that you received when retrieving the public key to update.
                * 			For example: <code>E2QWRUHAPOMQZL</code>.</p>
                */
            IfMatch?: string;
    }
    export namespace UpdatePublicKeyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdatePublicKeyRequest) => any;
    }
    export interface UpdatePublicKeyResult {
            /**
                * <p>The public key.</p>
                */
            PublicKey?: PublicKey;
            /**
                * <p>The identifier of the current version of the public key.</p>
                */
            ETag?: string;
    }
    export namespace UpdatePublicKeyResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdatePublicKeyResult) => any;
    }
    export interface UpdateRealtimeLogConfigRequest {
            /**
                * <p>Contains information about the Amazon Kinesis data stream where you are sending real-time
                * 			log data.</p>
                */
            EndPoints?: EndPoint[];
            /**
                * <p>A list of fields to include in each real-time log record.</p>
                * 		       <p>For more information about fields, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields">Real-time log configuration fields</a> in the
                * 			<i>Amazon CloudFront Developer Guide</i>.</p>
                */
            Fields?: string[];
            /**
                * <p>The name for this real-time log configuration.</p>
                */
            Name?: string;
            /**
                * <p>The Amazon Resource Name (ARN) for this real-time log configuration.</p>
                */
            ARN?: string;
            /**
                * <p>The sampling rate for this real-time log configuration. The sampling rate determines the
                * 			percentage of viewer requests that are represented in the real-time log data. You must
                * 			provide an integer between 1 and 100, inclusive.</p>
                */
            SamplingRate?: number;
    }
    export namespace UpdateRealtimeLogConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateRealtimeLogConfigRequest) => any;
    }
    export interface UpdateRealtimeLogConfigResult {
            /**
                * <p>A real-time log configuration.</p>
                */
            RealtimeLogConfig?: RealtimeLogConfig;
    }
    export namespace UpdateRealtimeLogConfigResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateRealtimeLogConfigResult) => any;
    }
    export interface UpdateResponseHeadersPolicyRequest {
            /**
                * <p>A response headers policy configuration.</p>
                */
            ResponseHeadersPolicyConfig: ResponseHeadersPolicyConfig | undefined;
            /**
                * <p>The identifier for the response headers policy that you are updating.</p>
                */
            Id: string | undefined;
            /**
                * <p>The version of the response headers policy that you are updating.</p>
                * 		       <p>The version is returned in the cache policy’s <code>ETag</code> field in the response
                * 			to <code>GetResponseHeadersPolicyConfig</code>.</p>
                */
            IfMatch?: string;
    }
    export namespace UpdateResponseHeadersPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateResponseHeadersPolicyRequest) => any;
    }
    export interface UpdateResponseHeadersPolicyResult {
            /**
                * <p>A response headers policy.</p>
                */
            ResponseHeadersPolicy?: ResponseHeadersPolicy;
            /**
                * <p>The current version of the response headers policy.</p>
                */
            ETag?: string;
    }
    export namespace UpdateResponseHeadersPolicyResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateResponseHeadersPolicyResult) => any;
    }
    /**
        * <p>The request to update a streaming distribution.</p>
        */
    export interface UpdateStreamingDistributionRequest {
            /**
                * <p>The streaming distribution's configuration information.</p>
                */
            StreamingDistributionConfig: StreamingDistributionConfig | undefined;
            /**
                * <p>The streaming distribution's id.</p>
                */
            Id: string | undefined;
            /**
                * <p>The value of the <code>ETag</code> header that you received when retrieving the
                * 			streaming distribution's configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
                */
            IfMatch?: string;
    }
    export namespace UpdateStreamingDistributionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateStreamingDistributionRequest) => any;
    }
    /**
        * <p>The returned result of the corresponding request.</p>
        */
    export interface UpdateStreamingDistributionResult {
            /**
                * <p>The streaming distribution's information.</p>
                */
            StreamingDistribution?: StreamingDistribution;
            /**
                * <p>The current version of the configuration. For example:
                * 			<code>E2QWRUHAPOMQZL</code>.</p>
                */
            ETag?: string;
    }
    export namespace UpdateStreamingDistributionResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateStreamingDistributionResult) => any;
    }
}

declare module '@aws-sdk/client-cloudfront/node_modules/@aws-sdk/client-cloudfront/dist-types/models/CloudFrontServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from CloudFront service.
        */
    export class CloudFrontServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

