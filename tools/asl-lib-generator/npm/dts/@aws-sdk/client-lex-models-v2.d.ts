// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/smithy-client
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http

declare module '@aws-sdk/client-lex-models-v2' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { BuildBotLocaleCommandInput, BuildBotLocaleCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/BuildBotLocaleCommand";
    import { CreateBotAliasCommandInput, CreateBotAliasCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateBotAliasCommand";
    import { CreateBotCommandInput, CreateBotCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateBotCommand";
    import { CreateBotLocaleCommandInput, CreateBotLocaleCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateBotLocaleCommand";
    import { CreateBotVersionCommandInput, CreateBotVersionCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateBotVersionCommand";
    import { CreateExportCommandInput, CreateExportCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateExportCommand";
    import { CreateIntentCommandInput, CreateIntentCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateIntentCommand";
    import { CreateResourcePolicyCommandInput, CreateResourcePolicyCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateResourcePolicyCommand";
    import { CreateResourcePolicyStatementCommandInput, CreateResourcePolicyStatementCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateResourcePolicyStatementCommand";
    import { CreateSlotCommandInput, CreateSlotCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateSlotCommand";
    import { CreateSlotTypeCommandInput, CreateSlotTypeCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateSlotTypeCommand";
    import { CreateUploadUrlCommandInput, CreateUploadUrlCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateUploadUrlCommand";
    import { DeleteBotAliasCommandInput, DeleteBotAliasCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteBotAliasCommand";
    import { DeleteBotCommandInput, DeleteBotCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteBotCommand";
    import { DeleteBotLocaleCommandInput, DeleteBotLocaleCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteBotLocaleCommand";
    import { DeleteBotVersionCommandInput, DeleteBotVersionCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteBotVersionCommand";
    import { DeleteCustomVocabularyCommandInput, DeleteCustomVocabularyCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteCustomVocabularyCommand";
    import { DeleteExportCommandInput, DeleteExportCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteExportCommand";
    import { DeleteImportCommandInput, DeleteImportCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteImportCommand";
    import { DeleteIntentCommandInput, DeleteIntentCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteIntentCommand";
    import { DeleteResourcePolicyCommandInput, DeleteResourcePolicyCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteResourcePolicyCommand";
    import { DeleteResourcePolicyStatementCommandInput, DeleteResourcePolicyStatementCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteResourcePolicyStatementCommand";
    import { DeleteSlotCommandInput, DeleteSlotCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteSlotCommand";
    import { DeleteSlotTypeCommandInput, DeleteSlotTypeCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteSlotTypeCommand";
    import { DeleteUtterancesCommandInput, DeleteUtterancesCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteUtterancesCommand";
    import { DescribeBotAliasCommandInput, DescribeBotAliasCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeBotAliasCommand";
    import { DescribeBotCommandInput, DescribeBotCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeBotCommand";
    import { DescribeBotLocaleCommandInput, DescribeBotLocaleCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeBotLocaleCommand";
    import { DescribeBotRecommendationCommandInput, DescribeBotRecommendationCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeBotRecommendationCommand";
    import { DescribeBotVersionCommandInput, DescribeBotVersionCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeBotVersionCommand";
    import { DescribeCustomVocabularyMetadataCommandInput, DescribeCustomVocabularyMetadataCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeCustomVocabularyMetadataCommand";
    import { DescribeExportCommandInput, DescribeExportCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeExportCommand";
    import { DescribeImportCommandInput, DescribeImportCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeImportCommand";
    import { DescribeIntentCommandInput, DescribeIntentCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeIntentCommand";
    import { DescribeResourcePolicyCommandInput, DescribeResourcePolicyCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeResourcePolicyCommand";
    import { DescribeSlotCommandInput, DescribeSlotCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeSlotCommand";
    import { DescribeSlotTypeCommandInput, DescribeSlotTypeCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeSlotTypeCommand";
    import { ListAggregatedUtterancesCommandInput, ListAggregatedUtterancesCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListAggregatedUtterancesCommand";
    import { ListBotAliasesCommandInput, ListBotAliasesCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListBotAliasesCommand";
    import { ListBotLocalesCommandInput, ListBotLocalesCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListBotLocalesCommand";
    import { ListBotRecommendationsCommandInput, ListBotRecommendationsCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListBotRecommendationsCommand";
    import { ListBotsCommandInput, ListBotsCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListBotsCommand";
    import { ListBotVersionsCommandInput, ListBotVersionsCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListBotVersionsCommand";
    import { ListBuiltInIntentsCommandInput, ListBuiltInIntentsCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListBuiltInIntentsCommand";
    import { ListBuiltInSlotTypesCommandInput, ListBuiltInSlotTypesCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListBuiltInSlotTypesCommand";
    import { ListExportsCommandInput, ListExportsCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListExportsCommand";
    import { ListImportsCommandInput, ListImportsCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListImportsCommand";
    import { ListIntentsCommandInput, ListIntentsCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListIntentsCommand";
    import { ListRecommendedIntentsCommandInput, ListRecommendedIntentsCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListRecommendedIntentsCommand";
    import { ListSlotsCommandInput, ListSlotsCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListSlotsCommand";
    import { ListSlotTypesCommandInput, ListSlotTypesCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListSlotTypesCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListTagsForResourceCommand";
    import { SearchAssociatedTranscriptsCommandInput, SearchAssociatedTranscriptsCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/SearchAssociatedTranscriptsCommand";
    import { StartBotRecommendationCommandInput, StartBotRecommendationCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/StartBotRecommendationCommand";
    import { StartImportCommandInput, StartImportCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/StartImportCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UntagResourceCommand";
    import { UpdateBotAliasCommandInput, UpdateBotAliasCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateBotAliasCommand";
    import { UpdateBotCommandInput, UpdateBotCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateBotCommand";
    import { UpdateBotLocaleCommandInput, UpdateBotLocaleCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateBotLocaleCommand";
    import { UpdateBotRecommendationCommandInput, UpdateBotRecommendationCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateBotRecommendationCommand";
    import { UpdateExportCommandInput, UpdateExportCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateExportCommand";
    import { UpdateIntentCommandInput, UpdateIntentCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateIntentCommand";
    import { UpdateResourcePolicyCommandInput, UpdateResourcePolicyCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateResourcePolicyCommand";
    import { UpdateSlotCommandInput, UpdateSlotCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateSlotCommand";
    import { UpdateSlotTypeCommandInput, UpdateSlotTypeCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateSlotTypeCommand";
    import { LexModelsV2Client } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    /**
        * <p></p>
        */
    export class LexModelsV2 extends LexModelsV2Client {
            /**
                * <p>Builds a bot, its intents, and its slot types into a specific
                *          locale. A bot can be built into multiple locales. At runtime the locale
                *          is used to choose a specific build of the bot.</p>
                */
            buildBotLocale(args: BuildBotLocaleCommandInput, options?: __HttpHandlerOptions): Promise<BuildBotLocaleCommandOutput>;
            buildBotLocale(args: BuildBotLocaleCommandInput, cb: (err: any, data?: BuildBotLocaleCommandOutput) => void): void;
            buildBotLocale(args: BuildBotLocaleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BuildBotLocaleCommandOutput) => void): void;
            /**
                * <p>Creates an Amazon Lex conversational bot. </p>
                */
            createBot(args: CreateBotCommandInput, options?: __HttpHandlerOptions): Promise<CreateBotCommandOutput>;
            createBot(args: CreateBotCommandInput, cb: (err: any, data?: CreateBotCommandOutput) => void): void;
            createBot(args: CreateBotCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateBotCommandOutput) => void): void;
            /**
                * <p>Creates an alias for the specified version of a bot. Use an alias to
                *          enable you to change the version of a bot without updating applications
                *          that use the bot.</p>
                *          <p>For example, you can create an alias called "PROD" that your
                *          applications use to call the Amazon Lex bot. </p>
                */
            createBotAlias(args: CreateBotAliasCommandInput, options?: __HttpHandlerOptions): Promise<CreateBotAliasCommandOutput>;
            createBotAlias(args: CreateBotAliasCommandInput, cb: (err: any, data?: CreateBotAliasCommandOutput) => void): void;
            createBotAlias(args: CreateBotAliasCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateBotAliasCommandOutput) => void): void;
            /**
                * <p>Creates a locale in the bot. The locale contains the intents and
                *          slot types that the bot uses in conversations with users in the
                *          specified language and locale. You must add a locale to a bot before
                *          you can add intents and slot types to the bot.</p>
                */
            createBotLocale(args: CreateBotLocaleCommandInput, options?: __HttpHandlerOptions): Promise<CreateBotLocaleCommandOutput>;
            createBotLocale(args: CreateBotLocaleCommandInput, cb: (err: any, data?: CreateBotLocaleCommandOutput) => void): void;
            createBotLocale(args: CreateBotLocaleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateBotLocaleCommandOutput) => void): void;
            /**
                * <p>Creates a new version of the bot based on the <code>DRAFT</code>
                *          version. If the <code>DRAFT</code> version of this resource hasn't
                *          changed since you created the last version, Amazon Lex doesn't create a new
                *          version, it returns the last created version.</p>
                *          <p>When you create the first version of a bot, Amazon Lex sets the version
                *          to 1. Subsequent versions increment by 1.</p>
                */
            createBotVersion(args: CreateBotVersionCommandInput, options?: __HttpHandlerOptions): Promise<CreateBotVersionCommandOutput>;
            createBotVersion(args: CreateBotVersionCommandInput, cb: (err: any, data?: CreateBotVersionCommandOutput) => void): void;
            createBotVersion(args: CreateBotVersionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateBotVersionCommandOutput) => void): void;
            /**
                * <p>Creates a zip archive containing the contents of a bot or a bot
                *          locale. The archive contains a directory structure that contains JSON
                *          files that define the bot.</p>
                *          <p>You can create an archive that contains the complete definition of a
                *          bot, or you can specify that the archive contain only the definition of
                *          a single bot locale.</p>
                *          <p>For more information about exporting bots, and about the structure
                *          of the export archive, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/importing-exporting.html"> Importing and
                *             exporting bots </a>
                *          </p>
                */
            createExport(args: CreateExportCommandInput, options?: __HttpHandlerOptions): Promise<CreateExportCommandOutput>;
            createExport(args: CreateExportCommandInput, cb: (err: any, data?: CreateExportCommandOutput) => void): void;
            createExport(args: CreateExportCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateExportCommandOutput) => void): void;
            /**
                * <p>Creates an intent.</p>
                *          <p>To define the interaction between the user and your bot, you define
                *          one or more intents. For example, for a pizza ordering bot you would
                *          create an <code>OrderPizza</code> intent.</p>
                *          <p>When you create an intent, you must provide a name. You can
                *          optionally provide the following:</p>
                *          <ul>
                *             <li>
                *                <p>Sample utterances. For example, "I want to order a pizza" and
                *                "Can I order a pizza." You can't provide utterances for built-in
                *                intents.</p>
                *             </li>
                *             <li>
                *                <p>Information to be gathered. You specify slots for the
                *                information that you bot requests from the user. You can specify
                *                standard slot types, such as date and time, or custom slot types
                *                for your application.</p>
                *             </li>
                *             <li>
                *                <p>How the intent is fulfilled. You can provide a Lambda function
                *                or configure the intent to return the intent information to your
                *                client application. If you use a Lambda function, Amazon Lex invokes
                *                the function when all of the intent information is
                *                available.</p>
                *             </li>
                *             <li>
                *                <p>A confirmation prompt to send to the user to confirm an
                *                intent. For example, "Shall I order your pizza?"</p>
                *             </li>
                *             <li>
                *                <p>A conclusion statement to send to the user after the intent is
                *                fulfilled. For example, "I ordered your pizza."</p>
                *             </li>
                *             <li>
                *                <p>A follow-up prompt that asks the user for additional activity.
                *                For example, "Do you want a drink with your pizza?"</p>
                *             </li>
                *          </ul>
                */
            createIntent(args: CreateIntentCommandInput, options?: __HttpHandlerOptions): Promise<CreateIntentCommandOutput>;
            createIntent(args: CreateIntentCommandInput, cb: (err: any, data?: CreateIntentCommandOutput) => void): void;
            createIntent(args: CreateIntentCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateIntentCommandOutput) => void): void;
            /**
                * <p>Creates a new resource policy with the specified policy
                *          statements.</p>
                */
            createResourcePolicy(args: CreateResourcePolicyCommandInput, options?: __HttpHandlerOptions): Promise<CreateResourcePolicyCommandOutput>;
            createResourcePolicy(args: CreateResourcePolicyCommandInput, cb: (err: any, data?: CreateResourcePolicyCommandOutput) => void): void;
            createResourcePolicy(args: CreateResourcePolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateResourcePolicyCommandOutput) => void): void;
            /**
                * <p>Adds a new resource policy statement to a bot or bot alias. If a
                *          resource policy exists, the statement is added to the current resource
                *          policy. If a policy doesn't exist, a new policy is created.</p>
                *          <p>You can't create a resource policy statement that allows
                *          cross-account access.</p>
                */
            createResourcePolicyStatement(args: CreateResourcePolicyStatementCommandInput, options?: __HttpHandlerOptions): Promise<CreateResourcePolicyStatementCommandOutput>;
            createResourcePolicyStatement(args: CreateResourcePolicyStatementCommandInput, cb: (err: any, data?: CreateResourcePolicyStatementCommandOutput) => void): void;
            createResourcePolicyStatement(args: CreateResourcePolicyStatementCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateResourcePolicyStatementCommandOutput) => void): void;
            /**
                * <p>Creates a slot in an intent. A slot is a variable needed to fulfill
                *          an intent. For example, an <code>OrderPizza</code> intent might need
                *          slots for size, crust, and number of pizzas. For each slot, you define
                *          one or more utterances that Amazon Lex uses to elicit a response from the
                *          user. </p>
                */
            createSlot(args: CreateSlotCommandInput, options?: __HttpHandlerOptions): Promise<CreateSlotCommandOutput>;
            createSlot(args: CreateSlotCommandInput, cb: (err: any, data?: CreateSlotCommandOutput) => void): void;
            createSlot(args: CreateSlotCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateSlotCommandOutput) => void): void;
            /**
                * <p>Creates a custom slot type</p>
                *          <p> To create a custom slot type, specify a name for the slot type and
                *          a set of enumeration values, the values that a slot of this type can
                *          assume. </p>
                */
            createSlotType(args: CreateSlotTypeCommandInput, options?: __HttpHandlerOptions): Promise<CreateSlotTypeCommandOutput>;
            createSlotType(args: CreateSlotTypeCommandInput, cb: (err: any, data?: CreateSlotTypeCommandOutput) => void): void;
            createSlotType(args: CreateSlotTypeCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateSlotTypeCommandOutput) => void): void;
            /**
                * <p>Gets a pre-signed S3 write URL that you use to upload the zip
                *          archive when importing a bot or a bot locale. </p>
                */
            createUploadUrl(args: CreateUploadUrlCommandInput, options?: __HttpHandlerOptions): Promise<CreateUploadUrlCommandOutput>;
            createUploadUrl(args: CreateUploadUrlCommandInput, cb: (err: any, data?: CreateUploadUrlCommandOutput) => void): void;
            createUploadUrl(args: CreateUploadUrlCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateUploadUrlCommandOutput) => void): void;
            /**
                * <p>Deletes all versions of a bot, including the <code>Draft</code>
                *          version. To delete a specific version, use the
                *             <code>DeleteBotVersion</code> operation.</p>
                *          <p>When you delete a bot, all of the resources contained in the bot are
                *          also deleted. Deleting a bot removes all locales, intents, slot, and
                *          slot types defined for the bot.</p>
                *          <p>If a bot has an alias, the <code>DeleteBot</code> operation returns
                *          a <code>ResourceInUseException</code> exception. If you want to delete
                *          the bot and the alias, set the <code>skipResourceInUseCheck</code>
                *          parameter to <code>true</code>.</p>
                */
            deleteBot(args: DeleteBotCommandInput, options?: __HttpHandlerOptions): Promise<DeleteBotCommandOutput>;
            deleteBot(args: DeleteBotCommandInput, cb: (err: any, data?: DeleteBotCommandOutput) => void): void;
            deleteBot(args: DeleteBotCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteBotCommandOutput) => void): void;
            /**
                * <p>Deletes the specified bot alias.</p>
                */
            deleteBotAlias(args: DeleteBotAliasCommandInput, options?: __HttpHandlerOptions): Promise<DeleteBotAliasCommandOutput>;
            deleteBotAlias(args: DeleteBotAliasCommandInput, cb: (err: any, data?: DeleteBotAliasCommandOutput) => void): void;
            deleteBotAlias(args: DeleteBotAliasCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteBotAliasCommandOutput) => void): void;
            /**
                * <p>Removes a locale from a bot.</p>
                *          <p>When you delete a locale, all intents, slots, and slot types defined
                *          for the locale are also deleted.</p>
                */
            deleteBotLocale(args: DeleteBotLocaleCommandInput, options?: __HttpHandlerOptions): Promise<DeleteBotLocaleCommandOutput>;
            deleteBotLocale(args: DeleteBotLocaleCommandInput, cb: (err: any, data?: DeleteBotLocaleCommandOutput) => void): void;
            deleteBotLocale(args: DeleteBotLocaleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteBotLocaleCommandOutput) => void): void;
            /**
                * <p>Deletes a specific version of a bot. To delete all version of a bot,
                *          use the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_DeleteBot.html">DeleteBot</a> operation.</p>
                */
            deleteBotVersion(args: DeleteBotVersionCommandInput, options?: __HttpHandlerOptions): Promise<DeleteBotVersionCommandOutput>;
            deleteBotVersion(args: DeleteBotVersionCommandInput, cb: (err: any, data?: DeleteBotVersionCommandOutput) => void): void;
            deleteBotVersion(args: DeleteBotVersionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteBotVersionCommandOutput) => void): void;
            /**
                * <p>Removes a custom vocabulary from the specified locale
                *       in the specified bot.</p>
                */
            deleteCustomVocabulary(args: DeleteCustomVocabularyCommandInput, options?: __HttpHandlerOptions): Promise<DeleteCustomVocabularyCommandOutput>;
            deleteCustomVocabulary(args: DeleteCustomVocabularyCommandInput, cb: (err: any, data?: DeleteCustomVocabularyCommandOutput) => void): void;
            deleteCustomVocabulary(args: DeleteCustomVocabularyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteCustomVocabularyCommandOutput) => void): void;
            /**
                * <p>Removes a previous export and the associated files stored in an S3
                *          bucket.</p>
                */
            deleteExport(args: DeleteExportCommandInput, options?: __HttpHandlerOptions): Promise<DeleteExportCommandOutput>;
            deleteExport(args: DeleteExportCommandInput, cb: (err: any, data?: DeleteExportCommandOutput) => void): void;
            deleteExport(args: DeleteExportCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteExportCommandOutput) => void): void;
            /**
                * <p>Removes a previous import and the associated file stored in an S3
                *          bucket.</p>
                */
            deleteImport(args: DeleteImportCommandInput, options?: __HttpHandlerOptions): Promise<DeleteImportCommandOutput>;
            deleteImport(args: DeleteImportCommandInput, cb: (err: any, data?: DeleteImportCommandOutput) => void): void;
            deleteImport(args: DeleteImportCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteImportCommandOutput) => void): void;
            /**
                * <p>Removes the specified intent.</p>
                *          <p>Deleting an intent also deletes the slots associated with the
                *          intent.</p>
                */
            deleteIntent(args: DeleteIntentCommandInput, options?: __HttpHandlerOptions): Promise<DeleteIntentCommandOutput>;
            deleteIntent(args: DeleteIntentCommandInput, cb: (err: any, data?: DeleteIntentCommandOutput) => void): void;
            deleteIntent(args: DeleteIntentCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteIntentCommandOutput) => void): void;
            /**
                * <p>Removes an existing policy from a bot or bot alias. If the resource
                *          doesn't have a policy attached, Amazon Lex returns an exception.</p>
                */
            deleteResourcePolicy(args: DeleteResourcePolicyCommandInput, options?: __HttpHandlerOptions): Promise<DeleteResourcePolicyCommandOutput>;
            deleteResourcePolicy(args: DeleteResourcePolicyCommandInput, cb: (err: any, data?: DeleteResourcePolicyCommandOutput) => void): void;
            deleteResourcePolicy(args: DeleteResourcePolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteResourcePolicyCommandOutput) => void): void;
            /**
                * <p>Deletes a policy statement from a resource policy. If you delete the
                *          last statement from a policy, the policy is deleted. If you specify a
                *          statement ID that doesn't exist in the policy, or if the bot or bot
                *          alias doesn't have a policy attached, Amazon Lex returns an
                *          exception.</p>
                */
            deleteResourcePolicyStatement(args: DeleteResourcePolicyStatementCommandInput, options?: __HttpHandlerOptions): Promise<DeleteResourcePolicyStatementCommandOutput>;
            deleteResourcePolicyStatement(args: DeleteResourcePolicyStatementCommandInput, cb: (err: any, data?: DeleteResourcePolicyStatementCommandOutput) => void): void;
            deleteResourcePolicyStatement(args: DeleteResourcePolicyStatementCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteResourcePolicyStatementCommandOutput) => void): void;
            /**
                * <p>Deletes the specified slot from an intent.</p>
                */
            deleteSlot(args: DeleteSlotCommandInput, options?: __HttpHandlerOptions): Promise<DeleteSlotCommandOutput>;
            deleteSlot(args: DeleteSlotCommandInput, cb: (err: any, data?: DeleteSlotCommandOutput) => void): void;
            deleteSlot(args: DeleteSlotCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteSlotCommandOutput) => void): void;
            /**
                * <p>Deletes a slot type from a bot locale.</p>
                *          <p>If a slot is using the slot type, Amazon Lex throws a
                *             <code>ResourceInUseException</code> exception. To avoid the
                *          exception, set the <code>skipResourceInUseCheck</code> parameter to
                *             <code>true</code>.</p>
                */
            deleteSlotType(args: DeleteSlotTypeCommandInput, options?: __HttpHandlerOptions): Promise<DeleteSlotTypeCommandOutput>;
            deleteSlotType(args: DeleteSlotTypeCommandInput, cb: (err: any, data?: DeleteSlotTypeCommandOutput) => void): void;
            deleteSlotType(args: DeleteSlotTypeCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteSlotTypeCommandOutput) => void): void;
            /**
                * <p>Deletes stored utterances.</p>
                *          <p>Amazon Lex stores the utterances that users send to your bot. Utterances
                *          are stored for 15 days for use with the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_ListAggregatedUtterances.html">ListAggregatedUtterances</a> operation, and
                *          then stored indefinitely for use in improving the ability of your bot
                *          to respond to user input..</p>
                *          <p>Use the <code>DeleteUtterances</code> operation to manually delete
                *          utterances for a specific session. When you use the
                *             <code>DeleteUtterances</code> operation, utterances stored for
                *          improving your bot's ability to respond to user input are deleted
                *          immediately. Utterances stored for use with the
                *             <code>ListAggregatedUtterances</code> operation are deleted after 15
                *          days.</p>
                */
            deleteUtterances(args: DeleteUtterancesCommandInput, options?: __HttpHandlerOptions): Promise<DeleteUtterancesCommandOutput>;
            deleteUtterances(args: DeleteUtterancesCommandInput, cb: (err: any, data?: DeleteUtterancesCommandOutput) => void): void;
            deleteUtterances(args: DeleteUtterancesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteUtterancesCommandOutput) => void): void;
            /**
                * <p>Provides metadata information about a bot. </p>
                */
            describeBot(args: DescribeBotCommandInput, options?: __HttpHandlerOptions): Promise<DescribeBotCommandOutput>;
            describeBot(args: DescribeBotCommandInput, cb: (err: any, data?: DescribeBotCommandOutput) => void): void;
            describeBot(args: DescribeBotCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeBotCommandOutput) => void): void;
            /**
                * <p>Get information about a specific bot alias.</p>
                */
            describeBotAlias(args: DescribeBotAliasCommandInput, options?: __HttpHandlerOptions): Promise<DescribeBotAliasCommandOutput>;
            describeBotAlias(args: DescribeBotAliasCommandInput, cb: (err: any, data?: DescribeBotAliasCommandOutput) => void): void;
            describeBotAlias(args: DescribeBotAliasCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeBotAliasCommandOutput) => void): void;
            /**
                * <p>Describes the settings that a bot has for a specific locale. </p>
                */
            describeBotLocale(args: DescribeBotLocaleCommandInput, options?: __HttpHandlerOptions): Promise<DescribeBotLocaleCommandOutput>;
            describeBotLocale(args: DescribeBotLocaleCommandInput, cb: (err: any, data?: DescribeBotLocaleCommandOutput) => void): void;
            describeBotLocale(args: DescribeBotLocaleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeBotLocaleCommandOutput) => void): void;
            /**
                * <p>Provides metadata information about a bot recommendation. This
                *          information will enable you to get a description on the request inputs,
                *          to download associated transcripts after processing is complete, and to
                *          download intents and slot-types generated by the bot
                *          recommendation.</p>
                */
            describeBotRecommendation(args: DescribeBotRecommendationCommandInput, options?: __HttpHandlerOptions): Promise<DescribeBotRecommendationCommandOutput>;
            describeBotRecommendation(args: DescribeBotRecommendationCommandInput, cb: (err: any, data?: DescribeBotRecommendationCommandOutput) => void): void;
            describeBotRecommendation(args: DescribeBotRecommendationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeBotRecommendationCommandOutput) => void): void;
            /**
                * <p>Provides metadata about a version of a bot.</p>
                */
            describeBotVersion(args: DescribeBotVersionCommandInput, options?: __HttpHandlerOptions): Promise<DescribeBotVersionCommandOutput>;
            describeBotVersion(args: DescribeBotVersionCommandInput, cb: (err: any, data?: DescribeBotVersionCommandOutput) => void): void;
            describeBotVersion(args: DescribeBotVersionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeBotVersionCommandOutput) => void): void;
            /**
                * <p>Provides metadata information about a custom vocabulary.</p>
                */
            describeCustomVocabularyMetadata(args: DescribeCustomVocabularyMetadataCommandInput, options?: __HttpHandlerOptions): Promise<DescribeCustomVocabularyMetadataCommandOutput>;
            describeCustomVocabularyMetadata(args: DescribeCustomVocabularyMetadataCommandInput, cb: (err: any, data?: DescribeCustomVocabularyMetadataCommandOutput) => void): void;
            describeCustomVocabularyMetadata(args: DescribeCustomVocabularyMetadataCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeCustomVocabularyMetadataCommandOutput) => void): void;
            /**
                * <p>Gets information about a specific export.</p>
                */
            describeExport(args: DescribeExportCommandInput, options?: __HttpHandlerOptions): Promise<DescribeExportCommandOutput>;
            describeExport(args: DescribeExportCommandInput, cb: (err: any, data?: DescribeExportCommandOutput) => void): void;
            describeExport(args: DescribeExportCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeExportCommandOutput) => void): void;
            /**
                * <p>Gets information about a specific import.</p>
                */
            describeImport(args: DescribeImportCommandInput, options?: __HttpHandlerOptions): Promise<DescribeImportCommandOutput>;
            describeImport(args: DescribeImportCommandInput, cb: (err: any, data?: DescribeImportCommandOutput) => void): void;
            describeImport(args: DescribeImportCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeImportCommandOutput) => void): void;
            /**
                * <p>Returns metadata about an intent.</p>
                */
            describeIntent(args: DescribeIntentCommandInput, options?: __HttpHandlerOptions): Promise<DescribeIntentCommandOutput>;
            describeIntent(args: DescribeIntentCommandInput, cb: (err: any, data?: DescribeIntentCommandOutput) => void): void;
            describeIntent(args: DescribeIntentCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeIntentCommandOutput) => void): void;
            /**
                * <p>Gets the resource policy and policy revision for a bot or bot
                *          alias.</p>
                */
            describeResourcePolicy(args: DescribeResourcePolicyCommandInput, options?: __HttpHandlerOptions): Promise<DescribeResourcePolicyCommandOutput>;
            describeResourcePolicy(args: DescribeResourcePolicyCommandInput, cb: (err: any, data?: DescribeResourcePolicyCommandOutput) => void): void;
            describeResourcePolicy(args: DescribeResourcePolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeResourcePolicyCommandOutput) => void): void;
            /**
                * <p>Gets metadata information about a slot.</p>
                */
            describeSlot(args: DescribeSlotCommandInput, options?: __HttpHandlerOptions): Promise<DescribeSlotCommandOutput>;
            describeSlot(args: DescribeSlotCommandInput, cb: (err: any, data?: DescribeSlotCommandOutput) => void): void;
            describeSlot(args: DescribeSlotCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeSlotCommandOutput) => void): void;
            /**
                * <p>Gets metadata information about a slot type.</p>
                */
            describeSlotType(args: DescribeSlotTypeCommandInput, options?: __HttpHandlerOptions): Promise<DescribeSlotTypeCommandOutput>;
            describeSlotType(args: DescribeSlotTypeCommandInput, cb: (err: any, data?: DescribeSlotTypeCommandOutput) => void): void;
            describeSlotType(args: DescribeSlotTypeCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeSlotTypeCommandOutput) => void): void;
            /**
                * <p>Provides a list of utterances that users have sent to the
                *          bot.</p>
                *          <p>Utterances are aggregated by the text of the utterance. For example,
                *          all instances where customers used the phrase "I want to order pizza"
                *          are aggregated into the same line in the response.</p>
                *          <p>You can see both detected utterances and missed utterances. A
                *          detected utterance is where the bot properly recognized the utterance
                *          and activated the associated intent. A missed utterance was not
                *          recognized by the bot and didn't activate an intent.</p>
                *          <p>Utterances can be aggregated for a bot alias or for a bot version,
                *          but not both at the same time.</p>
                *          <p>Utterances statistics are not generated under the following
                *          conditions:</p>
                *          <ul>
                *             <li>
                *                <p>The <code>childDirected</code> field was set to true when the
                *                bot was created.</p>
                *             </li>
                *             <li>
                *                <p>You are using slot obfuscation with one or more slots.</p>
                *             </li>
                *             <li>
                *                <p>You opted out of participating in improving Amazon Lex.</p>
                *             </li>
                *          </ul>
                */
            listAggregatedUtterances(args: ListAggregatedUtterancesCommandInput, options?: __HttpHandlerOptions): Promise<ListAggregatedUtterancesCommandOutput>;
            listAggregatedUtterances(args: ListAggregatedUtterancesCommandInput, cb: (err: any, data?: ListAggregatedUtterancesCommandOutput) => void): void;
            listAggregatedUtterances(args: ListAggregatedUtterancesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListAggregatedUtterancesCommandOutput) => void): void;
            /**
                * <p>Gets a list of aliases for the specified bot.</p>
                */
            listBotAliases(args: ListBotAliasesCommandInput, options?: __HttpHandlerOptions): Promise<ListBotAliasesCommandOutput>;
            listBotAliases(args: ListBotAliasesCommandInput, cb: (err: any, data?: ListBotAliasesCommandOutput) => void): void;
            listBotAliases(args: ListBotAliasesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListBotAliasesCommandOutput) => void): void;
            /**
                * <p>Gets a list of locales for the specified bot.</p>
                */
            listBotLocales(args: ListBotLocalesCommandInput, options?: __HttpHandlerOptions): Promise<ListBotLocalesCommandOutput>;
            listBotLocales(args: ListBotLocalesCommandInput, cb: (err: any, data?: ListBotLocalesCommandOutput) => void): void;
            listBotLocales(args: ListBotLocalesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListBotLocalesCommandOutput) => void): void;
            /**
                * <p>Get a list of bot recommendations that meet the specified
                *          criteria.</p>
                */
            listBotRecommendations(args: ListBotRecommendationsCommandInput, options?: __HttpHandlerOptions): Promise<ListBotRecommendationsCommandOutput>;
            listBotRecommendations(args: ListBotRecommendationsCommandInput, cb: (err: any, data?: ListBotRecommendationsCommandOutput) => void): void;
            listBotRecommendations(args: ListBotRecommendationsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListBotRecommendationsCommandOutput) => void): void;
            /**
                * <p>Gets a list of available bots.</p>
                */
            listBots(args: ListBotsCommandInput, options?: __HttpHandlerOptions): Promise<ListBotsCommandOutput>;
            listBots(args: ListBotsCommandInput, cb: (err: any, data?: ListBotsCommandOutput) => void): void;
            listBots(args: ListBotsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListBotsCommandOutput) => void): void;
            /**
                * <p>Gets information about all of the versions of a bot.</p>
                *          <p>The <code>ListBotVersions</code> operation returns a summary of each
                *          version of a bot. For example, if a bot has three numbered versions,
                *          the <code>ListBotVersions</code> operation returns for summaries, one
                *          for each numbered version and one for the <code>DRAFT</code>
                *          version.</p>
                *          <p>The <code>ListBotVersions</code> operation always returns at least
                *          one version, the <code>DRAFT</code> version.</p>
                */
            listBotVersions(args: ListBotVersionsCommandInput, options?: __HttpHandlerOptions): Promise<ListBotVersionsCommandOutput>;
            listBotVersions(args: ListBotVersionsCommandInput, cb: (err: any, data?: ListBotVersionsCommandOutput) => void): void;
            listBotVersions(args: ListBotVersionsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListBotVersionsCommandOutput) => void): void;
            /**
                * <p>Gets a list of built-in intents provided by Amazon Lex that you can use
                *          in your bot. </p>
                *          <p>To use a built-in intent as a the base for your own intent, include
                *          the built-in intent signature in the <code>parentIntentSignature</code>
                *          parameter when you call the <code>CreateIntent</code> operation. For
                *          more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_CreateIntent.html">CreateIntent</a>.</p>
                */
            listBuiltInIntents(args: ListBuiltInIntentsCommandInput, options?: __HttpHandlerOptions): Promise<ListBuiltInIntentsCommandOutput>;
            listBuiltInIntents(args: ListBuiltInIntentsCommandInput, cb: (err: any, data?: ListBuiltInIntentsCommandOutput) => void): void;
            listBuiltInIntents(args: ListBuiltInIntentsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListBuiltInIntentsCommandOutput) => void): void;
            /**
                * <p>Gets a list of built-in slot types that meet the specified
                *          criteria.</p>
                */
            listBuiltInSlotTypes(args: ListBuiltInSlotTypesCommandInput, options?: __HttpHandlerOptions): Promise<ListBuiltInSlotTypesCommandOutput>;
            listBuiltInSlotTypes(args: ListBuiltInSlotTypesCommandInput, cb: (err: any, data?: ListBuiltInSlotTypesCommandOutput) => void): void;
            listBuiltInSlotTypes(args: ListBuiltInSlotTypesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListBuiltInSlotTypesCommandOutput) => void): void;
            /**
                * <p>Lists the exports for a bot, bot locale, or custom vocabulary.
                *          Exports are kept in the list for 7 days.</p>
                */
            listExports(args: ListExportsCommandInput, options?: __HttpHandlerOptions): Promise<ListExportsCommandOutput>;
            listExports(args: ListExportsCommandInput, cb: (err: any, data?: ListExportsCommandOutput) => void): void;
            listExports(args: ListExportsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListExportsCommandOutput) => void): void;
            /**
                * <p>Lists the imports for a bot, bot locale, or custom vocabulary.
                *          Imports are kept in the list for 7 days.</p>
                */
            listImports(args: ListImportsCommandInput, options?: __HttpHandlerOptions): Promise<ListImportsCommandOutput>;
            listImports(args: ListImportsCommandInput, cb: (err: any, data?: ListImportsCommandOutput) => void): void;
            listImports(args: ListImportsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListImportsCommandOutput) => void): void;
            /**
                * <p>Get a list of intents that meet the specified criteria.</p>
                */
            listIntents(args: ListIntentsCommandInput, options?: __HttpHandlerOptions): Promise<ListIntentsCommandOutput>;
            listIntents(args: ListIntentsCommandInput, cb: (err: any, data?: ListIntentsCommandOutput) => void): void;
            listIntents(args: ListIntentsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListIntentsCommandOutput) => void): void;
            /**
                * <p>Gets a list of recommended intents provided by the bot
                *          recommendation that you can use in your bot.</p>
                */
            listRecommendedIntents(args: ListRecommendedIntentsCommandInput, options?: __HttpHandlerOptions): Promise<ListRecommendedIntentsCommandOutput>;
            listRecommendedIntents(args: ListRecommendedIntentsCommandInput, cb: (err: any, data?: ListRecommendedIntentsCommandOutput) => void): void;
            listRecommendedIntents(args: ListRecommendedIntentsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListRecommendedIntentsCommandOutput) => void): void;
            /**
                * <p>Gets a list of slots that match the specified criteria.</p>
                */
            listSlots(args: ListSlotsCommandInput, options?: __HttpHandlerOptions): Promise<ListSlotsCommandOutput>;
            listSlots(args: ListSlotsCommandInput, cb: (err: any, data?: ListSlotsCommandOutput) => void): void;
            listSlots(args: ListSlotsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListSlotsCommandOutput) => void): void;
            /**
                * <p>Gets a list of slot types that match the specified criteria.</p>
                */
            listSlotTypes(args: ListSlotTypesCommandInput, options?: __HttpHandlerOptions): Promise<ListSlotTypesCommandOutput>;
            listSlotTypes(args: ListSlotTypesCommandInput, cb: (err: any, data?: ListSlotTypesCommandOutput) => void): void;
            listSlotTypes(args: ListSlotTypesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListSlotTypesCommandOutput) => void): void;
            /**
                * <p>Gets a list of tags associated with a resource. Only bots, bot
                *          aliases, and bot channels can have tags associated with them.</p>
                */
            listTagsForResource(args: ListTagsForResourceCommandInput, options?: __HttpHandlerOptions): Promise<ListTagsForResourceCommandOutput>;
            listTagsForResource(args: ListTagsForResourceCommandInput, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            listTagsForResource(args: ListTagsForResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            /**
                * <p>Search for associated transcripts that meet the specified
                *          criteria.</p>
                */
            searchAssociatedTranscripts(args: SearchAssociatedTranscriptsCommandInput, options?: __HttpHandlerOptions): Promise<SearchAssociatedTranscriptsCommandOutput>;
            searchAssociatedTranscripts(args: SearchAssociatedTranscriptsCommandInput, cb: (err: any, data?: SearchAssociatedTranscriptsCommandOutput) => void): void;
            searchAssociatedTranscripts(args: SearchAssociatedTranscriptsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: SearchAssociatedTranscriptsCommandOutput) => void): void;
            /**
                * <p>Use this to provide your transcript data, and to start the bot
                *          recommendation process.</p>
                */
            startBotRecommendation(args: StartBotRecommendationCommandInput, options?: __HttpHandlerOptions): Promise<StartBotRecommendationCommandOutput>;
            startBotRecommendation(args: StartBotRecommendationCommandInput, cb: (err: any, data?: StartBotRecommendationCommandOutput) => void): void;
            startBotRecommendation(args: StartBotRecommendationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: StartBotRecommendationCommandOutput) => void): void;
            /**
                * <p>Starts importing a bot, bot locale, or custom vocabulary from a zip
                *          archive that you uploaded to an S3 bucket.</p>
                */
            startImport(args: StartImportCommandInput, options?: __HttpHandlerOptions): Promise<StartImportCommandOutput>;
            startImport(args: StartImportCommandInput, cb: (err: any, data?: StartImportCommandOutput) => void): void;
            startImport(args: StartImportCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: StartImportCommandOutput) => void): void;
            /**
                * <p>Adds the specified tags to the specified resource. If a tag key
                *          already exists, the existing value is replaced with the new
                *          value.</p>
                */
            tagResource(args: TagResourceCommandInput, options?: __HttpHandlerOptions): Promise<TagResourceCommandOutput>;
            tagResource(args: TagResourceCommandInput, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            tagResource(args: TagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            /**
                * <p>Removes tags from a bot, bot alias, or bot channel.</p>
                */
            untagResource(args: UntagResourceCommandInput, options?: __HttpHandlerOptions): Promise<UntagResourceCommandOutput>;
            untagResource(args: UntagResourceCommandInput, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            untagResource(args: UntagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            /**
                * <p>Updates the configuration of an existing bot. </p>
                */
            updateBot(args: UpdateBotCommandInput, options?: __HttpHandlerOptions): Promise<UpdateBotCommandOutput>;
            updateBot(args: UpdateBotCommandInput, cb: (err: any, data?: UpdateBotCommandOutput) => void): void;
            updateBot(args: UpdateBotCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateBotCommandOutput) => void): void;
            /**
                * <p>Updates the configuration of an existing bot alias.</p>
                */
            updateBotAlias(args: UpdateBotAliasCommandInput, options?: __HttpHandlerOptions): Promise<UpdateBotAliasCommandOutput>;
            updateBotAlias(args: UpdateBotAliasCommandInput, cb: (err: any, data?: UpdateBotAliasCommandOutput) => void): void;
            updateBotAlias(args: UpdateBotAliasCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateBotAliasCommandOutput) => void): void;
            /**
                * <p>Updates the settings that a bot has for a specific locale.</p>
                */
            updateBotLocale(args: UpdateBotLocaleCommandInput, options?: __HttpHandlerOptions): Promise<UpdateBotLocaleCommandOutput>;
            updateBotLocale(args: UpdateBotLocaleCommandInput, cb: (err: any, data?: UpdateBotLocaleCommandOutput) => void): void;
            updateBotLocale(args: UpdateBotLocaleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateBotLocaleCommandOutput) => void): void;
            /**
                * <p>Updates an existing bot recommendation request.</p>
                */
            updateBotRecommendation(args: UpdateBotRecommendationCommandInput, options?: __HttpHandlerOptions): Promise<UpdateBotRecommendationCommandOutput>;
            updateBotRecommendation(args: UpdateBotRecommendationCommandInput, cb: (err: any, data?: UpdateBotRecommendationCommandOutput) => void): void;
            updateBotRecommendation(args: UpdateBotRecommendationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateBotRecommendationCommandOutput) => void): void;
            /**
                * <p>Updates the password used to protect an export zip archive.</p>
                *          <p>The password is not required. If you don't supply a password, Amazon Lex
                *          generates a zip file that is not protected by a password. This is the
                *          archive that is available at the pre-signed S3 URL provided by the
                *             <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_DescribeExport.html">DescribeExport</a> operation.</p>
                */
            updateExport(args: UpdateExportCommandInput, options?: __HttpHandlerOptions): Promise<UpdateExportCommandOutput>;
            updateExport(args: UpdateExportCommandInput, cb: (err: any, data?: UpdateExportCommandOutput) => void): void;
            updateExport(args: UpdateExportCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateExportCommandOutput) => void): void;
            /**
                * <p>Updates the settings for an intent.</p>
                */
            updateIntent(args: UpdateIntentCommandInput, options?: __HttpHandlerOptions): Promise<UpdateIntentCommandOutput>;
            updateIntent(args: UpdateIntentCommandInput, cb: (err: any, data?: UpdateIntentCommandOutput) => void): void;
            updateIntent(args: UpdateIntentCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateIntentCommandOutput) => void): void;
            /**
                * <p>Replaces the existing resource policy for a bot or bot alias with a
                *          new one. If the policy doesn't exist, Amazon Lex returns an
                *          exception.</p>
                */
            updateResourcePolicy(args: UpdateResourcePolicyCommandInput, options?: __HttpHandlerOptions): Promise<UpdateResourcePolicyCommandOutput>;
            updateResourcePolicy(args: UpdateResourcePolicyCommandInput, cb: (err: any, data?: UpdateResourcePolicyCommandOutput) => void): void;
            updateResourcePolicy(args: UpdateResourcePolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateResourcePolicyCommandOutput) => void): void;
            /**
                * <p>Updates the settings for a slot.</p>
                */
            updateSlot(args: UpdateSlotCommandInput, options?: __HttpHandlerOptions): Promise<UpdateSlotCommandOutput>;
            updateSlot(args: UpdateSlotCommandInput, cb: (err: any, data?: UpdateSlotCommandOutput) => void): void;
            updateSlot(args: UpdateSlotCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateSlotCommandOutput) => void): void;
            /**
                * <p>Updates the configuration of an existing slot type.</p>
                */
            updateSlotType(args: UpdateSlotTypeCommandInput, options?: __HttpHandlerOptions): Promise<UpdateSlotTypeCommandOutput>;
            updateSlotType(args: UpdateSlotTypeCommandInput, cb: (err: any, data?: UpdateSlotTypeCommandOutput) => void): void;
            updateSlotType(args: UpdateSlotTypeCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateSlotTypeCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/BuildBotLocaleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { BuildBotLocaleRequest, BuildBotLocaleResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface BuildBotLocaleCommandInput extends BuildBotLocaleRequest {
    }
    export interface BuildBotLocaleCommandOutput extends BuildBotLocaleResponse, __MetadataBearer {
    }
    /**
        * <p>Builds a bot, its intents, and its slot types into a specific
        *          locale. A bot can be built into multiple locales. At runtime the locale
        *          is used to choose a specific build of the bot.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, BuildBotLocaleCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, BuildBotLocaleCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new BuildBotLocaleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BuildBotLocaleCommandInput} for command's `input` shape.
        * @see {@link BuildBotLocaleCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class BuildBotLocaleCommand extends $Command<BuildBotLocaleCommandInput, BuildBotLocaleCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: BuildBotLocaleCommandInput;
            constructor(input: BuildBotLocaleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BuildBotLocaleCommandInput, BuildBotLocaleCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateBotAliasCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { CreateBotAliasRequest, CreateBotAliasResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface CreateBotAliasCommandInput extends CreateBotAliasRequest {
    }
    export interface CreateBotAliasCommandOutput extends CreateBotAliasResponse, __MetadataBearer {
    }
    /**
        * <p>Creates an alias for the specified version of a bot. Use an alias to
        *          enable you to change the version of a bot without updating applications
        *          that use the bot.</p>
        *          <p>For example, you can create an alias called "PROD" that your
        *          applications use to call the Amazon Lex bot. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, CreateBotAliasCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, CreateBotAliasCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new CreateBotAliasCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateBotAliasCommandInput} for command's `input` shape.
        * @see {@link CreateBotAliasCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class CreateBotAliasCommand extends $Command<CreateBotAliasCommandInput, CreateBotAliasCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: CreateBotAliasCommandInput;
            constructor(input: CreateBotAliasCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateBotAliasCommandInput, CreateBotAliasCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateBotCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { CreateBotRequest, CreateBotResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface CreateBotCommandInput extends CreateBotRequest {
    }
    export interface CreateBotCommandOutput extends CreateBotResponse, __MetadataBearer {
    }
    /**
        * <p>Creates an Amazon Lex conversational bot. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, CreateBotCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, CreateBotCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new CreateBotCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateBotCommandInput} for command's `input` shape.
        * @see {@link CreateBotCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class CreateBotCommand extends $Command<CreateBotCommandInput, CreateBotCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: CreateBotCommandInput;
            constructor(input: CreateBotCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateBotCommandInput, CreateBotCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateBotLocaleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { CreateBotLocaleRequest, CreateBotLocaleResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface CreateBotLocaleCommandInput extends CreateBotLocaleRequest {
    }
    export interface CreateBotLocaleCommandOutput extends CreateBotLocaleResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a locale in the bot. The locale contains the intents and
        *          slot types that the bot uses in conversations with users in the
        *          specified language and locale. You must add a locale to a bot before
        *          you can add intents and slot types to the bot.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, CreateBotLocaleCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, CreateBotLocaleCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new CreateBotLocaleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateBotLocaleCommandInput} for command's `input` shape.
        * @see {@link CreateBotLocaleCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class CreateBotLocaleCommand extends $Command<CreateBotLocaleCommandInput, CreateBotLocaleCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: CreateBotLocaleCommandInput;
            constructor(input: CreateBotLocaleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateBotLocaleCommandInput, CreateBotLocaleCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateBotVersionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { CreateBotVersionRequest, CreateBotVersionResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface CreateBotVersionCommandInput extends CreateBotVersionRequest {
    }
    export interface CreateBotVersionCommandOutput extends CreateBotVersionResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a new version of the bot based on the <code>DRAFT</code>
        *          version. If the <code>DRAFT</code> version of this resource hasn't
        *          changed since you created the last version, Amazon Lex doesn't create a new
        *          version, it returns the last created version.</p>
        *          <p>When you create the first version of a bot, Amazon Lex sets the version
        *          to 1. Subsequent versions increment by 1.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, CreateBotVersionCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, CreateBotVersionCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new CreateBotVersionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateBotVersionCommandInput} for command's `input` shape.
        * @see {@link CreateBotVersionCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class CreateBotVersionCommand extends $Command<CreateBotVersionCommandInput, CreateBotVersionCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: CreateBotVersionCommandInput;
            constructor(input: CreateBotVersionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateBotVersionCommandInput, CreateBotVersionCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateExportCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { CreateExportRequest, CreateExportResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface CreateExportCommandInput extends CreateExportRequest {
    }
    export interface CreateExportCommandOutput extends CreateExportResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a zip archive containing the contents of a bot or a bot
        *          locale. The archive contains a directory structure that contains JSON
        *          files that define the bot.</p>
        *          <p>You can create an archive that contains the complete definition of a
        *          bot, or you can specify that the archive contain only the definition of
        *          a single bot locale.</p>
        *          <p>For more information about exporting bots, and about the structure
        *          of the export archive, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/importing-exporting.html"> Importing and
        *             exporting bots </a>
        *          </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, CreateExportCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, CreateExportCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new CreateExportCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateExportCommandInput} for command's `input` shape.
        * @see {@link CreateExportCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class CreateExportCommand extends $Command<CreateExportCommandInput, CreateExportCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: CreateExportCommandInput;
            constructor(input: CreateExportCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateExportCommandInput, CreateExportCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateIntentCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { CreateIntentRequest, CreateIntentResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface CreateIntentCommandInput extends CreateIntentRequest {
    }
    export interface CreateIntentCommandOutput extends CreateIntentResponse, __MetadataBearer {
    }
    /**
        * <p>Creates an intent.</p>
        *          <p>To define the interaction between the user and your bot, you define
        *          one or more intents. For example, for a pizza ordering bot you would
        *          create an <code>OrderPizza</code> intent.</p>
        *          <p>When you create an intent, you must provide a name. You can
        *          optionally provide the following:</p>
        *          <ul>
        *             <li>
        *                <p>Sample utterances. For example, "I want to order a pizza" and
        *                "Can I order a pizza." You can't provide utterances for built-in
        *                intents.</p>
        *             </li>
        *             <li>
        *                <p>Information to be gathered. You specify slots for the
        *                information that you bot requests from the user. You can specify
        *                standard slot types, such as date and time, or custom slot types
        *                for your application.</p>
        *             </li>
        *             <li>
        *                <p>How the intent is fulfilled. You can provide a Lambda function
        *                or configure the intent to return the intent information to your
        *                client application. If you use a Lambda function, Amazon Lex invokes
        *                the function when all of the intent information is
        *                available.</p>
        *             </li>
        *             <li>
        *                <p>A confirmation prompt to send to the user to confirm an
        *                intent. For example, "Shall I order your pizza?"</p>
        *             </li>
        *             <li>
        *                <p>A conclusion statement to send to the user after the intent is
        *                fulfilled. For example, "I ordered your pizza."</p>
        *             </li>
        *             <li>
        *                <p>A follow-up prompt that asks the user for additional activity.
        *                For example, "Do you want a drink with your pizza?"</p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, CreateIntentCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, CreateIntentCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new CreateIntentCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateIntentCommandInput} for command's `input` shape.
        * @see {@link CreateIntentCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class CreateIntentCommand extends $Command<CreateIntentCommandInput, CreateIntentCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: CreateIntentCommandInput;
            constructor(input: CreateIntentCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateIntentCommandInput, CreateIntentCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateResourcePolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { CreateResourcePolicyRequest, CreateResourcePolicyResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface CreateResourcePolicyCommandInput extends CreateResourcePolicyRequest {
    }
    export interface CreateResourcePolicyCommandOutput extends CreateResourcePolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a new resource policy with the specified policy
        *          statements.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, CreateResourcePolicyCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, CreateResourcePolicyCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new CreateResourcePolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateResourcePolicyCommandInput} for command's `input` shape.
        * @see {@link CreateResourcePolicyCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class CreateResourcePolicyCommand extends $Command<CreateResourcePolicyCommandInput, CreateResourcePolicyCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: CreateResourcePolicyCommandInput;
            constructor(input: CreateResourcePolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateResourcePolicyCommandInput, CreateResourcePolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateResourcePolicyStatementCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { CreateResourcePolicyStatementRequest, CreateResourcePolicyStatementResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface CreateResourcePolicyStatementCommandInput extends CreateResourcePolicyStatementRequest {
    }
    export interface CreateResourcePolicyStatementCommandOutput extends CreateResourcePolicyStatementResponse, __MetadataBearer {
    }
    /**
        * <p>Adds a new resource policy statement to a bot or bot alias. If a
        *          resource policy exists, the statement is added to the current resource
        *          policy. If a policy doesn't exist, a new policy is created.</p>
        *          <p>You can't create a resource policy statement that allows
        *          cross-account access.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, CreateResourcePolicyStatementCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, CreateResourcePolicyStatementCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new CreateResourcePolicyStatementCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateResourcePolicyStatementCommandInput} for command's `input` shape.
        * @see {@link CreateResourcePolicyStatementCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class CreateResourcePolicyStatementCommand extends $Command<CreateResourcePolicyStatementCommandInput, CreateResourcePolicyStatementCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: CreateResourcePolicyStatementCommandInput;
            constructor(input: CreateResourcePolicyStatementCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateResourcePolicyStatementCommandInput, CreateResourcePolicyStatementCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateSlotCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { CreateSlotRequest, CreateSlotResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface CreateSlotCommandInput extends CreateSlotRequest {
    }
    export interface CreateSlotCommandOutput extends CreateSlotResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a slot in an intent. A slot is a variable needed to fulfill
        *          an intent. For example, an <code>OrderPizza</code> intent might need
        *          slots for size, crust, and number of pizzas. For each slot, you define
        *          one or more utterances that Amazon Lex uses to elicit a response from the
        *          user. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, CreateSlotCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, CreateSlotCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new CreateSlotCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateSlotCommandInput} for command's `input` shape.
        * @see {@link CreateSlotCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class CreateSlotCommand extends $Command<CreateSlotCommandInput, CreateSlotCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: CreateSlotCommandInput;
            constructor(input: CreateSlotCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateSlotCommandInput, CreateSlotCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateSlotTypeCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { CreateSlotTypeRequest, CreateSlotTypeResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface CreateSlotTypeCommandInput extends CreateSlotTypeRequest {
    }
    export interface CreateSlotTypeCommandOutput extends CreateSlotTypeResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a custom slot type</p>
        *          <p> To create a custom slot type, specify a name for the slot type and
        *          a set of enumeration values, the values that a slot of this type can
        *          assume. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, CreateSlotTypeCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, CreateSlotTypeCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new CreateSlotTypeCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateSlotTypeCommandInput} for command's `input` shape.
        * @see {@link CreateSlotTypeCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class CreateSlotTypeCommand extends $Command<CreateSlotTypeCommandInput, CreateSlotTypeCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: CreateSlotTypeCommandInput;
            constructor(input: CreateSlotTypeCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateSlotTypeCommandInput, CreateSlotTypeCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateUploadUrlCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { CreateUploadUrlRequest, CreateUploadUrlResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface CreateUploadUrlCommandInput extends CreateUploadUrlRequest {
    }
    export interface CreateUploadUrlCommandOutput extends CreateUploadUrlResponse, __MetadataBearer {
    }
    /**
        * <p>Gets a pre-signed S3 write URL that you use to upload the zip
        *          archive when importing a bot or a bot locale. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, CreateUploadUrlCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, CreateUploadUrlCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new CreateUploadUrlCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateUploadUrlCommandInput} for command's `input` shape.
        * @see {@link CreateUploadUrlCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class CreateUploadUrlCommand extends $Command<CreateUploadUrlCommandInput, CreateUploadUrlCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: CreateUploadUrlCommandInput;
            constructor(input: CreateUploadUrlCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateUploadUrlCommandInput, CreateUploadUrlCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteBotAliasCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DeleteBotAliasRequest, DeleteBotAliasResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DeleteBotAliasCommandInput extends DeleteBotAliasRequest {
    }
    export interface DeleteBotAliasCommandOutput extends DeleteBotAliasResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes the specified bot alias.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DeleteBotAliasCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DeleteBotAliasCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DeleteBotAliasCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteBotAliasCommandInput} for command's `input` shape.
        * @see {@link DeleteBotAliasCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DeleteBotAliasCommand extends $Command<DeleteBotAliasCommandInput, DeleteBotAliasCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DeleteBotAliasCommandInput;
            constructor(input: DeleteBotAliasCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteBotAliasCommandInput, DeleteBotAliasCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteBotCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DeleteBotRequest, DeleteBotResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DeleteBotCommandInput extends DeleteBotRequest {
    }
    export interface DeleteBotCommandOutput extends DeleteBotResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes all versions of a bot, including the <code>Draft</code>
        *          version. To delete a specific version, use the
        *             <code>DeleteBotVersion</code> operation.</p>
        *          <p>When you delete a bot, all of the resources contained in the bot are
        *          also deleted. Deleting a bot removes all locales, intents, slot, and
        *          slot types defined for the bot.</p>
        *          <p>If a bot has an alias, the <code>DeleteBot</code> operation returns
        *          a <code>ResourceInUseException</code> exception. If you want to delete
        *          the bot and the alias, set the <code>skipResourceInUseCheck</code>
        *          parameter to <code>true</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DeleteBotCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DeleteBotCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DeleteBotCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteBotCommandInput} for command's `input` shape.
        * @see {@link DeleteBotCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DeleteBotCommand extends $Command<DeleteBotCommandInput, DeleteBotCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DeleteBotCommandInput;
            constructor(input: DeleteBotCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteBotCommandInput, DeleteBotCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteBotLocaleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DeleteBotLocaleRequest, DeleteBotLocaleResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DeleteBotLocaleCommandInput extends DeleteBotLocaleRequest {
    }
    export interface DeleteBotLocaleCommandOutput extends DeleteBotLocaleResponse, __MetadataBearer {
    }
    /**
        * <p>Removes a locale from a bot.</p>
        *          <p>When you delete a locale, all intents, slots, and slot types defined
        *          for the locale are also deleted.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DeleteBotLocaleCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DeleteBotLocaleCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DeleteBotLocaleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteBotLocaleCommandInput} for command's `input` shape.
        * @see {@link DeleteBotLocaleCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DeleteBotLocaleCommand extends $Command<DeleteBotLocaleCommandInput, DeleteBotLocaleCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DeleteBotLocaleCommandInput;
            constructor(input: DeleteBotLocaleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteBotLocaleCommandInput, DeleteBotLocaleCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteBotVersionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DeleteBotVersionRequest, DeleteBotVersionResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DeleteBotVersionCommandInput extends DeleteBotVersionRequest {
    }
    export interface DeleteBotVersionCommandOutput extends DeleteBotVersionResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes a specific version of a bot. To delete all version of a bot,
        *          use the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_DeleteBot.html">DeleteBot</a> operation.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DeleteBotVersionCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DeleteBotVersionCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DeleteBotVersionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteBotVersionCommandInput} for command's `input` shape.
        * @see {@link DeleteBotVersionCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DeleteBotVersionCommand extends $Command<DeleteBotVersionCommandInput, DeleteBotVersionCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DeleteBotVersionCommandInput;
            constructor(input: DeleteBotVersionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteBotVersionCommandInput, DeleteBotVersionCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteCustomVocabularyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DeleteCustomVocabularyRequest, DeleteCustomVocabularyResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DeleteCustomVocabularyCommandInput extends DeleteCustomVocabularyRequest {
    }
    export interface DeleteCustomVocabularyCommandOutput extends DeleteCustomVocabularyResponse, __MetadataBearer {
    }
    /**
        * <p>Removes a custom vocabulary from the specified locale
        *       in the specified bot.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DeleteCustomVocabularyCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DeleteCustomVocabularyCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DeleteCustomVocabularyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteCustomVocabularyCommandInput} for command's `input` shape.
        * @see {@link DeleteCustomVocabularyCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DeleteCustomVocabularyCommand extends $Command<DeleteCustomVocabularyCommandInput, DeleteCustomVocabularyCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DeleteCustomVocabularyCommandInput;
            constructor(input: DeleteCustomVocabularyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteCustomVocabularyCommandInput, DeleteCustomVocabularyCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteExportCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DeleteExportRequest, DeleteExportResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DeleteExportCommandInput extends DeleteExportRequest {
    }
    export interface DeleteExportCommandOutput extends DeleteExportResponse, __MetadataBearer {
    }
    /**
        * <p>Removes a previous export and the associated files stored in an S3
        *          bucket.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DeleteExportCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DeleteExportCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DeleteExportCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteExportCommandInput} for command's `input` shape.
        * @see {@link DeleteExportCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DeleteExportCommand extends $Command<DeleteExportCommandInput, DeleteExportCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DeleteExportCommandInput;
            constructor(input: DeleteExportCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteExportCommandInput, DeleteExportCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteImportCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DeleteImportRequest, DeleteImportResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DeleteImportCommandInput extends DeleteImportRequest {
    }
    export interface DeleteImportCommandOutput extends DeleteImportResponse, __MetadataBearer {
    }
    /**
        * <p>Removes a previous import and the associated file stored in an S3
        *          bucket.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DeleteImportCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DeleteImportCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DeleteImportCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteImportCommandInput} for command's `input` shape.
        * @see {@link DeleteImportCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DeleteImportCommand extends $Command<DeleteImportCommandInput, DeleteImportCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DeleteImportCommandInput;
            constructor(input: DeleteImportCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteImportCommandInput, DeleteImportCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteIntentCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DeleteIntentRequest } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DeleteIntentCommandInput extends DeleteIntentRequest {
    }
    export interface DeleteIntentCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Removes the specified intent.</p>
        *          <p>Deleting an intent also deletes the slots associated with the
        *          intent.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DeleteIntentCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DeleteIntentCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DeleteIntentCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteIntentCommandInput} for command's `input` shape.
        * @see {@link DeleteIntentCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DeleteIntentCommand extends $Command<DeleteIntentCommandInput, DeleteIntentCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DeleteIntentCommandInput;
            constructor(input: DeleteIntentCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteIntentCommandInput, DeleteIntentCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteResourcePolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DeleteResourcePolicyRequest, DeleteResourcePolicyResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DeleteResourcePolicyCommandInput extends DeleteResourcePolicyRequest {
    }
    export interface DeleteResourcePolicyCommandOutput extends DeleteResourcePolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Removes an existing policy from a bot or bot alias. If the resource
        *          doesn't have a policy attached, Amazon Lex returns an exception.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DeleteResourcePolicyCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DeleteResourcePolicyCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DeleteResourcePolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteResourcePolicyCommandInput} for command's `input` shape.
        * @see {@link DeleteResourcePolicyCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DeleteResourcePolicyCommand extends $Command<DeleteResourcePolicyCommandInput, DeleteResourcePolicyCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DeleteResourcePolicyCommandInput;
            constructor(input: DeleteResourcePolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteResourcePolicyCommandInput, DeleteResourcePolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteResourcePolicyStatementCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DeleteResourcePolicyStatementRequest, DeleteResourcePolicyStatementResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DeleteResourcePolicyStatementCommandInput extends DeleteResourcePolicyStatementRequest {
    }
    export interface DeleteResourcePolicyStatementCommandOutput extends DeleteResourcePolicyStatementResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes a policy statement from a resource policy. If you delete the
        *          last statement from a policy, the policy is deleted. If you specify a
        *          statement ID that doesn't exist in the policy, or if the bot or bot
        *          alias doesn't have a policy attached, Amazon Lex returns an
        *          exception.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DeleteResourcePolicyStatementCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DeleteResourcePolicyStatementCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DeleteResourcePolicyStatementCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteResourcePolicyStatementCommandInput} for command's `input` shape.
        * @see {@link DeleteResourcePolicyStatementCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DeleteResourcePolicyStatementCommand extends $Command<DeleteResourcePolicyStatementCommandInput, DeleteResourcePolicyStatementCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DeleteResourcePolicyStatementCommandInput;
            constructor(input: DeleteResourcePolicyStatementCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteResourcePolicyStatementCommandInput, DeleteResourcePolicyStatementCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteSlotCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DeleteSlotRequest } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DeleteSlotCommandInput extends DeleteSlotRequest {
    }
    export interface DeleteSlotCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes the specified slot from an intent.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DeleteSlotCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DeleteSlotCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DeleteSlotCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteSlotCommandInput} for command's `input` shape.
        * @see {@link DeleteSlotCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DeleteSlotCommand extends $Command<DeleteSlotCommandInput, DeleteSlotCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DeleteSlotCommandInput;
            constructor(input: DeleteSlotCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteSlotCommandInput, DeleteSlotCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteSlotTypeCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DeleteSlotTypeRequest } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DeleteSlotTypeCommandInput extends DeleteSlotTypeRequest {
    }
    export interface DeleteSlotTypeCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes a slot type from a bot locale.</p>
        *          <p>If a slot is using the slot type, Amazon Lex throws a
        *             <code>ResourceInUseException</code> exception. To avoid the
        *          exception, set the <code>skipResourceInUseCheck</code> parameter to
        *             <code>true</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DeleteSlotTypeCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DeleteSlotTypeCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DeleteSlotTypeCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteSlotTypeCommandInput} for command's `input` shape.
        * @see {@link DeleteSlotTypeCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DeleteSlotTypeCommand extends $Command<DeleteSlotTypeCommandInput, DeleteSlotTypeCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DeleteSlotTypeCommandInput;
            constructor(input: DeleteSlotTypeCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteSlotTypeCommandInput, DeleteSlotTypeCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteUtterancesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DeleteUtterancesRequest, DeleteUtterancesResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DeleteUtterancesCommandInput extends DeleteUtterancesRequest {
    }
    export interface DeleteUtterancesCommandOutput extends DeleteUtterancesResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes stored utterances.</p>
        *          <p>Amazon Lex stores the utterances that users send to your bot. Utterances
        *          are stored for 15 days for use with the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_ListAggregatedUtterances.html">ListAggregatedUtterances</a> operation, and
        *          then stored indefinitely for use in improving the ability of your bot
        *          to respond to user input..</p>
        *          <p>Use the <code>DeleteUtterances</code> operation to manually delete
        *          utterances for a specific session. When you use the
        *             <code>DeleteUtterances</code> operation, utterances stored for
        *          improving your bot's ability to respond to user input are deleted
        *          immediately. Utterances stored for use with the
        *             <code>ListAggregatedUtterances</code> operation are deleted after 15
        *          days.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DeleteUtterancesCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DeleteUtterancesCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DeleteUtterancesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteUtterancesCommandInput} for command's `input` shape.
        * @see {@link DeleteUtterancesCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DeleteUtterancesCommand extends $Command<DeleteUtterancesCommandInput, DeleteUtterancesCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DeleteUtterancesCommandInput;
            constructor(input: DeleteUtterancesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteUtterancesCommandInput, DeleteUtterancesCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeBotAliasCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DescribeBotAliasRequest, DescribeBotAliasResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DescribeBotAliasCommandInput extends DescribeBotAliasRequest {
    }
    export interface DescribeBotAliasCommandOutput extends DescribeBotAliasResponse, __MetadataBearer {
    }
    /**
        * <p>Get information about a specific bot alias.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DescribeBotAliasCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DescribeBotAliasCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DescribeBotAliasCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeBotAliasCommandInput} for command's `input` shape.
        * @see {@link DescribeBotAliasCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DescribeBotAliasCommand extends $Command<DescribeBotAliasCommandInput, DescribeBotAliasCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DescribeBotAliasCommandInput;
            constructor(input: DescribeBotAliasCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeBotAliasCommandInput, DescribeBotAliasCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeBotCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DescribeBotRequest, DescribeBotResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DescribeBotCommandInput extends DescribeBotRequest {
    }
    export interface DescribeBotCommandOutput extends DescribeBotResponse, __MetadataBearer {
    }
    /**
        * <p>Provides metadata information about a bot. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DescribeBotCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DescribeBotCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DescribeBotCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeBotCommandInput} for command's `input` shape.
        * @see {@link DescribeBotCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DescribeBotCommand extends $Command<DescribeBotCommandInput, DescribeBotCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DescribeBotCommandInput;
            constructor(input: DescribeBotCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeBotCommandInput, DescribeBotCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeBotLocaleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DescribeBotLocaleRequest, DescribeBotLocaleResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DescribeBotLocaleCommandInput extends DescribeBotLocaleRequest {
    }
    export interface DescribeBotLocaleCommandOutput extends DescribeBotLocaleResponse, __MetadataBearer {
    }
    /**
        * <p>Describes the settings that a bot has for a specific locale. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DescribeBotLocaleCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DescribeBotLocaleCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DescribeBotLocaleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeBotLocaleCommandInput} for command's `input` shape.
        * @see {@link DescribeBotLocaleCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DescribeBotLocaleCommand extends $Command<DescribeBotLocaleCommandInput, DescribeBotLocaleCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DescribeBotLocaleCommandInput;
            constructor(input: DescribeBotLocaleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeBotLocaleCommandInput, DescribeBotLocaleCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeBotRecommendationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DescribeBotRecommendationRequest, DescribeBotRecommendationResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DescribeBotRecommendationCommandInput extends DescribeBotRecommendationRequest {
    }
    export interface DescribeBotRecommendationCommandOutput extends DescribeBotRecommendationResponse, __MetadataBearer {
    }
    /**
        * <p>Provides metadata information about a bot recommendation. This
        *          information will enable you to get a description on the request inputs,
        *          to download associated transcripts after processing is complete, and to
        *          download intents and slot-types generated by the bot
        *          recommendation.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DescribeBotRecommendationCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DescribeBotRecommendationCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DescribeBotRecommendationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeBotRecommendationCommandInput} for command's `input` shape.
        * @see {@link DescribeBotRecommendationCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DescribeBotRecommendationCommand extends $Command<DescribeBotRecommendationCommandInput, DescribeBotRecommendationCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DescribeBotRecommendationCommandInput;
            constructor(input: DescribeBotRecommendationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeBotRecommendationCommandInput, DescribeBotRecommendationCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeBotVersionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DescribeBotVersionRequest, DescribeBotVersionResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DescribeBotVersionCommandInput extends DescribeBotVersionRequest {
    }
    export interface DescribeBotVersionCommandOutput extends DescribeBotVersionResponse, __MetadataBearer {
    }
    /**
        * <p>Provides metadata about a version of a bot.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DescribeBotVersionCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DescribeBotVersionCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DescribeBotVersionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeBotVersionCommandInput} for command's `input` shape.
        * @see {@link DescribeBotVersionCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DescribeBotVersionCommand extends $Command<DescribeBotVersionCommandInput, DescribeBotVersionCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DescribeBotVersionCommandInput;
            constructor(input: DescribeBotVersionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeBotVersionCommandInput, DescribeBotVersionCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeCustomVocabularyMetadataCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DescribeCustomVocabularyMetadataRequest, DescribeCustomVocabularyMetadataResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DescribeCustomVocabularyMetadataCommandInput extends DescribeCustomVocabularyMetadataRequest {
    }
    export interface DescribeCustomVocabularyMetadataCommandOutput extends DescribeCustomVocabularyMetadataResponse, __MetadataBearer {
    }
    /**
        * <p>Provides metadata information about a custom vocabulary.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DescribeCustomVocabularyMetadataCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DescribeCustomVocabularyMetadataCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DescribeCustomVocabularyMetadataCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeCustomVocabularyMetadataCommandInput} for command's `input` shape.
        * @see {@link DescribeCustomVocabularyMetadataCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DescribeCustomVocabularyMetadataCommand extends $Command<DescribeCustomVocabularyMetadataCommandInput, DescribeCustomVocabularyMetadataCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DescribeCustomVocabularyMetadataCommandInput;
            constructor(input: DescribeCustomVocabularyMetadataCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeCustomVocabularyMetadataCommandInput, DescribeCustomVocabularyMetadataCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeExportCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DescribeExportRequest, DescribeExportResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DescribeExportCommandInput extends DescribeExportRequest {
    }
    export interface DescribeExportCommandOutput extends DescribeExportResponse, __MetadataBearer {
    }
    /**
        * <p>Gets information about a specific export.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DescribeExportCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DescribeExportCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DescribeExportCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeExportCommandInput} for command's `input` shape.
        * @see {@link DescribeExportCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DescribeExportCommand extends $Command<DescribeExportCommandInput, DescribeExportCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DescribeExportCommandInput;
            constructor(input: DescribeExportCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeExportCommandInput, DescribeExportCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeImportCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DescribeImportRequest, DescribeImportResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DescribeImportCommandInput extends DescribeImportRequest {
    }
    export interface DescribeImportCommandOutput extends DescribeImportResponse, __MetadataBearer {
    }
    /**
        * <p>Gets information about a specific import.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DescribeImportCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DescribeImportCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DescribeImportCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeImportCommandInput} for command's `input` shape.
        * @see {@link DescribeImportCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DescribeImportCommand extends $Command<DescribeImportCommandInput, DescribeImportCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DescribeImportCommandInput;
            constructor(input: DescribeImportCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeImportCommandInput, DescribeImportCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeIntentCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DescribeIntentRequest, DescribeIntentResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DescribeIntentCommandInput extends DescribeIntentRequest {
    }
    export interface DescribeIntentCommandOutput extends DescribeIntentResponse, __MetadataBearer {
    }
    /**
        * <p>Returns metadata about an intent.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DescribeIntentCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DescribeIntentCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DescribeIntentCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeIntentCommandInput} for command's `input` shape.
        * @see {@link DescribeIntentCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DescribeIntentCommand extends $Command<DescribeIntentCommandInput, DescribeIntentCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DescribeIntentCommandInput;
            constructor(input: DescribeIntentCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeIntentCommandInput, DescribeIntentCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeResourcePolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DescribeResourcePolicyRequest, DescribeResourcePolicyResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DescribeResourcePolicyCommandInput extends DescribeResourcePolicyRequest {
    }
    export interface DescribeResourcePolicyCommandOutput extends DescribeResourcePolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Gets the resource policy and policy revision for a bot or bot
        *          alias.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DescribeResourcePolicyCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DescribeResourcePolicyCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DescribeResourcePolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeResourcePolicyCommandInput} for command's `input` shape.
        * @see {@link DescribeResourcePolicyCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DescribeResourcePolicyCommand extends $Command<DescribeResourcePolicyCommandInput, DescribeResourcePolicyCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DescribeResourcePolicyCommandInput;
            constructor(input: DescribeResourcePolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeResourcePolicyCommandInput, DescribeResourcePolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeSlotCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DescribeSlotRequest, DescribeSlotResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DescribeSlotCommandInput extends DescribeSlotRequest {
    }
    export interface DescribeSlotCommandOutput extends DescribeSlotResponse, __MetadataBearer {
    }
    /**
        * <p>Gets metadata information about a slot.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DescribeSlotCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DescribeSlotCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DescribeSlotCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeSlotCommandInput} for command's `input` shape.
        * @see {@link DescribeSlotCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DescribeSlotCommand extends $Command<DescribeSlotCommandInput, DescribeSlotCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DescribeSlotCommandInput;
            constructor(input: DescribeSlotCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeSlotCommandInput, DescribeSlotCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeSlotTypeCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { DescribeSlotTypeRequest, DescribeSlotTypeResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface DescribeSlotTypeCommandInput extends DescribeSlotTypeRequest {
    }
    export interface DescribeSlotTypeCommandOutput extends DescribeSlotTypeResponse, __MetadataBearer {
    }
    /**
        * <p>Gets metadata information about a slot type.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, DescribeSlotTypeCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, DescribeSlotTypeCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new DescribeSlotTypeCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeSlotTypeCommandInput} for command's `input` shape.
        * @see {@link DescribeSlotTypeCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class DescribeSlotTypeCommand extends $Command<DescribeSlotTypeCommandInput, DescribeSlotTypeCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: DescribeSlotTypeCommandInput;
            constructor(input: DescribeSlotTypeCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeSlotTypeCommandInput, DescribeSlotTypeCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListAggregatedUtterancesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { ListAggregatedUtterancesRequest, ListAggregatedUtterancesResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface ListAggregatedUtterancesCommandInput extends ListAggregatedUtterancesRequest {
    }
    export interface ListAggregatedUtterancesCommandOutput extends ListAggregatedUtterancesResponse, __MetadataBearer {
    }
    /**
        * <p>Provides a list of utterances that users have sent to the
        *          bot.</p>
        *          <p>Utterances are aggregated by the text of the utterance. For example,
        *          all instances where customers used the phrase "I want to order pizza"
        *          are aggregated into the same line in the response.</p>
        *          <p>You can see both detected utterances and missed utterances. A
        *          detected utterance is where the bot properly recognized the utterance
        *          and activated the associated intent. A missed utterance was not
        *          recognized by the bot and didn't activate an intent.</p>
        *          <p>Utterances can be aggregated for a bot alias or for a bot version,
        *          but not both at the same time.</p>
        *          <p>Utterances statistics are not generated under the following
        *          conditions:</p>
        *          <ul>
        *             <li>
        *                <p>The <code>childDirected</code> field was set to true when the
        *                bot was created.</p>
        *             </li>
        *             <li>
        *                <p>You are using slot obfuscation with one or more slots.</p>
        *             </li>
        *             <li>
        *                <p>You opted out of participating in improving Amazon Lex.</p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, ListAggregatedUtterancesCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, ListAggregatedUtterancesCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new ListAggregatedUtterancesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListAggregatedUtterancesCommandInput} for command's `input` shape.
        * @see {@link ListAggregatedUtterancesCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class ListAggregatedUtterancesCommand extends $Command<ListAggregatedUtterancesCommandInput, ListAggregatedUtterancesCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: ListAggregatedUtterancesCommandInput;
            constructor(input: ListAggregatedUtterancesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListAggregatedUtterancesCommandInput, ListAggregatedUtterancesCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListBotAliasesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { ListBotAliasesRequest, ListBotAliasesResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface ListBotAliasesCommandInput extends ListBotAliasesRequest {
    }
    export interface ListBotAliasesCommandOutput extends ListBotAliasesResponse, __MetadataBearer {
    }
    /**
        * <p>Gets a list of aliases for the specified bot.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, ListBotAliasesCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, ListBotAliasesCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new ListBotAliasesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListBotAliasesCommandInput} for command's `input` shape.
        * @see {@link ListBotAliasesCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class ListBotAliasesCommand extends $Command<ListBotAliasesCommandInput, ListBotAliasesCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: ListBotAliasesCommandInput;
            constructor(input: ListBotAliasesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListBotAliasesCommandInput, ListBotAliasesCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListBotLocalesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { ListBotLocalesRequest, ListBotLocalesResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface ListBotLocalesCommandInput extends ListBotLocalesRequest {
    }
    export interface ListBotLocalesCommandOutput extends ListBotLocalesResponse, __MetadataBearer {
    }
    /**
        * <p>Gets a list of locales for the specified bot.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, ListBotLocalesCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, ListBotLocalesCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new ListBotLocalesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListBotLocalesCommandInput} for command's `input` shape.
        * @see {@link ListBotLocalesCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class ListBotLocalesCommand extends $Command<ListBotLocalesCommandInput, ListBotLocalesCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: ListBotLocalesCommandInput;
            constructor(input: ListBotLocalesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListBotLocalesCommandInput, ListBotLocalesCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListBotRecommendationsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { ListBotRecommendationsRequest, ListBotRecommendationsResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface ListBotRecommendationsCommandInput extends ListBotRecommendationsRequest {
    }
    export interface ListBotRecommendationsCommandOutput extends ListBotRecommendationsResponse, __MetadataBearer {
    }
    /**
        * <p>Get a list of bot recommendations that meet the specified
        *          criteria.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, ListBotRecommendationsCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, ListBotRecommendationsCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new ListBotRecommendationsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListBotRecommendationsCommandInput} for command's `input` shape.
        * @see {@link ListBotRecommendationsCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class ListBotRecommendationsCommand extends $Command<ListBotRecommendationsCommandInput, ListBotRecommendationsCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: ListBotRecommendationsCommandInput;
            constructor(input: ListBotRecommendationsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListBotRecommendationsCommandInput, ListBotRecommendationsCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListBotsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { ListBotsRequest, ListBotsResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface ListBotsCommandInput extends ListBotsRequest {
    }
    export interface ListBotsCommandOutput extends ListBotsResponse, __MetadataBearer {
    }
    /**
        * <p>Gets a list of available bots.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, ListBotsCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, ListBotsCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new ListBotsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListBotsCommandInput} for command's `input` shape.
        * @see {@link ListBotsCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class ListBotsCommand extends $Command<ListBotsCommandInput, ListBotsCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: ListBotsCommandInput;
            constructor(input: ListBotsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListBotsCommandInput, ListBotsCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListBotVersionsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { ListBotVersionsRequest, ListBotVersionsResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface ListBotVersionsCommandInput extends ListBotVersionsRequest {
    }
    export interface ListBotVersionsCommandOutput extends ListBotVersionsResponse, __MetadataBearer {
    }
    /**
        * <p>Gets information about all of the versions of a bot.</p>
        *          <p>The <code>ListBotVersions</code> operation returns a summary of each
        *          version of a bot. For example, if a bot has three numbered versions,
        *          the <code>ListBotVersions</code> operation returns for summaries, one
        *          for each numbered version and one for the <code>DRAFT</code>
        *          version.</p>
        *          <p>The <code>ListBotVersions</code> operation always returns at least
        *          one version, the <code>DRAFT</code> version.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, ListBotVersionsCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, ListBotVersionsCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new ListBotVersionsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListBotVersionsCommandInput} for command's `input` shape.
        * @see {@link ListBotVersionsCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class ListBotVersionsCommand extends $Command<ListBotVersionsCommandInput, ListBotVersionsCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: ListBotVersionsCommandInput;
            constructor(input: ListBotVersionsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListBotVersionsCommandInput, ListBotVersionsCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListBuiltInIntentsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { ListBuiltInIntentsRequest, ListBuiltInIntentsResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface ListBuiltInIntentsCommandInput extends ListBuiltInIntentsRequest {
    }
    export interface ListBuiltInIntentsCommandOutput extends ListBuiltInIntentsResponse, __MetadataBearer {
    }
    /**
        * <p>Gets a list of built-in intents provided by Amazon Lex that you can use
        *          in your bot. </p>
        *          <p>To use a built-in intent as a the base for your own intent, include
        *          the built-in intent signature in the <code>parentIntentSignature</code>
        *          parameter when you call the <code>CreateIntent</code> operation. For
        *          more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_CreateIntent.html">CreateIntent</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, ListBuiltInIntentsCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, ListBuiltInIntentsCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new ListBuiltInIntentsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListBuiltInIntentsCommandInput} for command's `input` shape.
        * @see {@link ListBuiltInIntentsCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class ListBuiltInIntentsCommand extends $Command<ListBuiltInIntentsCommandInput, ListBuiltInIntentsCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: ListBuiltInIntentsCommandInput;
            constructor(input: ListBuiltInIntentsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListBuiltInIntentsCommandInput, ListBuiltInIntentsCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListBuiltInSlotTypesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { ListBuiltInSlotTypesRequest, ListBuiltInSlotTypesResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface ListBuiltInSlotTypesCommandInput extends ListBuiltInSlotTypesRequest {
    }
    export interface ListBuiltInSlotTypesCommandOutput extends ListBuiltInSlotTypesResponse, __MetadataBearer {
    }
    /**
        * <p>Gets a list of built-in slot types that meet the specified
        *          criteria.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, ListBuiltInSlotTypesCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, ListBuiltInSlotTypesCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new ListBuiltInSlotTypesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListBuiltInSlotTypesCommandInput} for command's `input` shape.
        * @see {@link ListBuiltInSlotTypesCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class ListBuiltInSlotTypesCommand extends $Command<ListBuiltInSlotTypesCommandInput, ListBuiltInSlotTypesCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: ListBuiltInSlotTypesCommandInput;
            constructor(input: ListBuiltInSlotTypesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListBuiltInSlotTypesCommandInput, ListBuiltInSlotTypesCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListExportsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { ListExportsRequest, ListExportsResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface ListExportsCommandInput extends ListExportsRequest {
    }
    export interface ListExportsCommandOutput extends ListExportsResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the exports for a bot, bot locale, or custom vocabulary.
        *          Exports are kept in the list for 7 days.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, ListExportsCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, ListExportsCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new ListExportsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListExportsCommandInput} for command's `input` shape.
        * @see {@link ListExportsCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class ListExportsCommand extends $Command<ListExportsCommandInput, ListExportsCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: ListExportsCommandInput;
            constructor(input: ListExportsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListExportsCommandInput, ListExportsCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListImportsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { ListImportsRequest, ListImportsResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface ListImportsCommandInput extends ListImportsRequest {
    }
    export interface ListImportsCommandOutput extends ListImportsResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the imports for a bot, bot locale, or custom vocabulary.
        *          Imports are kept in the list for 7 days.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, ListImportsCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, ListImportsCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new ListImportsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListImportsCommandInput} for command's `input` shape.
        * @see {@link ListImportsCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class ListImportsCommand extends $Command<ListImportsCommandInput, ListImportsCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: ListImportsCommandInput;
            constructor(input: ListImportsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListImportsCommandInput, ListImportsCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListIntentsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { ListIntentsRequest, ListIntentsResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface ListIntentsCommandInput extends ListIntentsRequest {
    }
    export interface ListIntentsCommandOutput extends ListIntentsResponse, __MetadataBearer {
    }
    /**
        * <p>Get a list of intents that meet the specified criteria.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, ListIntentsCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, ListIntentsCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new ListIntentsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListIntentsCommandInput} for command's `input` shape.
        * @see {@link ListIntentsCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class ListIntentsCommand extends $Command<ListIntentsCommandInput, ListIntentsCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: ListIntentsCommandInput;
            constructor(input: ListIntentsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListIntentsCommandInput, ListIntentsCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListRecommendedIntentsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { ListRecommendedIntentsRequest, ListRecommendedIntentsResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface ListRecommendedIntentsCommandInput extends ListRecommendedIntentsRequest {
    }
    export interface ListRecommendedIntentsCommandOutput extends ListRecommendedIntentsResponse, __MetadataBearer {
    }
    /**
        * <p>Gets a list of recommended intents provided by the bot
        *          recommendation that you can use in your bot.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, ListRecommendedIntentsCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, ListRecommendedIntentsCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new ListRecommendedIntentsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListRecommendedIntentsCommandInput} for command's `input` shape.
        * @see {@link ListRecommendedIntentsCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class ListRecommendedIntentsCommand extends $Command<ListRecommendedIntentsCommandInput, ListRecommendedIntentsCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: ListRecommendedIntentsCommandInput;
            constructor(input: ListRecommendedIntentsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListRecommendedIntentsCommandInput, ListRecommendedIntentsCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListSlotsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { ListSlotsRequest, ListSlotsResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface ListSlotsCommandInput extends ListSlotsRequest {
    }
    export interface ListSlotsCommandOutput extends ListSlotsResponse, __MetadataBearer {
    }
    /**
        * <p>Gets a list of slots that match the specified criteria.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, ListSlotsCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, ListSlotsCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new ListSlotsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListSlotsCommandInput} for command's `input` shape.
        * @see {@link ListSlotsCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class ListSlotsCommand extends $Command<ListSlotsCommandInput, ListSlotsCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: ListSlotsCommandInput;
            constructor(input: ListSlotsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListSlotsCommandInput, ListSlotsCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListSlotTypesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { ListSlotTypesRequest, ListSlotTypesResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface ListSlotTypesCommandInput extends ListSlotTypesRequest {
    }
    export interface ListSlotTypesCommandOutput extends ListSlotTypesResponse, __MetadataBearer {
    }
    /**
        * <p>Gets a list of slot types that match the specified criteria.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, ListSlotTypesCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, ListSlotTypesCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new ListSlotTypesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListSlotTypesCommandInput} for command's `input` shape.
        * @see {@link ListSlotTypesCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class ListSlotTypesCommand extends $Command<ListSlotTypesCommandInput, ListSlotTypesCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: ListSlotTypesCommandInput;
            constructor(input: ListSlotTypesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListSlotTypesCommandInput, ListSlotTypesCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListTagsForResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { ListTagsForResourceRequest, ListTagsForResourceResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface ListTagsForResourceCommandInput extends ListTagsForResourceRequest {
    }
    export interface ListTagsForResourceCommandOutput extends ListTagsForResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Gets a list of tags associated with a resource. Only bots, bot
        *          aliases, and bot channels can have tags associated with them.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, ListTagsForResourceCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, ListTagsForResourceCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new ListTagsForResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTagsForResourceCommandInput} for command's `input` shape.
        * @see {@link ListTagsForResourceCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class ListTagsForResourceCommand extends $Command<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: ListTagsForResourceCommandInput;
            constructor(input: ListTagsForResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/SearchAssociatedTranscriptsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { SearchAssociatedTranscriptsRequest, SearchAssociatedTranscriptsResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface SearchAssociatedTranscriptsCommandInput extends SearchAssociatedTranscriptsRequest {
    }
    export interface SearchAssociatedTranscriptsCommandOutput extends SearchAssociatedTranscriptsResponse, __MetadataBearer {
    }
    /**
        * <p>Search for associated transcripts that meet the specified
        *          criteria.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, SearchAssociatedTranscriptsCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, SearchAssociatedTranscriptsCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new SearchAssociatedTranscriptsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link SearchAssociatedTranscriptsCommandInput} for command's `input` shape.
        * @see {@link SearchAssociatedTranscriptsCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class SearchAssociatedTranscriptsCommand extends $Command<SearchAssociatedTranscriptsCommandInput, SearchAssociatedTranscriptsCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: SearchAssociatedTranscriptsCommandInput;
            constructor(input: SearchAssociatedTranscriptsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<SearchAssociatedTranscriptsCommandInput, SearchAssociatedTranscriptsCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/StartBotRecommendationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { StartBotRecommendationRequest, StartBotRecommendationResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface StartBotRecommendationCommandInput extends StartBotRecommendationRequest {
    }
    export interface StartBotRecommendationCommandOutput extends StartBotRecommendationResponse, __MetadataBearer {
    }
    /**
        * <p>Use this to provide your transcript data, and to start the bot
        *          recommendation process.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, StartBotRecommendationCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, StartBotRecommendationCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new StartBotRecommendationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link StartBotRecommendationCommandInput} for command's `input` shape.
        * @see {@link StartBotRecommendationCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class StartBotRecommendationCommand extends $Command<StartBotRecommendationCommandInput, StartBotRecommendationCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: StartBotRecommendationCommandInput;
            constructor(input: StartBotRecommendationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<StartBotRecommendationCommandInput, StartBotRecommendationCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/StartImportCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { StartImportRequest, StartImportResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface StartImportCommandInput extends StartImportRequest {
    }
    export interface StartImportCommandOutput extends StartImportResponse, __MetadataBearer {
    }
    /**
        * <p>Starts importing a bot, bot locale, or custom vocabulary from a zip
        *          archive that you uploaded to an S3 bucket.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, StartImportCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, StartImportCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new StartImportCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link StartImportCommandInput} for command's `input` shape.
        * @see {@link StartImportCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class StartImportCommand extends $Command<StartImportCommandInput, StartImportCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: StartImportCommandInput;
            constructor(input: StartImportCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<StartImportCommandInput, StartImportCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/TagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { TagResourceRequest, TagResourceResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface TagResourceCommandInput extends TagResourceRequest {
    }
    export interface TagResourceCommandOutput extends TagResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Adds the specified tags to the specified resource. If a tag key
        *          already exists, the existing value is replaced with the new
        *          value.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, TagResourceCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, TagResourceCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new TagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TagResourceCommandInput} for command's `input` shape.
        * @see {@link TagResourceCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class TagResourceCommand extends $Command<TagResourceCommandInput, TagResourceCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: TagResourceCommandInput;
            constructor(input: TagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TagResourceCommandInput, TagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UntagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { UntagResourceRequest, UntagResourceResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface UntagResourceCommandInput extends UntagResourceRequest {
    }
    export interface UntagResourceCommandOutput extends UntagResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Removes tags from a bot, bot alias, or bot channel.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, UntagResourceCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, UntagResourceCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new UntagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UntagResourceCommandInput} for command's `input` shape.
        * @see {@link UntagResourceCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class UntagResourceCommand extends $Command<UntagResourceCommandInput, UntagResourceCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: UntagResourceCommandInput;
            constructor(input: UntagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UntagResourceCommandInput, UntagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateBotAliasCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { UpdateBotAliasRequest, UpdateBotAliasResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface UpdateBotAliasCommandInput extends UpdateBotAliasRequest {
    }
    export interface UpdateBotAliasCommandOutput extends UpdateBotAliasResponse, __MetadataBearer {
    }
    /**
        * <p>Updates the configuration of an existing bot alias.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, UpdateBotAliasCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, UpdateBotAliasCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new UpdateBotAliasCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateBotAliasCommandInput} for command's `input` shape.
        * @see {@link UpdateBotAliasCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class UpdateBotAliasCommand extends $Command<UpdateBotAliasCommandInput, UpdateBotAliasCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: UpdateBotAliasCommandInput;
            constructor(input: UpdateBotAliasCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateBotAliasCommandInput, UpdateBotAliasCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateBotCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { UpdateBotRequest, UpdateBotResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface UpdateBotCommandInput extends UpdateBotRequest {
    }
    export interface UpdateBotCommandOutput extends UpdateBotResponse, __MetadataBearer {
    }
    /**
        * <p>Updates the configuration of an existing bot. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, UpdateBotCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, UpdateBotCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new UpdateBotCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateBotCommandInput} for command's `input` shape.
        * @see {@link UpdateBotCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class UpdateBotCommand extends $Command<UpdateBotCommandInput, UpdateBotCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: UpdateBotCommandInput;
            constructor(input: UpdateBotCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateBotCommandInput, UpdateBotCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateBotLocaleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { UpdateBotLocaleRequest, UpdateBotLocaleResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface UpdateBotLocaleCommandInput extends UpdateBotLocaleRequest {
    }
    export interface UpdateBotLocaleCommandOutput extends UpdateBotLocaleResponse, __MetadataBearer {
    }
    /**
        * <p>Updates the settings that a bot has for a specific locale.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, UpdateBotLocaleCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, UpdateBotLocaleCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new UpdateBotLocaleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateBotLocaleCommandInput} for command's `input` shape.
        * @see {@link UpdateBotLocaleCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class UpdateBotLocaleCommand extends $Command<UpdateBotLocaleCommandInput, UpdateBotLocaleCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: UpdateBotLocaleCommandInput;
            constructor(input: UpdateBotLocaleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateBotLocaleCommandInput, UpdateBotLocaleCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateBotRecommendationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { UpdateBotRecommendationRequest, UpdateBotRecommendationResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface UpdateBotRecommendationCommandInput extends UpdateBotRecommendationRequest {
    }
    export interface UpdateBotRecommendationCommandOutput extends UpdateBotRecommendationResponse, __MetadataBearer {
    }
    /**
        * <p>Updates an existing bot recommendation request.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, UpdateBotRecommendationCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, UpdateBotRecommendationCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new UpdateBotRecommendationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateBotRecommendationCommandInput} for command's `input` shape.
        * @see {@link UpdateBotRecommendationCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class UpdateBotRecommendationCommand extends $Command<UpdateBotRecommendationCommandInput, UpdateBotRecommendationCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: UpdateBotRecommendationCommandInput;
            constructor(input: UpdateBotRecommendationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateBotRecommendationCommandInput, UpdateBotRecommendationCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateExportCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { UpdateExportRequest, UpdateExportResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface UpdateExportCommandInput extends UpdateExportRequest {
    }
    export interface UpdateExportCommandOutput extends UpdateExportResponse, __MetadataBearer {
    }
    /**
        * <p>Updates the password used to protect an export zip archive.</p>
        *          <p>The password is not required. If you don't supply a password, Amazon Lex
        *          generates a zip file that is not protected by a password. This is the
        *          archive that is available at the pre-signed S3 URL provided by the
        *             <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_DescribeExport.html">DescribeExport</a> operation.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, UpdateExportCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, UpdateExportCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new UpdateExportCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateExportCommandInput} for command's `input` shape.
        * @see {@link UpdateExportCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class UpdateExportCommand extends $Command<UpdateExportCommandInput, UpdateExportCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: UpdateExportCommandInput;
            constructor(input: UpdateExportCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateExportCommandInput, UpdateExportCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateIntentCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { UpdateIntentRequest, UpdateIntentResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface UpdateIntentCommandInput extends UpdateIntentRequest {
    }
    export interface UpdateIntentCommandOutput extends UpdateIntentResponse, __MetadataBearer {
    }
    /**
        * <p>Updates the settings for an intent.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, UpdateIntentCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, UpdateIntentCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new UpdateIntentCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateIntentCommandInput} for command's `input` shape.
        * @see {@link UpdateIntentCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class UpdateIntentCommand extends $Command<UpdateIntentCommandInput, UpdateIntentCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: UpdateIntentCommandInput;
            constructor(input: UpdateIntentCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateIntentCommandInput, UpdateIntentCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateResourcePolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { UpdateResourcePolicyRequest, UpdateResourcePolicyResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface UpdateResourcePolicyCommandInput extends UpdateResourcePolicyRequest {
    }
    export interface UpdateResourcePolicyCommandOutput extends UpdateResourcePolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Replaces the existing resource policy for a bot or bot alias with a
        *          new one. If the policy doesn't exist, Amazon Lex returns an
        *          exception.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, UpdateResourcePolicyCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, UpdateResourcePolicyCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new UpdateResourcePolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateResourcePolicyCommandInput} for command's `input` shape.
        * @see {@link UpdateResourcePolicyCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class UpdateResourcePolicyCommand extends $Command<UpdateResourcePolicyCommandInput, UpdateResourcePolicyCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: UpdateResourcePolicyCommandInput;
            constructor(input: UpdateResourcePolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateResourcePolicyCommandInput, UpdateResourcePolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateSlotCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { UpdateSlotRequest, UpdateSlotResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface UpdateSlotCommandInput extends UpdateSlotRequest {
    }
    export interface UpdateSlotCommandOutput extends UpdateSlotResponse, __MetadataBearer {
    }
    /**
        * <p>Updates the settings for a slot.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, UpdateSlotCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, UpdateSlotCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new UpdateSlotCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateSlotCommandInput} for command's `input` shape.
        * @see {@link UpdateSlotCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class UpdateSlotCommand extends $Command<UpdateSlotCommandInput, UpdateSlotCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: UpdateSlotCommandInput;
            constructor(input: UpdateSlotCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateSlotCommandInput, UpdateSlotCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateSlotTypeCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexModelsV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client";
    import { UpdateSlotTypeRequest, UpdateSlotTypeResponse } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0";
    export interface UpdateSlotTypeCommandInput extends UpdateSlotTypeRequest {
    }
    export interface UpdateSlotTypeCommandOutput extends UpdateSlotTypeResponse, __MetadataBearer {
    }
    /**
        * <p>Updates the configuration of an existing slot type.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexModelsV2Client, UpdateSlotTypeCommand } from "@aws-sdk/client-lex-models-v2"; // ES Modules import
        * // const { LexModelsV2Client, UpdateSlotTypeCommand } = require("@aws-sdk/client-lex-models-v2"); // CommonJS import
        * const client = new LexModelsV2Client(config);
        * const command = new UpdateSlotTypeCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateSlotTypeCommandInput} for command's `input` shape.
        * @see {@link UpdateSlotTypeCommandOutput} for command's `response` shape.
        * @see {@link LexModelsV2ClientResolvedConfig | config} for LexModelsV2Client's `config` shape.
        *
        */
    export class UpdateSlotTypeCommand extends $Command<UpdateSlotTypeCommandInput, UpdateSlotTypeCommandOutput, LexModelsV2ClientResolvedConfig> {
            readonly input: UpdateSlotTypeCommandInput;
            constructor(input: UpdateSlotTypeCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexModelsV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateSlotTypeCommandInput, UpdateSlotTypeCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/LexModelsV2Client' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { BuildBotLocaleCommandInput, BuildBotLocaleCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/BuildBotLocaleCommand";
    import { CreateBotAliasCommandInput, CreateBotAliasCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateBotAliasCommand";
    import { CreateBotCommandInput, CreateBotCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateBotCommand";
    import { CreateBotLocaleCommandInput, CreateBotLocaleCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateBotLocaleCommand";
    import { CreateBotVersionCommandInput, CreateBotVersionCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateBotVersionCommand";
    import { CreateExportCommandInput, CreateExportCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateExportCommand";
    import { CreateIntentCommandInput, CreateIntentCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateIntentCommand";
    import { CreateResourcePolicyCommandInput, CreateResourcePolicyCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateResourcePolicyCommand";
    import { CreateResourcePolicyStatementCommandInput, CreateResourcePolicyStatementCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateResourcePolicyStatementCommand";
    import { CreateSlotCommandInput, CreateSlotCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateSlotCommand";
    import { CreateSlotTypeCommandInput, CreateSlotTypeCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateSlotTypeCommand";
    import { CreateUploadUrlCommandInput, CreateUploadUrlCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/CreateUploadUrlCommand";
    import { DeleteBotAliasCommandInput, DeleteBotAliasCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteBotAliasCommand";
    import { DeleteBotCommandInput, DeleteBotCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteBotCommand";
    import { DeleteBotLocaleCommandInput, DeleteBotLocaleCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteBotLocaleCommand";
    import { DeleteBotVersionCommandInput, DeleteBotVersionCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteBotVersionCommand";
    import { DeleteCustomVocabularyCommandInput, DeleteCustomVocabularyCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteCustomVocabularyCommand";
    import { DeleteExportCommandInput, DeleteExportCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteExportCommand";
    import { DeleteImportCommandInput, DeleteImportCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteImportCommand";
    import { DeleteIntentCommandInput, DeleteIntentCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteIntentCommand";
    import { DeleteResourcePolicyCommandInput, DeleteResourcePolicyCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteResourcePolicyCommand";
    import { DeleteResourcePolicyStatementCommandInput, DeleteResourcePolicyStatementCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteResourcePolicyStatementCommand";
    import { DeleteSlotCommandInput, DeleteSlotCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteSlotCommand";
    import { DeleteSlotTypeCommandInput, DeleteSlotTypeCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteSlotTypeCommand";
    import { DeleteUtterancesCommandInput, DeleteUtterancesCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DeleteUtterancesCommand";
    import { DescribeBotAliasCommandInput, DescribeBotAliasCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeBotAliasCommand";
    import { DescribeBotCommandInput, DescribeBotCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeBotCommand";
    import { DescribeBotLocaleCommandInput, DescribeBotLocaleCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeBotLocaleCommand";
    import { DescribeBotRecommendationCommandInput, DescribeBotRecommendationCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeBotRecommendationCommand";
    import { DescribeBotVersionCommandInput, DescribeBotVersionCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeBotVersionCommand";
    import { DescribeCustomVocabularyMetadataCommandInput, DescribeCustomVocabularyMetadataCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeCustomVocabularyMetadataCommand";
    import { DescribeExportCommandInput, DescribeExportCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeExportCommand";
    import { DescribeImportCommandInput, DescribeImportCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeImportCommand";
    import { DescribeIntentCommandInput, DescribeIntentCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeIntentCommand";
    import { DescribeResourcePolicyCommandInput, DescribeResourcePolicyCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeResourcePolicyCommand";
    import { DescribeSlotCommandInput, DescribeSlotCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeSlotCommand";
    import { DescribeSlotTypeCommandInput, DescribeSlotTypeCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/DescribeSlotTypeCommand";
    import { ListAggregatedUtterancesCommandInput, ListAggregatedUtterancesCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListAggregatedUtterancesCommand";
    import { ListBotAliasesCommandInput, ListBotAliasesCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListBotAliasesCommand";
    import { ListBotLocalesCommandInput, ListBotLocalesCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListBotLocalesCommand";
    import { ListBotRecommendationsCommandInput, ListBotRecommendationsCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListBotRecommendationsCommand";
    import { ListBotsCommandInput, ListBotsCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListBotsCommand";
    import { ListBotVersionsCommandInput, ListBotVersionsCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListBotVersionsCommand";
    import { ListBuiltInIntentsCommandInput, ListBuiltInIntentsCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListBuiltInIntentsCommand";
    import { ListBuiltInSlotTypesCommandInput, ListBuiltInSlotTypesCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListBuiltInSlotTypesCommand";
    import { ListExportsCommandInput, ListExportsCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListExportsCommand";
    import { ListImportsCommandInput, ListImportsCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListImportsCommand";
    import { ListIntentsCommandInput, ListIntentsCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListIntentsCommand";
    import { ListRecommendedIntentsCommandInput, ListRecommendedIntentsCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListRecommendedIntentsCommand";
    import { ListSlotsCommandInput, ListSlotsCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListSlotsCommand";
    import { ListSlotTypesCommandInput, ListSlotTypesCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListSlotTypesCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/ListTagsForResourceCommand";
    import { SearchAssociatedTranscriptsCommandInput, SearchAssociatedTranscriptsCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/SearchAssociatedTranscriptsCommand";
    import { StartBotRecommendationCommandInput, StartBotRecommendationCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/StartBotRecommendationCommand";
    import { StartImportCommandInput, StartImportCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/StartImportCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UntagResourceCommand";
    import { UpdateBotAliasCommandInput, UpdateBotAliasCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateBotAliasCommand";
    import { UpdateBotCommandInput, UpdateBotCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateBotCommand";
    import { UpdateBotLocaleCommandInput, UpdateBotLocaleCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateBotLocaleCommand";
    import { UpdateBotRecommendationCommandInput, UpdateBotRecommendationCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateBotRecommendationCommand";
    import { UpdateExportCommandInput, UpdateExportCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateExportCommand";
    import { UpdateIntentCommandInput, UpdateIntentCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateIntentCommand";
    import { UpdateResourcePolicyCommandInput, UpdateResourcePolicyCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateResourcePolicyCommand";
    import { UpdateSlotCommandInput, UpdateSlotCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateSlotCommand";
    import { UpdateSlotTypeCommandInput, UpdateSlotTypeCommandOutput } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/commands/UpdateSlotTypeCommand";
    export type ServiceInputTypes = BuildBotLocaleCommandInput | CreateBotAliasCommandInput | CreateBotCommandInput | CreateBotLocaleCommandInput | CreateBotVersionCommandInput | CreateExportCommandInput | CreateIntentCommandInput | CreateResourcePolicyCommandInput | CreateResourcePolicyStatementCommandInput | CreateSlotCommandInput | CreateSlotTypeCommandInput | CreateUploadUrlCommandInput | DeleteBotAliasCommandInput | DeleteBotCommandInput | DeleteBotLocaleCommandInput | DeleteBotVersionCommandInput | DeleteCustomVocabularyCommandInput | DeleteExportCommandInput | DeleteImportCommandInput | DeleteIntentCommandInput | DeleteResourcePolicyCommandInput | DeleteResourcePolicyStatementCommandInput | DeleteSlotCommandInput | DeleteSlotTypeCommandInput | DeleteUtterancesCommandInput | DescribeBotAliasCommandInput | DescribeBotCommandInput | DescribeBotLocaleCommandInput | DescribeBotRecommendationCommandInput | DescribeBotVersionCommandInput | DescribeCustomVocabularyMetadataCommandInput | DescribeExportCommandInput | DescribeImportCommandInput | DescribeIntentCommandInput | DescribeResourcePolicyCommandInput | DescribeSlotCommandInput | DescribeSlotTypeCommandInput | ListAggregatedUtterancesCommandInput | ListBotAliasesCommandInput | ListBotLocalesCommandInput | ListBotRecommendationsCommandInput | ListBotVersionsCommandInput | ListBotsCommandInput | ListBuiltInIntentsCommandInput | ListBuiltInSlotTypesCommandInput | ListExportsCommandInput | ListImportsCommandInput | ListIntentsCommandInput | ListRecommendedIntentsCommandInput | ListSlotTypesCommandInput | ListSlotsCommandInput | ListTagsForResourceCommandInput | SearchAssociatedTranscriptsCommandInput | StartBotRecommendationCommandInput | StartImportCommandInput | TagResourceCommandInput | UntagResourceCommandInput | UpdateBotAliasCommandInput | UpdateBotCommandInput | UpdateBotLocaleCommandInput | UpdateBotRecommendationCommandInput | UpdateExportCommandInput | UpdateIntentCommandInput | UpdateResourcePolicyCommandInput | UpdateSlotCommandInput | UpdateSlotTypeCommandInput;
    export type ServiceOutputTypes = BuildBotLocaleCommandOutput | CreateBotAliasCommandOutput | CreateBotCommandOutput | CreateBotLocaleCommandOutput | CreateBotVersionCommandOutput | CreateExportCommandOutput | CreateIntentCommandOutput | CreateResourcePolicyCommandOutput | CreateResourcePolicyStatementCommandOutput | CreateSlotCommandOutput | CreateSlotTypeCommandOutput | CreateUploadUrlCommandOutput | DeleteBotAliasCommandOutput | DeleteBotCommandOutput | DeleteBotLocaleCommandOutput | DeleteBotVersionCommandOutput | DeleteCustomVocabularyCommandOutput | DeleteExportCommandOutput | DeleteImportCommandOutput | DeleteIntentCommandOutput | DeleteResourcePolicyCommandOutput | DeleteResourcePolicyStatementCommandOutput | DeleteSlotCommandOutput | DeleteSlotTypeCommandOutput | DeleteUtterancesCommandOutput | DescribeBotAliasCommandOutput | DescribeBotCommandOutput | DescribeBotLocaleCommandOutput | DescribeBotRecommendationCommandOutput | DescribeBotVersionCommandOutput | DescribeCustomVocabularyMetadataCommandOutput | DescribeExportCommandOutput | DescribeImportCommandOutput | DescribeIntentCommandOutput | DescribeResourcePolicyCommandOutput | DescribeSlotCommandOutput | DescribeSlotTypeCommandOutput | ListAggregatedUtterancesCommandOutput | ListBotAliasesCommandOutput | ListBotLocalesCommandOutput | ListBotRecommendationsCommandOutput | ListBotVersionsCommandOutput | ListBotsCommandOutput | ListBuiltInIntentsCommandOutput | ListBuiltInSlotTypesCommandOutput | ListExportsCommandOutput | ListImportsCommandOutput | ListIntentsCommandOutput | ListRecommendedIntentsCommandOutput | ListSlotTypesCommandOutput | ListSlotsCommandOutput | ListTagsForResourceCommandOutput | SearchAssociatedTranscriptsCommandOutput | StartBotRecommendationCommandOutput | StartImportCommandOutput | TagResourceCommandOutput | UntagResourceCommandOutput | UpdateBotAliasCommandOutput | UpdateBotCommandOutput | UpdateBotLocaleCommandOutput | UpdateBotRecommendationCommandOutput | UpdateExportCommandOutput | UpdateIntentCommandOutput | UpdateResourcePolicyCommandOutput | UpdateSlotCommandOutput | UpdateSlotTypeCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type LexModelsV2ClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of LexModelsV2Client class constructor that set the region, credentials and other options.
        */
    export interface LexModelsV2ClientConfig extends LexModelsV2ClientConfigType {
    }
    type LexModelsV2ClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of LexModelsV2Client class. This is resolved and normalized from the {@link LexModelsV2ClientConfig | constructor configuration interface}.
        */
    export interface LexModelsV2ClientResolvedConfig extends LexModelsV2ClientResolvedConfigType {
    }
    /**
        * <p></p>
        */
    export class LexModelsV2Client extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, LexModelsV2ClientResolvedConfig> {
            /**
                * The resolved configuration of LexModelsV2Client class. This is resolved and normalized from the {@link LexModelsV2ClientConfig | constructor configuration interface}.
                */
            readonly config: LexModelsV2ClientResolvedConfig;
            constructor(configuration: LexModelsV2ClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { LexModelsV2ServiceException as __BaseException } from "@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/LexModelsV2ServiceException";
    export enum AudioRecognitionStrategy {
            UseSlotValuesAsCustomVocabulary = "UseSlotValuesAsCustomVocabulary"
    }
    /**
        * <p>Provides settings that enable advanced recognition settings for slot values.</p>
        */
    export interface AdvancedRecognitionSetting {
            /**
                * <p>Enables using the slot values as a custom vocabulary for recognizing user utterances.</p>
                */
            audioRecognitionStrategy?: AudioRecognitionStrategy | string;
    }
    export namespace AdvancedRecognitionSetting {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AdvancedRecognitionSetting) => any;
    }
    export enum AggregatedUtterancesFilterName {
            Utterance = "Utterance"
    }
    export enum AggregatedUtterancesFilterOperator {
            Contains = "CO",
            Equals = "EQ"
    }
    /**
        * <p>Filters responses returned by the
        *             <code>ListAggregatedUtterances</code> operation.</p>
        */
    export interface AggregatedUtterancesFilter {
            /**
                * <p>The name of the field to filter the utterance list.</p>
                */
            name: AggregatedUtterancesFilterName | string | undefined;
            /**
                * <p>The value to use for filtering the list of bots.</p>
                */
            values: string[] | undefined;
            /**
                * <p>The operator to use for the filter. Specify <code>EQ</code> when the
                *             <code>ListAggregatedUtterances</code> operation should return only
                *          utterances that equal the specified value. Specify <code>CO</code> when
                *          the <code>ListAggregatedUtterances</code> operation should return
                *          utterances that contain the specified value.</p>
                */
            operator: AggregatedUtterancesFilterOperator | string | undefined;
    }
    export namespace AggregatedUtterancesFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AggregatedUtterancesFilter) => any;
    }
    export enum AggregatedUtterancesSortAttribute {
            HitCount = "HitCount",
            MissedCount = "MissedCount"
    }
    export enum SortOrder {
            Ascending = "Ascending",
            Descending = "Descending"
    }
    /**
        * <p>Specifies attributes for sorting a list of utterances.</p>
        */
    export interface AggregatedUtterancesSortBy {
            /**
                * <p>The utterance attribute to sort by.</p>
                */
            attribute: AggregatedUtterancesSortAttribute | string | undefined;
            /**
                * <p>Specifies whether to sort the aggregated utterances in ascending or
                *          descending order.</p>
                */
            order: SortOrder | string | undefined;
    }
    export namespace AggregatedUtterancesSortBy {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AggregatedUtterancesSortBy) => any;
    }
    /**
        * <p>Provides summary information for aggregated utterances. The
        *             <code>ListAggregatedUtterances</code> operations combines all
        *          instances of the same utterance into a single aggregated
        *          summary.</p>
        */
    export interface AggregatedUtterancesSummary {
            /**
                * <p>The text of the utterance. If the utterance was used with the
                *             <code>RecognizeUtterance</code> operation, the text is the
                *          transcription of the audio utterance.</p>
                */
            utterance?: string;
            /**
                * <p>The number of times that the utterance was detected by Amazon Lex during
                *          the time period. When an utterance is detected, it activates an intent
                *          or a slot.</p>
                */
            hitCount?: number;
            /**
                * <p>The number of times that the utterance was missed by Amazon Lex An
                *          utterance is missed when it doesn't activate an intent or slot.</p>
                */
            missedCount?: number;
            /**
                * <p>The date and time that the utterance was first recorded in the time
                *          window for aggregation. An utterance may have been sent to Amazon Lex before
                *          that time, but only utterances within the time window are
                *          counted.</p>
                */
            utteranceFirstRecordedInAggregationDuration?: Date;
            /**
                * <p>The last date and time that an utterance was recorded in the time
                *          window for aggregation. An utterance may be sent to Amazon Lex after that
                *          time, but only utterances within the time window are counted.</p>
                */
            utteranceLastRecordedInAggregationDuration?: Date;
            /**
                * <p>Aggregated utterance data may contain utterances from versions of
                *          your bot that have since been deleted. When the aggregated contains
                *          this kind of data, this field is set to true.</p>
                */
            containsDataFromDeletedResources?: boolean;
    }
    export namespace AggregatedUtterancesSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AggregatedUtterancesSummary) => any;
    }
    /**
        * <p>The object containing information that associates the recommended
        *          intent/slot type with a conversation.</p>
        */
    export interface AssociatedTranscript {
            /**
                * <p>The content of the transcript that meets the search filter criteria.
                *          For the JSON format of the transcript, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/designing-output-format.html">Output transcript
                *             format</a>.</p>
                */
            transcript?: string;
    }
    export namespace AssociatedTranscript {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AssociatedTranscript) => any;
    }
    export enum AssociatedTranscriptFilterName {
            IntentId = "IntentId",
            SlotTypeId = "SlotTypeId"
    }
    /**
        * <p>Filters to search for the associated transcript.</p>
        */
    export interface AssociatedTranscriptFilter {
            /**
                * <p>The name of the field to use for filtering. The allowed names are
                *          IntentId and SlotTypeId.</p>
                */
            name: AssociatedTranscriptFilterName | string | undefined;
            /**
                * <p>The values to use to filter the transcript.</p>
                */
            values: string[] | undefined;
    }
    export namespace AssociatedTranscriptFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AssociatedTranscriptFilter) => any;
    }
    /**
        * <p>Specifies an Amazon S3 bucket for logging audio conversations</p>
        */
    export interface S3BucketLogDestination {
            /**
                * <p>The Amazon Resource Name (ARN) of an AWS Key Management Service
                *          (KMS) key for encrypting audio log files stored in an S3 bucket.</p>
                */
            kmsKeyArn?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of an Amazon S3 bucket where audio
                *          log files are stored.</p>
                */
            s3BucketArn: string | undefined;
            /**
                * <p>The S3 prefix to assign to audio log files.</p>
                */
            logPrefix: string | undefined;
    }
    export namespace S3BucketLogDestination {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: S3BucketLogDestination) => any;
    }
    /**
        * <p>The location of audio log files collected when conversation logging
        *          is enabled for a bot.</p>
        */
    export interface AudioLogDestination {
            /**
                * <p>The Amazon S3 bucket where the audio log files are stored. The IAM
                *          role specified in the <code>roleArn</code> parameter of the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_CreateBot.html">CreateBot</a> operation must have permission to write to this
                *          bucket.</p>
                */
            s3Bucket: S3BucketLogDestination | undefined;
    }
    export namespace AudioLogDestination {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AudioLogDestination) => any;
    }
    /**
        * <p>Settings for logging audio of conversations between Amazon Lex and a
        *          user. You specify whether to log audio and the Amazon S3 bucket where
        *          the audio file is stored.</p>
        */
    export interface AudioLogSetting {
            /**
                * <p>Determines whether audio logging in enabled for the bot.</p>
                */
            enabled: boolean | undefined;
            /**
                * <p>The location of audio log files collected when conversation logging
                *          is enabled for a bot.</p>
                */
            destination: AudioLogDestination | undefined;
    }
    export namespace AudioLogSetting {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AudioLogSetting) => any;
    }
    /**
        * <p>Provides a record of an event that affects a bot alias. For example,
        *          when the version of a bot that the alias points to changes.</p>
        */
    export interface BotAliasHistoryEvent {
            /**
                * <p>The version of the bot that was used in the event. </p>
                */
            botVersion?: string;
            /**
                * <p>The date and time that the event started.</p>
                */
            startDate?: Date;
            /**
                * <p>The date and time that the event ended.</p>
                */
            endDate?: Date;
    }
    export namespace BotAliasHistoryEvent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BotAliasHistoryEvent) => any;
    }
    /**
        * <p>Specifies a Lambda function that verifies requests to a bot or
        *          fulfills the user's request to a bot.</p>
        */
    export interface LambdaCodeHook {
            /**
                * <p>The Amazon Resource Name (ARN) of the Lambda function.</p>
                */
            lambdaARN: string | undefined;
            /**
                * <p>The version of the request-response that you want Amazon Lex to use to
                *          invoke your Lambda function.</p>
                */
            codeHookInterfaceVersion: string | undefined;
    }
    export namespace LambdaCodeHook {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LambdaCodeHook) => any;
    }
    /**
        * <p>Contains information about code hooks that Amazon Lex calls during a
        *          conversation.</p>
        */
    export interface CodeHookSpecification {
            /**
                * <p>Specifies a Lambda function that verifies requests to a bot or
                *          fulfills the user's request to a bot.</p>
                */
            lambdaCodeHook: LambdaCodeHook | undefined;
    }
    export namespace CodeHookSpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CodeHookSpecification) => any;
    }
    /**
        * <p>Specifies settings that are unique to a locale. For example, you can
        *          use different Lambda function depending on the bot's locale.</p>
        */
    export interface BotAliasLocaleSettings {
            /**
                * <p>Determines whether the locale is enabled for the bot. If the value
                *          is <code>false</code>, the locale isn't available for use.</p>
                */
            enabled: boolean | undefined;
            /**
                * <p>Specifies the Lambda function that should be used in the
                *          locale.</p>
                */
            codeHookSpecification?: CodeHookSpecification;
    }
    export namespace BotAliasLocaleSettings {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BotAliasLocaleSettings) => any;
    }
    export enum BotAliasStatus {
            Available = "Available",
            Creating = "Creating",
            Deleting = "Deleting",
            Failed = "Failed"
    }
    /**
        * <p>Summary information about bot aliases returned from the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_ListBotAliases.html">ListBotAliases</a> operation.</p>
        */
    export interface BotAliasSummary {
            /**
                * <p>The unique identifier assigned to the bot alias. You can use this ID
                *          to get detailed information about the alias using the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_DescribeBotAlias.html">DescribeBotAlias</a> operation.</p>
                */
            botAliasId?: string;
            /**
                * <p>The name of the bot alias.</p>
                */
            botAliasName?: string;
            /**
                * <p>The description of the bot alias.</p>
                */
            description?: string;
            /**
                * <p>The version of the bot that the bot alias references.</p>
                */
            botVersion?: string;
            /**
                * <p>The current state of the bot alias. If the status is
                *             <code>Available</code>, the alias is ready for use.</p>
                */
            botAliasStatus?: BotAliasStatus | string;
            /**
                * <p>A timestamp of the date and time that the bot alias was
                *          created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>A timestamp of the date and time that the bot alias was last
                *          updated.</p>
                */
            lastUpdatedDateTime?: Date;
    }
    export namespace BotAliasSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BotAliasSummary) => any;
    }
    /**
        * <p>Provides the identity of a the bot that was exported.</p>
        */
    export interface BotExportSpecification {
            /**
                * <p>The identifier of the bot assigned by Amazon Lex.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot that was exported. This will be either
                *             <code>DRAFT</code> or the version number.</p>
                */
            botVersion: string | undefined;
    }
    export namespace BotExportSpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BotExportSpecification) => any;
    }
    export enum BotFilterName {
            BotName = "BotName"
    }
    export enum BotFilterOperator {
            Contains = "CO",
            Equals = "EQ"
    }
    /**
        * <p>Filters the responses returned by the <code>ListBots</code>
        *          operation.</p>
        */
    export interface BotFilter {
            /**
                * <p>The name of the field to filter the list of bots.</p>
                */
            name: BotFilterName | string | undefined;
            /**
                * <p>The value to use for filtering the list of bots.</p>
                */
            values: string[] | undefined;
            /**
                * <p>The operator to use for the filter. Specify <code>EQ</code> when the
                *             <code>ListBots</code> operation should return only aliases that
                *          equal the specified value. Specify <code>CO</code> when the
                *             <code>ListBots</code> operation should return aliases that contain
                *          the specified value.</p>
                */
            operator: BotFilterOperator | string | undefined;
    }
    export namespace BotFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BotFilter) => any;
    }
    /**
        * <p>By default, data stored by Amazon Lex is encrypted. The
        *             <code>DataPrivacy</code> structure provides settings that determine
        *          how Amazon Lex handles special cases of securing the data for your bot.
        *       </p>
        */
    export interface DataPrivacy {
            /**
                * <p>For each Amazon Lex bot created with the Amazon Lex Model Building Service,
                *          you must specify whether your use of Amazon Lex is related to a website,
                *          program, or other application that is directed or targeted, in whole or
                *          in part, to children under age 13 and subject to the Children's Online
                *          Privacy Protection Act (COPPA) by specifying <code>true</code> or
                *             <code>false</code> in the <code>childDirected</code> field. By
                *          specifying <code>true</code> in the <code>childDirected</code> field,
                *          you confirm that your use of Amazon Lex <b>is</b>
                *          related to a website, program, or other application that is directed or
                *          targeted, in whole or in part, to children under age 13 and subject to
                *          COPPA. By specifying <code>false</code> in the
                *             <code>childDirected</code> field, you confirm that your use of Amazon Lex
                *             <b>is not</b> related to a website,
                *          program, or other application that is directed or targeted, in whole or
                *          in part, to children under age 13 and subject to COPPA. You may not
                *          specify a default value for the <code>childDirected</code> field that
                *          does not accurately reflect whether your use of Amazon Lex is related to a
                *          website, program, or other application that is directed or targeted, in
                *          whole or in part, to children under age 13 and subject to COPPA. If
                *          your use of Amazon Lex relates to a website, program, or other application
                *          that is directed in whole or in part, to children under age 13, you
                *          must obtain any required verifiable parental consent under COPPA. For
                *          information regarding the use of Amazon Lex in connection with websites,
                *          programs, or other applications that are directed or targeted, in whole
                *          or in part, to children under age 13, see the <a href="https://aws.amazon.com/lex/faqs#data-security">Amazon Lex
                *             FAQ</a>.</p>
                */
            childDirected: boolean | undefined;
    }
    export namespace DataPrivacy {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DataPrivacy) => any;
    }
    /**
        * <p>Provides the bot parameters required for importing a bot.</p>
        */
    export interface BotImportSpecification {
            /**
                * <p>The name that Amazon Lex should use for the bot.</p>
                */
            botName: string | undefined;
            /**
                * <p>The Amazon Resource Name (ARN) of the IAM role used to build and run
                *          the bot.</p>
                */
            roleArn: string | undefined;
            /**
                * <p>By default, data stored by Amazon Lex is encrypted. The
                *             <code>DataPrivacy</code> structure provides settings that determine
                *          how Amazon Lex handles special cases of securing the data for your bot.
                *       </p>
                */
            dataPrivacy: DataPrivacy | undefined;
            /**
                * <p>The time, in seconds, that Amazon Lex should keep information about a
                *          user's conversation with the bot. </p>
                *          <p>A user interaction remains active for the amount of time specified.
                *          If no conversation occurs during this time, the session expires and
                *          Amazon Lex deletes any data provided before the timeout.</p>
                *          <p>You can specify between 60 (1 minute) and 86,400 (24 hours)
                *          seconds.</p>
                */
            idleSessionTTLInSeconds?: number;
            /**
                * <p>A list of tags to add to the bot. You can only add tags when you
                *          import a bot. You can't use the <code>UpdateBot</code> operation to
                *          update tags. To update tags, use the <code>TagResource</code>
                *          operation.</p>
                */
            botTags?: Record<string, string>;
            /**
                * <p>A list of tags to add to the test alias for a bot. You can only add
                *          tags when you import a bot. You can't use the <code>UpdateAlias</code>
                *          operation to update tags. To update tags on the test alias, use the
                *             <code>TagResource</code> operation.</p>
                */
            testBotAliasTags?: Record<string, string>;
    }
    export namespace BotImportSpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BotImportSpecification) => any;
    }
    /**
        * <p>Provides the bot locale parameters required for exporting a bot
        *          locale.</p>
        */
    export interface BotLocaleExportSpecification {
            /**
                * <p>The identifier of the bot to create the locale for.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot to export.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale to export. The string must
                *          match one of the locales in the bot.</p>
                */
            localeId: string | undefined;
    }
    export namespace BotLocaleExportSpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BotLocaleExportSpecification) => any;
    }
    export enum BotLocaleFilterName {
            BotLocaleName = "BotLocaleName"
    }
    export enum BotLocaleFilterOperator {
            Contains = "CO",
            Equals = "EQ"
    }
    /**
        * <p>Filters responses returned by the <code>ListBotLocales</code>
        *          operation.</p>
        */
    export interface BotLocaleFilter {
            /**
                * <p>The name of the field to filter the list of bots.</p>
                */
            name: BotLocaleFilterName | string | undefined;
            /**
                * <p>The value to use for filtering the list of bots.</p>
                */
            values: string[] | undefined;
            /**
                * <p>The operator to use for the filter. Specify <code>EQ</code> when the
                *             <code>ListBotLocales</code> operation should return only aliases
                *          that equal the specified value. Specify <code>CO</code> when the
                *             <code>ListBotLocales</code> operation should return aliases that
                *          contain the specified value.</p>
                */
            operator: BotLocaleFilterOperator | string | undefined;
    }
    export namespace BotLocaleFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BotLocaleFilter) => any;
    }
    /**
        * <p>Provides information about an event that occurred affecting the bot
        *          locale.</p>
        */
    export interface BotLocaleHistoryEvent {
            /**
                * <p>A description of the event that occurred.</p>
                */
            event: string | undefined;
            /**
                * <p>A timestamp of the date and time that the event occurred.</p>
                */
            eventDate: Date | undefined;
    }
    export namespace BotLocaleHistoryEvent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BotLocaleHistoryEvent) => any;
    }
    export enum VoiceEngine {
            Neural = "neural",
            Standard = "standard"
    }
    /**
        * <p>Defines settings for using an Amazon Polly voice to communicate with a
        *          user.</p>
        */
    export interface VoiceSettings {
            /**
                * <p>The identifier of the Amazon Polly voice to use.</p>
                */
            voiceId: string | undefined;
            /**
                * <p>Indicates the type of Amazon Polly voice that Amazon Lex should use for voice interaction with the user. For more
                *          information, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/API_SynthesizeSpeech.html#polly-SynthesizeSpeech-request-Engine">
                *                <code>engine</code> parameter of the
                *                <code>SynthesizeSpeech</code> operation</a> in the
                *                <i>Amazon Polly developer guide</i>.</p>
                *          <p>If you do not specify a value, the default is
                *          <code>standard</code>.</p>
                */
            engine?: VoiceEngine | string;
    }
    export namespace VoiceSettings {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: VoiceSettings) => any;
    }
    /**
        * <p>Provides the bot locale parameters required for importing a bot
        *          locale.</p>
        */
    export interface BotLocaleImportSpecification {
            /**
                * <p>The identifier of the bot to import the locale to.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot to import the locale to. This can only be the
                *             <code>DRAFT</code> version of the bot.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale that the bot will be used
                *          in. The string must match one of the supported locales. All of the
                *          intents, slot types, and slots used in the bot must have the same
                *          locale. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported
                *          languages</a>.</p>
                */
            localeId: string | undefined;
            /**
                * <p>Determines the threshold where Amazon Lex will insert the
                *             <code>AMAZON.FallbackIntent</code>,
                *             <code>AMAZON.KendraSearchIntent</code>, or both when returning
                *          alternative intents. <code>AMAZON.FallbackIntent</code> and
                *             <code>AMAZON.KendraSearchIntent</code> are only inserted if they are
                *          configured for the bot. </p>
                *          <p>For example, suppose a bot is configured with the confidence
                *          threshold of 0.80 and the <code>AMAZON.FallbackIntent</code>. Amazon
                *          Lex returns three alternative intents with the following confidence
                *          scores: IntentA (0.70), IntentB (0.60), IntentC (0.50). The response
                *          from the <code>PostText</code> operation would be:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>AMAZON.FallbackIntent</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>IntentA</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>IntentB</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>IntentC</code>
                *                </p>
                *             </li>
                *          </ul>
                */
            nluIntentConfidenceThreshold?: number;
            /**
                * <p>Defines settings for using an Amazon Polly voice to communicate with a
                *          user.</p>
                */
            voiceSettings?: VoiceSettings;
    }
    export namespace BotLocaleImportSpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BotLocaleImportSpecification) => any;
    }
    export enum BotLocaleSortAttribute {
            BotLocaleName = "BotLocaleName"
    }
    /**
        * <p>Specifies attributes for sorting a list of bot locales.</p>
        */
    export interface BotLocaleSortBy {
            /**
                * <p>The bot locale attribute to sort by.</p>
                */
            attribute: BotLocaleSortAttribute | string | undefined;
            /**
                * <p>Specifies whether to sort the bot locales in ascending or descending
                *          order.</p>
                */
            order: SortOrder | string | undefined;
    }
    export namespace BotLocaleSortBy {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BotLocaleSortBy) => any;
    }
    export enum BotLocaleStatus {
            Building = "Building",
            Built = "Built",
            Creating = "Creating",
            Deleting = "Deleting",
            Failed = "Failed",
            Importing = "Importing",
            NotBuilt = "NotBuilt",
            Processing = "Processing",
            ReadyExpressTesting = "ReadyExpressTesting"
    }
    /**
        * <p>Summary information about bot locales returned by the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_ListBotLocales.html">ListBotLocales</a> operation.</p>
        */
    export interface BotLocaleSummary {
            /**
                * <p>The language and locale of the bot locale.</p>
                */
            localeId?: string;
            /**
                * <p>The name of the bot locale.</p>
                */
            localeName?: string;
            /**
                * <p>The description of the bot locale.</p>
                */
            description?: string;
            /**
                * <p>The current status of the bot locale. When the status is
                *             <code>Built</code> the locale is ready for use.</p>
                */
            botLocaleStatus?: BotLocaleStatus | string;
            /**
                * <p>A timestamp of the date and time that the bot locale was last
                *          updated.</p>
                */
            lastUpdatedDateTime?: Date;
            /**
                * <p>A timestamp of the date and time that the bot locale was last
                *          built.</p>
                */
            lastBuildSubmittedDateTime?: Date;
    }
    export namespace BotLocaleSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BotLocaleSummary) => any;
    }
    /**
        * <p>The object that contains the statistical summary of recommended
        *          intents associated with the bot recommendation.</p>
        */
    export interface IntentStatistics {
            /**
                * <p>The number of recommended intents associated with the bot
                *          recommendation.</p>
                */
            discoveredIntentCount?: number;
    }
    export namespace IntentStatistics {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: IntentStatistics) => any;
    }
    /**
        * <p>The object that contains the statistical summary of the recommended
        *          slot type associated with the bot recommendation.</p>
        */
    export interface SlotTypeStatistics {
            /**
                * <p>The number of recommended slot types associated with the bot
                *          recommendation.</p>
                */
            discoveredSlotTypeCount?: number;
    }
    export namespace SlotTypeStatistics {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SlotTypeStatistics) => any;
    }
    /**
        * <p>A statistical summary of the bot recommendation results.</p>
        */
    export interface BotRecommendationResultStatistics {
            /**
                * <p>Statistical information about about the intents associated with the
                *          bot recommendation results.</p>
                */
            intents?: IntentStatistics;
            /**
                * <p>Statistical information about the slot types associated with the bot
                *          recommendation results.</p>
                */
            slotTypes?: SlotTypeStatistics;
    }
    export namespace BotRecommendationResultStatistics {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BotRecommendationResultStatistics) => any;
    }
    /**
        * <p>The object representing the URL of the bot definition, the URL of
        *          the associated transcript, and a statistical summary of the bot
        *          recommendation results.</p>
        */
    export interface BotRecommendationResults {
            /**
                * <p>The presigned URL link of the recommended bot definition.</p>
                */
            botLocaleExportUrl?: string;
            /**
                * <p>The presigned url link of the associated transcript.</p>
                */
            associatedTranscriptsUrl?: string;
            /**
                * <p>The statistical summary of the bot recommendation results.</p>
                */
            statistics?: BotRecommendationResultStatistics;
    }
    export namespace BotRecommendationResults {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BotRecommendationResults) => any;
    }
    export enum BotRecommendationStatus {
            Available = "Available",
            Deleted = "Deleted",
            Deleting = "Deleting",
            Downloading = "Downloading",
            Failed = "Failed",
            Processing = "Processing",
            Updating = "Updating"
    }
    /**
        * <p>A summary of the bot recommendation.</p>
        */
    export interface BotRecommendationSummary {
            /**
                * <p>The status of the bot recommendation.</p>
                *          <p>If the status is Failed, then the reasons for the failure are listed
                *          in the failureReasons field. </p>
                */
            botRecommendationStatus: BotRecommendationStatus | string | undefined;
            /**
                * <p>The unique identifier of the bot recommendation to be
                *          updated.</p>
                */
            botRecommendationId: string | undefined;
            /**
                * <p>A timestamp of the date and time that the bot recommendation was
                *          created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>A timestamp of the date and time that the bot recommendation was
                *          last updated.</p>
                */
            lastUpdatedDateTime?: Date;
    }
    export namespace BotRecommendationSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BotRecommendationSummary) => any;
    }
    export enum BotSortAttribute {
            BotName = "BotName"
    }
    /**
        * <p>Specifies attributes for sorting a list of bots.</p>
        */
    export interface BotSortBy {
            /**
                * <p>The attribute to use to sort the list of bots.</p>
                */
            attribute: BotSortAttribute | string | undefined;
            /**
                * <p>The order to sort the list. You can choose ascending or
                *          descending.</p>
                */
            order: SortOrder | string | undefined;
    }
    export namespace BotSortBy {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BotSortBy) => any;
    }
    export enum BotStatus {
            Available = "Available",
            Creating = "Creating",
            Deleting = "Deleting",
            Failed = "Failed",
            Importing = "Importing",
            Inactive = "Inactive",
            Versioning = "Versioning"
    }
    /**
        * <p>Summary information about a bot returned by the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_ListBots.html">ListBots</a> operation.</p>
        */
    export interface BotSummary {
            /**
                * <p>The unique identifier assigned to the bot. Use this ID to get
                *          detailed information about the bot with the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_DescribeBot.html">DescribeBot</a> operation.</p>
                */
            botId?: string;
            /**
                * <p>The name of the bot.</p>
                */
            botName?: string;
            /**
                * <p>The description of the bot.</p>
                */
            description?: string;
            /**
                * <p>The current status of the bot. When the status is
                *             <code>Available</code> the bot is ready for use.</p>
                */
            botStatus?: BotStatus | string;
            /**
                * <p>The latest numerical version in use for the bot.</p>
                */
            latestBotVersion?: string;
            /**
                * <p>The date and time that the bot was last updated.</p>
                */
            lastUpdatedDateTime?: Date;
    }
    export namespace BotSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BotSummary) => any;
    }
    /**
        * <p>The version of a bot used for a bot locale.</p>
        */
    export interface BotVersionLocaleDetails {
            /**
                * <p>The version of a bot used for a bot locale.</p>
                */
            sourceBotVersion: string | undefined;
    }
    export namespace BotVersionLocaleDetails {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BotVersionLocaleDetails) => any;
    }
    export enum BotVersionSortAttribute {
            BotVersion = "BotVersion"
    }
    /**
        * <p>Specifies attributes for sorting a list of bot versions.</p>
        */
    export interface BotVersionSortBy {
            /**
                * <p>The attribute to use to sort the list of versions.</p>
                */
            attribute: BotVersionSortAttribute | string | undefined;
            /**
                * <p>The order to sort the list. You can specify ascending or descending
                *          order.</p>
                */
            order: SortOrder | string | undefined;
    }
    export namespace BotVersionSortBy {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BotVersionSortBy) => any;
    }
    /**
        * <p>Summary information about a bot version returned by the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_ListBotVersions.html">ListBotVersions</a> operation.</p>
        */
    export interface BotVersionSummary {
            /**
                * <p>The name of the bot associated with the version.</p>
                */
            botName?: string;
            /**
                * <p>The numeric version of the bot, or <code>DRAFT</code> to indicate
                *          that this is the version of the bot that can be updated..</p>
                */
            botVersion?: string;
            /**
                * <p>The description of the version.</p>
                */
            description?: string;
            /**
                * <p>The status of the bot. When the status is available, the version of
                *          the bot is ready for use.</p>
                */
            botStatus?: BotStatus | string;
            /**
                * <p>A timestamp of the date and time that the version was
                *          created.</p>
                */
            creationDateTime?: Date;
    }
    export namespace BotVersionSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BotVersionSummary) => any;
    }
    export interface BuildBotLocaleRequest {
            /**
                * <p>The identifier of the bot to build. The identifier is returned in
                *          the response from the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_CreateBot.html">CreateBot</a> operation.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot to build. This can only be the draft version
                *          of the bot.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale that the bot will be used
                *          in. The string must match one of the supported locales. All of the
                *          intents, slot types, and slots used in the bot must have the same
                *          locale. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId: string | undefined;
    }
    export namespace BuildBotLocaleRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BuildBotLocaleRequest) => any;
    }
    export interface BuildBotLocaleResponse {
            /**
                * <p>The identifier of the specified bot.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot that was built. This is only the draft
                *          version of the bot.</p>
                */
            botVersion?: string;
            /**
                * <p>The language and locale specified of where the bot can be
                *          used.</p>
                */
            localeId?: string;
            /**
                * <p>The bot's build status. When the status is
                *             <code>ReadyExpressTesting</code> you can test the bot using the
                *          utterances defined for the intents and slot types. When the status is
                *             <code>Built</code>, the bot is ready for use and can be tested using
                *          any utterance.</p>
                */
            botLocaleStatus?: BotLocaleStatus | string;
            /**
                * <p>A timestamp indicating the date and time that the bot was last built
                *          for this locale.</p>
                */
            lastBuildSubmittedDateTime?: Date;
    }
    export namespace BuildBotLocaleResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BuildBotLocaleResponse) => any;
    }
    /**
        * <p>The action that you tried to perform couldn't be completed because
        *          the resource is in a conflicting state. For example, deleting a bot
        *          that is in the CREATING state. Try your request again. </p>
        */
    export class ConflictException extends __BaseException {
            readonly name: "ConflictException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ConflictException, __BaseException>);
    }
    /**
        * <p>The service encountered an unexpected condition. Try your request
        *          again.</p>
        */
    export class InternalServerException extends __BaseException {
            readonly name: "InternalServerException";
            readonly $fault: "server";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InternalServerException, __BaseException>);
    }
    /**
        * <p>Your request couldn't be completed because one or more request
        *          fields aren't valid. Check the fields in your request and try
        *          again.</p>
        */
    export class PreconditionFailedException extends __BaseException {
            readonly name: "PreconditionFailedException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<PreconditionFailedException, __BaseException>);
    }
    /**
        * <p>You have reached a quota for your bot. </p>
        */
    export class ServiceQuotaExceededException extends __BaseException {
            readonly name: "ServiceQuotaExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ServiceQuotaExceededException, __BaseException>);
    }
    /**
        * <p>Your request rate is too high. Reduce the frequency of
        *          requests.</p>
        */
    export class ThrottlingException extends __BaseException {
            readonly name: "ThrottlingException";
            readonly $fault: "client";
            retryAfterSeconds?: number;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ThrottlingException, __BaseException>);
    }
    /**
        * <p>One of the input parameters in your request isn't valid. Check the
        *          parameters and try your request again.</p>
        */
    export class ValidationException extends __BaseException {
            readonly name: "ValidationException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ValidationException, __BaseException>);
    }
    export enum BuiltInIntentSortAttribute {
            IntentSignature = "IntentSignature"
    }
    /**
        * <p>Specifies attributes for sorting a list of built-in intents.</p>
        */
    export interface BuiltInIntentSortBy {
            /**
                * <p>The attribute to use to sort the list of built-in intents.</p>
                */
            attribute: BuiltInIntentSortAttribute | string | undefined;
            /**
                * <p>The order to sort the list. You can specify ascending or descending
                *          order.</p>
                */
            order: SortOrder | string | undefined;
    }
    export namespace BuiltInIntentSortBy {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BuiltInIntentSortBy) => any;
    }
    /**
        * <p>Provides summary information about a built-in intent for the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_ListBuiltInIntents.html"> ListBuiltInIntents </a> operation.</p>
        */
    export interface BuiltInIntentSummary {
            /**
                * <p>The signature of the built-in intent. Use this to specify the parent
                *          intent of a derived intent.</p>
                */
            intentSignature?: string;
            /**
                * <p>The description of the intent.</p>
                */
            description?: string;
    }
    export namespace BuiltInIntentSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BuiltInIntentSummary) => any;
    }
    export enum BuiltInSlotTypeSortAttribute {
            SlotTypeSignature = "SlotTypeSignature"
    }
    /**
        * <p>Specifies attributes for sorting a list of built-in slot
        *          types.</p>
        */
    export interface BuiltInSlotTypeSortBy {
            /**
                * <p>The attribute to use to sort the list of built-in intents.</p>
                */
            attribute: BuiltInSlotTypeSortAttribute | string | undefined;
            /**
                * <p>The order to sort the list. You can choose ascending or
                *          descending.</p>
                */
            order: SortOrder | string | undefined;
    }
    export namespace BuiltInSlotTypeSortBy {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BuiltInSlotTypeSortBy) => any;
    }
    /**
        * <p>Provides summary information about a built-in slot type for the
        *             <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_ListBuiltInSlotTypes.html"> ListBuiltInSlotTypes </a>
        *          operation.</p>
        */
    export interface BuiltInSlotTypeSummary {
            /**
                * <p>The signature of the built-in slot type. Use this to specify the
                *          parent slot type of a derived slot type.</p>
                */
            slotTypeSignature?: string;
            /**
                * <p>The description of the built-in slot type.</p>
                */
            description?: string;
    }
    export namespace BuiltInSlotTypeSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BuiltInSlotTypeSummary) => any;
    }
    /**
        * <p>Describes a button to use on a response card used to gather slot
        *          values from a user.</p>
        */
    export interface Button {
            /**
                * <p>The text that appears on the button. Use this to tell the user what
                *          value is returned when they choose this button.</p>
                */
            text: string | undefined;
            /**
                * <p>The value returned to Amazon Lex when the user chooses this button. This
                *          must be one of the slot values configured for the slot.</p>
                */
            value: string | undefined;
    }
    export namespace Button {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Button) => any;
    }
    /**
        * <p>The Amazon CloudWatch Logs log group where the text and metadata logs are
        *          delivered. The log group must exist before you enable logging.</p>
        */
    export interface CloudWatchLogGroupLogDestination {
            /**
                * <p>The Amazon Resource Name (ARN) of the log group where text and
                *          metadata logs are delivered.</p>
                */
            cloudWatchLogGroupArn: string | undefined;
            /**
                * <p>The prefix of the log stream name within the log group that you
                *          specified </p>
                */
            logPrefix: string | undefined;
    }
    export namespace CloudWatchLogGroupLogDestination {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CloudWatchLogGroupLogDestination) => any;
    }
    /**
        * <p>Defines the Amazon CloudWatch Logs destination log group for
        *          conversation text logs.</p>
        */
    export interface TextLogDestination {
            /**
                * <p>Defines the Amazon CloudWatch Logs log group where text and metadata logs are
                *          delivered.</p>
                */
            cloudWatch: CloudWatchLogGroupLogDestination | undefined;
    }
    export namespace TextLogDestination {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TextLogDestination) => any;
    }
    /**
        * <p>Defines settings to enable text conversation logs.</p>
        */
    export interface TextLogSetting {
            /**
                * <p>Determines whether conversation logs should be stored for an
                *          alias.</p>
                */
            enabled: boolean | undefined;
            /**
                * <p>Defines the Amazon CloudWatch Logs destination log group for
                *          conversation text logs.</p>
                */
            destination: TextLogDestination | undefined;
    }
    export namespace TextLogSetting {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TextLogSetting) => any;
    }
    /**
        * <p>Configures conversation logging that saves audio, text, and metadata
        *          for the conversations with your users.</p>
        */
    export interface ConversationLogSettings {
            /**
                * <p>The Amazon CloudWatch Logs settings for logging text and metadata.</p>
                */
            textLogSettings?: TextLogSetting[];
            /**
                * <p>The Amazon S3 settings for logging audio to an S3 bucket.</p>
                */
            audioLogSettings?: AudioLogSetting[];
    }
    export namespace ConversationLogSettings {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ConversationLogSettings) => any;
    }
    export interface CreateBotRequest {
            /**
                * <p>The name of the bot. The bot name must be unique in the account that
                *          creates the bot.</p>
                */
            botName: string | undefined;
            /**
                * <p>A description of the bot. It appears in lists to help you identify a
                *          particular bot.</p>
                */
            description?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of an IAM role that has permission to
                *          access the bot.</p>
                */
            roleArn: string | undefined;
            /**
                * <p>Provides information on additional privacy protections Amazon Lex should
                *          use with the bot's data.</p>
                */
            dataPrivacy: DataPrivacy | undefined;
            /**
                * <p>The time, in seconds, that Amazon Lex should keep information about a
                *          user's conversation with the bot. </p>
                *          <p>A user interaction remains active for the amount of time specified.
                *          If no conversation occurs during this time, the session expires and
                *          Amazon Lex deletes any data provided before the timeout.</p>
                *          <p>You can specify between 60 (1 minute) and 86,400 (24 hours)
                *          seconds.</p>
                */
            idleSessionTTLInSeconds: number | undefined;
            /**
                * <p>A list of tags to add to the bot. You can only add tags when you
                *          create a bot. You can't use the <code>UpdateBot</code> operation to
                *          update tags. To update tags, use the <code>TagResource</code>
                *          operation.</p>
                */
            botTags?: Record<string, string>;
            /**
                * <p>A list of tags to add to the test alias for a bot. You can only add
                *          tags when you create a bot. You can't use the <code>UpdateAlias</code>
                *          operation to update tags. To update tags on the test alias, use the
                *             <code>TagResource</code> operation.</p>
                */
            testBotAliasTags?: Record<string, string>;
    }
    export namespace CreateBotRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateBotRequest) => any;
    }
    export interface CreateBotResponse {
            /**
                * <p>A unique identifier for a particular bot. You use this to identify
                *          the bot when you call other Amazon Lex API operations.</p>
                */
            botId?: string;
            /**
                * <p>The name specified for the bot.</p>
                */
            botName?: string;
            /**
                * <p>The description specified for the bot.</p>
                */
            description?: string;
            /**
                * <p>The IAM role specified for the bot.</p>
                */
            roleArn?: string;
            /**
                * <p>The data privacy settings specified for the bot.</p>
                */
            dataPrivacy?: DataPrivacy;
            /**
                * <p>The session idle time specified for the bot.</p>
                */
            idleSessionTTLInSeconds?: number;
            /**
                * <p>Shows the current status of the bot. The bot is first in the
                *             <code>Creating</code> status. Once the bot is read for use, it
                *          changes to the <code>Available</code> status. After the bot is created,
                *          you can use the <code>Draft</code> version of the bot.</p>
                */
            botStatus?: BotStatus | string;
            /**
                * <p>A timestamp indicating the date and time that the bot was
                *          created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>A list of tags associated with the bot.</p>
                */
            botTags?: Record<string, string>;
            /**
                * <p>A list of tags associated with the test alias for the bot.</p>
                */
            testBotAliasTags?: Record<string, string>;
    }
    export namespace CreateBotResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateBotResponse) => any;
    }
    /**
        * <p>Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of
        *          user utterances.</p>
        */
    export interface SentimentAnalysisSettings {
            /**
                * <p>Sets whether Amazon Lex uses Amazon Comprehend to detect the sentiment of user
                *          utterances.</p>
                */
            detectSentiment: boolean | undefined;
    }
    export namespace SentimentAnalysisSettings {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SentimentAnalysisSettings) => any;
    }
    export interface CreateBotAliasRequest {
            /**
                * <p>The alias to create. The name must be unique for the bot.</p>
                */
            botAliasName: string | undefined;
            /**
                * <p>A description of the alias. Use this description to help identify
                *          the alias.</p>
                */
            description?: string;
            /**
                * <p>The version of the bot that this alias points to. You can use the
                *             <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_UpdateBotAlias.html">UpdateBotAlias</a> operation to change the
                *          bot version associated with the alias.</p>
                */
            botVersion?: string;
            /**
                * <p>Maps configuration information to a specific locale. You can use
                *          this parameter to specify a specific Lambda function to run different
                *          functions in different locales.</p>
                */
            botAliasLocaleSettings?: Record<string, BotAliasLocaleSettings>;
            /**
                * <p>Specifies whether Amazon Lex logs text and audio for a conversation with
                *          the bot. When you enable conversation logs, text logs store text input,
                *          transcripts of audio input, and associated metadata in Amazon CloudWatch Logs. Audio
                *          logs store audio input in Amazon S3.</p>
                */
            conversationLogSettings?: ConversationLogSettings;
            /**
                * <p>Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of
                *          user utterances.</p>
                */
            sentimentAnalysisSettings?: SentimentAnalysisSettings;
            /**
                * <p>The unique identifier of the bot that the alias applies to.</p>
                */
            botId: string | undefined;
            /**
                * <p>A list of tags to add to the bot alias. You can only add tags when
                *          you create an alias, you can't use the <code>UpdateBotAlias</code>
                *          operation to update the tags on a bot alias. To update tags, use the
                *             <code>TagResource</code> operation.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace CreateBotAliasRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateBotAliasRequest) => any;
    }
    export interface CreateBotAliasResponse {
            /**
                * <p>The unique identifier of the bot alias.</p>
                */
            botAliasId?: string;
            /**
                * <p>The name specified for the bot alias.</p>
                */
            botAliasName?: string;
            /**
                * <p>The description specified for the bot alias.</p>
                */
            description?: string;
            /**
                * <p>The version of the bot associated with this alias.</p>
                */
            botVersion?: string;
            /**
                * <p>Configuration information for a specific locale.</p>
                */
            botAliasLocaleSettings?: Record<string, BotAliasLocaleSettings>;
            /**
                * <p>The conversation log settings specified for the alias.</p>
                */
            conversationLogSettings?: ConversationLogSettings;
            /**
                * <p>Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of
                *          user utterances.</p>
                */
            sentimentAnalysisSettings?: SentimentAnalysisSettings;
            /**
                * <p>The current status of the alias. The alias is first put into the
                *             <code>Creating</code> state. When the alias is ready to be used, it
                *          is put into the <code>Available</code> state. You can use the
                *             <code>DescribeBotAlias</code> operation to get the current state of
                *          an alias.</p>
                */
            botAliasStatus?: BotAliasStatus | string;
            /**
                * <p>The unique identifier of the bot that this alias applies to.</p>
                */
            botId?: string;
            /**
                * <p>A Unix timestamp indicating the date and time that the bot alias was
                *          created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>A list of tags associated with the bot alias.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace CreateBotAliasResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateBotAliasResponse) => any;
    }
    export interface CreateBotLocaleRequest {
            /**
                * <p>The identifier of the bot to create the locale for.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot to create the locale for. This can only be
                *          the draft version of the bot.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale that the bot will be used
                *          in. The string must match one of the supported locales. All of the
                *          intents, slot types, and slots used in the bot must have the same
                *          locale. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId: string | undefined;
            /**
                * <p>A description of the bot locale. Use this to help identify the bot
                *          locale in lists.</p>
                */
            description?: string;
            /**
                * <p>Determines the threshold where Amazon Lex will insert the
                *             <code>AMAZON.FallbackIntent</code>,
                *             <code>AMAZON.KendraSearchIntent</code>, or both when returning
                *          alternative intents. <code>AMAZON.FallbackIntent</code> and
                *             <code>AMAZON.KendraSearchIntent</code> are only inserted if they are
                *          configured for the bot.</p>
                *          <p>For example, suppose a bot is configured with the confidence
                *          threshold of 0.80 and the <code>AMAZON.FallbackIntent</code>. Amazon Lex
                *          returns three alternative intents with the following confidence scores:
                *          IntentA (0.70), IntentB (0.60), IntentC (0.50). The response from the
                *             <code>RecognizeText</code> operation would be:</p>
                *          <ul>
                *             <li>
                *                <p>AMAZON.FallbackIntent</p>
                *             </li>
                *             <li>
                *                <p>IntentA</p>
                *             </li>
                *             <li>
                *                <p>IntentB</p>
                *             </li>
                *             <li>
                *                <p>IntentC</p>
                *             </li>
                *          </ul>
                */
            nluIntentConfidenceThreshold: number | undefined;
            /**
                * <p>The Amazon Polly voice ID that Amazon Lex uses for voice interaction with the
                *          user.</p>
                */
            voiceSettings?: VoiceSettings;
    }
    export namespace CreateBotLocaleRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateBotLocaleRequest) => any;
    }
    export interface CreateBotLocaleResponse {
            /**
                * <p>The specified bot identifier.</p>
                */
            botId?: string;
            /**
                * <p>The specified bot version.</p>
                */
            botVersion?: string;
            /**
                * <p>The specified locale name.</p>
                */
            localeName?: string;
            /**
                * <p>The specified locale identifier.</p>
                */
            localeId?: string;
            /**
                * <p>The specified description of the bot locale.</p>
                */
            description?: string;
            /**
                * <p>The specified confidence threshold for inserting the
                *             <code>AMAZON.FallbackIntent</code> and
                *             <code>AMAZON.KendraSearchIntent</code> intents.</p>
                */
            nluIntentConfidenceThreshold?: number;
            /**
                * <p>The Amazon Polly voice ID that Amazon Lex uses for voice interaction with the
                *          user.</p>
                */
            voiceSettings?: VoiceSettings;
            /**
                * <p>The status of the bot.</p>
                *          <p>When the status is <code>Creating</code> the bot locale is being
                *          configured. When the status is <code>Building</code> Amazon Lex is building
                *          the bot for testing and use.</p>
                *          <p>If the status of the bot is <code>ReadyExpressTesting</code>, you
                *          can test the bot using the exact utterances specified in the bots'
                *          intents. When the bot is ready for full testing or to run, the status
                *          is <code>Built</code>.</p>
                *          <p>If there was a problem with building the bot, the status is
                *             <code>Failed</code>. If the bot was saved but not built, the status
                *          is <code>NotBuilt</code>.</p>
                */
            botLocaleStatus?: BotLocaleStatus | string;
            /**
                * <p>A timestamp specifying the date and time that the bot locale was
                *          created.</p>
                */
            creationDateTime?: Date;
    }
    export namespace CreateBotLocaleResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateBotLocaleResponse) => any;
    }
    export interface CreateBotVersionRequest {
            /**
                * <p>The identifier of the bot to create the version for.</p>
                */
            botId: string | undefined;
            /**
                * <p>A description of the version. Use the description to help identify
                *          the version in lists.</p>
                */
            description?: string;
            /**
                * <p>Specifies the locales that Amazon Lex adds to this version. You can
                *          choose the <code>Draft</code> version or any other previously published
                *          version for each locale. When you specify a source version, the locale
                *          data is copied from the source version to the new version.</p>
                */
            botVersionLocaleSpecification: Record<string, BotVersionLocaleDetails> | undefined;
    }
    export namespace CreateBotVersionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateBotVersionRequest) => any;
    }
    export interface CreateBotVersionResponse {
            /**
                * <p>The bot identifier specified in the request.</p>
                */
            botId?: string;
            /**
                * <p>The description of the version specified in the request.</p>
                */
            description?: string;
            /**
                * <p>The version number assigned to the version.</p>
                */
            botVersion?: string;
            /**
                * <p>The source versions used for each locale in the new version.</p>
                */
            botVersionLocaleSpecification?: Record<string, BotVersionLocaleDetails>;
            /**
                * <p>When you send a request to create or update a bot, Amazon Lex sets the
                *          status response element to <code>Creating</code>. After Amazon Lex builds
                *          the bot, it sets status to <code>Available</code>. If Amazon Lex can't build
                *          the bot, it sets status to <code>Failed</code>.</p>
                */
            botStatus?: BotStatus | string;
            /**
                * <p>A timestamp of the date and time that the version was
                *          created.</p>
                */
            creationDateTime?: Date;
    }
    export namespace CreateBotVersionResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateBotVersionResponse) => any;
    }
    export enum ImportExportFileFormat {
            LexJson = "LexJson",
            TSV = "TSV"
    }
    /**
        * <p>Provides the parameters required for exporting a custom vocabulary.</p>
        */
    export interface CustomVocabularyExportSpecification {
            /**
                * <p>The identifier of the bot that contains the custom vocabulary to export.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot that contains the custom vocabulary to export.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The locale of the bot that contains the custom vocabulary to export.</p>
                */
            localeId: string | undefined;
    }
    export namespace CustomVocabularyExportSpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CustomVocabularyExportSpecification) => any;
    }
    /**
        * <p>Provides information about the bot or bot locale that you want to
        *          export. You can specify the <code>botExportSpecification</code> or the
        *             <code>botLocaleExportSpecification</code>, but not both.</p>
        */
    export interface ExportResourceSpecification {
            /**
                * <p>Parameters for exporting a bot.</p>
                */
            botExportSpecification?: BotExportSpecification;
            /**
                * <p>Parameters for exporting a bot locale.</p>
                */
            botLocaleExportSpecification?: BotLocaleExportSpecification;
            /**
                * <p>The parameters required to export a custom vocabulary.</p>
                */
            customVocabularyExportSpecification?: CustomVocabularyExportSpecification;
    }
    export namespace ExportResourceSpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExportResourceSpecification) => any;
    }
    export interface CreateExportRequest {
            /**
                * <p>Specifies the type of resource to export, either a bot or a bot
                *          locale. You can only specify one type of resource to export.</p>
                */
            resourceSpecification: ExportResourceSpecification | undefined;
            /**
                * <p>The file format of the bot or bot locale definition files.</p>
                */
            fileFormat: ImportExportFileFormat | string | undefined;
            /**
                * <p>An password to use to encrypt the exported archive. Using a password
                *          is optional, but you should encrypt the archive to protect the data in
                *          transit between Amazon Lex and your local computer.</p>
                */
            filePassword?: string;
    }
    export namespace CreateExportRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateExportRequest) => any;
    }
    export enum ExportStatus {
            Completed = "Completed",
            Deleting = "Deleting",
            Failed = "Failed",
            InProgress = "InProgress"
    }
    export interface CreateExportResponse {
            /**
                * <p>An identifier for a specific request to create an export.</p>
                */
            exportId?: string;
            /**
                * <p>A description of the type of resource that was exported, either a
                *          bot or a bot locale.</p>
                */
            resourceSpecification?: ExportResourceSpecification;
            /**
                * <p>The file format used for the bot or bot locale definition
                *          files.</p>
                */
            fileFormat?: ImportExportFileFormat | string;
            /**
                * <p>The status of the export. When the status is <code>Completed</code>,
                *          you can use the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_DescribeExport.html">DescribeExport</a> operation to get the
                *          pre-signed S3 URL link to your exported bot or bot locale.</p>
                */
            exportStatus?: ExportStatus | string;
            /**
                * <p>The date and time that the request to export a bot was
                *          created.</p>
                */
            creationDateTime?: Date;
    }
    export namespace CreateExportResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateExportResponse) => any;
    }
    /**
        * <p>You asked to describe a resource that doesn't exist. Check the
        *          resource that you are requesting and try again.</p>
        */
    export class ResourceNotFoundException extends __BaseException {
            readonly name: "ResourceNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>);
    }
    /**
        * <p>Settings that determine the Lambda function that Amazon Lex uses for
        *          processing user responses.</p>
        */
    export interface DialogCodeHookSettings {
            /**
                * <p>Enables the dialog code hook so that it processes user
                *          requests.</p>
                */
            enabled: boolean | undefined;
    }
    export namespace DialogCodeHookSettings {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DialogCodeHookSettings) => any;
    }
    /**
        * <p>A custom response string that Amazon Lex sends to your application. You
        *          define the content and structure the string.</p>
        */
    export interface CustomPayload {
            /**
                * <p>The string that is sent to your application.</p>
                */
            value: string | undefined;
    }
    export namespace CustomPayload {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CustomPayload) => any;
    }
    /**
        * <p>A card that is shown to the user by a messaging platform. You define
        *          the contents of the card, the card is displayed by the platform. </p>
        *          <p>When you use a response card, the response from the user is
        *          constrained to the text associated with a button on the card.</p>
        */
    export interface ImageResponseCard {
            /**
                * <p>The title to display on the response card. The format of the title
                *          is determined by the platform displaying the response card.</p>
                */
            title: string | undefined;
            /**
                * <p>The subtitle to display on the response card. The format of the
                *          subtitle is determined by the platform displaying the response
                *          card.</p>
                */
            subtitle?: string;
            /**
                * <p>The URL of an image to display on the response card. The image URL
                *          must be publicly available so that the platform displaying the response
                *          card has access to the image.</p>
                */
            imageUrl?: string;
            /**
                * <p>A list of buttons that should be displayed on the response card. The
                *          arrangement of the buttons is determined by the platform that displays
                *          the button.</p>
                */
            buttons?: Button[];
    }
    export namespace ImageResponseCard {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImageResponseCard) => any;
    }
    /**
        * <p>Defines an ASCII text message to send to the user.</p>
        */
    export interface PlainTextMessage {
            /**
                * <p>The message to send to the user.</p>
                */
            value: string | undefined;
    }
    export namespace PlainTextMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PlainTextMessage) => any;
    }
    /**
        * <p>Defines a Speech Synthesis Markup Language (SSML) prompt.</p>
        */
    export interface SSMLMessage {
            /**
                * <p>The SSML text that defines the prompt.</p>
                */
            value: string | undefined;
    }
    export namespace SSMLMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SSMLMessage) => any;
    }
    /**
        * <p>The object that provides message text and it's type.</p>
        */
    export interface Message {
            /**
                * <p>A message in plain text format.</p>
                */
            plainTextMessage?: PlainTextMessage;
            /**
                * <p>A message in a custom format defined by the client
                *          application.</p>
                */
            customPayload?: CustomPayload;
            /**
                * <p>A message in Speech Synthesis Markup Language (SSML).</p>
                */
            ssmlMessage?: SSMLMessage;
            /**
                * <p>A message that defines a response card that the client application
                *          can show to the user.</p>
                */
            imageResponseCard?: ImageResponseCard;
    }
    export namespace Message {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Message) => any;
    }
    /**
        * <p>Provides one or more messages that Amazon Lex should send to the
        *          user.</p>
        */
    export interface MessageGroup {
            /**
                * <p>The primary message that Amazon Lex should send to the user.</p>
                */
            message: Message | undefined;
            /**
                * <p>Message variations to send to the user. When variations are defined,
                *          Amazon Lex chooses the primary message or one of the variations to send to
                *          the user.</p>
                */
            variations?: Message[];
    }
    export namespace MessageGroup {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: MessageGroup) => any;
    }
    /**
        * <p>Provides settings for a message that is sent to the user when a
        *          fulfillment Lambda function starts running.</p>
        */
    export interface FulfillmentStartResponseSpecification {
            /**
                * <p>The delay between when the Lambda fulfillment function starts running
                *          and the start message is played. If the Lambda function returns before
                *          the delay is over, the start message isn't played.</p>
                */
            delayInSeconds: number | undefined;
            /**
                * <p>One to 5 message groups that contain start messages. Amazon Lex chooses
                *          one of the messages to play to the user.</p>
                */
            messageGroups: MessageGroup[] | undefined;
            /**
                * <p>Determines whether the user can interrupt the start message while it
                *          is playing.</p>
                */
            allowInterrupt?: boolean;
    }
    export namespace FulfillmentStartResponseSpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FulfillmentStartResponseSpecification) => any;
    }
    /**
        * <p>Provides settings for a message that is sent periodically to the
        *          user while a fulfillment Lambda function is running.</p>
        */
    export interface FulfillmentUpdateResponseSpecification {
            /**
                * <p>The frequency that a message is sent to the user. When the period
                *          ends, Amazon Lex chooses a message from the message groups and plays it to
                *          the user. If the fulfillment Lambda returns before the first period
                *          ends, an update message is not played to the user.</p>
                */
            frequencyInSeconds: number | undefined;
            /**
                * <p>One to 5 message groups that contain update messages. Amazon Lex chooses
                *          one of the messages to play to the user.</p>
                */
            messageGroups: MessageGroup[] | undefined;
            /**
                * <p>Determines whether the user can interrupt an update message while it
                *          is playing.</p>
                */
            allowInterrupt?: boolean;
    }
    export namespace FulfillmentUpdateResponseSpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FulfillmentUpdateResponseSpecification) => any;
    }
    /**
        * <p>Provides information for updating the user on the progress of
        *          fulfilling an intent.</p>
        */
    export interface FulfillmentUpdatesSpecification {
            /**
                * <p>Determines whether fulfillment updates are sent to the user. When
                *          this field is true, updates are sent.</p>
                *          <p>If the <code>active</code> field is set to true, the
                *             <code>startResponse</code>, <code>updateResponse</code>, and
                *             <code>timeoutInSeconds</code> fields are required.</p>
                */
            active: boolean | undefined;
            /**
                * <p>Provides configuration information for the message sent to users
                *          when the fulfillment Lambda functions starts running.</p>
                */
            startResponse?: FulfillmentStartResponseSpecification;
            /**
                * <p>Provides configuration information for messages sent periodically to
                *          the user while the fulfillment Lambda function is running.</p>
                */
            updateResponse?: FulfillmentUpdateResponseSpecification;
            /**
                * <p>The length of time that the fulfillment Lambda function should run
                *          before it times out.</p>
                */
            timeoutInSeconds?: number;
    }
    export namespace FulfillmentUpdatesSpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FulfillmentUpdatesSpecification) => any;
    }
    /**
        * <p>Specifies a list of message groups that Amazon Lex uses to respond the
        *          user input.</p>
        */
    export interface ResponseSpecification {
            /**
                * <p>A collection of responses that Amazon Lex can send to the user. Amazon Lex
                *          chooses the actual response to send at runtime.</p>
                */
            messageGroups: MessageGroup[] | undefined;
            /**
                * <p>Indicates whether the user can interrupt a speech response from
                *          Amazon Lex.</p>
                */
            allowInterrupt?: boolean;
    }
    export namespace ResponseSpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseSpecification) => any;
    }
    /**
        * <p>Provides a setting that determines whether the post-fulfillment
        *          response is sent to the user. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/streaming-progress.html#progress-complete">https://docs.aws.amazon.com/lexv2/latest/dg/streaming-progress.html#progress-complete</a>
        *          </p>
        */
    export interface PostFulfillmentStatusSpecification {
            /**
                * <p>Specifies a list of message groups that Amazon Lex uses to respond the
                *          user input.</p>
                */
            successResponse?: ResponseSpecification;
            /**
                * <p>Specifies a list of message groups that Amazon Lex uses to respond the
                *          user input.</p>
                */
            failureResponse?: ResponseSpecification;
            /**
                * <p>Specifies a list of message groups that Amazon Lex uses to respond the
                *          user input.</p>
                */
            timeoutResponse?: ResponseSpecification;
    }
    export namespace PostFulfillmentStatusSpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PostFulfillmentStatusSpecification) => any;
    }
    /**
        * <p>Determines if a Lambda function should be invoked for a specific
        *          intent.</p>
        */
    export interface FulfillmentCodeHookSettings {
            /**
                * <p>Indicates whether a Lambda function should be invoked to fulfill a
                *          specific intent.</p>
                */
            enabled: boolean | undefined;
            /**
                * <p>Provides settings for messages sent to the user for after the Lambda
                *          fulfillment function completes. Post-fulfillment messages can be sent
                *          for both streaming and non-streaming conversations.</p>
                */
            postFulfillmentStatusSpecification?: PostFulfillmentStatusSpecification;
            /**
                * <p>Provides settings for update messages sent to the user for
                *          long-running Lambda fulfillment functions. Fulfillment updates can be
                *          used only with streaming conversations.</p>
                */
            fulfillmentUpdatesSpecification?: FulfillmentUpdatesSpecification;
    }
    export namespace FulfillmentCodeHookSettings {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FulfillmentCodeHookSettings) => any;
    }
    /**
        * <p>The name of a context that must be active for an intent to be
        *          selected by Amazon Lex.</p>
        */
    export interface InputContext {
            /**
                * <p>The name of the context.</p>
                */
            name: string | undefined;
    }
    export namespace InputContext {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InputContext) => any;
    }
    /**
        * <p>Provides a statement the Amazon Lex conveys to the user when the intent
        *          is successfully fulfilled.</p>
        */
    export interface IntentClosingSetting {
            /**
                * <p>The response that Amazon Lex sends to the user when the intent is
                *          complete.</p>
                */
            closingResponse: ResponseSpecification | undefined;
            /**
                * <p>Specifies whether an intent's closing response is used. When this
                *          field is false, the closing response isn't sent to the user. If the
                *             <code>active</code> field isn't specified, the default is
                *          true.</p>
                */
            active?: boolean;
    }
    export namespace IntentClosingSetting {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: IntentClosingSetting) => any;
    }
    export enum MessageSelectionStrategy {
            Ordered = "Ordered",
            Random = "Random"
    }
    /**
        * <p>Specifies a list of message groups that Amazon Lex sends to a user to
        *          elicit a response.</p>
        */
    export interface PromptSpecification {
            /**
                * <p>A collection of messages that Amazon Lex can send to the user. Amazon Lex
                *          chooses the actual message to send at runtime.</p>
                */
            messageGroups: MessageGroup[] | undefined;
            /**
                * <p>The maximum number of times the bot tries to elicit a response from
                *          the user using this prompt.</p>
                */
            maxRetries: number | undefined;
            /**
                * <p>Indicates whether the user can interrupt a speech prompt from the
                *          bot.</p>
                */
            allowInterrupt?: boolean;
            /**
                * <p>Indicates how a message is selected from a message group among retries.</p>
                */
            messageSelectionStrategy?: MessageSelectionStrategy | string;
    }
    export namespace PromptSpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PromptSpecification) => any;
    }
    /**
        * <p>Provides a prompt for making sure that the user is ready for the
        *          intent to be fulfilled.</p>
        */
    export interface IntentConfirmationSetting {
            /**
                * <p>Prompts the user to confirm the intent. This question should have a
                *          yes or no answer.</p>
                *          <p>Amazon Lex uses this prompt to ensure that the user acknowledges that the
                *          intent is ready for fulfillment. For example, with the
                *             <code>OrderPizza</code> intent, you might want to confirm that the
                *          order is correct before placing it. For other intents, such as intents
                *          that simply respond to user questions, you might not need to ask the
                *          user for confirmation before providing the information. </p>
                */
            promptSpecification: PromptSpecification | undefined;
            /**
                * <p>When the user answers "no" to the question defined in
                *             <code>promptSpecification</code>, Amazon Lex responds with this response
                *          to acknowledge that the intent was canceled. </p>
                */
            declinationResponse: ResponseSpecification | undefined;
            /**
                * <p>Specifies whether the intent's confirmation is sent to the user.
                *          When this field is false, confirmation and declination responses aren't
                *          sent. If the <code>active</code> field isn't specified, the default is
                *          true.</p>
                */
            active?: boolean;
    }
    export namespace IntentConfirmationSetting {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: IntentConfirmationSetting) => any;
    }
    /**
        * <p>Provides configuration information for the AMAZON.KendraSearchIntent
        *          intent. When you use this intent, Amazon Lex searches the specified Amazon Kendra
        *          index and returns documents from the index that match the user's
        *          utterance.</p>
        */
    export interface KendraConfiguration {
            /**
                * <p>The Amazon Resource Name (ARN) of the Amazon Kendra index that you want the
                *          AMAZON.KendraSearchIntent intent to search. The index must be in the
                *          same account and Region as the Amazon Lex bot.</p>
                */
            kendraIndex: string | undefined;
            /**
                * <p>Determines whether the AMAZON.KendraSearchIntent intent uses a
                *          custom query string to query the Amazon Kendra index.</p>
                */
            queryFilterStringEnabled?: boolean;
            /**
                * <p>A query filter that Amazon Lex sends to Amazon Kendra to filter the response from
                *          a query. The filter is in the format defined by Amazon Kendra. For more
                *          information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/filtering.html">Filtering
                *          queries</a>.</p>
                */
            queryFilterString?: string;
    }
    export namespace KendraConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: KendraConfiguration) => any;
    }
    /**
        * <p>Describes a session context that is activated when an intent is
        *          fulfilled.</p>
        */
    export interface OutputContext {
            /**
                * <p>The name of the output context.</p>
                */
            name: string | undefined;
            /**
                * <p>The amount of time, in seconds, that the output context should
                *          remain active. The time is figured from the first time the context is
                *          sent to the user.</p>
                */
            timeToLiveInSeconds: number | undefined;
            /**
                * <p>The number of conversation turns that the output context should
                *          remain active. The number of turns is counted from the first time that
                *          the context is sent to the user.</p>
                */
            turnsToLive: number | undefined;
    }
    export namespace OutputContext {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OutputContext) => any;
    }
    /**
        * <p>A sample utterance that invokes an intent or respond to a slot
        *          elicitation prompt.</p>
        */
    export interface SampleUtterance {
            /**
                * <p>The sample utterance that Amazon Lex uses to build its machine-learning
                *          model to recognize intents.</p>
                */
            utterance: string | undefined;
    }
    export namespace SampleUtterance {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SampleUtterance) => any;
    }
    export interface CreateIntentRequest {
            /**
                * <p>The name of the intent. Intent names must be unique in the locale
                *          that contains the intent and cannot match the name of any built-in
                *          intent.</p>
                */
            intentName: string | undefined;
            /**
                * <p>A description of the intent. Use the description to help identify
                *          the intent in lists.</p>
                */
            description?: string;
            /**
                * <p>A unique identifier for the built-in intent to base this intent
                *          on.</p>
                */
            parentIntentSignature?: string;
            /**
                * <p>An array of strings that a user might say to signal the intent. For
                *          example, "I want a pizza", or "I want a {PizzaSize} pizza". </p>
                *          <p>In an utterance, slot names are enclosed in curly braces ("{", "}")
                *          to indicate where they should be displayed in the utterance shown to
                *          the user.. </p>
                */
            sampleUtterances?: SampleUtterance[];
            /**
                * <p>Specifies that Amazon Lex invokes the alias Lambda function for each user
                *          input. You can invoke this Lambda function to personalize user
                *          interaction.</p>
                *          <p>For example, suppose that your bot determines that the user's name
                *          is John. You Lambda function might retrieve John's information from a
                *          backend database and prepopulate some of the values. For example, if
                *          you find that John is gluten intolerant, you might set the
                *          corresponding intent slot, <code>glutenIntolerant</code> to
                *             <code>true</code>. You might find John's phone number and set the
                *          corresponding session attribute.</p>
                */
            dialogCodeHook?: DialogCodeHookSettings;
            /**
                * <p>Specifies that Amazon Lex invokes the alias Lambda function when the
                *          intent is ready for fulfillment. You can invoke this function to
                *          complete the bot's transaction with the user.</p>
                *          <p>For example, in a pizza ordering bot, the Lambda function can look up
                *          the closest pizza restaurant to the customer's location and then place
                *          an order on the customer's behalf.</p>
                */
            fulfillmentCodeHook?: FulfillmentCodeHookSettings;
            /**
                * <p>Provides prompts that Amazon Lex sends to the user to confirm the
                *          completion of an intent. If the user answers "no," the settings contain
                *          a statement that is sent to the user to end the intent.</p>
                */
            intentConfirmationSetting?: IntentConfirmationSetting;
            /**
                * <p>Sets the response that Amazon Lex sends to the user when the intent is
                *          closed.</p>
                */
            intentClosingSetting?: IntentClosingSetting;
            /**
                * <p>A list of contexts that must be active for this intent to be
                *          considered by Amazon Lex.</p>
                *          <p>When an intent has an input context list, Amazon Lex only considers using
                *          the intent in an interaction with the user when the specified contexts
                *          are included in the active context list for the session. If the
                *          contexts are not active, then Amazon Lex will not use the intent.</p>
                *          <p>A context can be automatically activated using the
                *             <code>outputContexts</code> property or it can be set at
                *          runtime.</p>
                *          <p> For example, if there are two intents with different input contexts
                *          that respond to the same utterances, only the intent with the active
                *          context will respond.</p>
                *          <p>An intent may have up to 5 input contexts. If an intent has multiple
                *          input contexts, all of the contexts must be active to consider the
                *          intent.</p>
                */
            inputContexts?: InputContext[];
            /**
                * <p>A lists of contexts that the intent activates when it is
                *          fulfilled.</p>
                *          <p>You can use an output context to indicate the intents that Amazon Lex
                *          should consider for the next turn of the conversation with a customer. </p>
                *          <p>When you use the <code>outputContextsList</code> property, all of
                *          the contexts specified in the list are activated when the intent is
                *          fulfilled. You can set up to 10 output contexts. You can also set the
                *          number of conversation turns that the context should be active, or the
                *          length of time that the context should be active.</p>
                */
            outputContexts?: OutputContext[];
            /**
                * <p>Configuration information required to use the
                *             <code>AMAZON.KendraSearchIntent</code> intent to connect to an Amazon Kendra
                *          index. The <code>AMAZON.KendraSearchIntent</code> intent is called when
                *          Amazon Lex can't determine another intent to invoke.</p>
                */
            kendraConfiguration?: KendraConfiguration;
            /**
                * <p>The identifier of the bot associated with this intent.</p>
                */
            botId: string | undefined;
            /**
                * <p>The identifier of the version of the bot associated with this
                *          intent.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale where this intent is used.
                *          All of the bots, slot types, and slots used by the intent must have the
                *          same locale. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId: string | undefined;
    }
    export namespace CreateIntentRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateIntentRequest) => any;
    }
    export interface CreateIntentResponse {
            /**
                * <p>A unique identifier for the intent.</p>
                */
            intentId?: string;
            /**
                * <p>The name specified for the intent.</p>
                */
            intentName?: string;
            /**
                * <p>The description specified for the intent.</p>
                */
            description?: string;
            /**
                * <p>The signature of the parent intent specified for the intent.</p>
                */
            parentIntentSignature?: string;
            /**
                * <p>The sample utterances specified for the intent.</p>
                */
            sampleUtterances?: SampleUtterance[];
            /**
                * <p>The dialog Lambda function specified for the intent.</p>
                */
            dialogCodeHook?: DialogCodeHookSettings;
            /**
                * <p>The fulfillment Lambda function specified for the intent.</p>
                */
            fulfillmentCodeHook?: FulfillmentCodeHookSettings;
            /**
                * <p>The confirmation setting specified for the intent.</p>
                */
            intentConfirmationSetting?: IntentConfirmationSetting;
            /**
                * <p>The closing setting specified for the intent.</p>
                */
            intentClosingSetting?: IntentClosingSetting;
            /**
                * <p>The list of input contexts specified for the intent.</p>
                */
            inputContexts?: InputContext[];
            /**
                * <p>The list of output contexts specified for the intent.</p>
                */
            outputContexts?: OutputContext[];
            /**
                * <p>Configuration for searching a Amazon Kendra index specified for the
                *          intent.</p>
                */
            kendraConfiguration?: KendraConfiguration;
            /**
                * <p>The identifier of the bot associated with the intent.</p>
                */
            botId?: string;
            /**
                * <p>The identifier of the version of the bot associated with the
                *          intent.</p>
                */
            botVersion?: string;
            /**
                * <p>The locale that the intent is specified to use.</p>
                */
            localeId?: string;
            /**
                * <p>A timestamp of the date and time that the intent was created.</p>
                */
            creationDateTime?: Date;
    }
    export namespace CreateIntentResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateIntentResponse) => any;
    }
    export interface CreateResourcePolicyRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the bot or bot alias that the
                *          resource policy is attached to.</p>
                */
            resourceArn: string | undefined;
            /**
                * <p>A resource policy to add to the resource. The policy is a JSON
                *          structure that contains one or more statements that define the policy.
                *          The policy must follow the IAM syntax. For more information about the
                *          contents of a JSON policy document, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies.html"> IAM JSON policy
                *             reference </a>. </p>
                *          <p>If the policy isn't valid, Amazon Lex returns a validation
                *          exception.</p>
                */
            policy: string | undefined;
    }
    export namespace CreateResourcePolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateResourcePolicyRequest) => any;
    }
    export interface CreateResourcePolicyResponse {
            /**
                * <p>The Amazon Resource Name (ARN) of the bot or bot alias that the
                *          resource policy was attached to.</p>
                */
            resourceArn?: string;
            /**
                * <p>The current revision of the resource policy. Use the revision ID to
                *          make sure that you are updating the most current version of a resource
                *          policy when you add a policy statement to a resource, delete a
                *          resource, or update a resource.</p>
                */
            revisionId?: string;
    }
    export namespace CreateResourcePolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateResourcePolicyResponse) => any;
    }
    export enum Effect {
            Allow = "Allow",
            Deny = "Deny"
    }
    /**
        * <p>The IAM principal that you allowing or denying access to an Amazon Lex
        *          action. You must provide a <code>service</code> or an <code>arn</code>,
        *          but not both in the same statement. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html"> AWS JSON policy elements: Principal </a>.</p>
        */
    export interface Principal {
            /**
                * <p>The name of the AWS service that should allowed or denied access to
                *          an Amazon Lex action.</p>
                */
            service?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the principal.</p>
                */
            arn?: string;
    }
    export namespace Principal {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Principal) => any;
    }
    export interface CreateResourcePolicyStatementRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the bot or bot alias that the
                *          resource policy is attached to.</p>
                */
            resourceArn: string | undefined;
            /**
                * <p>The name of the statement. The ID is the same as the
                *             <code>Sid</code> IAM property. The statement name must be unique
                *          within the policy. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_sid.html">IAM
                *             JSON policy elements: Sid</a>. </p>
                */
            statementId: string | undefined;
            /**
                * <p>Determines whether the statement allows or denies access to the
                *          resource.</p>
                */
            effect: Effect | string | undefined;
            /**
                * <p>An IAM principal, such as an IAM users, IAM roles, or AWS services
                *          that is allowed or denied access to a resource. For more information,
                *          see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html">AWS JSON policy elements: Principal</a>.</p>
                */
            principal: Principal[] | undefined;
            /**
                * <p>The Amazon Lex action that this policy either allows or denies. The
                *          action must apply to the resource type of the specified ARN. For more
                *          information, see <a href="https://docs.aws.amazon.com/service-authorization/latest/reference/list_amazonlexv2.html">
                *             Actions, resources, and condition keys for Amazon Lex V2</a>.</p>
                */
            action: string[] | undefined;
            /**
                * <p>Specifies a condition when the policy is in effect. If the principal
                *          of the policy is a service principal, you must provide two condition
                *          blocks, one with a SourceAccount global condition key and one with a
                *          SourceArn global condition key.</p>
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition.html">IAM JSON policy elements: Condition </a>.</p>
                */
            condition?: Record<string, Record<string, string>>;
            /**
                * <p>The identifier of the revision of the policy to edit. If this
                *          revision ID doesn't match the current revision ID, Amazon Lex throws an
                *          exception.</p>
                *          <p>If you don't specify a revision, Amazon Lex overwrites the contents of
                *          the policy with the new values.</p>
                */
            expectedRevisionId?: string;
    }
    export namespace CreateResourcePolicyStatementRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateResourcePolicyStatementRequest) => any;
    }
    export interface CreateResourcePolicyStatementResponse {
            /**
                * <p>The Amazon Resource Name (ARN) of the bot or bot alias that the
                *          resource policy is attached to.</p>
                */
            resourceArn?: string;
            /**
                * <p>The current revision of the resource policy. Use the revision ID to
                *          make sure that you are updating the most current version of a resource
                *          policy when you add a policy statement to a resource, delete a
                *          resource, or update a resource.</p>
                */
            revisionId?: string;
    }
    export namespace CreateResourcePolicyStatementResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateResourcePolicyStatementResponse) => any;
    }
    /**
        * <p>Indicates whether a slot can return multiple values.</p>
        */
    export interface MultipleValuesSetting {
            /**
                * <p>Indicates whether a slot can return multiple values. When
                *             <code>true</code>, the slot may return more than one value in a
                *          response. When <code>false</code>, the slot returns only a single
                *          value.</p>
                *          <p>Multi-value slots are only available in the en-US locale. If you set
                *          this value to <code>true</code> in any other locale, Amazon Lex throws a
                *             <code>ValidationException</code>.</p>
                *          <p>If the <code>allowMutlipleValues</code> is not set, the default
                *          value is <code>false</code>.</p>
                */
            allowMultipleValues?: boolean;
    }
    export namespace MultipleValuesSetting {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: MultipleValuesSetting) => any;
    }
    export enum ObfuscationSettingType {
            DefaultObfuscation = "DefaultObfuscation",
            None = "None"
    }
    /**
        * <p>Determines whether Amazon Lex obscures slot values in conversation logs.
        *       </p>
        */
    export interface ObfuscationSetting {
            /**
                * <p>Value that determines whether Amazon Lex obscures slot values in
                *          conversation logs. The default is to obscure the values.</p>
                */
            obfuscationSettingType: ObfuscationSettingType | string | undefined;
    }
    export namespace ObfuscationSetting {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ObfuscationSetting) => any;
    }
    /**
        * <p>Specifies the default value to use when a user doesn't provide a
        *          value for a slot.</p>
        */
    export interface SlotDefaultValue {
            /**
                * <p>The default value to use when a user doesn't provide a value for a
                *          slot.</p>
                */
            defaultValue: string | undefined;
    }
    export namespace SlotDefaultValue {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SlotDefaultValue) => any;
    }
    /**
        * <p>Defines a list of values that Amazon Lex should use as the default value
        *          for a slot.</p>
        */
    export interface SlotDefaultValueSpecification {
            /**
                * <p>A list of default values. Amazon Lex chooses the default value to use in
                *          the order that they are presented in the list.</p>
                */
            defaultValueList: SlotDefaultValue[] | undefined;
    }
    export namespace SlotDefaultValueSpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SlotDefaultValueSpecification) => any;
    }
    export enum SlotConstraint {
            Optional = "Optional",
            Required = "Required"
    }
    /**
        * <p>Defines the messages that Amazon Lex sends to a user to remind them that
        *          the bot is waiting for a response.</p>
        */
    export interface StillWaitingResponseSpecification {
            /**
                * <p>One or more message groups, each containing one or more messages,
                *          that define the prompts that Amazon Lex sends to the user.</p>
                */
            messageGroups: MessageGroup[] | undefined;
            /**
                * <p>How often a message should be sent to the user. Minimum of 1 second,
                *          maximum of 5 minutes.</p>
                */
            frequencyInSeconds: number | undefined;
            /**
                * <p>If Amazon Lex waits longer than this length of time for a response, it
                *          will stop sending messages.</p>
                */
            timeoutInSeconds: number | undefined;
            /**
                * <p>Indicates that the user can interrupt the response by speaking while
                *          the message is being played.</p>
                */
            allowInterrupt?: boolean;
    }
    export namespace StillWaitingResponseSpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StillWaitingResponseSpecification) => any;
    }
    /**
        * <p>Specifies the prompts that Amazon Lex uses while a bot is waiting for
        *          customer input. </p>
        */
    export interface WaitAndContinueSpecification {
            /**
                * <p>The response that Amazon Lex sends to indicate that the bot is waiting
                *          for the conversation to continue.</p>
                */
            waitingResponse: ResponseSpecification | undefined;
            /**
                * <p>The response that Amazon Lex sends to indicate that the bot is ready to
                *          continue the conversation.</p>
                */
            continueResponse: ResponseSpecification | undefined;
            /**
                * <p>A response that Amazon Lex sends periodically to the user to indicate
                *          that the bot is still waiting for input from the user.</p>
                */
            stillWaitingResponse?: StillWaitingResponseSpecification;
            /**
                * <p>Specifies whether the bot will wait for a user to respond. When this
                *          field is false, wait and continue responses for a slot aren't used. If
                *          the <code>active</code> field isn't specified, the default is
                *          true.</p>
                */
            active?: boolean;
    }
    export namespace WaitAndContinueSpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: WaitAndContinueSpecification) => any;
    }
    /**
        * <p>Settings that you can use for eliciting a slot value.</p>
        */
    export interface SlotValueElicitationSetting {
            /**
                * <p>A list of default values for a slot. Default values are used when
                *          Amazon Lex hasn't determined a value for a slot. You can specify default
                *          values from context variables, session attributes, and defined
                *          values.</p>
                */
            defaultValueSpecification?: SlotDefaultValueSpecification;
            /**
                * <p>Specifies whether the slot is required or optional.</p>
                */
            slotConstraint: SlotConstraint | string | undefined;
            /**
                * <p>The prompt that Amazon Lex uses to elicit the slot value from the
                *          user.</p>
                */
            promptSpecification?: PromptSpecification;
            /**
                * <p>If you know a specific pattern that users might respond to an Amazon Lex
                *          request for a slot value, you can provide those utterances to improve
                *          accuracy. This is optional. In most cases, Amazon Lex is capable of
                *          understanding user utterances.</p>
                */
            sampleUtterances?: SampleUtterance[];
            /**
                * <p>Specifies the prompts that Amazon Lex uses while a bot is waiting for
                *          customer input. </p>
                */
            waitAndContinueSpecification?: WaitAndContinueSpecification;
    }
    export namespace SlotValueElicitationSetting {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SlotValueElicitationSetting) => any;
    }
    export interface CreateSlotRequest {
            /**
                * <p>The name of the slot. Slot names must be unique within the bot that
                *          contains the slot.</p>
                */
            slotName: string | undefined;
            /**
                * <p>A description of the slot. Use this to help identify the slot in
                *          lists.</p>
                */
            description?: string;
            /**
                * <p>The unique identifier for the slot type associated with this slot.
                *          The slot type determines the values that can be entered into the
                *          slot.</p>
                */
            slotTypeId?: string;
            /**
                * <p>Specifies prompts that Amazon Lex sends to the user to elicit a response
                *          that provides the value for the slot. </p>
                */
            valueElicitationSetting: SlotValueElicitationSetting | undefined;
            /**
                * <p>Determines how slot values are used in Amazon CloudWatch logs. If the value of
                *          the <code>obfuscationSetting</code> parameter is
                *             <code>DefaultObfuscation</code>, slot values are obfuscated in the
                *          log output. If the value is <code>None</code>, the actual value is
                *          present in the log output.</p>
                *          <p>The default is to obfuscate values in the CloudWatch logs.</p>
                */
            obfuscationSetting?: ObfuscationSetting;
            /**
                * <p>The identifier of the bot associated with the slot.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot associated with the slot.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale that the slot will be used
                *          in. The string must match one of the supported locales. All of the
                *          bots, intents, slot types used by the slot must have the same locale.
                *          For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId: string | undefined;
            /**
                * <p>The identifier of the intent that contains the slot.</p>
                */
            intentId: string | undefined;
            /**
                * <p>Indicates whether the slot returns multiple values in one response.
                *          Multi-value slots are only available in the en-US locale. If you set
                *          this value to <code>true</code> in any other locale, Amazon Lex throws a
                *             <code>ValidationException</code>. </p>
                *          <p>If the <code>multipleValuesSetting</code> is not set, the default
                *          value is <code>false</code>.</p>
                */
            multipleValuesSetting?: MultipleValuesSetting;
    }
    export namespace CreateSlotRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateSlotRequest) => any;
    }
    export interface CreateSlotResponse {
            /**
                * <p>The unique identifier associated with the slot. Use this to identify
                *          the slot when you update or delete it.</p>
                */
            slotId?: string;
            /**
                * <p>The name specified for the slot.</p>
                */
            slotName?: string;
            /**
                * <p>The description associated with the slot.</p>
                */
            description?: string;
            /**
                * <p>The unique identifier of the slot type associated with this
                *          slot.</p>
                */
            slotTypeId?: string;
            /**
                * <p>The value elicitation settings specified for the slot.</p>
                */
            valueElicitationSetting?: SlotValueElicitationSetting;
            /**
                * <p>Indicates whether the slot is configured to obfuscate values in Amazon CloudWatch
                *          logs.</p>
                */
            obfuscationSetting?: ObfuscationSetting;
            /**
                * <p>The unique identifier of the bot associated with the slot.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot associated with the slot.</p>
                */
            botVersion?: string;
            /**
                * <p>The language and local specified for the slot.</p>
                */
            localeId?: string;
            /**
                * <p>The unique identifier of the intent associated with the slot.</p>
                */
            intentId?: string;
            /**
                * <p>The timestamp of the date and time that the slot was created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>Indicates whether the slot returns multiple values in one
                *          response.</p>
                */
            multipleValuesSetting?: MultipleValuesSetting;
    }
    export namespace CreateSlotResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateSlotResponse) => any;
    }
    /**
        * <p>Describes the Amazon S3 bucket name and location for the grammar
        *          that is the source for the slot type.</p>
        */
    export interface GrammarSlotTypeSource {
            /**
                * <p>The name of the S3 bucket that contains the grammar source.</p>
                */
            s3BucketName: string | undefined;
            /**
                * <p>The path to the grammar in the S3 bucket.</p>
                */
            s3ObjectKey: string | undefined;
            /**
                * <p>The Amazon KMS key required to decrypt the contents of the grammar,
                *          if any.</p>
                */
            kmsKeyArn?: string;
    }
    export namespace GrammarSlotTypeSource {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GrammarSlotTypeSource) => any;
    }
    /**
        * <p>Settings requried for a slot type based on a grammar that you
        *          provide.</p>
        */
    export interface GrammarSlotTypeSetting {
            /**
                * <p>The source of the grammar used to create the slot type.</p>
                */
            source?: GrammarSlotTypeSource;
    }
    export namespace GrammarSlotTypeSetting {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GrammarSlotTypeSetting) => any;
    }
    /**
        * <p>Provides information about the external source of the slot type's
        *          definition.</p>
        */
    export interface ExternalSourceSetting {
            /**
                * <p>Settings required for a slot type based on a grammar that you
                *          provide.</p>
                */
            grammarSlotTypeSetting?: GrammarSlotTypeSetting;
    }
    export namespace ExternalSourceSetting {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExternalSourceSetting) => any;
    }
    /**
        * <p>Defines one of the values for a slot type.</p>
        */
    export interface SampleValue {
            /**
                * <p>The value that can be used for a slot type.</p>
                */
            value: string | undefined;
    }
    export namespace SampleValue {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SampleValue) => any;
    }
    /**
        * <p>Each slot type can have a set of values. Each
        *             <code>SlotTypeValue</code> represents a value that the slot type can
        *          take.</p>
        */
    export interface SlotTypeValue {
            /**
                * <p>The value of the slot type entry.</p>
                */
            sampleValue?: SampleValue;
            /**
                * <p>Additional values related to the slot type entry.</p>
                */
            synonyms?: SampleValue[];
    }
    export namespace SlotTypeValue {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SlotTypeValue) => any;
    }
    /**
        * <p>Provides a regular expression used to validate the value of a
        *          slot.</p>
        */
    export interface SlotValueRegexFilter {
            /**
                * <p>A regular expression used to validate the value of a slot.</p>
                *          <p> Use a standard regular expression. Amazon Lex supports the following
                *          characters in the regular expression: </p>
                *          <ul>
                *             <li>
                *                <p>A-Z, a-z</p>
                *             </li>
                *             <li>
                *                <p>0-9</p>
                *             </li>
                *             <li>
                *                <p>Unicode characters ("\ u<Unicode>")</p>
                *             </li>
                *          </ul>
                *          <p> Represent Unicode characters with four digits, for example "\u0041"
                *          or "\u005A". </p>
                *          <p> The following regular expression operators are not supported: </p>
                *          <ul>
                *             <li>
                *                <p>Infinite repeaters: *, +, or {x,} with no upper bound.</p>
                *             </li>
                *             <li>
                *                <p>Wild card (.)</p>
                *             </li>
                *          </ul>
                */
            pattern: string | undefined;
    }
    export namespace SlotValueRegexFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SlotValueRegexFilter) => any;
    }
    export enum SlotValueResolutionStrategy {
            OriginalValue = "OriginalValue",
            TopResolution = "TopResolution"
    }
    /**
        * <p>Contains settings used by Amazon Lex to select a slot value.</p>
        */
    export interface SlotValueSelectionSetting {
            /**
                * <p>Determines the slot resolution strategy that Amazon Lex uses to
                *          return slot type values. The field can be set to one of the following
                *          values:</p>
                *
                *          <ul>
                *             <li>
                *                <p>OriginalValue - Returns the value entered by the user, if the
                *                user value is similar to the slot value.</p>
                *             </li>
                *             <li>
                *                <p>TopResolution - If there is a resolution list for the slot,
                *                return the first value in the resolution list as the slot type
                *                value. If there is no resolution list, null is returned.</p>
                *             </li>
                *          </ul>
                *
                *          <p>If you don't specify the valueSelectionStrategy, the default is
                *          OriginalValue. </p>
                */
            resolutionStrategy: SlotValueResolutionStrategy | string | undefined;
            /**
                * <p>A regular expression used to validate the value of a slot.</p>
                */
            regexFilter?: SlotValueRegexFilter;
            /**
                * <p>Provides settings that enable advanced recognition settings for slot
                *          values.</p>
                */
            advancedRecognitionSetting?: AdvancedRecognitionSetting;
    }
    export namespace SlotValueSelectionSetting {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SlotValueSelectionSetting) => any;
    }
    export interface CreateSlotTypeRequest {
            /**
                * <p>The name for the slot. A slot type name must be unique within the
                *          account.</p>
                */
            slotTypeName: string | undefined;
            /**
                * <p>A description of the slot type. Use the description to help identify
                *          the slot type in lists.</p>
                */
            description?: string;
            /**
                * <p>A list of <code>SlotTypeValue</code> objects that defines the values
                *          that the slot type can take. Each value can have a list of synonyms,
                *          additional values that help train the machine learning model about the
                *          values that it resolves for a slot.</p>
                */
            slotTypeValues?: SlotTypeValue[];
            /**
                * <p>Determines the strategy that Amazon Lex uses to select a value from the
                *          list of possible values. The field can be set to one of the following
                *          values:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>OriginalValue</code> - Returns the value entered by the
                *                user, if the user value is similar to the slot value.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>TopResolution</code> - If there is a resolution list for
                *                the slot, return the first value in the resolution list. If there
                *                is no resolution list, return null.</p>
                *             </li>
                *          </ul>
                *          <p>If you don't specify the <code>valueSelectionSetting</code>
                *          parameter, the default is <code>OriginalValue</code>.</p>
                */
            valueSelectionSetting?: SlotValueSelectionSetting;
            /**
                * <p>The built-in slot type used as a parent of this slot type. When you
                *          define a parent slot type, the new slot type has the configuration of
                *          the parent slot type.</p>
                *          <p>Only <code>AMAZON.AlphaNumeric</code> is supported.</p>
                */
            parentSlotTypeSignature?: string;
            /**
                * <p>The identifier of the bot associated with this slot type.</p>
                */
            botId: string | undefined;
            /**
                * <p>The identifier of the bot version associated with this slot
                *          type.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale that the slot type will be
                *          used in. The string must match one of the supported locales. All of the
                *          bots, intents, and slots used by the slot type must have the same
                *          locale. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId: string | undefined;
            /**
                * <p>Sets the type of external information used to create the slot
                *          type.</p>
                */
            externalSourceSetting?: ExternalSourceSetting;
    }
    export namespace CreateSlotTypeRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateSlotTypeRequest) => any;
    }
    export interface CreateSlotTypeResponse {
            /**
                * <p>The unique identifier assigned to the slot type. Use this to
                *          identify the slot type in the <code>UpdateSlotType</code> and
                *             <code>DeleteSlotType</code> operations.</p>
                */
            slotTypeId?: string;
            /**
                * <p>The name specified for the slot type.</p>
                */
            slotTypeName?: string;
            /**
                * <p>The description specified for the slot type.</p>
                */
            description?: string;
            /**
                * <p>The list of values that the slot type can assume.</p>
                */
            slotTypeValues?: SlotTypeValue[];
            /**
                * <p>The strategy that Amazon Lex uses to select a value from the list of
                *          possible values.</p>
                */
            valueSelectionSetting?: SlotValueSelectionSetting;
            /**
                * <p>The signature of the base slot type specified for the slot
                *          type.</p>
                */
            parentSlotTypeSignature?: string;
            /**
                * <p>The identifier for the bot associated with the slot type.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot associated with the slot type.</p>
                */
            botVersion?: string;
            /**
                * <p>The specified language and local specified for the slot type.</p>
                */
            localeId?: string;
            /**
                * <p>A timestamp of the date and time that the slot type was
                *          created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>The type of external information used to create the slot
                *          type.</p>
                */
            externalSourceSetting?: ExternalSourceSetting;
    }
    export namespace CreateSlotTypeResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateSlotTypeResponse) => any;
    }
    export interface CreateUploadUrlRequest {
    }
    export namespace CreateUploadUrlRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateUploadUrlRequest) => any;
    }
    export interface CreateUploadUrlResponse {
            /**
                * <p>An identifier for a unique import job. Use it when you call the
                *             <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_StartImport.html">StartImport</a> operation.</p>
                */
            importId?: string;
            /**
                * <p>A pre-signed S3 write URL. Upload the zip archive file that contains
                *          the definition of your bot or bot locale.</p>
                */
            uploadUrl?: string;
    }
    export namespace CreateUploadUrlResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateUploadUrlResponse) => any;
    }
    /**
        * <p>Provides the parameters required for importing a custom vocabulary.</p>
        */
    export interface CustomVocabularyImportSpecification {
            /**
                * <p>The identifier of the bot to import the custom vocabulary to.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot to import the custom vocabulary to.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the local to import the custom vocabulary to. The value must
                *       be <code>en_GB</code>.</p>
                */
            localeId: string | undefined;
    }
    export namespace CustomVocabularyImportSpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CustomVocabularyImportSpecification) => any;
    }
    export enum CustomVocabularyStatus {
            Creating = "Creating",
            Deleting = "Deleting",
            Exporting = "Exporting",
            Importing = "Importing",
            Ready = "Ready"
    }
    /**
        * <p>The object used for specifying the data range that the customer
        *          wants Amazon Lex to read through in the input transcripts.</p>
        */
    export interface DateRangeFilter {
            /**
                * <p>A timestamp indicating the start date for the date range
                *          filter.</p>
                */
            startDateTime: Date | undefined;
            /**
                * <p>A timestamp indicating the end date for the date range
                *          filter.</p>
                */
            endDateTime: Date | undefined;
    }
    export namespace DateRangeFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DateRangeFilter) => any;
    }
    export interface DeleteBotRequest {
            /**
                * <p>The identifier of the bot to delete. </p>
                */
            botId: string | undefined;
            /**
                * <p>When <code>true</code>, Amazon Lex doesn't check to see if another
                *          resource, such as an alias, is using the bot before it is
                *          deleted.</p>
                */
            skipResourceInUseCheck?: boolean;
    }
    export namespace DeleteBotRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteBotRequest) => any;
    }
    export interface DeleteBotResponse {
            /**
                * <p>The unique identifier of the bot that Amazon Lex is deleting.</p>
                */
            botId?: string;
            /**
                * <p>The current status of the bot. The status is <code>Deleting</code>
                *          while the bot and its associated resources are being deleted.</p>
                */
            botStatus?: BotStatus | string;
    }
    export namespace DeleteBotResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteBotResponse) => any;
    }
    export interface DeleteBotAliasRequest {
            /**
                * <p>The unique identifier of the bot alias to delete.</p>
                */
            botAliasId: string | undefined;
            /**
                * <p>The unique identifier of the bot associated with the alias to
                *          delete.</p>
                */
            botId: string | undefined;
            /**
                * <p>When this parameter is true, Amazon Lex doesn't check to see if any other
                *          resource is using the alias before it is deleted.</p>
                */
            skipResourceInUseCheck?: boolean;
    }
    export namespace DeleteBotAliasRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteBotAliasRequest) => any;
    }
    export interface DeleteBotAliasResponse {
            /**
                * <p>The unique identifier of the bot alias to delete.</p>
                */
            botAliasId?: string;
            /**
                * <p>The unique identifier of the bot that contains the alias to
                *          delete.</p>
                */
            botId?: string;
            /**
                * <p>The current status of the alias. The status is <code>Deleting</code>
                *          while the alias is in the process of being deleted. Once the alias is
                *          deleted, it will no longer appear in the list of aliases returned by
                *          the <code>ListBotAliases</code> operation.</p>
                */
            botAliasStatus?: BotAliasStatus | string;
    }
    export namespace DeleteBotAliasResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteBotAliasResponse) => any;
    }
    export interface DeleteBotLocaleRequest {
            /**
                * <p>The unique identifier of the bot that contains the locale.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot that contains the locale. </p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale that will be deleted. The
                *          string must match one of the supported locales. For more information,
                *          see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId: string | undefined;
    }
    export namespace DeleteBotLocaleRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteBotLocaleRequest) => any;
    }
    export interface DeleteBotLocaleResponse {
            /**
                * <p>The identifier of the bot that contained the deleted locale.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot that contained the deleted locale.</p>
                */
            botVersion?: string;
            /**
                * <p>The language and locale of the deleted locale.</p>
                */
            localeId?: string;
            /**
                * <p>The status of deleting the bot locale. The locale first enters the
                *             <code>Deleting</code> status. Once the locale is deleted it no
                *          longer appears in the list of locales for the bot.</p>
                */
            botLocaleStatus?: BotLocaleStatus | string;
    }
    export namespace DeleteBotLocaleResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteBotLocaleResponse) => any;
    }
    export interface DeleteBotVersionRequest {
            /**
                * <p>The identifier of the bot that contains the version.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot to delete.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>By default, the <code>DeleteBotVersion</code> operations throws a
                *             <code>ResourceInUseException</code> exception if you try to delete a
                *          bot version that has an alias pointing at it. Set the
                *             <code>skipResourceInUseCheck</code> parameter to <code>true</code>
                *          to skip this check and remove the version even if an alias points to
                *          it.</p>
                */
            skipResourceInUseCheck?: boolean;
    }
    export namespace DeleteBotVersionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteBotVersionRequest) => any;
    }
    export interface DeleteBotVersionResponse {
            /**
                * <p>The identifier of the bot that is being deleted.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot that is being deleted.</p>
                */
            botVersion?: string;
            /**
                * <p>The current status of the bot. </p>
                */
            botStatus?: BotStatus | string;
    }
    export namespace DeleteBotVersionResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteBotVersionResponse) => any;
    }
    export interface DeleteCustomVocabularyRequest {
            /**
                * <p>The unique identifier of the bot to remove the custom
                *       vocabulary from.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot to remove the custom vocabulary
                *       from.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The locale identifier for the locale that contains the
                *       custom vocabulary to remove.</p>
                */
            localeId: string | undefined;
    }
    export namespace DeleteCustomVocabularyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteCustomVocabularyRequest) => any;
    }
    export interface DeleteCustomVocabularyResponse {
            /**
                * <p>The identifier of the bot that the custom vocabulary
                *       was removed from.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot that the custom vocabulary
                *          was removed from.</p>
                */
            botVersion?: string;
            /**
                * <p>The locale identifier for the locale that the
                *          custom vocabulary was removed from.</p>
                */
            localeId?: string;
            /**
                * <p>The status of removing the custom vocabulary.</p>
                */
            customVocabularyStatus?: CustomVocabularyStatus | string;
    }
    export namespace DeleteCustomVocabularyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteCustomVocabularyResponse) => any;
    }
    export interface DeleteExportRequest {
            /**
                * <p>The unique identifier of the export to delete.</p>
                */
            exportId: string | undefined;
    }
    export namespace DeleteExportRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteExportRequest) => any;
    }
    export interface DeleteExportResponse {
            /**
                * <p>The unique identifier of the deleted export.</p>
                */
            exportId?: string;
            /**
                * <p>The current status of the deletion. When the deletion is complete,
                *          the export will no longer be returned by the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_ListExports.html">ListExports</a> operation and calls to the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_DescribeExport.html">
                *             DescribeExport</a> operation with the export identifier will
                *          fail.</p>
                */
            exportStatus?: ExportStatus | string;
    }
    export namespace DeleteExportResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteExportResponse) => any;
    }
    export interface DeleteImportRequest {
            /**
                * <p>The unique identifier of the import to delete.</p>
                */
            importId: string | undefined;
    }
    export namespace DeleteImportRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteImportRequest) => any;
    }
    export enum ImportStatus {
            Completed = "Completed",
            Deleting = "Deleting",
            Failed = "Failed",
            InProgress = "InProgress"
    }
    export interface DeleteImportResponse {
            /**
                * <p>The unique identifier of the deleted import.</p>
                */
            importId?: string;
            /**
                * <p>The current status of the deletion. When the deletion is complete,
                *          the import will no longer be returned by the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_ListImports.html">ListImports</a> operation and calls to the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_DescribeImport.html">DescribeImport</a> operation with the import identifier will
                *          fail.</p>
                */
            importStatus?: ImportStatus | string;
    }
    export namespace DeleteImportResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteImportResponse) => any;
    }
    export interface DeleteIntentRequest {
            /**
                * <p>The unique identifier of the intent to delete.</p>
                */
            intentId: string | undefined;
            /**
                * <p>The identifier of the bot associated with the intent.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot associated with the intent.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale where the bot will be
                *          deleted. The string must match one of the supported locales. For more
                *          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId: string | undefined;
    }
    export namespace DeleteIntentRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteIntentRequest) => any;
    }
    export interface DeleteResourcePolicyRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the bot or bot alias that has the
                *          resource policy attached.</p>
                */
            resourceArn: string | undefined;
            /**
                * <p>The identifier of the revision to edit. If this ID doesn't match the
                *          current revision number, Amazon Lex returns an exception</p>
                *          <p>If you don't specify a revision ID, Amazon Lex will delete the current
                *          policy.</p>
                */
            expectedRevisionId?: string;
    }
    export namespace DeleteResourcePolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteResourcePolicyRequest) => any;
    }
    export interface DeleteResourcePolicyResponse {
            /**
                * <p>The Amazon Resource Name (ARN) of the bot or bot alias that the
                *          resource policy was deleted from.</p>
                */
            resourceArn?: string;
            /**
                * <p>The current revision of the resource policy. Use the revision ID to
                *          make sure that you are updating the most current version of a resource
                *          policy when you add a policy statement to a resource, delete a
                *          resource, or update a resource.</p>
                */
            revisionId?: string;
    }
    export namespace DeleteResourcePolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteResourcePolicyResponse) => any;
    }
    export interface DeleteResourcePolicyStatementRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the bot or bot alias that the
                *          resource policy is attached to.</p>
                */
            resourceArn: string | undefined;
            /**
                * <p>The name of the statement (SID) to delete from the policy.</p>
                */
            statementId: string | undefined;
            /**
                * <p>The identifier of the revision of the policy to delete the statement
                *          from. If this revision ID doesn't match the current revision ID, Amazon Lex
                *          throws an exception.</p>
                *          <p>If you don't specify a revision, Amazon Lex removes the current contents
                *          of the statement. </p>
                */
            expectedRevisionId?: string;
    }
    export namespace DeleteResourcePolicyStatementRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteResourcePolicyStatementRequest) => any;
    }
    export interface DeleteResourcePolicyStatementResponse {
            /**
                * <p>The Amazon Resource Name (ARN) of the bot or bot alias that the
                *          resource policy statement was removed from.</p>
                */
            resourceArn?: string;
            /**
                * <p>The current revision of the resource policy. Use the revision ID to
                *          make sure that you are updating the most current version of a resource
                *          policy when you add a policy statement to a resource, delete a
                *          resource, or update a resource.</p>
                */
            revisionId?: string;
    }
    export namespace DeleteResourcePolicyStatementResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteResourcePolicyStatementResponse) => any;
    }
    export interface DeleteSlotRequest {
            /**
                * <p>The identifier of the slot to delete. </p>
                */
            slotId: string | undefined;
            /**
                * <p>The identifier of the bot associated with the slot to delete.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot associated with the slot to delete.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale that the slot will be
                *          deleted from. The string must match one of the supported locales. For
                *          more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId: string | undefined;
            /**
                * <p>The identifier of the intent associated with the slot.</p>
                */
            intentId: string | undefined;
    }
    export namespace DeleteSlotRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteSlotRequest) => any;
    }
    export interface DeleteSlotTypeRequest {
            /**
                * <p>The identifier of the slot type to delete.</p>
                */
            slotTypeId: string | undefined;
            /**
                * <p>The identifier of the bot associated with the slot type.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot associated with the slot type.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale that the slot type will be
                *          deleted from. The string must match one of the supported locales. For
                *          more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId: string | undefined;
            /**
                * <p>By default, the <code>DeleteSlotType</code> operations throws a
                *             <code>ResourceInUseException</code> exception if you try to delete a
                *          slot type used by a slot. Set the <code>skipResourceInUseCheck</code>
                *          parameter to <code>true</code> to skip this check and remove the slot
                *          type even if a slot uses it.</p>
                */
            skipResourceInUseCheck?: boolean;
    }
    export namespace DeleteSlotTypeRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteSlotTypeRequest) => any;
    }
    export interface DeleteUtterancesRequest {
            /**
                * <p>The unique identifier of the bot that contains the
                *          utterances.</p>
                */
            botId: string | undefined;
            /**
                * <p>The identifier of the language and locale where the utterances were
                *          collected. The string must match one of the supported locales. For more
                *          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported
                *          languages</a>.</p>
                */
            localeId?: string;
            /**
                * <p>The unique identifier of the session with the user. The ID is
                *          returned in the response from the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_runtime_RecognizeText.html">RecognizeText</a> and <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_runtime_RecognizeUtterance.html">RecognizeUtterance</a> operations.</p>
                */
            sessionId?: string;
    }
    export namespace DeleteUtterancesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteUtterancesRequest) => any;
    }
    export interface DeleteUtterancesResponse {
    }
    export namespace DeleteUtterancesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteUtterancesResponse) => any;
    }
    export interface DescribeBotRequest {
            /**
                * <p>The unique identifier of the bot to describe.</p>
                */
            botId: string | undefined;
    }
    export namespace DescribeBotRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeBotRequest) => any;
    }
    export interface DescribeBotResponse {
            /**
                * <p>The unique identifier of the bot.</p>
                */
            botId?: string;
            /**
                * <p>The name of the bot.</p>
                */
            botName?: string;
            /**
                * <p>The description of the bot. </p>
                */
            description?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of an IAM role that has permission to
                *          access the bot.</p>
                */
            roleArn?: string;
            /**
                * <p>Settings for managing data privacy of the bot and its conversations
                *          with users.</p>
                */
            dataPrivacy?: DataPrivacy;
            /**
                * <p>The maximum time in seconds that Amazon Lex retains the data gathered in
                *          a conversation.</p>
                */
            idleSessionTTLInSeconds?: number;
            /**
                * <p>The current status of the bot. When the status is
                *             <code>Available</code> the bot is ready to be used in conversations
                *          with users.</p>
                */
            botStatus?: BotStatus | string;
            /**
                * <p>A timestamp of the date and time that the bot was created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>A timestamp of the date and time that the bot was last
                *          updated.</p>
                */
            lastUpdatedDateTime?: Date;
    }
    export namespace DescribeBotResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeBotResponse) => any;
    }
    export interface DescribeBotAliasRequest {
            /**
                * <p>The identifier of the bot alias to describe.</p>
                */
            botAliasId: string | undefined;
            /**
                * <p>The identifier of the bot associated with the bot alias to
                *          describe.</p>
                */
            botId: string | undefined;
    }
    export namespace DescribeBotAliasRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeBotAliasRequest) => any;
    }
    export interface DescribeBotAliasResponse {
            /**
                * <p>The identifier of the bot alias.</p>
                */
            botAliasId?: string;
            /**
                * <p>The name of the bot alias.</p>
                */
            botAliasName?: string;
            /**
                * <p>The description of the bot alias.</p>
                */
            description?: string;
            /**
                * <p>The version of the bot associated with the bot alias.</p>
                */
            botVersion?: string;
            /**
                * <p>The locale settings that are unique to the alias.</p>
                */
            botAliasLocaleSettings?: Record<string, BotAliasLocaleSettings>;
            /**
                * <p>Specifics of how Amazon Lex logs text and audio conversations with the
                *          bot associated with the alias.</p>
                */
            conversationLogSettings?: ConversationLogSettings;
            /**
                * <p>Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of
                *          user utterances.</p>
                */
            sentimentAnalysisSettings?: SentimentAnalysisSettings;
            /**
                * <p>A list of events that affect a bot alias. For example, an event is
                *          recorded when the version that the alias points to changes.</p>
                */
            botAliasHistoryEvents?: BotAliasHistoryEvent[];
            /**
                * <p>The current status of the alias. When the alias is
                *             <code>Available</code>, the alias is ready for use with your
                *          bot.</p>
                */
            botAliasStatus?: BotAliasStatus | string;
            /**
                * <p>The identifier of the bot associated with the bot alias.</p>
                */
            botId?: string;
            /**
                * <p>A timestamp of the date and time that the alias was created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>A timestamp of the date and time that the alias was last
                *          updated.</p>
                */
            lastUpdatedDateTime?: Date;
    }
    export namespace DescribeBotAliasResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeBotAliasResponse) => any;
    }
    export interface DescribeBotLocaleRequest {
            /**
                * <p>The identifier of the bot associated with the locale.</p>
                */
            botId: string | undefined;
            /**
                * <p>The identifier of the version of the bot associated with the
                *          locale.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The unique identifier of the locale to describe. The string must
                *          match one of the supported locales. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>. </p>
                */
            localeId: string | undefined;
    }
    export namespace DescribeBotLocaleRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeBotLocaleRequest) => any;
    }
    export interface DescribeBotLocaleResponse {
            /**
                * <p>The identifier of the bot associated with the locale.</p>
                */
            botId?: string;
            /**
                * <p>The identifier of the version of the bot associated with the
                *          locale.</p>
                */
            botVersion?: string;
            /**
                * <p>The unique identifier of the described locale.</p>
                */
            localeId?: string;
            /**
                * <p>The name of the locale.</p>
                */
            localeName?: string;
            /**
                * <p>The description of the locale.</p>
                */
            description?: string;
            /**
                * <p>The confidence threshold where Amazon Lex inserts the
                *             <code>AMAZON.FallbackIntent</code> and
                *             <code>AMAZON.KendraSearchIntent</code> intents in the list of
                *          possible intents for an utterance.</p>
                */
            nluIntentConfidenceThreshold?: number;
            /**
                * <p>The Amazon Polly voice Amazon Lex uses for voice interaction with the
                *          user.</p>
                */
            voiceSettings?: VoiceSettings;
            /**
                * <p>The number of intents defined for the locale.</p>
                */
            intentsCount?: number;
            /**
                * <p>The number of slot types defined for the locale.</p>
                */
            slotTypesCount?: number;
            /**
                * <p>The status of the bot. If the status is <code>Failed</code>, the
                *          reasons for the failure are listed in the <code>failureReasons</code>
                *          field.</p>
                */
            botLocaleStatus?: BotLocaleStatus | string;
            /**
                * <p>if <code>botLocaleStatus</code> is <code>Failed</code>, Amazon Lex
                *          explains why it failed to build the bot.</p>
                */
            failureReasons?: string[];
            /**
                * <p>The date and time that the locale was created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>The date and time that the locale was last updated.</p>
                */
            lastUpdatedDateTime?: Date;
            /**
                * <p>The date and time that the locale was last submitted for
                *          building.</p>
                */
            lastBuildSubmittedDateTime?: Date;
            /**
                * <p>History of changes, such as when a locale is used in an alias, that
                *          have taken place for the locale.</p>
                */
            botLocaleHistoryEvents?: BotLocaleHistoryEvent[];
            /**
                * <p>Recommended actions to take to resolve an error in the
                *             <code>failureReasons</code> field.</p>
                */
            recommendedActions?: string[];
    }
    export namespace DescribeBotLocaleResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeBotLocaleResponse) => any;
    }
    export interface DescribeBotRecommendationRequest {
            /**
                * <p>The unique identifier of the bot associated with the bot
                *          recommendation.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot associated with the bot
                *          recommendation.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale of the bot recommendation
                *          to describe. The string must match one of the supported locales. For
                *          more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId: string | undefined;
            /**
                * <p>The identifier of the bot recommendation to describe.</p>
                */
            botRecommendationId: string | undefined;
    }
    export namespace DescribeBotRecommendationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeBotRecommendationRequest) => any;
    }
    /**
        * <p>The object representing the passwords that were used to encrypt the
        *          data related to the bot recommendation, as well as the KMS key ARN used
        *          to encrypt the associated metadata.</p>
        */
    export interface EncryptionSetting {
            /**
                * <p>The KMS key ARN used to encrypt the metadata associated with the bot
                *          recommendation.</p>
                */
            kmsKeyArn?: string;
            /**
                * <p>The password used to encrypt the recommended bot recommendation
                *          file.</p>
                */
            botLocaleExportPassword?: string;
            /**
                * <p>The password used to encrypt the associated transcript file.</p>
                */
            associatedTranscriptsPassword?: string;
    }
    export namespace EncryptionSetting {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EncryptionSetting) => any;
    }
    /**
        * <p>The object that contains a path format that will be applied when
        *          Amazon Lex reads the transcript file in the bucket you provide. Specify this
        *          object if you only want Lex to read a subset of files in your Amazon S3
        *          bucket.</p>
        */
    export interface PathFormat {
            /**
                * <p>A list of Amazon S3 prefixes that points to sub-folders in the Amazon S3
                *          bucket. Specify this list if you only want Lex to read the files under
                *          this set of sub-folders.</p>
                */
            objectPrefixes?: string[];
    }
    export namespace PathFormat {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PathFormat) => any;
    }
    /**
        * <p>The object that contains transcript filter details that are
        *          associated with a bot recommendation.</p>
        */
    export interface LexTranscriptFilter {
            /**
                * <p>The object that contains a date range filter that will be applied to
                *          the transcript. Specify this object if you want Amazon Lex to only read the
                *          files that are within the date range.</p>
                */
            dateRangeFilter?: DateRangeFilter;
    }
    export namespace LexTranscriptFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LexTranscriptFilter) => any;
    }
    /**
        * <p>The object representing the filter that Amazon Lex will use to select the
        *          appropriate transcript.</p>
        */
    export interface TranscriptFilter {
            /**
                * <p>The object representing the filter that Amazon Lex will use to select the
                *          appropriate transcript when the transcript format is the Amazon Lex
                *          format.</p>
                */
            lexTranscriptFilter?: LexTranscriptFilter;
    }
    export namespace TranscriptFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TranscriptFilter) => any;
    }
    export enum TranscriptFormat {
            Lex = "Lex"
    }
    /**
        * <p>The object representing the Amazon S3 bucket containing the transcript,
        *          as well as the associated metadata.</p>
        */
    export interface S3BucketTranscriptSource {
            /**
                * <p>The name of the bucket containing the transcript and the associated
                *          metadata.</p>
                */
            s3BucketName: string | undefined;
            /**
                * <p>The object that contains a path format that will be applied when
                *          Amazon Lex reads the transcript file in the bucket you provide. Specify this
                *          object if you only want Lex to read a subset of files in your Amazon S3
                *          bucket.</p>
                */
            pathFormat?: PathFormat;
            /**
                * <p>The format of the transcript content. Currently, Genie only supports
                *          the Amazon Lex transcript format.</p>
                */
            transcriptFormat: TranscriptFormat | string | undefined;
            /**
                * <p>The object that contains the filter which will be applied when Amazon Lex
                *          reads through the Amazon S3 bucket. Specify this object if you want Amazon Lex to
                *          read only a subset of the Amazon S3 bucket based on the filter you
                *          provide.</p>
                */
            transcriptFilter?: TranscriptFilter;
            /**
                * <p>The ARN of the KMS key that customer use to encrypt their Amazon S3
                *          bucket. Only use this field if your bucket is encrypted using a
                *          customer managed KMS key.</p>
                */
            kmsKeyArn?: string;
    }
    export namespace S3BucketTranscriptSource {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: S3BucketTranscriptSource) => any;
    }
    /**
        * <p>Indicates the setting of the location where the transcript is
        *          stored.</p>
        */
    export interface TranscriptSourceSetting {
            /**
                * <p>Indicates the setting of the Amazon S3 bucket where the transcript is
                *          stored.</p>
                */
            s3BucketTranscriptSource?: S3BucketTranscriptSource;
    }
    export namespace TranscriptSourceSetting {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TranscriptSourceSetting) => any;
    }
    export interface DescribeBotRecommendationResponse {
            /**
                * <p>The identifier of the bot associated with the bot
                *          recommendation.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot associated with the bot
                *          recommendation.</p>
                */
            botVersion?: string;
            /**
                * <p>The identifier of the language and locale of the bot recommendation
                *          to describe.</p>
                */
            localeId?: string;
            /**
                * <p>The status of the bot recommendation. If the status is Failed, then
                *          the reasons for the failure are listed in the failureReasons field.
                *       </p>
                */
            botRecommendationStatus?: BotRecommendationStatus | string;
            /**
                * <p>The identifier of the bot recommendation being described.</p>
                */
            botRecommendationId?: string;
            /**
                * <p>If botRecommendationStatus is Failed, Amazon Lex explains why.</p>
                */
            failureReasons?: string[];
            /**
                * <p>The date and time that the bot recommendation was created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>The date and time that the bot recommendation was last
                *          updated.</p>
                */
            lastUpdatedDateTime?: Date;
            /**
                * <p>The object representing the Amazon S3 bucket containing the transcript,
                *          as well as the associated metadata.</p>
                */
            transcriptSourceSetting?: TranscriptSourceSetting;
            /**
                * <p>The object representing the passwords that were used to encrypt the
                *          data related to the bot recommendation results, as well as the KMS key
                *          ARN used to encrypt the associated metadata.</p>
                */
            encryptionSetting?: EncryptionSetting;
            /**
                * <p>The object representing the URL of the bot definition, the URL of
                *          the associated transcript and a statistical summary of the bot
                *          recommendation results.</p>
                */
            botRecommendationResults?: BotRecommendationResults;
    }
    export namespace DescribeBotRecommendationResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeBotRecommendationResponse) => any;
    }
    export interface DescribeBotVersionRequest {
            /**
                * <p>The identifier of the bot containing the version to return metadata
                *          for.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot to return metadata for.</p>
                */
            botVersion: string | undefined;
    }
    export namespace DescribeBotVersionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeBotVersionRequest) => any;
    }
    export interface DescribeBotVersionResponse {
            /**
                * <p>The identifier of the bot that contains the version.</p>
                */
            botId?: string;
            /**
                * <p>The name of the bot that contains the version.</p>
                */
            botName?: string;
            /**
                * <p>The version of the bot to describe.</p>
                */
            botVersion?: string;
            /**
                * <p>The description specified for the bot.</p>
                */
            description?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of an IAM role that has permission to
                *          access the bot version.</p>
                */
            roleArn?: string;
            /**
                * <p>Data privacy settings for the bot version.</p>
                */
            dataPrivacy?: DataPrivacy;
            /**
                * <p>The number of seconds that a session with the bot remains active
                *          before it is discarded by Amazon Lex.</p>
                */
            idleSessionTTLInSeconds?: number;
            /**
                * <p>The current status of the bot. When the status is
                *             <code>Available</code>, the bot version is ready for use.</p>
                */
            botStatus?: BotStatus | string;
            /**
                * <p>If the <code>botStatus</code> is <code>Failed</code>, this contains
                *          a list of reasons that the version couldn't be built.</p>
                */
            failureReasons?: string[];
            /**
                * <p>A timestamp of the date and time that the bot version was
                *          created.</p>
                */
            creationDateTime?: Date;
    }
    export namespace DescribeBotVersionResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeBotVersionResponse) => any;
    }
    export interface DescribeCustomVocabularyMetadataRequest {
            /**
                * <p>The unique identifier of the bot that contains the custom vocabulary.</p>
                */
            botId: string | undefined;
            /**
                * <p>The bot version of the bot to return metadata for.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The locale to return the custom vocabulary information for.
                *       The locale must be <code>en_GB</code>.</p>
                */
            localeId: string | undefined;
    }
    export namespace DescribeCustomVocabularyMetadataRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeCustomVocabularyMetadataRequest) => any;
    }
    export interface DescribeCustomVocabularyMetadataResponse {
            /**
                * <p>The identifier of the bot that contains the custom vocabulary.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot that contains the custom vocabulary to describe.</p>
                */
            botVersion?: string;
            /**
                * <p>The locale that contains the custom vocabulary to describe.</p>
                */
            localeId?: string;
            /**
                * <p>The status of the custom vocabulary. If the status is
                *       <code>Ready</code> the custom vocabulary is ready to use.</p>
                */
            customVocabularyStatus?: CustomVocabularyStatus | string;
            /**
                * <p>The date and time that the custom vocabulary was created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>The date and time that the custom vocabulary was last updated.</p>
                */
            lastUpdatedDateTime?: Date;
    }
    export namespace DescribeCustomVocabularyMetadataResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeCustomVocabularyMetadataResponse) => any;
    }
    export interface DescribeExportRequest {
            /**
                * <p>The unique identifier of the export to describe.</p>
                */
            exportId: string | undefined;
    }
    export namespace DescribeExportRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeExportRequest) => any;
    }
    export interface DescribeExportResponse {
            /**
                * <p>The unique identifier of the described export.</p>
                */
            exportId?: string;
            /**
                * <p>The bot, bot ID, and optional locale ID of the exported bot or bot
                *          locale.</p>
                */
            resourceSpecification?: ExportResourceSpecification;
            /**
                * <p>The file format used in the files that describe the resource.
                *       </p>
                */
            fileFormat?: ImportExportFileFormat | string;
            /**
                * <p>The status of the export. When the status is <code>Complete</code>
                *          the export archive file is available for download.</p>
                */
            exportStatus?: ExportStatus | string;
            /**
                * <p>If the <code>exportStatus</code> is failed, contains one or more
                *          reasons why the export could not be completed.</p>
                */
            failureReasons?: string[];
            /**
                * <p>A pre-signed S3 URL that points to the bot or bot locale archive.
                *          The URL is only available for 5 minutes after calling the
                *             <code>DescribeExport</code> operation.</p>
                */
            downloadUrl?: string;
            /**
                * <p>The date and time that the export was created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>The last date and time that the export was updated.</p>
                */
            lastUpdatedDateTime?: Date;
    }
    export namespace DescribeExportResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeExportResponse) => any;
    }
    export interface DescribeImportRequest {
            /**
                * <p>The unique identifier of the import to describe.</p>
                */
            importId: string | undefined;
    }
    export namespace DescribeImportRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeImportRequest) => any;
    }
    export enum MergeStrategy {
            Append = "Append",
            FailOnConflict = "FailOnConflict",
            Overwrite = "Overwrite"
    }
    /**
        * <p>Provides information about the bot or bot locale that you want to
        *          import. You can specify the <code>botImportSpecification</code> or the
        *             <code>botLocaleImportSpecification</code>, but not both.</p>
        */
    export interface ImportResourceSpecification {
            /**
                * <p>Parameters for importing a bot.</p>
                */
            botImportSpecification?: BotImportSpecification;
            /**
                * <p>Parameters for importing a bot locale.</p>
                */
            botLocaleImportSpecification?: BotLocaleImportSpecification;
            /**
                * <p>Provides the parameters required for importing a custom vocabulary.</p>
                */
            customVocabularyImportSpecification?: CustomVocabularyImportSpecification;
    }
    export namespace ImportResourceSpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImportResourceSpecification) => any;
    }
    export interface DescribeImportResponse {
            /**
                * <p>The unique identifier of the described import.</p>
                */
            importId?: string;
            /**
                * <p>The specifications of the imported bot, bot locale, or custom
                *          vocabulary.</p>
                */
            resourceSpecification?: ImportResourceSpecification;
            /**
                * <p>The unique identifier that Amazon Lex assigned to the resource created by
                *          the import.</p>
                */
            importedResourceId?: string;
            /**
                * <p>The name of the imported resource.</p>
                */
            importedResourceName?: string;
            /**
                * <p>The strategy used when there was a name conflict between the
                *          imported resource and an existing resource. When the merge strategy is
                *             <code>FailOnConflict</code> existing resources are not overwritten
                *          and the import fails.</p>
                */
            mergeStrategy?: MergeStrategy | string;
            /**
                * <p>The status of the import process. When the status is
                *             <code>Completed</code> the resource is imported and ready for
                *          use.</p>
                */
            importStatus?: ImportStatus | string;
            /**
                * <p>If the <code>importStatus</code> field is <code>Failed</code>, this
                *          provides one or more reasons for the failure.</p>
                */
            failureReasons?: string[];
            /**
                * <p>The date and time that the import was created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>The date and time that the import was last updated.</p>
                */
            lastUpdatedDateTime?: Date;
    }
    export namespace DescribeImportResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeImportResponse) => any;
    }
    export interface DescribeIntentRequest {
            /**
                * <p>The identifier of the intent to describe.</p>
                */
            intentId: string | undefined;
            /**
                * <p>The identifier of the bot associated with the intent.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot associated with the intent.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale of the intent to describe.
                *          The string must match one of the supported locales. For more
                *          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId: string | undefined;
    }
    export namespace DescribeIntentRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeIntentRequest) => any;
    }
    /**
        * <p>Sets the priority that Amazon Lex should use when eliciting slot values
        *          from a user.</p>
        */
    export interface SlotPriority {
            /**
                * <p>The priority that a slot should be elicited.</p>
                */
            priority: number | undefined;
            /**
                * <p>The unique identifier of the slot.</p>
                */
            slotId: string | undefined;
    }
    export namespace SlotPriority {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SlotPriority) => any;
    }
    export interface DescribeIntentResponse {
            /**
                * <p>The unique identifier assigned to the intent when it was
                *          created.</p>
                */
            intentId?: string;
            /**
                * <p>The name specified for the intent.</p>
                */
            intentName?: string;
            /**
                * <p>The description of the intent.</p>
                */
            description?: string;
            /**
                * <p>The identifier of the built-in intent that this intent is derived
                *          from, if any.</p>
                */
            parentIntentSignature?: string;
            /**
                * <p>User utterances that trigger this intent.</p>
                */
            sampleUtterances?: SampleUtterance[];
            /**
                * <p>The Lambda function called during each turn of a conversation with
                *          the intent.</p>
                */
            dialogCodeHook?: DialogCodeHookSettings;
            /**
                * <p>The Lambda function called when the intent is complete and ready for
                *          fulfillment.</p>
                */
            fulfillmentCodeHook?: FulfillmentCodeHookSettings;
            /**
                * <p>The list that determines the priority that slots should be elicited
                *          from the user.</p>
                */
            slotPriorities?: SlotPriority[];
            /**
                * <p>Prompts that Amazon Lex sends to the user to confirm completion of an
                *          intent.</p>
                */
            intentConfirmationSetting?: IntentConfirmationSetting;
            /**
                * <p>The response that Amazon Lex sends to when the intent is closed.</p>
                */
            intentClosingSetting?: IntentClosingSetting;
            /**
                * <p>A list of contexts that must be active for the intent to be
                *          considered for sending to the user.</p>
                */
            inputContexts?: InputContext[];
            /**
                * <p>A list of contexts that are activated when the intent is
                *          fulfilled.</p>
                */
            outputContexts?: OutputContext[];
            /**
                * <p>Configuration information required to use the
                *             <code>AMAZON.KendraSearchIntent</code> intent.</p>
                */
            kendraConfiguration?: KendraConfiguration;
            /**
                * <p>The identifier of the bot associated with the intent.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot associated with the intent.</p>
                */
            botVersion?: string;
            /**
                * <p>The language and locale specified for the intent.</p>
                */
            localeId?: string;
            /**
                * <p>A timestamp of the date and time that the intent was created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>A timestamp of the date and time that the intent was last
                *          updated.</p>
                */
            lastUpdatedDateTime?: Date;
    }
    export namespace DescribeIntentResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeIntentResponse) => any;
    }
    export interface DescribeResourcePolicyRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the bot or bot alias that the
                *          resource policy is attached to.</p>
                */
            resourceArn: string | undefined;
    }
    export namespace DescribeResourcePolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeResourcePolicyRequest) => any;
    }
    export interface DescribeResourcePolicyResponse {
            /**
                * <p>The Amazon Resource Name (ARN) of the bot or bot alias that the
                *          resource policy is attached to.</p>
                */
            resourceArn?: string;
            /**
                * <p>The JSON structure that contains the resource policy. For more
                *          information about the contents of a JSON policy document, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies.html"> IAM JSON policy
                *             reference </a>.</p>
                */
            policy?: string;
            /**
                * <p>The current revision of the resource policy. Use the revision ID to
                *          make sure that you are updating the most current version of a resource
                *          policy when you add a policy statement to a resource, delete a
                *          resource, or update a resource.</p>
                */
            revisionId?: string;
    }
    export namespace DescribeResourcePolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeResourcePolicyResponse) => any;
    }
    export interface DescribeSlotRequest {
            /**
                * <p>The unique identifier for the slot.</p>
                */
            slotId: string | undefined;
            /**
                * <p>The identifier of the bot associated with the slot.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot associated with the slot.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale of the slot to describe.
                *          The string must match one of the supported locales. For more
                *          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId: string | undefined;
            /**
                * <p>The identifier of the intent that contains the slot.</p>
                */
            intentId: string | undefined;
    }
    export namespace DescribeSlotRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeSlotRequest) => any;
    }
    export interface DescribeSlotResponse {
            /**
                * <p>The unique identifier generated for the slot.</p>
                */
            slotId?: string;
            /**
                * <p>The name specified for the slot.</p>
                */
            slotName?: string;
            /**
                * <p>The description specified for the slot.</p>
                */
            description?: string;
            /**
                * <p>The identifier of the slot type that determines the values entered
                *          into the slot.</p>
                */
            slotTypeId?: string;
            /**
                * <p>Prompts that Amazon Lex uses to elicit a value for the slot.</p>
                */
            valueElicitationSetting?: SlotValueElicitationSetting;
            /**
                * <p>Whether slot values are shown in Amazon CloudWatch logs. If the value is
                *             <code>None</code>, the actual value of the slot is shown in
                *          logs.</p>
                */
            obfuscationSetting?: ObfuscationSetting;
            /**
                * <p>The identifier of the bot associated with the slot.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot associated with the slot.</p>
                */
            botVersion?: string;
            /**
                * <p>The language and locale specified for the slot.</p>
                */
            localeId?: string;
            /**
                * <p>The identifier of the intent associated with the slot.</p>
                */
            intentId?: string;
            /**
                * <p>A timestamp of the date and time that the slot was created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>A timestamp of the date and time that the slot was last
                *          updated.</p>
                */
            lastUpdatedDateTime?: Date;
            /**
                * <p>Indicates whether the slot accepts multiple values in a single
                *          utterance.</p>
                *          <p>If the <code>multipleValuesSetting</code> is not set, the default
                *          value is <code>false</code>.</p>
                */
            multipleValuesSetting?: MultipleValuesSetting;
    }
    export namespace DescribeSlotResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeSlotResponse) => any;
    }
    export interface DescribeSlotTypeRequest {
            /**
                * <p>The identifier of the slot type.</p>
                */
            slotTypeId: string | undefined;
            /**
                * <p>The identifier of the bot associated with the slot type.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot associated with the slot type.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale of the slot type to
                *          describe. The string must match one of the supported locales. For more
                *          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId: string | undefined;
    }
    export namespace DescribeSlotTypeRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeSlotTypeRequest) => any;
    }
    export interface DescribeSlotTypeResponse {
            /**
                * <p>The unique identifier for the slot type.</p>
                */
            slotTypeId?: string;
            /**
                * <p>The name specified for the slot type.</p>
                */
            slotTypeName?: string;
            /**
                * <p>The description specified for the slot type.</p>
                */
            description?: string;
            /**
                * <p>The values that the slot type can take. Includes any synonyms for
                *          the slot type values.</p>
                */
            slotTypeValues?: SlotTypeValue[];
            /**
                * <p>The strategy that Amazon Lex uses to choose a value from a list of
                *          possible values.</p>
                */
            valueSelectionSetting?: SlotValueSelectionSetting;
            /**
                * <p>The built in slot type used as a parent to this slot type.</p>
                */
            parentSlotTypeSignature?: string;
            /**
                * <p>The identifier of the bot associated with the slot type.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot associated with the slot type.</p>
                */
            botVersion?: string;
            /**
                * <p>The language and locale specified for the slot type.</p>
                */
            localeId?: string;
            /**
                * <p>A timestamp of the date and time that the slot type was
                *          created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>A timestamp of the date and time that the slot type was last
                *          updated.</p>
                */
            lastUpdatedDateTime?: Date;
            /**
                * <p>Provides information about the external source of the slot type's
                *          definition.</p>
                */
            externalSourceSetting?: ExternalSourceSetting;
    }
    export namespace DescribeSlotTypeResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeSlotTypeResponse) => any;
    }
    export enum ExportFilterName {
            ExportResourceType = "ExportResourceType"
    }
    export enum ExportFilterOperator {
            Contains = "CO",
            Equals = "EQ"
    }
    /**
        * <p>Filters the response form the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_ListExports.html">ListExports</a> operation</p>
        */
    export interface ExportFilter {
            /**
                * <p>The name of the field to use for filtering.</p>
                */
            name: ExportFilterName | string | undefined;
            /**
                * <p>The values to use to filter the response. The values must be
                *             <code>Bot</code>, <code>BotLocale</code>, or
                *             <code>CustomVocabulary</code>.</p>
                */
            values: string[] | undefined;
            /**
                * <p>The operator to use for the filter. Specify EQ when the
                *             <code>ListExports</code> operation should return only resource types
                *          that equal the specified value. Specify CO when the
                *             <code>ListExports</code> operation should return resource types that
                *          contain the specified value.</p>
                */
            operator: ExportFilterOperator | string | undefined;
    }
    export namespace ExportFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExportFilter) => any;
    }
    export enum ExportSortAttribute {
            LastUpdatedDateTime = "LastUpdatedDateTime"
    }
    /**
        * <p>Provides information about sorting a list of exports.</p>
        */
    export interface ExportSortBy {
            /**
                * <p>The export field to use for sorting.</p>
                */
            attribute: ExportSortAttribute | string | undefined;
            /**
                * <p>The order to sort the list.</p>
                */
            order: SortOrder | string | undefined;
    }
    export namespace ExportSortBy {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExportSortBy) => any;
    }
    /**
        * <p>Provides summary information about an export in an export list.
        *       </p>
        */
    export interface ExportSummary {
            /**
                * <p>The unique identifier that Amazon Lex assigned to the export.</p>
                */
            exportId?: string;
            /**
                * <p>Information about the bot or bot locale that was exported.</p>
                */
            resourceSpecification?: ExportResourceSpecification;
            /**
                * <p>The file format used in the export files.</p>
                */
            fileFormat?: ImportExportFileFormat | string;
            /**
                * <p>The status of the export. When the status is <code>Completed</code>
                *          the export is ready to download.</p>
                */
            exportStatus?: ExportStatus | string;
            /**
                * <p>The date and time that the export was created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>The date and time that the export was last updated.</p>
                */
            lastUpdatedDateTime?: Date;
    }
    export namespace ExportSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExportSummary) => any;
    }
    export enum ImportFilterName {
            ImportResourceType = "ImportResourceType"
    }
    export enum ImportFilterOperator {
            Contains = "CO",
            Equals = "EQ"
    }
    /**
        * <p>Filters the response from the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_ListImports.html">ListImports</a> operation.</p>
        */
    export interface ImportFilter {
            /**
                * <p>The name of the field to use for filtering.</p>
                */
            name: ImportFilterName | string | undefined;
            /**
                * <p>The values to use to filter the response. The values must be
                *             <code>Bot</code>, <code>BotLocale</code>, or
                *             <code>CustomVocabulary</code>.</p>
                */
            values: string[] | undefined;
            /**
                * <p>The operator to use for the filter. Specify EQ when the
                *             <code>ListImports</code> operation should return only resource types
                *          that equal the specified value. Specify CO when the
                *             <code>ListImports</code> operation should return resource types that
                *          contain the specified value.</p>
                */
            operator: ImportFilterOperator | string | undefined;
    }
    export namespace ImportFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImportFilter) => any;
    }
    export enum ImportResourceType {
            Bot = "Bot",
            BotLocale = "BotLocale",
            CustomVocabulary = "CustomVocabulary"
    }
    export enum ImportSortAttribute {
            LastUpdatedDateTime = "LastUpdatedDateTime"
    }
    /**
        * <p>Provides information for sorting a list of imports.</p>
        */
    export interface ImportSortBy {
            /**
                * <p>The export field to use for sorting.</p>
                */
            attribute: ImportSortAttribute | string | undefined;
            /**
                * <p>The order to sort the list.</p>
                */
            order: SortOrder | string | undefined;
    }
    export namespace ImportSortBy {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImportSortBy) => any;
    }
    /**
        * <p>Provides summary information about an import in an import
        *          list.</p>
        */
    export interface ImportSummary {
            /**
                * <p>The unique identifier that Amazon Lex assigned to the import.</p>
                */
            importId?: string;
            /**
                * <p>The unique identifier that Amazon Lex assigned to the imported
                *          resource.</p>
                */
            importedResourceId?: string;
            /**
                * <p>The name that you gave the imported resource.</p>
                */
            importedResourceName?: string;
            /**
                * <p>The status of the resource. When the status is
                *             <code>Completed</code> the resource is ready to build.</p>
                */
            importStatus?: ImportStatus | string;
            /**
                * <p>The strategy used to merge existing bot or bot locale definitions
                *          with the imported definition.</p>
                */
            mergeStrategy?: MergeStrategy | string;
            /**
                * <p>The date and time that the import was created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>The date and time that the import was last updated.</p>
                */
            lastUpdatedDateTime?: Date;
            /**
                * <p>The type of resource that was imported.</p>
                */
            importedResourceType?: ImportResourceType | string;
    }
    export namespace ImportSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImportSummary) => any;
    }
    export enum IntentFilterName {
            IntentName = "IntentName"
    }
    export enum IntentFilterOperator {
            Contains = "CO",
            Equals = "EQ"
    }
    /**
        * <p>Filters the response from the <code>ListIntents</code>
        *          operation.</p>
        */
    export interface IntentFilter {
            /**
                * <p>The name of the field to use for the filter.</p>
                */
            name: IntentFilterName | string | undefined;
            /**
                * <p>The value to use for the filter.</p>
                */
            values: string[] | undefined;
            /**
                * <p>The operator to use for the filter. Specify <code>EQ</code> when the
                *             <code>ListIntents</code> operation should return only aliases that
                *          equal the specified value. Specify <code>CO</code> when the
                *             <code>ListIntents</code> operation should return aliases that
                *          contain the specified value.</p>
                */
            operator: IntentFilterOperator | string | undefined;
    }
    export namespace IntentFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: IntentFilter) => any;
    }
    export enum IntentSortAttribute {
            IntentName = "IntentName",
            LastUpdatedDateTime = "LastUpdatedDateTime"
    }
    /**
        * <p>Specifies attributes for sorting a list of intents.</p>
        */
    export interface IntentSortBy {
            /**
                * <p>The attribute to use to sort the list of intents.</p>
                */
            attribute: IntentSortAttribute | string | undefined;
            /**
                * <p>The order to sort the list. You can choose ascending or
                *          descending.</p>
                */
            order: SortOrder | string | undefined;
    }
    export namespace IntentSortBy {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: IntentSortBy) => any;
    }
    /**
        * <p>Summary information about an intent returned by the
        *             <code>ListIntents</code> operation.</p>
        */
    export interface IntentSummary {
            /**
                * <p>The unique identifier assigned to the intent. Use this ID to get
                *          detailed information about the intent with the
                *             <code>DescribeIntent</code> operation.</p>
                */
            intentId?: string;
            /**
                * <p>The name of the intent.</p>
                */
            intentName?: string;
            /**
                * <p>The description of the intent.</p>
                */
            description?: string;
            /**
                * <p>If this intent is derived from a built-in intent, the name of the
                *          parent intent.</p>
                */
            parentIntentSignature?: string;
            /**
                * <p>The input contexts that must be active for this intent to be
                *          considered for recognition.</p>
                */
            inputContexts?: InputContext[];
            /**
                * <p>The output contexts that are activated when this intent is
                *          fulfilled.</p>
                */
            outputContexts?: OutputContext[];
            /**
                * <p>The timestamp of the date and time that the intent was last
                *          updated.</p>
                */
            lastUpdatedDateTime?: Date;
    }
    export namespace IntentSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: IntentSummary) => any;
    }
    export enum TimeDimension {
            Days = "Days",
            Hours = "Hours",
            Weeks = "Weeks"
    }
    /**
        * <p>Specifies the time window that utterance statistics are returned
        *          for. The time window is always relative to the last time that the that
        *          utterances were aggregated. For example, if the
        *             <code>ListAggregatedUtterances</code> operation is called at 1600,
        *          the time window is set to 1 hour, and the last refresh time was 1530,
        *          only utterances made between 1430 and 1530 are returned.</p>
        *          <p>You can choose the time window that statistics should be returned
        *          for.</p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <b>Hours</b> - You can request
        *                utterance statistics for 1, 3, 6, 12, or 24 hour time windows.
        *                Statistics are refreshed every half hour for 1 hour time windows,
        *                and hourly for the other time windows.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <b>Days</b> - You can request
        *                utterance statistics for 3 days. Statistics are refreshed every 6
        *                hours.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <b>Weeks</b> - You can see
        *                statistics for one or two weeks. Statistics are refreshed every
        *                12 hours for one week time windows, and once per day for two week
        *                time windows.</p>
        *             </li>
        *          </ul>
        */
    export interface RelativeAggregationDuration {
            /**
                * <p>The type of time period that the <code>timeValue</code> field
                *          represents. </p>
                */
            timeDimension: TimeDimension | string | undefined;
            /**
                * <p>The period of the time window to gather statistics for. The valid
                *          value depends on the setting of the <code>timeDimension</code>
                *          field.</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>Hours</code> - 1/3/6/12/24</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>Days</code> - 3</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>Weeks</code> - 1/2</p>
                *             </li>
                *          </ul>
                */
            timeValue: number | undefined;
    }
    export namespace RelativeAggregationDuration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RelativeAggregationDuration) => any;
    }
    /**
        * <p>Provides parameters for setting the time window and duration for
        *          aggregating utterance data.</p>
        */
    export interface UtteranceAggregationDuration {
            /**
                * <p>The desired time window for aggregating utterances. </p>
                */
            relativeAggregationDuration: RelativeAggregationDuration | undefined;
    }
    export namespace UtteranceAggregationDuration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UtteranceAggregationDuration) => any;
    }
    export interface ListAggregatedUtterancesRequest {
            /**
                * <p>The unique identifier of the bot associated with this
                *          request.</p>
                */
            botId: string | undefined;
            /**
                * <p>The identifier of the bot alias associated with this request. If you
                *          specify the bot alias, you can't specify the bot version.</p>
                */
            botAliasId?: string;
            /**
                * <p>The identifier of the bot version associated with this request. If
                *          you specify the bot version, you can't specify the bot alias.</p>
                */
            botVersion?: string;
            /**
                * <p>The identifier of the language and locale where the utterances were
                *          collected. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported
                *          languages</a>.</p>
                */
            localeId: string | undefined;
            /**
                * <p>The time window for aggregating the utterance information. You can
                *          specify a time between one hour and two weeks.</p>
                */
            aggregationDuration: UtteranceAggregationDuration | undefined;
            /**
                * <p>Specifies sorting parameters for the list of utterances. You can
                *          sort by the hit count, the missed count, or the number of distinct
                *          sessions the utterance appeared in.</p>
                */
            sortBy?: AggregatedUtterancesSortBy;
            /**
                * <p>Provides the specification of a filter used to limit the utterances
                *          in the response to only those that match the filter specification. You
                *          can only specify one filter and one string to filter on.</p>
                */
            filters?: AggregatedUtterancesFilter[];
            /**
                * <p>The maximum number of utterances to return in each page of results.
                *          If there are fewer results than the maximum page size, only the actual
                *          number of results are returned. If you don't specify the
                *             <code>maxResults</code> parameter, 1,000 results are
                *          returned.</p>
                */
            maxResults?: number;
            /**
                * <p>If the response from the <code>ListAggregatedUtterances</code>
                *          operation contains more results that specified in the
                *             <code>maxResults</code> parameter, a token is returned in the
                *          response. Use that token in the <code>nextToken</code> parameter to
                *          return the next page of results.</p>
                */
            nextToken?: string;
    }
    export namespace ListAggregatedUtterancesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListAggregatedUtterancesRequest) => any;
    }
    export interface ListAggregatedUtterancesResponse {
            /**
                * <p>The identifier of the bot that contains the utterances.</p>
                */
            botId?: string;
            /**
                * <p>The identifier of the bot alias that contains the utterances. If you
                *          specified the bot version, the bot alias ID isn't returned.</p>
                */
            botAliasId?: string;
            /**
                * <p>The identifier of the bot version that contains the utterances. If
                *          you specified the bot alias, the bot version isn't returned.</p>
                */
            botVersion?: string;
            /**
                * <p>The identifier of the language and locale that the utterances are
                *          in.</p>
                */
            localeId?: string;
            /**
                * <p>The time period used to aggregate the utterance data.</p>
                */
            aggregationDuration?: UtteranceAggregationDuration;
            /**
                * <p>The date and time that the aggregation window begins. Only data
                *          collected after this time is returned in the results.</p>
                */
            aggregationWindowStartTime?: Date;
            /**
                * <p>The date and time that the aggregation window ends. Only data
                *          collected between the start time and the end time are returned in the
                *          results. </p>
                */
            aggregationWindowEndTime?: Date;
            /**
                * <p>The last date and time that the aggregated data was collected. The
                *          time period depends on the length of the aggregation window.</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <b>Hours</b> - for 1 hour time
                *                window, every half hour; otherwise every hour.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>Days</b> - every 6 hours</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>Weeks</b> - for a one week time
                *                window, every 12 hours; otherwise, every day</p>
                *             </li>
                *          </ul>
                */
            aggregationLastRefreshedDateTime?: Date;
            /**
                * <p>Summaries of the aggregated utterance data. Each response contains
                *          information about the number of times that the utterance was seen
                *          during the time period, whether it was detected or missed, and when it
                *          was seen during the time period.</p>
                */
            aggregatedUtterancesSummaries?: AggregatedUtterancesSummary[];
            /**
                * <p>A token that indicates whether there are more results to return in a
                *          response to the <code>ListAggregatedUtterances</code> operation. If the
                *             <code>nextToken</code> field is present, you send the contents as
                *          the <code>nextToken</code> parameter of a
                *             <code>ListAggregatedUtterances</code> operation request to get the
                *          next page of results.</p>
                */
            nextToken?: string;
    }
    export namespace ListAggregatedUtterancesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListAggregatedUtterancesResponse) => any;
    }
    export interface ListBotAliasesRequest {
            /**
                * <p>The identifier of the bot to list aliases for.</p>
                */
            botId: string | undefined;
            /**
                * <p>The maximum number of aliases to return in each page of results. If
                *          there are fewer results than the max page size, only the actual number
                *          of results are returned.</p>
                */
            maxResults?: number;
            /**
                * <p>If the response from the <code>ListBotAliases</code> operation
                *          contains more results than specified in the <code>maxResults</code>
                *          parameter, a token is returned in the response. Use that token in the
                *             <code>nextToken</code> parameter to return the next page of
                *          results.</p>
                */
            nextToken?: string;
    }
    export namespace ListBotAliasesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListBotAliasesRequest) => any;
    }
    export interface ListBotAliasesResponse {
            /**
                * <p>Summary information for the bot aliases that meet the filter
                *          criteria specified in the request. The length of the list is specified
                *          in the <code>maxResults</code> parameter of the request. If there are
                *          more aliases available, the <code>nextToken</code> field contains a
                *          token to get the next page of results.</p>
                */
            botAliasSummaries?: BotAliasSummary[];
            /**
                * <p>A token that indicates whether there are more results to return in a
                *          response to the <code>ListBotAliases</code> operation. If the
                *             <code>nextToken</code> field is present, you send the contents as
                *          the <code>nextToken</code> parameter of a <code>ListBotAliases</code>
                *          operation request to get the next page of results.</p>
                */
            nextToken?: string;
            /**
                * <p>The identifier of the bot associated with the aliases.</p>
                */
            botId?: string;
    }
    export namespace ListBotAliasesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListBotAliasesResponse) => any;
    }
    export interface ListBotLocalesRequest {
            /**
                * <p>The identifier of the bot to list locales for.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot to list locales for.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>Specifies sorting parameters for the list of locales. You can sort
                *          by locale name in ascending or descending order.</p>
                */
            sortBy?: BotLocaleSortBy;
            /**
                * <p>Provides the specification for a filter used to limit the response
                *          to only those locales that match the filter specification. You can only
                *          specify one filter and one value to filter on.</p>
                */
            filters?: BotLocaleFilter[];
            /**
                * <p>The maximum number of aliases to return in each page of results. If
                *          there are fewer results than the max page size, only the actual number
                *          of results are returned.</p>
                */
            maxResults?: number;
            /**
                * <p>If the response from the <code>ListBotLocales</code> operation
                *          contains more results than specified in the <code>maxResults</code>
                *          parameter, a token is returned in the response. Use that token as the
                *             <code>nextToken</code> parameter to return the next page of results.
                *       </p>
                */
            nextToken?: string;
    }
    export namespace ListBotLocalesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListBotLocalesRequest) => any;
    }
    export interface ListBotLocalesResponse {
            /**
                * <p>The identifier of the bot to list locales for.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot.</p>
                */
            botVersion?: string;
            /**
                * <p>A token that indicates whether there are more results to return in a
                *          response to the <code>ListBotLocales</code> operation. If the
                *             <code>nextToken</code> field is present, you send the contents as
                *          the <code>nextToken</code> parameter of a <code>ListBotLocales</code>
                *          operation request to get the next page of results.</p>
                */
            nextToken?: string;
            /**
                * <p>Summary information for the locales that meet the filter criteria
                *          specified in the request. The length of the list is specified in the
                *             <code>maxResults</code> parameter of the request. If there are more
                *          locales available, the <code>nextToken</code> field contains a token to
                *          get the next page of results.</p>
                */
            botLocaleSummaries?: BotLocaleSummary[];
    }
    export namespace ListBotLocalesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListBotLocalesResponse) => any;
    }
    export interface ListBotRecommendationsRequest {
            /**
                * <p>The unique identifier of the bot that contains the bot
                *          recommendation list.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot that contains the bot recommendation
                *          list.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale of the bot recommendation
                *          list.</p>
                */
            localeId: string | undefined;
            /**
                * <p>The maximum number of bot recommendations to return in each page of
                *          results. If there are fewer results than the max page size, only the
                *          actual number of results are returned.</p>
                */
            maxResults?: number;
            /**
                * <p>If the response from the ListBotRecommendation operation contains
                *          more results than specified in the maxResults parameter, a token is
                *          returned in the response. Use that token in the nextToken parameter to
                *          return the next page of results.</p>
                */
            nextToken?: string;
    }
    export namespace ListBotRecommendationsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListBotRecommendationsRequest) => any;
    }
    export interface ListBotRecommendationsResponse {
            /**
                * <p>The unique identifier of the bot that contains the bot
                *          recommendation list.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot that contains the bot recommendation
                *          list.</p>
                */
            botVersion?: string;
            /**
                * <p>The identifier of the language and locale of the bot recommendation
                *          list.</p>
                */
            localeId?: string;
            /**
                * <p>Summary information for the bot recommendations that meet the filter
                *          specified in this request. The length of the list is specified in the
                *          maxResults parameter of the request. If there are more bot
                *          recommendations available, the nextToken field contains a token to get
                *          the next page of results.</p>
                */
            botRecommendationSummaries?: BotRecommendationSummary[];
            /**
                * <p>A token that indicates whether there are more results to return in a
                *          response to the ListBotRecommendations operation. If the nextToken
                *          field is present, you send the contents as the nextToken parameter of a
                *          ListBotRecommendations operation request to get the next page of
                *          results. </p>
                */
            nextToken?: string;
    }
    export namespace ListBotRecommendationsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListBotRecommendationsResponse) => any;
    }
    export interface ListBotsRequest {
            /**
                * <p>Specifies sorting parameters for the list of bots. You can specify
                *          that the list be sorted by bot name in ascending or descending
                *          order.</p>
                */
            sortBy?: BotSortBy;
            /**
                * <p>Provides the specification of a filter used to limit the bots in the
                *          response to only those that match the filter specification. You can
                *          only specify one filter and one string to filter on.</p>
                */
            filters?: BotFilter[];
            /**
                * <p>The maximum number of bots to return in each page of results. If
                *          there are fewer results than the maximum page size, only the actual
                *          number of results are returned.</p>
                */
            maxResults?: number;
            /**
                * <p>If the response from the <code>ListBots</code> operation contains
                *          more results than specified in the <code>maxResults</code> parameter, a
                *          token is returned in the response. </p>
                *          <p>Use the returned token in the <code>nextToken</code> parameter of a
                *             <code>ListBots</code> request to return the next page of results.
                *          For a complete set of results, call the <code>ListBots</code> operation
                *          until the <code>nextToken</code> returned in the response is
                *          null.</p>
                */
            nextToken?: string;
    }
    export namespace ListBotsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListBotsRequest) => any;
    }
    export interface ListBotsResponse {
            /**
                * <p>Summary information for the bots that meet the filter criteria
                *          specified in the request. The length of the list is specified in the
                *             <code>maxResults</code> parameter of the request. If there are more
                *          bots available, the <code>nextToken</code> field contains a token to
                *          the next page of results.</p>
                */
            botSummaries?: BotSummary[];
            /**
                * <p>A token that indicates whether there are more results to return in a
                *          response to the <code>ListBots</code> operation. If the
                *             <code>nextToken</code> field is present, you send the contents as
                *          the <code>nextToken</code> parameter of a <code>ListBots</code>
                *          operation request to get the next page of results.</p>
                */
            nextToken?: string;
    }
    export namespace ListBotsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListBotsResponse) => any;
    }
    export interface ListBotVersionsRequest {
            /**
                * <p>The identifier of the bot to list versions for.</p>
                */
            botId: string | undefined;
            /**
                * <p>Specifies sorting parameters for the list of versions. You can
                *          specify that the list be sorted by version name in either ascending or
                *          descending order.</p>
                */
            sortBy?: BotVersionSortBy;
            /**
                * <p>The maximum number of versions to return in each page of results. If
                *          there are fewer results than the max page size, only the actual number
                *          of results are returned.</p>
                */
            maxResults?: number;
            /**
                * <p>If the response to the <code>ListBotVersion</code> operation
                *          contains more results than specified in the <code>maxResults</code>
                *          parameter, a token is returned in the response. Use that token in the
                *             <code>nextToken</code> parameter to return the next page of
                *          results.</p>
                */
            nextToken?: string;
    }
    export namespace ListBotVersionsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListBotVersionsRequest) => any;
    }
    export interface ListBotVersionsResponse {
            /**
                * <p>The identifier of the bot to list versions for.</p>
                */
            botId?: string;
            /**
                * <p>Summary information for the bot versions that meet the filter
                *          criteria specified in the request. The length of the list is specified
                *          in the <code>maxResults</code> parameter of the request. If there are
                *          more versions available, the <code>nextToken</code> field contains a
                *          token to get the next page of results.</p>
                */
            botVersionSummaries?: BotVersionSummary[];
            /**
                * <p>A token that indicates whether there are more results to return in a
                *          response to the <code>ListBotVersions</code> operation. If the
                *             <code>nextToken</code> field is present, you send the contents as
                *          the <code>nextToken</code> parameter of a <code>ListBotAliases</code>
                *          operation request to get the next page of results.</p>
                */
            nextToken?: string;
    }
    export namespace ListBotVersionsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListBotVersionsResponse) => any;
    }
    export interface ListBuiltInIntentsRequest {
            /**
                * <p>The identifier of the language and locale of the intents to list.
                *          The string must match one of the supported locales. For more
                *          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId: string | undefined;
            /**
                * <p>Specifies sorting parameters for the list of built-in intents. You
                *          can specify that the list be sorted by the built-in intent signature in
                *          either ascending or descending order.</p>
                */
            sortBy?: BuiltInIntentSortBy;
            /**
                * <p>The maximum number of built-in intents to return in each page of
                *          results. If there are fewer results than the max page size, only the
                *          actual number of results are returned.</p>
                */
            maxResults?: number;
            /**
                * <p>If the response from the <code>ListBuiltInIntents</code> operation
                *          contains more results than specified in the <code>maxResults</code>
                *          parameter, a token is returned in the response. Use that token in the
                *             <code>nextToken</code> parameter to return the next page of
                *          results.</p>
                */
            nextToken?: string;
    }
    export namespace ListBuiltInIntentsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListBuiltInIntentsRequest) => any;
    }
    export interface ListBuiltInIntentsResponse {
            /**
                * <p>Summary information for the built-in intents that meet the filter
                *          criteria specified in the request. The length of the list is specified
                *          in the <code>maxResults</code> parameter of the request. If there are
                *          more intents available, the <code>nextToken</code> field contains a
                *          token to get the next page of results.</p>
                */
            builtInIntentSummaries?: BuiltInIntentSummary[];
            /**
                * <p>A token that indicates whether there are more results to return in a
                *          response to the <code>ListBuiltInIntents</code> operation. If the
                *             <code>nextToken</code> field is present, you send the contents as
                *          the <code>nextToken</code> parameter of a <code>ListBotAliases</code>
                *          operation request to get the next page of results.</p>
                */
            nextToken?: string;
            /**
                * <p>The language and locale of the intents in the list.</p>
                */
            localeId?: string;
    }
    export namespace ListBuiltInIntentsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListBuiltInIntentsResponse) => any;
    }
    export interface ListBuiltInSlotTypesRequest {
            /**
                * <p>The identifier of the language and locale of the slot types to list.
                *          The string must match one of the supported locales. For more
                *          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId: string | undefined;
            /**
                * <p>Determines the sort order for the response from the
                *             <code>ListBuiltInSlotTypes</code> operation. You can choose to sort
                *          by the slot type signature in either ascending or descending
                *          order.</p>
                */
            sortBy?: BuiltInSlotTypeSortBy;
            /**
                * <p>The maximum number of built-in slot types to return in each page of
                *          results. If there are fewer results than the max page size, only the
                *          actual number of results are returned.</p>
                */
            maxResults?: number;
            /**
                * <p>If the response from the <code>ListBuiltInSlotTypes</code> operation
                *          contains more results than specified in the <code>maxResults</code>
                *          parameter, a token is returned in the response. Use that token in the
                *             <code>nextToken</code> parameter to return the next page of
                *          results.</p>
                */
            nextToken?: string;
    }
    export namespace ListBuiltInSlotTypesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListBuiltInSlotTypesRequest) => any;
    }
    export interface ListBuiltInSlotTypesResponse {
            /**
                * <p>Summary information for the built-in slot types that meet the filter
                *          criteria specified in the request. The length of the list is specified
                *          in the <code>maxResults</code> parameter of the request. If there are
                *          more slot types available, the <code>nextToken</code> field contains a
                *          token to get the next page of results.</p>
                */
            builtInSlotTypeSummaries?: BuiltInSlotTypeSummary[];
            /**
                * <p>A token that indicates whether there are more results to return in a
                *          response to the <code>ListBuiltInSlotTypes</code> operation. If the
                *             <code>nextToken</code> field is present, you send the contents as
                *          the <code>nextToken</code> parameter of a
                *             <code>LIstBuiltInSlotTypes</code> operation request to get the next
                *          page of results.</p>
                */
            nextToken?: string;
            /**
                * <p>The language and locale of the slot types in the list.</p>
                */
            localeId?: string;
    }
    export namespace ListBuiltInSlotTypesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListBuiltInSlotTypesResponse) => any;
    }
    export interface ListExportsRequest {
            /**
                * <p>The unique identifier that Amazon Lex assigned to the bot.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot to list exports for. </p>
                */
            botVersion?: string;
            /**
                * <p>Determines the field that the list of exports is sorted by. You can
                *          sort by the <code>LastUpdatedDateTime</code> field in ascending or
                *          descending order.</p>
                */
            sortBy?: ExportSortBy;
            /**
                * <p>Provides the specification of a filter used to limit the exports in
                *          the response to only those that match the filter specification. You can
                *          only specify one filter and one string to filter on.</p>
                */
            filters?: ExportFilter[];
            /**
                * <p>The maximum number of exports to return in each page of results. If
                *          there are fewer results than the max page size, only the actual number
                *          of results are returned.</p>
                */
            maxResults?: number;
            /**
                * <p>If the response from the <code>ListExports</code> operation contains
                *          more results that specified in the <code>maxResults</code> parameter, a
                *          token is returned in the response. </p>
                *          <p>Use the returned token in the <code>nextToken</code> parameter of a
                *             <code>ListExports</code> request to return the next page of results.
                *          For a complete set of results, call the <code>ListExports</code>
                *          operation until the <code>nextToken</code> returned in the response is
                *          null.</p>
                */
            nextToken?: string;
            /**
                * <p>Specifies the resources that should be exported. If you
                *       don't specify a resource type in the <code>filters</code> parameter,
                *       both bot locales and custom vocabularies are exported.</p>
                */
            localeId?: string;
    }
    export namespace ListExportsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListExportsRequest) => any;
    }
    export interface ListExportsResponse {
            /**
                * <p>The unique identifier assigned to the bot by Amazon Lex.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot that was exported.</p>
                */
            botVersion?: string;
            /**
                * <p>Summary information for the exports that meet the filter criteria
                *          specified in the request. The length of the list is specified in the
                *             <code>maxResults</code> parameter. If there are more exports
                *          available, the <code>nextToken</code> field contains a token to get the
                *          next page of results.</p>
                */
            exportSummaries?: ExportSummary[];
            /**
                * <p>A token that indicates whether there are more results to return in a
                *          response to the <code>ListExports</code> operation. If the
                *             <code>nextToken</code> field is present, you send the contents as
                *          the <code>nextToken</code> parameter of a <code>ListExports</code>
                *          operation request to get the next page of results.</p>
                */
            nextToken?: string;
            /**
                * <p>The locale specified in the request.</p>
                */
            localeId?: string;
    }
    export namespace ListExportsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListExportsResponse) => any;
    }
    export interface ListImportsRequest {
            /**
                * <p>The unique identifier that Amazon Lex assigned to the bot.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot to list imports for.</p>
                */
            botVersion?: string;
            /**
                * <p>Determines the field that the list of imports is sorted by. You can
                *          sort by the <code>LastUpdatedDateTime</code> field in ascending or
                *          descending order.</p>
                */
            sortBy?: ImportSortBy;
            /**
                * <p>Provides the specification of a filter used to limit the bots in the
                *          response to only those that match the filter specification. You can
                *          only specify one filter and one string to filter on.</p>
                */
            filters?: ImportFilter[];
            /**
                * <p>The maximum number of imports to return in each page of results. If
                *          there are fewer results than the max page size, only the actual number
                *          of results are returned.</p>
                */
            maxResults?: number;
            /**
                * <p>If the response from the <code>ListImports</code> operation contains
                *          more results than specified in the <code>maxResults</code> parameter, a
                *          token is returned in the response.</p>
                *          <p>Use the returned token in the <code>nextToken</code> parameter of a
                *             <code>ListImports</code> request to return the next page of results.
                *          For a complete set of results, call the <code>ListImports</code>
                *          operation until the <code>nextToken</code> returned in the response is
                *          null.</p>
                */
            nextToken?: string;
            /**
                * <p>Specifies the locale that should be present in the list. If you
                *          don't specify a resource type in the <code>filters</code> parameter,
                *          the list contains both bot locales and custom vocabularies.</p>
                */
            localeId?: string;
    }
    export namespace ListImportsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListImportsRequest) => any;
    }
    export interface ListImportsResponse {
            /**
                * <p>The unique identifier assigned by Amazon Lex to the bot.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot that was imported. It will always be
                *             <code>DRAFT</code>.</p>
                */
            botVersion?: string;
            /**
                * <p>Summary information for the imports that meet the filter criteria
                *          specified in the request. The length of the list is specified in the
                *             <code>maxResults</code> parameter. If there are more imports
                *          available, the <code>nextToken</code> field contains a token to get the
                *          next page of results.</p>
                */
            importSummaries?: ImportSummary[];
            /**
                * <p>A token that indicates whether there are more results to return in a
                *          response to the <code>ListImports</code> operation. If the
                *             <code>nextToken</code> field is present, you send the contents as
                *          the <code>nextToken</code> parameter of a <code>ListImports</code>
                *          operation request to get the next page of results.</p>
                */
            nextToken?: string;
            /**
                * <p>The locale specified in the request.</p>
                */
            localeId?: string;
    }
    export namespace ListImportsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListImportsResponse) => any;
    }
    export interface ListIntentsRequest {
            /**
                * <p>The unique identifier of the bot that contains the intent.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot that contains the intent.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale of the intents to list.
                *          The string must match one of the supported locales. For more
                *          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId: string | undefined;
            /**
                * <p>Determines the sort order for the response from the
                *             <code>ListIntents</code> operation. You can choose to sort by the
                *          intent name or last updated date in either ascending or descending
                *          order.</p>
                */
            sortBy?: IntentSortBy;
            /**
                * <p>Provides the specification of a filter used to limit the intents in
                *          the response to only those that match the filter specification. You can
                *          only specify one filter and only one string to filter on.</p>
                */
            filters?: IntentFilter[];
            /**
                * <p>The maximum number of intents to return in each page of results. If
                *          there are fewer results than the max page size, only the actual number
                *          of results are returned.</p>
                */
            maxResults?: number;
            /**
                * <p>If the response from the <code>ListIntents</code> operation contains
                *          more results than specified in the <code>maxResults</code> parameter, a
                *          token is returned in the response.</p>
                *          <p>Use the returned token in the <code>nextToken</code> parameter of a
                *             <code>ListIntents</code> request to return the next page of results.
                *          For a complete set of results, call the <code>ListIntents</code>
                *          operation until the <code>nextToken</code> returned in the response is
                *          null.</p>
                */
            nextToken?: string;
    }
    export namespace ListIntentsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListIntentsRequest) => any;
    }
    export interface ListIntentsResponse {
            /**
                * <p>The identifier of the bot that contains the intent.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot that contains the intent.</p>
                */
            botVersion?: string;
            /**
                * <p>The language and locale of the intents in the list.</p>
                */
            localeId?: string;
            /**
                * <p>Summary information for the intents that meet the filter criteria
                *          specified in the request. The length of the list is specified in the
                *             <code>maxResults</code> parameter of the request. If there are more
                *          intents available, the <code>nextToken</code> field contains a token to
                *          get the next page of results.</p>
                */
            intentSummaries?: IntentSummary[];
            /**
                * <p>A token that indicates whether there are more results to return in a
                *          response to the <code>ListIntents</code> operation. If the
                *             <code>nextToken</code> field is present, you send the contents as
                *          the <code>nextToken</code> parameter of a <code>ListIntents</code>
                *          operation request to get the next page of results.</p>
                */
            nextToken?: string;
    }
    export namespace ListIntentsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListIntentsResponse) => any;
    }
    export interface ListRecommendedIntentsRequest {
            /**
                * <p>The unique identifier of the bot associated with the recommended
                *          intents.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot that contains the recommended intents.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale of the recommended
                *          intents.</p>
                */
            localeId: string | undefined;
            /**
                * <p>The identifier of the bot recommendation that contains the
                *          recommended intents.</p>
                */
            botRecommendationId: string | undefined;
            /**
                * <p>If the response from the ListRecommendedIntents operation contains
                *          more results than specified in the maxResults parameter, a token is
                *          returned in the response. Use that token in the nextToken parameter to
                *          return the next page of results.</p>
                */
            nextToken?: string;
            /**
                * <p>The maximum number of bot recommendations to return in each page of
                *          results. If there are fewer results than the max page size, only the
                *          actual number of results are returned.</p>
                */
            maxResults?: number;
    }
    export namespace ListRecommendedIntentsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListRecommendedIntentsRequest) => any;
    }
    /**
        * <p>An object that contains a summary of a recommended intent.</p>
        */
    export interface RecommendedIntentSummary {
            /**
                * <p>The unique identifier of a recommended intent associated with the
                *          bot recommendation.</p>
                */
            intentId?: string;
            /**
                * <p>The name of a recommended intent associated with the bot
                *          recommendation.</p>
                */
            intentName?: string;
            /**
                * <p>The count of sample utterances of a recommended intent that is
                *          associated with a bot recommendation.</p>
                */
            sampleUtterancesCount?: number;
    }
    export namespace RecommendedIntentSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RecommendedIntentSummary) => any;
    }
    export interface ListRecommendedIntentsResponse {
            /**
                * <p>The unique identifier of the bot associated with the recommended
                *          intent.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot that contains the intent.</p>
                */
            botVersion?: string;
            /**
                * <p>The identifier of the language and locale of the intents to list.
                *          The string must match one of the supported locales. For more
                *          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId?: string;
            /**
                * <p>The identifier of the bot recommendation that contains the
                *          recommended intent.</p>
                */
            botRecommendationId?: string;
            /**
                * <p>Summary information for the intents that meet the filter criteria
                *          specified in the request. The length of the list is specified in the
                *          maxResults parameter of the request. If there are more intents
                *          available, the nextToken field contains a token to get the next page of
                *          results.</p>
                */
            summaryList?: RecommendedIntentSummary[];
            /**
                * <p>A token that indicates whether there are more results to return in a
                *          response to the ListRecommendedIntents operation. If the nextToken
                *          field is present, you send the contents as the nextToken parameter of a
                *          ListRecommendedIntents operation request to get the next page of
                *          results.</p>
                */
            nextToken?: string;
    }
    export namespace ListRecommendedIntentsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListRecommendedIntentsResponse) => any;
    }
    export enum SlotFilterName {
            SlotName = "SlotName"
    }
    export enum SlotFilterOperator {
            Contains = "CO",
            Equals = "EQ"
    }
    /**
        * <p>Filters the response from the <code>ListSlots</code>
        *          operation.</p>
        */
    export interface SlotFilter {
            /**
                * <p>The name of the field to use for filtering.</p>
                */
            name: SlotFilterName | string | undefined;
            /**
                * <p>The value to use to filter the response.</p>
                */
            values: string[] | undefined;
            /**
                * <p>The operator to use for the filter. Specify <code>EQ</code> when the
                *             <code>ListSlots</code> operation should return only aliases that
                *          equal the specified value. Specify <code>CO</code> when the
                *             <code>ListSlots</code> operation should return aliases that contain
                *          the specified value.</p>
                */
            operator: SlotFilterOperator | string | undefined;
    }
    export namespace SlotFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SlotFilter) => any;
    }
    export enum SlotSortAttribute {
            LastUpdatedDateTime = "LastUpdatedDateTime",
            SlotName = "SlotName"
    }
    /**
        * <p>Specifies attributes for sorting a list of bots.</p>
        */
    export interface SlotSortBy {
            /**
                * <p>The attribute to use to sort the list.</p>
                */
            attribute: SlotSortAttribute | string | undefined;
            /**
                * <p>The order to sort the list. You can choose ascending or
                *          descending.</p>
                */
            order: SortOrder | string | undefined;
    }
    export namespace SlotSortBy {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SlotSortBy) => any;
    }
    export interface ListSlotsRequest {
            /**
                * <p>The identifier of the bot that contains the slot.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot that contains the slot.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale of the slots to list. The
                *          string must match one of the supported locales. For more information,
                *          see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId: string | undefined;
            /**
                * <p>The unique identifier of the intent that contains the slot.</p>
                */
            intentId: string | undefined;
            /**
                * <p>Determines the sort order for the response from the
                *             <code>ListSlots</code> operation. You can choose to sort by the slot
                *          name or last updated date in either ascending or descending
                *          order.</p>
                */
            sortBy?: SlotSortBy;
            /**
                * <p>Provides the specification of a filter used to limit the slots in
                *          the response to only those that match the filter specification. You can
                *          only specify one filter and only one string to filter on.</p>
                */
            filters?: SlotFilter[];
            /**
                * <p>The maximum number of slots to return in each page of results. If
                *          there are fewer results than the max page size, only the actual number
                *          of results are returned.</p>
                */
            maxResults?: number;
            /**
                * <p>If the response from the <code>ListSlots</code> operation contains
                *          more results than specified in the <code>maxResults</code> parameter, a
                *          token is returned in the response. Use that token in the
                *             <code>nextToken</code> parameter to return the next page of
                *          results.</p>
                */
            nextToken?: string;
    }
    export namespace ListSlotsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListSlotsRequest) => any;
    }
    /**
        * <p>Summary information about a slot, a value that the bot elicits from
        *          the user.</p>
        */
    export interface SlotSummary {
            /**
                * <p>The unique identifier of the slot.</p>
                */
            slotId?: string;
            /**
                * <p>The name given to the slot.</p>
                */
            slotName?: string;
            /**
                * <p>The description of the slot.</p>
                */
            description?: string;
            /**
                * <p>Whether the slot is required or optional. An intent is complete when
                *          all required slots are filled.</p>
                */
            slotConstraint?: SlotConstraint | string;
            /**
                * <p>The unique identifier for the slot type that defines the values for
                *          the slot.</p>
                */
            slotTypeId?: string;
            /**
                * <p>Prompts that are sent to the user to elicit a value for the
                *          slot.</p>
                */
            valueElicitationPromptSpecification?: PromptSpecification;
            /**
                * <p>The timestamp of the last date and time that the slot was
                *          updated.</p>
                */
            lastUpdatedDateTime?: Date;
    }
    export namespace SlotSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SlotSummary) => any;
    }
    export interface ListSlotsResponse {
            /**
                * <p>The identifier of the bot that contains the slots.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot that contains the slots.</p>
                */
            botVersion?: string;
            /**
                * <p>The language and locale of the slots in the list.</p>
                */
            localeId?: string;
            /**
                * <p>The identifier of the intent that contains the slots.</p>
                */
            intentId?: string;
            /**
                * <p>Summary information for the slots that meet the filter criteria
                *          specified in the request. The length of the list is specified in the
                *             <code>maxResults</code> parameter of the request. If there are more
                *          slots available, the <code>nextToken</code> field contains a token to
                *          get the next page of results.</p>
                */
            slotSummaries?: SlotSummary[];
            /**
                * <p>A token that indicates whether there are more results to return in a
                *          response to the <code>ListSlots</code> operation. If the
                *             <code>nextToken</code> field is present, you send the contents as
                *          the <code>nextToken</code> parameter of a <code>ListSlots</code>
                *          operation request to get the next page of results.</p>
                */
            nextToken?: string;
    }
    export namespace ListSlotsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListSlotsResponse) => any;
    }
    export enum SlotTypeFilterName {
            ExternalSourceType = "ExternalSourceType",
            SlotTypeName = "SlotTypeName"
    }
    export enum SlotTypeFilterOperator {
            Contains = "CO",
            Equals = "EQ"
    }
    /**
        * <p>Filters the response from the <code>ListSlotTypes</code>
        *          operation.</p>
        */
    export interface SlotTypeFilter {
            /**
                * <p>The name of the field to use for filtering.</p>
                */
            name: SlotTypeFilterName | string | undefined;
            /**
                * <p>The value to use to filter the response.</p>
                */
            values: string[] | undefined;
            /**
                * <p>The operator to use for the filter. Specify <code>EQ</code> when the
                *             <code>ListSlotTypes</code> operation should return only aliases that
                *          equal the specified value. Specify <code>CO</code> when the
                *             <code>ListSlotTypes</code> operation should return aliases that
                *          contain the specified value.</p>
                */
            operator: SlotTypeFilterOperator | string | undefined;
    }
    export namespace SlotTypeFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SlotTypeFilter) => any;
    }
    export enum SlotTypeSortAttribute {
            LastUpdatedDateTime = "LastUpdatedDateTime",
            SlotTypeName = "SlotTypeName"
    }
    /**
        * <p>Specifies attributes for sorting a list of slot types.</p>
        */
    export interface SlotTypeSortBy {
            /**
                * <p>The attribute to use to sort the list of slot types.</p>
                */
            attribute: SlotTypeSortAttribute | string | undefined;
            /**
                * <p>The order to sort the list. You can say ascending or
                *          descending.</p>
                */
            order: SortOrder | string | undefined;
    }
    export namespace SlotTypeSortBy {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SlotTypeSortBy) => any;
    }
    export interface ListSlotTypesRequest {
            /**
                * <p>The unique identifier of the bot that contains the slot
                *          types.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot that contains the slot type.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale of the slot types to list.
                *          The string must match one of the supported locales. For more
                *          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId: string | undefined;
            /**
                * <p>Determines the sort order for the response from the
                *             <code>ListSlotTypes</code> operation. You can choose to sort by the
                *          slot type name or last updated date in either ascending or descending
                *          order.</p>
                */
            sortBy?: SlotTypeSortBy;
            /**
                * <p>Provides the specification of a filter used to limit the slot types
                *          in the response to only those that match the filter specification. You
                *          can only specify one filter and only one string to filter on.</p>
                */
            filters?: SlotTypeFilter[];
            /**
                * <p>The maximum number of slot types to return in each page of results.
                *          If there are fewer results than the max page size, only the actual
                *          number of results are returned.</p>
                */
            maxResults?: number;
            /**
                * <p>If the response from the <code>ListSlotTypes</code> operation
                *          contains more results than specified in the <code>maxResults</code>
                *          parameter, a token is returned in the response. Use that token in the
                *             <code>nextToken</code> parameter to return the next page of
                *          results.</p>
                */
            nextToken?: string;
    }
    export namespace ListSlotTypesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListSlotTypesRequest) => any;
    }
    export enum SlotTypeCategory {
            Custom = "Custom",
            Extended = "Extended",
            ExternalGrammar = "ExternalGrammar"
    }
    /**
        * <p>Provides summary information about a slot type.</p>
        */
    export interface SlotTypeSummary {
            /**
                * <p>The unique identifier assigned to the slot type.</p>
                */
            slotTypeId?: string;
            /**
                * <p>The name of the slot type.</p>
                */
            slotTypeName?: string;
            /**
                * <p>The description of the slot type.</p>
                */
            description?: string;
            /**
                * <p>If the slot type is derived from a built-on slot type, the name of
                *          the parent slot type.</p>
                */
            parentSlotTypeSignature?: string;
            /**
                * <p>A timestamp of the date and time that the slot type was last
                *          updated.</p>
                */
            lastUpdatedDateTime?: Date;
            /**
                * <p>Indicates the type of the slot type.</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>Custom</code> - A slot type that you created using
                *                custom values. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/custom-slot-types.html">Creating custom slot
                *                types</a>.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>Extended</code> - A slot type created by extending the
                *                AMAZON.AlphaNumeric built-in slot type. For more information, see
                *                   <a href="https://docs.aws.amazon.com/lexv2/latest/dg/built-in-slot-alphanumerice.html">AMAZON.AlphaNumeric</a>.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ExternalGrammar</code> - A slot type using a custom
                *                GRXML grammar to define values. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/building-grxml.html">Using a custom grammar slot type</a>.</p>
                *             </li>
                *          </ul>
                */
            slotTypeCategory?: SlotTypeCategory | string;
    }
    export namespace SlotTypeSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SlotTypeSummary) => any;
    }
    export interface ListSlotTypesResponse {
            /**
                * <p>The identifier of the bot that contains the slot types.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot that contains the slot types.</p>
                */
            botVersion?: string;
            /**
                * <p>The language and local of the slot types in the list.</p>
                */
            localeId?: string;
            /**
                * <p>Summary information for the slot types that meet the filter criteria
                *          specified in the request. The length of the list is specified in the
                *             <code>maxResults</code> parameter of the request. If there are more
                *          slot types available, the <code>nextToken</code> field contains a token
                *          to get the next page of results.</p>
                */
            slotTypeSummaries?: SlotTypeSummary[];
            /**
                * <p>A token that indicates whether there are more results to return in a
                *          response to the <code>ListSlotTypes</code> operation. If the
                *             <code>nextToken</code> field is present, you send the contents as
                *          the <code>nextToken</code> parameter of a <code>ListSlotTypes</code>
                *          operation request to get the next page of results.</p>
                */
            nextToken?: string;
    }
    export namespace ListSlotTypesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListSlotTypesResponse) => any;
    }
    export interface ListTagsForResourceRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the resource to get a list of tags
                *          for.</p>
                */
            resourceARN: string | undefined;
    }
    export namespace ListTagsForResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceRequest) => any;
    }
    export interface ListTagsForResourceResponse {
            /**
                * <p>The tags associated with a resource.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace ListTagsForResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceResponse) => any;
    }
    export enum SearchOrder {
            Ascending = "Ascending",
            Descending = "Descending"
    }
    export interface SearchAssociatedTranscriptsRequest {
            /**
                * <p>The unique identifier of the bot associated with the transcripts
                *          that you are searching.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot containing the transcripts that you are
                *          searching.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale of the transcripts to
                *          search. The string must match one of the supported locales. For more
                *          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>
                *          </p>
                */
            localeId: string | undefined;
            /**
                * <p>The unique identifier of the bot recommendation associated with the
                *          transcripts to search.</p>
                */
            botRecommendationId: string | undefined;
            /**
                * <p>How SearchResults are ordered. Valid values are Ascending or
                *          Descending. The default is Descending.</p>
                */
            searchOrder?: SearchOrder | string;
            /**
                * <p>A list of filter objects.</p>
                */
            filters: AssociatedTranscriptFilter[] | undefined;
            /**
                * <p>The maximum number of bot recommendations to return in each page of
                *          results. If there are fewer results than the max page size, only the
                *          actual number of results are returned.</p>
                */
            maxResults?: number;
            /**
                * <p>If the response from the SearchAssociatedTranscriptsRequest
                *          operation contains more results than specified in the maxResults
                *          parameter, an index is returned in the response. Use that index in the
                *          nextIndex parameter to return the next page of results.</p>
                */
            nextIndex?: number;
    }
    export namespace SearchAssociatedTranscriptsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SearchAssociatedTranscriptsRequest) => any;
    }
    export interface SearchAssociatedTranscriptsResponse {
            /**
                * <p>The unique identifier of the bot associated with the transcripts
                *          that you are searching.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot containing the transcripts that you are
                *          searching.</p>
                */
            botVersion?: string;
            /**
                * <p>The identifier of the language and locale of the transcripts to
                *          search. The string must match one of the supported locales. For more
                *          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>
                *          </p>
                */
            localeId?: string;
            /**
                * <p> The unique identifier of the bot recommendation associated with the
                *          transcripts to search.</p>
                */
            botRecommendationId?: string;
            /**
                * <p>A index that indicates whether there are more results to return in a
                *          response to the SearchAssociatedTranscripts operation. If the nextIndex
                *          field is present, you send the contents as the nextIndex parameter of a
                *          SearchAssociatedTranscriptsRequest operation to get the next page of
                *          results.</p>
                */
            nextIndex?: number;
            /**
                * <p>The object that contains the associated transcript that meet the
                *          criteria you specified.</p>
                */
            associatedTranscripts?: AssociatedTranscript[];
            /**
                * <p>The total number of transcripts returned by the search.</p>
                */
            totalResults?: number;
    }
    export namespace SearchAssociatedTranscriptsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SearchAssociatedTranscriptsResponse) => any;
    }
    export interface StartBotRecommendationRequest {
            /**
                * <p>The unique identifier of the bot containing the bot
                *          recommendation.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot containing the bot recommendation.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale of the bot recommendation
                *          to start. The string must match one of the supported locales. For more
                *          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>
                *          </p>
                */
            localeId: string | undefined;
            /**
                * <p>The object representing the Amazon S3 bucket containing the transcript,
                *          as well as the associated metadata.</p>
                */
            transcriptSourceSetting: TranscriptSourceSetting | undefined;
            /**
                * <p>The object representing the passwords that will be used to encrypt
                *          the data related to the bot recommendation results, as well as the KMS
                *          key ARN used to encrypt the associated metadata.</p>
                */
            encryptionSetting?: EncryptionSetting;
    }
    export namespace StartBotRecommendationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartBotRecommendationRequest) => any;
    }
    export interface StartBotRecommendationResponse {
            /**
                * <p>The unique identifier of the bot containing the bot
                *          recommendation.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot containing the bot recommendation.</p>
                */
            botVersion?: string;
            /**
                * <p>The identifier of the language and locale of the bot recommendation
                *          to start. The string must match one of the supported locales. For more
                *          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>
                *          </p>
                */
            localeId?: string;
            /**
                * <p>The status of the bot recommendation.</p>
                *          <p>If the status is Failed, then the reasons for the failure are listed
                *          in the failureReasons field. </p>
                */
            botRecommendationStatus?: BotRecommendationStatus | string;
            /**
                * <p>The identifier of the bot recommendation that you have
                *          created.</p>
                */
            botRecommendationId?: string;
            /**
                * <p>A timestamp of the date and time that the bot recommendation was
                *          created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>The object representing the Amazon S3 bucket containing the transcript,
                *          as well as the associated metadata.</p>
                */
            transcriptSourceSetting?: TranscriptSourceSetting;
            /**
                * <p>The object representing the passwords that were used to encrypt the
                *          data related to the bot recommendation results, as well as the KMS key
                *          ARN used to encrypt the associated metadata.</p>
                */
            encryptionSetting?: EncryptionSetting;
    }
    export namespace StartBotRecommendationResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartBotRecommendationResponse) => any;
    }
    export interface StartImportRequest {
            /**
                * <p>The unique identifier for the import. It is included in the response
                *          from the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_CreateUploadUrl.html">CreateUploadUrl</a> operation.</p>
                */
            importId: string | undefined;
            /**
                * <p>Parameters for creating the bot, bot locale or custom
                *          vocabulary.</p>
                */
            resourceSpecification: ImportResourceSpecification | undefined;
            /**
                * <p>The strategy to use when there is a name conflict between the
                *          imported resource and an existing resource. When the merge strategy is
                *             <code>FailOnConflict</code> existing resources are not overwritten
                *          and the import fails.</p>
                */
            mergeStrategy: MergeStrategy | string | undefined;
            /**
                * <p>The password used to encrypt the zip archive that contains the
                *          resource definition. You should always encrypt the zip archive to
                *          protect it during transit between your site and Amazon Lex.</p>
                */
            filePassword?: string;
    }
    export namespace StartImportRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartImportRequest) => any;
    }
    export interface StartImportResponse {
            /**
                * <p>A unique identifier for the import.</p>
                */
            importId?: string;
            /**
                * <p>The parameters used when importing the resource.</p>
                */
            resourceSpecification?: ImportResourceSpecification;
            /**
                * <p>The strategy used when there was a name conflict between the
                *          imported resource and an existing resource. When the merge strategy is
                *             <code>FailOnConflict</code> existing resources are not overwritten
                *          and the import fails.</p>
                */
            mergeStrategy?: MergeStrategy | string;
            /**
                * <p>The current status of the import. When the status is
                *             <code>Complete</code> the bot, bot alias, or custom vocabulary is
                *          ready to use.</p>
                */
            importStatus?: ImportStatus | string;
            /**
                * <p>The date and time that the import request was created.</p>
                */
            creationDateTime?: Date;
    }
    export namespace StartImportResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartImportResponse) => any;
    }
    export interface TagResourceRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the bot, bot alias, or bot channel
                *          to tag.</p>
                */
            resourceARN: string | undefined;
            /**
                * <p>A list of tag keys to add to the resource. If a tag key already
                *          exists, the existing value is replaced with the new value.</p>
                */
            tags: Record<string, string> | undefined;
    }
    export namespace TagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceRequest) => any;
    }
    export interface TagResourceResponse {
    }
    export namespace TagResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceResponse) => any;
    }
    export interface UntagResourceRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the resource to remove the tags
                *          from.</p>
                */
            resourceARN: string | undefined;
            /**
                * <p>A list of tag keys to remove from the resource. If a tag key does
                *          not exist on the resource, it is ignored.</p>
                */
            tagKeys: string[] | undefined;
    }
    export namespace UntagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceRequest) => any;
    }
    export interface UntagResourceResponse {
    }
    export namespace UntagResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceResponse) => any;
    }
    export interface UpdateBotRequest {
            /**
                * <p>The unique identifier of the bot to update. This identifier is
                *          returned by the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_CreateBot.html">CreateBot</a> operation.</p>
                */
            botId: string | undefined;
            /**
                * <p>The new name of the bot. The name must be unique in the account that
                *          creates the bot.</p>
                */
            botName: string | undefined;
            /**
                * <p>A description of the bot.</p>
                */
            description?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of an IAM role that has permissions
                *          to access the bot.</p>
                */
            roleArn: string | undefined;
            /**
                * <p>Provides information on additional privacy protections Amazon Lex should
                *          use with the bot's data.</p>
                */
            dataPrivacy: DataPrivacy | undefined;
            /**
                * <p>The time, in seconds, that Amazon Lex should keep information about a
                *          user's conversation with the bot.</p>
                *          <p>A user interaction remains active for the amount of time specified.
                *          If no conversation occurs during this time, the session expires and
                *          Amazon Lex deletes any data provided before the timeout.</p>
                *          <p>You can specify between 60 (1 minute) and 86,400 (24 hours)
                *          seconds.</p>
                */
            idleSessionTTLInSeconds: number | undefined;
    }
    export namespace UpdateBotRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateBotRequest) => any;
    }
    export interface UpdateBotResponse {
            /**
                * <p>The unique identifier of the bot that was updated.</p>
                */
            botId?: string;
            /**
                * <p>The name of the bot after the update.</p>
                */
            botName?: string;
            /**
                * <p>The description of the bot after the update.</p>
                */
            description?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the IAM role used by the bot after
                *          the update.</p>
                */
            roleArn?: string;
            /**
                * <p>The data privacy settings for the bot after the update.</p>
                */
            dataPrivacy?: DataPrivacy;
            /**
                * <p>The session timeout, in seconds, for the bot after the
                *          update.</p>
                */
            idleSessionTTLInSeconds?: number;
            /**
                * <p>Shows the current status of the bot. The bot is first in the
                *             <code>Creating</code> status. Once the bot is read for use, it
                *          changes to the <code>Available</code> status. After the bot is created,
                *          you can use the <code>DRAFT</code> version of the bot.</p>
                */
            botStatus?: BotStatus | string;
            /**
                * <p>A timestamp of the date and time that the bot was created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>A timestamp of the date and time that the bot was last
                *          updated.</p>
                */
            lastUpdatedDateTime?: Date;
    }
    export namespace UpdateBotResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateBotResponse) => any;
    }
    export interface UpdateBotAliasRequest {
            /**
                * <p>The unique identifier of the bot alias.</p>
                */
            botAliasId: string | undefined;
            /**
                * <p>The new name to assign to the bot alias.</p>
                */
            botAliasName: string | undefined;
            /**
                * <p>The new description to assign to the bot alias.</p>
                */
            description?: string;
            /**
                * <p>The new bot version to assign to the bot alias.</p>
                */
            botVersion?: string;
            /**
                * <p>The new Lambda functions to use in each locale for the bot
                *          alias.</p>
                */
            botAliasLocaleSettings?: Record<string, BotAliasLocaleSettings>;
            /**
                * <p>The new settings for storing conversation logs in Amazon CloudWatch Logs and
                *          Amazon S3 buckets.</p>
                */
            conversationLogSettings?: ConversationLogSettings;
            /**
                * <p>Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of
                *          user utterances.</p>
                */
            sentimentAnalysisSettings?: SentimentAnalysisSettings;
            /**
                * <p>The identifier of the bot with the updated alias.</p>
                */
            botId: string | undefined;
    }
    export namespace UpdateBotAliasRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateBotAliasRequest) => any;
    }
    export interface UpdateBotAliasResponse {
            /**
                * <p>The identifier of the updated bot alias.</p>
                */
            botAliasId?: string;
            /**
                * <p>The updated name of the bot alias.</p>
                */
            botAliasName?: string;
            /**
                * <p>The updated description of the bot alias.</p>
                */
            description?: string;
            /**
                * <p>The updated version of the bot that the alias points to.</p>
                */
            botVersion?: string;
            /**
                * <p>The updated Lambda functions to use in each locale for the bot
                *          alias.</p>
                */
            botAliasLocaleSettings?: Record<string, BotAliasLocaleSettings>;
            /**
                * <p>The updated settings for storing conversation logs in Amazon CloudWatch Logs and
                *          Amazon S3 buckets.</p>
                */
            conversationLogSettings?: ConversationLogSettings;
            /**
                * <p>Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of
                *          user utterances.</p>
                */
            sentimentAnalysisSettings?: SentimentAnalysisSettings;
            /**
                * <p>The current status of the bot alias. When the status is
                *             <code>Available</code> the alias is ready for use.</p>
                */
            botAliasStatus?: BotAliasStatus | string;
            /**
                * <p>The identifier of the bot with the updated alias.</p>
                */
            botId?: string;
            /**
                * <p>A timestamp of the date and time that the bot was created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>A timestamp of the date and time that the bot was last
                *          updated.</p>
                */
            lastUpdatedDateTime?: Date;
    }
    export namespace UpdateBotAliasResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateBotAliasResponse) => any;
    }
    export interface UpdateBotLocaleRequest {
            /**
                * <p>The unique identifier of the bot that contains the locale.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot that contains the locale to be updated. The
                *          version can only be the <code>DRAFT</code> version.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale to update. The string must
                *          match one of the supported locales. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId: string | undefined;
            /**
                * <p>The new description of the locale.</p>
                */
            description?: string;
            /**
                * <p>The new confidence threshold where Amazon Lex inserts the
                *             <code>AMAZON.FallbackIntent</code> and
                *             <code>AMAZON.KendraSearchIntent</code> intents in the list of
                *          possible intents for an utterance.</p>
                */
            nluIntentConfidenceThreshold: number | undefined;
            /**
                * <p>The new Amazon Polly voice Amazon Lex should use for voice interaction with the
                *          user.</p>
                */
            voiceSettings?: VoiceSettings;
    }
    export namespace UpdateBotLocaleRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateBotLocaleRequest) => any;
    }
    export interface UpdateBotLocaleResponse {
            /**
                * <p>The identifier of the bot that contains the updated locale.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot that contains the updated locale.</p>
                */
            botVersion?: string;
            /**
                * <p>The language and locale of the updated bot locale.</p>
                */
            localeId?: string;
            /**
                * <p>The updated locale name for the locale.</p>
                */
            localeName?: string;
            /**
                * <p>The updated description of the locale.</p>
                */
            description?: string;
            /**
                * <p>The updated confidence threshold for inserting the
                *             <code>AMAZON.FallbackIntent</code> and
                *             <code>AMAZON.KendraSearchIntent</code> intents in the list of
                *          possible intents for an utterance.</p>
                */
            nluIntentConfidenceThreshold?: number;
            /**
                * <p>The updated Amazon Polly voice to use for voice interaction with the
                *          user.</p>
                */
            voiceSettings?: VoiceSettings;
            /**
                * <p>The current status of the locale. When the bot status is
                *             <code>Built</code> the locale is ready for use.</p>
                */
            botLocaleStatus?: BotLocaleStatus | string;
            /**
                * <p>If the <code>botLocaleStatus</code> is <code>Failed</code>, the
                *             <code>failureReasons</code> field lists the errors that occurred
                *          while building the bot.</p>
                */
            failureReasons?: string[];
            /**
                * <p>A timestamp of the date and time that the locale was created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>A timestamp of the date and time that the locale was last
                *          updated.</p>
                */
            lastUpdatedDateTime?: Date;
            /**
                * <p>Recommended actions to take to resolve an error in the
                *             <code>failureReasons</code> field.</p>
                */
            recommendedActions?: string[];
    }
    export namespace UpdateBotLocaleResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateBotLocaleResponse) => any;
    }
    export interface UpdateBotRecommendationRequest {
            /**
                * <p>The unique identifier of the bot containing the bot recommendation
                *          to be updated.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot containing the bot recommendation to be
                *          updated.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale of the bot recommendation
                *          to update. The string must match one of the supported locales. For more
                *          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>
                *          </p>
                */
            localeId: string | undefined;
            /**
                * <p>The unique identifier of the bot recommendation to be
                *          updated.</p>
                */
            botRecommendationId: string | undefined;
            /**
                * <p>The object representing the passwords that will be used to encrypt
                *          the data related to the bot recommendation results, as well as the KMS
                *          key ARN used to encrypt the associated metadata.</p>
                */
            encryptionSetting: EncryptionSetting | undefined;
    }
    export namespace UpdateBotRecommendationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateBotRecommendationRequest) => any;
    }
    export interface UpdateBotRecommendationResponse {
            /**
                * <p>The unique identifier of the bot containing the bot recommendation
                *          that has been updated.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot containing the bot recommendation that has
                *          been updated.</p>
                */
            botVersion?: string;
            /**
                * <p>The identifier of the language and locale of the bot recommendation
                *          to update. The string must match one of the supported locales. For more
                *          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>
                *          </p>
                */
            localeId?: string;
            /**
                * <p>The status of the bot recommendation.</p>
                *          <p>If the status is Failed, then the reasons for the failure are listed
                *          in the failureReasons field. </p>
                */
            botRecommendationStatus?: BotRecommendationStatus | string;
            /**
                * <p>The unique identifier of the bot recommendation to be
                *          updated.</p>
                */
            botRecommendationId?: string;
            /**
                * <p>A timestamp of the date and time that the bot recommendation was
                *          created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>A timestamp of the date and time that the bot recommendation was
                *          last updated.</p>
                */
            lastUpdatedDateTime?: Date;
            /**
                * <p>The object representing the Amazon S3 bucket containing the transcript,
                *          as well as the associated metadata.</p>
                */
            transcriptSourceSetting?: TranscriptSourceSetting;
            /**
                * <p>The object representing the passwords that were used to encrypt the
                *          data related to the bot recommendation results, as well as the KMS key
                *          ARN used to encrypt the associated metadata.</p>
                */
            encryptionSetting?: EncryptionSetting;
    }
    export namespace UpdateBotRecommendationResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateBotRecommendationResponse) => any;
    }
    export interface UpdateExportRequest {
            /**
                * <p>The unique identifier Amazon Lex assigned to the export.</p>
                */
            exportId: string | undefined;
            /**
                * <p>The new password to use to encrypt the export zip archive.</p>
                */
            filePassword?: string;
    }
    export namespace UpdateExportRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateExportRequest) => any;
    }
    export interface UpdateExportResponse {
            /**
                * <p>The unique identifier Amazon Lex assigned to the export.</p>
                */
            exportId?: string;
            /**
                * <p>A description of the type of resource that was exported, either a
                *          bot or a bot locale.</p>
                */
            resourceSpecification?: ExportResourceSpecification;
            /**
                * <p>The file format used for the files that define the resource. The
                *             <code>TSV</code> format is required to export a custom vocabulary
                *          only; otherwise use <code>LexJson</code> format.</p>
                */
            fileFormat?: ImportExportFileFormat | string;
            /**
                * <p>The status of the export. When the status is <code>Completed</code>
                *          the export archive is available for download.</p>
                */
            exportStatus?: ExportStatus | string;
            /**
                * <p>The date and time that the export was created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>The date and time that the export was last updated.</p>
                */
            lastUpdatedDateTime?: Date;
    }
    export namespace UpdateExportResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateExportResponse) => any;
    }
    export interface UpdateIntentRequest {
            /**
                * <p>The unique identifier of the intent to update.</p>
                */
            intentId: string | undefined;
            /**
                * <p>The new name for the intent.</p>
                */
            intentName: string | undefined;
            /**
                * <p>The new description of the intent.</p>
                */
            description?: string;
            /**
                * <p>The signature of the new built-in intent to use as the parent of
                *          this intent.</p>
                */
            parentIntentSignature?: string;
            /**
                * <p>New utterances used to invoke the intent.</p>
                */
            sampleUtterances?: SampleUtterance[];
            /**
                * <p>The new Lambda function to use between each turn of the conversation
                *          with the bot.</p>
                */
            dialogCodeHook?: DialogCodeHookSettings;
            /**
                * <p>The new Lambda function to call when all of the intents required
                *          slots are provided and the intent is ready for fulfillment.</p>
                */
            fulfillmentCodeHook?: FulfillmentCodeHookSettings;
            /**
                * <p>A new list of slots and their priorities that are contained by the
                *          intent.</p>
                */
            slotPriorities?: SlotPriority[];
            /**
                * <p>New prompts that Amazon Lex sends to the user to confirm the completion
                *          of an intent.</p>
                */
            intentConfirmationSetting?: IntentConfirmationSetting;
            /**
                * <p>The new response that Amazon Lex sends the user when the intent is
                *          closed.</p>
                */
            intentClosingSetting?: IntentClosingSetting;
            /**
                * <p>A new list of contexts that must be active in order for Amazon Lex to
                *          consider the intent.</p>
                */
            inputContexts?: InputContext[];
            /**
                * <p>A new list of contexts that Amazon Lex activates when the intent is
                *          fulfilled.</p>
                */
            outputContexts?: OutputContext[];
            /**
                * <p>New configuration settings for connecting to an Amazon Kendra index.</p>
                */
            kendraConfiguration?: KendraConfiguration;
            /**
                * <p>The identifier of the bot that contains the intent.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot that contains the intent. Must be
                *             <code>DRAFT</code>.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale where this intent is used.
                *          The string must match one of the supported locales. For more
                *          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId: string | undefined;
    }
    export namespace UpdateIntentRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateIntentRequest) => any;
    }
    export interface UpdateIntentResponse {
            /**
                * <p>The identifier of the intent that was updated.</p>
                */
            intentId?: string;
            /**
                * <p>The updated name of the intent.</p>
                */
            intentName?: string;
            /**
                * <p>The updated description of the intent.</p>
                */
            description?: string;
            /**
                * <p>The updated built-in intent that is the parent of this
                *          intent.</p>
                */
            parentIntentSignature?: string;
            /**
                * <p>The updated list of sample utterances for the intent.</p>
                */
            sampleUtterances?: SampleUtterance[];
            /**
                * <p>The updated Lambda function called during each turn of the
                *          conversation with the user.</p>
                */
            dialogCodeHook?: DialogCodeHookSettings;
            /**
                * <p>The updated Lambda function called when the intent is ready for
                *          fulfillment.</p>
                */
            fulfillmentCodeHook?: FulfillmentCodeHookSettings;
            /**
                * <p>The updated list of slots and their priorities that are elicited
                *          from the user for the intent.</p>
                */
            slotPriorities?: SlotPriority[];
            /**
                * <p>The updated prompts that Amazon Lex sends to the user to confirm the
                *          completion of an intent.</p>
                */
            intentConfirmationSetting?: IntentConfirmationSetting;
            /**
                * <p>The updated response that Amazon Lex sends the user when the intent is
                *          closed.</p>
                */
            intentClosingSetting?: IntentClosingSetting;
            /**
                * <p>The updated list of contexts that must be active for the intent to
                *          be considered by Amazon Lex.</p>
                */
            inputContexts?: InputContext[];
            /**
                * <p>The updated list of contexts that Amazon Lex activates when the intent is
                *          fulfilled.</p>
                */
            outputContexts?: OutputContext[];
            /**
                * <p>The updated configuration for connecting to an Amazon Kendra index with the
                *             <code>AMAZON.KendraSearchIntent</code> intent.</p>
                */
            kendraConfiguration?: KendraConfiguration;
            /**
                * <p>The identifier of the bot that contains the intent.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot that contains the intent. Will always be
                *             <code>DRAFT</code>.</p>
                */
            botVersion?: string;
            /**
                * <p>The updated language and locale of the intent.</p>
                */
            localeId?: string;
            /**
                * <p>A timestamp of when the intent was created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>A timestamp of the last time that the intent was modified.</p>
                */
            lastUpdatedDateTime?: Date;
    }
    export namespace UpdateIntentResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateIntentResponse) => any;
    }
    export interface UpdateResourcePolicyRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the bot or bot alias that the
                *          resource policy is attached to.</p>
                */
            resourceArn: string | undefined;
            /**
                * <p>A resource policy to add to the resource. The policy is a JSON
                *          structure that contains one or more statements that define the policy.
                *          The policy must follow the IAM syntax. For more information about the
                *          contents of a JSON policy document, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies.html"> IAM JSON policy
                *             reference </a>. </p>
                *          <p>If the policy isn't valid, Amazon Lex returns a validation
                *          exception.</p>
                */
            policy: string | undefined;
            /**
                * <p>The identifier of the revision of the policy to update. If this
                *          revision ID doesn't match the current revision ID, Amazon Lex throws an
                *          exception.</p>
                *          <p>If you don't specify a revision, Amazon Lex overwrites the contents of
                *          the policy with the new values.</p>
                */
            expectedRevisionId?: string;
    }
    export namespace UpdateResourcePolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateResourcePolicyRequest) => any;
    }
    export interface UpdateResourcePolicyResponse {
            /**
                * <p>The Amazon Resource Name (ARN) of the bot or bot alias that the
                *          resource policy is attached to.</p>
                */
            resourceArn?: string;
            /**
                * <p>The current revision of the resource policy. Use the revision ID to
                *          make sure that you are updating the most current version of a resource
                *          policy when you add a policy statement to a resource, delete a
                *          resource, or update a resource.</p>
                */
            revisionId?: string;
    }
    export namespace UpdateResourcePolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateResourcePolicyResponse) => any;
    }
    export interface UpdateSlotRequest {
            /**
                * <p>The unique identifier for the slot to update.</p>
                */
            slotId: string | undefined;
            /**
                * <p>The new name for the slot.</p>
                */
            slotName: string | undefined;
            /**
                * <p>The new description for the slot.</p>
                */
            description?: string;
            /**
                * <p>The unique identifier of the new slot type to associate with this
                *          slot. </p>
                */
            slotTypeId?: string;
            /**
                * <p>A new set of prompts that Amazon Lex sends to the user to elicit a
                *          response the provides a value for the slot.</p>
                */
            valueElicitationSetting: SlotValueElicitationSetting | undefined;
            /**
                * <p>New settings that determine how slot values are formatted in Amazon CloudWatch
                *          logs. </p>
                */
            obfuscationSetting?: ObfuscationSetting;
            /**
                * <p>The unique identifier of the bot that contains the slot.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot that contains the slot. Must always be
                *             <code>DRAFT</code>.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale that contains the slot.
                *          The string must match one of the supported locales. For more
                *          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId: string | undefined;
            /**
                * <p>The identifier of the intent that contains the slot.</p>
                */
            intentId: string | undefined;
            /**
                * <p>Determines whether the slot accepts multiple values in one response.
                *          Multiple value slots are only available in the en-US locale. If you set
                *          this value to <code>true</code> in any other locale, Amazon Lex throws a
                *             <code>ValidationException</code>.</p>
                *          <p>If the <code>multipleValuesSetting</code> is not set, the default
                *          value is <code>false</code>.</p>
                */
            multipleValuesSetting?: MultipleValuesSetting;
    }
    export namespace UpdateSlotRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateSlotRequest) => any;
    }
    export interface UpdateSlotResponse {
            /**
                * <p>The unique identifier of the slot that was updated.</p>
                */
            slotId?: string;
            /**
                * <p>The updated name of the slot.</p>
                */
            slotName?: string;
            /**
                * <p>The updated description of the bot.</p>
                */
            description?: string;
            /**
                * <p>The updated identifier of the slot type that provides values for the
                *          slot.</p>
                */
            slotTypeId?: string;
            /**
                * <p>The updated prompts that Amazon Lex sends to the user to elicit a
                *          response that provides a value for the slot.</p>
                */
            valueElicitationSetting?: SlotValueElicitationSetting;
            /**
                * <p>The updated setting that determines whether the slot value is
                *          obfuscated in the Amazon CloudWatch logs.</p>
                */
            obfuscationSetting?: ObfuscationSetting;
            /**
                * <p>The identifier of the bot that contains the slot.</p>
                */
            botId?: string;
            /**
                * <p>The identifier of the slot version that contains the slot. Will
                *          always be <code>DRAFT</code>.</p>
                */
            botVersion?: string;
            /**
                * <p>The locale that contains the slot.</p>
                */
            localeId?: string;
            /**
                * <p>The intent that contains the slot.</p>
                */
            intentId?: string;
            /**
                * <p>The timestamp of the date and time that the slot was created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>The timestamp of the date and time that the slot was last
                *          updated.</p>
                */
            lastUpdatedDateTime?: Date;
            /**
                * <p>Indicates whether the slot accepts multiple values in one
                *          response.</p>
                */
            multipleValuesSetting?: MultipleValuesSetting;
    }
    export namespace UpdateSlotResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateSlotResponse) => any;
    }
    export interface UpdateSlotTypeRequest {
            /**
                * <p>The unique identifier of the slot type to update.</p>
                */
            slotTypeId: string | undefined;
            /**
                * <p>The new name of the slot type.</p>
                */
            slotTypeName: string | undefined;
            /**
                * <p>The new description of the slot type.</p>
                */
            description?: string;
            /**
                * <p>A new list of values and their optional synonyms that define the
                *          values that the slot type can take.</p>
                */
            slotTypeValues?: SlotTypeValue[];
            /**
                * <p>The strategy that Amazon Lex should use when deciding on a value from the
                *          list of slot type values.</p>
                */
            valueSelectionSetting?: SlotValueSelectionSetting;
            /**
                * <p>The new built-in slot type that should be used as the parent of this
                *          slot type.</p>
                */
            parentSlotTypeSignature?: string;
            /**
                * <p>The identifier of the bot that contains the slot type.</p>
                */
            botId: string | undefined;
            /**
                * <p>The version of the bot that contains the slot type. Must be
                *             <code>DRAFT</code>.</p>
                */
            botVersion: string | undefined;
            /**
                * <p>The identifier of the language and locale that contains the slot
                *          type. The string must match one of the supported locales. For more
                *          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
                */
            localeId: string | undefined;
            /**
                * <p>Provides information about the external source of the slot type's
                *          definition.</p>
                */
            externalSourceSetting?: ExternalSourceSetting;
    }
    export namespace UpdateSlotTypeRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateSlotTypeRequest) => any;
    }
    export interface UpdateSlotTypeResponse {
            /**
                * <p>The unique identifier of the updated slot type.</p>
                */
            slotTypeId?: string;
            /**
                * <p>The updated name of the slot type.</p>
                */
            slotTypeName?: string;
            /**
                * <p>The updated description of the slot type.</p>
                */
            description?: string;
            /**
                * <p>The updated values that the slot type provides.</p>
                */
            slotTypeValues?: SlotTypeValue[];
            /**
                * <p>The updated strategy that Amazon Lex uses to determine which value to
                *          select from the slot type.</p>
                */
            valueSelectionSetting?: SlotValueSelectionSetting;
            /**
                * <p>The updated signature of the built-in slot type that is the parent
                *          of this slot type.</p>
                */
            parentSlotTypeSignature?: string;
            /**
                * <p>The identifier of the bot that contains the slot type.</p>
                */
            botId?: string;
            /**
                * <p>The version of the bot that contains the slot type. This is always
                *             <code>DRAFT</code>.</p>
                */
            botVersion?: string;
            /**
                * <p>The language and locale of the updated slot type.</p>
                */
            localeId?: string;
            /**
                * <p>The timestamp of the date and time that the slot type was
                *          created.</p>
                */
            creationDateTime?: Date;
            /**
                * <p>A timestamp of the date and time that the slot type was last
                *          updated.</p>
                */
            lastUpdatedDateTime?: Date;
            /**
                * <p>Provides information about the external source of the slot type's
                *          definition.</p>
                */
            externalSourceSetting?: ExternalSourceSetting;
    }
    export namespace UpdateSlotTypeResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateSlotTypeResponse) => any;
    }
}

declare module '@aws-sdk/client-lex-models-v2/node_modules/@aws-sdk/client-lex-models-v2/dist-types/models/LexModelsV2ServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from LexModelsV2 service.
        */
    export class LexModelsV2ServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

