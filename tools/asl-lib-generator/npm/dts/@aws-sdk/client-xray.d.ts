// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/smithy-client
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http

declare module '@aws-sdk/client-xray' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { BatchGetTracesCommandInput, BatchGetTracesCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/BatchGetTracesCommand";
    import { CreateGroupCommandInput, CreateGroupCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/CreateGroupCommand";
    import { CreateSamplingRuleCommandInput, CreateSamplingRuleCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/CreateSamplingRuleCommand";
    import { DeleteGroupCommandInput, DeleteGroupCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/DeleteGroupCommand";
    import { DeleteSamplingRuleCommandInput, DeleteSamplingRuleCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/DeleteSamplingRuleCommand";
    import { GetEncryptionConfigCommandInput, GetEncryptionConfigCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetEncryptionConfigCommand";
    import { GetGroupCommandInput, GetGroupCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetGroupCommand";
    import { GetGroupsCommandInput, GetGroupsCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetGroupsCommand";
    import { GetInsightCommandInput, GetInsightCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetInsightCommand";
    import { GetInsightEventsCommandInput, GetInsightEventsCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetInsightEventsCommand";
    import { GetInsightImpactGraphCommandInput, GetInsightImpactGraphCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetInsightImpactGraphCommand";
    import { GetInsightSummariesCommandInput, GetInsightSummariesCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetInsightSummariesCommand";
    import { GetSamplingRulesCommandInput, GetSamplingRulesCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetSamplingRulesCommand";
    import { GetSamplingStatisticSummariesCommandInput, GetSamplingStatisticSummariesCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetSamplingStatisticSummariesCommand";
    import { GetSamplingTargetsCommandInput, GetSamplingTargetsCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetSamplingTargetsCommand";
    import { GetServiceGraphCommandInput, GetServiceGraphCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetServiceGraphCommand";
    import { GetTimeSeriesServiceStatisticsCommandInput, GetTimeSeriesServiceStatisticsCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetTimeSeriesServiceStatisticsCommand";
    import { GetTraceGraphCommandInput, GetTraceGraphCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetTraceGraphCommand";
    import { GetTraceSummariesCommandInput, GetTraceSummariesCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetTraceSummariesCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/ListTagsForResourceCommand";
    import { PutEncryptionConfigCommandInput, PutEncryptionConfigCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/PutEncryptionConfigCommand";
    import { PutTelemetryRecordsCommandInput, PutTelemetryRecordsCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/PutTelemetryRecordsCommand";
    import { PutTraceSegmentsCommandInput, PutTraceSegmentsCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/PutTraceSegmentsCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/UntagResourceCommand";
    import { UpdateGroupCommandInput, UpdateGroupCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/UpdateGroupCommand";
    import { UpdateSamplingRuleCommandInput, UpdateSamplingRuleCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/UpdateSamplingRuleCommand";
    import { XRayClient } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    /**
        * <p>Amazon Web Services X-Ray provides APIs for managing debug traces and retrieving service maps
        *       and other data created by processing those traces.</p>
        */
    export class XRay extends XRayClient {
            /**
                * <p>Retrieves a list of traces specified by ID. Each trace is a collection of segment
                *       documents that originates from a single request. Use <code>GetTraceSummaries</code> to get a
                *       list of trace IDs.</p>
                */
            batchGetTraces(args: BatchGetTracesCommandInput, options?: __HttpHandlerOptions): Promise<BatchGetTracesCommandOutput>;
            batchGetTraces(args: BatchGetTracesCommandInput, cb: (err: any, data?: BatchGetTracesCommandOutput) => void): void;
            batchGetTraces(args: BatchGetTracesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchGetTracesCommandOutput) => void): void;
            /**
                * <p>Creates a group resource with a name and a filter expression. </p>
                */
            createGroup(args: CreateGroupCommandInput, options?: __HttpHandlerOptions): Promise<CreateGroupCommandOutput>;
            createGroup(args: CreateGroupCommandInput, cb: (err: any, data?: CreateGroupCommandOutput) => void): void;
            createGroup(args: CreateGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateGroupCommandOutput) => void): void;
            /**
                * <p>Creates a rule to control sampling behavior for instrumented applications. Services
                *          retrieve rules with <a href="https://docs.aws.amazon.com/xray/latest/api/API_GetSamplingRules.html">GetSamplingRules</a>, and evaluate each rule in ascending
                *          order of <i>priority</i> for each request. If a rule matches, the service
                *          records a trace, borrowing it from the reservoir size. After 10 seconds, the service
                *          reports back to X-Ray with <a href="https://docs.aws.amazon.com/xray/latest/api/API_GetSamplingTargets.html">GetSamplingTargets</a> to get updated versions of
                *          each in-use rule. The updated rule contains a trace quota that the service can use instead
                *          of borrowing from the reservoir.</p>
                */
            createSamplingRule(args: CreateSamplingRuleCommandInput, options?: __HttpHandlerOptions): Promise<CreateSamplingRuleCommandOutput>;
            createSamplingRule(args: CreateSamplingRuleCommandInput, cb: (err: any, data?: CreateSamplingRuleCommandOutput) => void): void;
            createSamplingRule(args: CreateSamplingRuleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateSamplingRuleCommandOutput) => void): void;
            /**
                * <p>Deletes a group resource.</p>
                */
            deleteGroup(args: DeleteGroupCommandInput, options?: __HttpHandlerOptions): Promise<DeleteGroupCommandOutput>;
            deleteGroup(args: DeleteGroupCommandInput, cb: (err: any, data?: DeleteGroupCommandOutput) => void): void;
            deleteGroup(args: DeleteGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteGroupCommandOutput) => void): void;
            /**
                * <p>Deletes a sampling rule.</p>
                */
            deleteSamplingRule(args: DeleteSamplingRuleCommandInput, options?: __HttpHandlerOptions): Promise<DeleteSamplingRuleCommandOutput>;
            deleteSamplingRule(args: DeleteSamplingRuleCommandInput, cb: (err: any, data?: DeleteSamplingRuleCommandOutput) => void): void;
            deleteSamplingRule(args: DeleteSamplingRuleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteSamplingRuleCommandOutput) => void): void;
            /**
                * <p>Retrieves the current encryption configuration for X-Ray data.</p>
                */
            getEncryptionConfig(args: GetEncryptionConfigCommandInput, options?: __HttpHandlerOptions): Promise<GetEncryptionConfigCommandOutput>;
            getEncryptionConfig(args: GetEncryptionConfigCommandInput, cb: (err: any, data?: GetEncryptionConfigCommandOutput) => void): void;
            getEncryptionConfig(args: GetEncryptionConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetEncryptionConfigCommandOutput) => void): void;
            /**
                * <p>Retrieves group resource details.</p>
                */
            getGroup(args: GetGroupCommandInput, options?: __HttpHandlerOptions): Promise<GetGroupCommandOutput>;
            getGroup(args: GetGroupCommandInput, cb: (err: any, data?: GetGroupCommandOutput) => void): void;
            getGroup(args: GetGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetGroupCommandOutput) => void): void;
            /**
                * <p>Retrieves all active group details.</p>
                */
            getGroups(args: GetGroupsCommandInput, options?: __HttpHandlerOptions): Promise<GetGroupsCommandOutput>;
            getGroups(args: GetGroupsCommandInput, cb: (err: any, data?: GetGroupsCommandOutput) => void): void;
            getGroups(args: GetGroupsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetGroupsCommandOutput) => void): void;
            /**
                * <p>Retrieves the summary information of an insight. This includes impact to clients and
                *          root cause services, the top anomalous services, the category, the state of the insight,
                *          and the start and end time of the insight.</p>
                */
            getInsight(args: GetInsightCommandInput, options?: __HttpHandlerOptions): Promise<GetInsightCommandOutput>;
            getInsight(args: GetInsightCommandInput, cb: (err: any, data?: GetInsightCommandOutput) => void): void;
            getInsight(args: GetInsightCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetInsightCommandOutput) => void): void;
            /**
                * <p>X-Ray reevaluates insights periodically until they're resolved, and records each intermediate state as an
                *          event. You can review an insight's events in the Impact Timeline on the Inspect page in the X-Ray
                *          console.</p>
                */
            getInsightEvents(args: GetInsightEventsCommandInput, options?: __HttpHandlerOptions): Promise<GetInsightEventsCommandOutput>;
            getInsightEvents(args: GetInsightEventsCommandInput, cb: (err: any, data?: GetInsightEventsCommandOutput) => void): void;
            getInsightEvents(args: GetInsightEventsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetInsightEventsCommandOutput) => void): void;
            /**
                * <p>Retrieves a service graph structure filtered by the specified insight. The service graph is limited to only
                *          structural information. For a complete service graph, use this API with the GetServiceGraph API.</p>
                */
            getInsightImpactGraph(args: GetInsightImpactGraphCommandInput, options?: __HttpHandlerOptions): Promise<GetInsightImpactGraphCommandOutput>;
            getInsightImpactGraph(args: GetInsightImpactGraphCommandInput, cb: (err: any, data?: GetInsightImpactGraphCommandOutput) => void): void;
            getInsightImpactGraph(args: GetInsightImpactGraphCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetInsightImpactGraphCommandOutput) => void): void;
            /**
                * <p>Retrieves the summaries of all insights in the specified group matching the provided filter values.</p>
                */
            getInsightSummaries(args: GetInsightSummariesCommandInput, options?: __HttpHandlerOptions): Promise<GetInsightSummariesCommandOutput>;
            getInsightSummaries(args: GetInsightSummariesCommandInput, cb: (err: any, data?: GetInsightSummariesCommandOutput) => void): void;
            getInsightSummaries(args: GetInsightSummariesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetInsightSummariesCommandOutput) => void): void;
            /**
                * <p>Retrieves all sampling rules.</p>
                */
            getSamplingRules(args: GetSamplingRulesCommandInput, options?: __HttpHandlerOptions): Promise<GetSamplingRulesCommandOutput>;
            getSamplingRules(args: GetSamplingRulesCommandInput, cb: (err: any, data?: GetSamplingRulesCommandOutput) => void): void;
            getSamplingRules(args: GetSamplingRulesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetSamplingRulesCommandOutput) => void): void;
            /**
                * <p>Retrieves information about recent sampling results for all sampling rules.</p>
                */
            getSamplingStatisticSummaries(args: GetSamplingStatisticSummariesCommandInput, options?: __HttpHandlerOptions): Promise<GetSamplingStatisticSummariesCommandOutput>;
            getSamplingStatisticSummaries(args: GetSamplingStatisticSummariesCommandInput, cb: (err: any, data?: GetSamplingStatisticSummariesCommandOutput) => void): void;
            getSamplingStatisticSummaries(args: GetSamplingStatisticSummariesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetSamplingStatisticSummariesCommandOutput) => void): void;
            /**
                * <p>Requests a sampling quota for rules that the service is using to sample requests.
                *       </p>
                */
            getSamplingTargets(args: GetSamplingTargetsCommandInput, options?: __HttpHandlerOptions): Promise<GetSamplingTargetsCommandOutput>;
            getSamplingTargets(args: GetSamplingTargetsCommandInput, cb: (err: any, data?: GetSamplingTargetsCommandOutput) => void): void;
            getSamplingTargets(args: GetSamplingTargetsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetSamplingTargetsCommandOutput) => void): void;
            /**
                * <p>Retrieves a document that describes services that process incoming requests, and
                *       downstream services that they call as a result. Root services process incoming requests and
                *       make calls to downstream services. Root services are applications that use the <a href="https://docs.aws.amazon.com/xray/index.html">Amazon Web Services X-Ray SDK</a>.
                *       Downstream services can be other applications, Amazon Web Services resources, HTTP web APIs, or SQL
                *       databases.</p>
                */
            getServiceGraph(args: GetServiceGraphCommandInput, options?: __HttpHandlerOptions): Promise<GetServiceGraphCommandOutput>;
            getServiceGraph(args: GetServiceGraphCommandInput, cb: (err: any, data?: GetServiceGraphCommandOutput) => void): void;
            getServiceGraph(args: GetServiceGraphCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetServiceGraphCommandOutput) => void): void;
            /**
                * <p>Get an aggregation of service statistics defined by a specific time
                *             range.</p>
                */
            getTimeSeriesServiceStatistics(args: GetTimeSeriesServiceStatisticsCommandInput, options?: __HttpHandlerOptions): Promise<GetTimeSeriesServiceStatisticsCommandOutput>;
            getTimeSeriesServiceStatistics(args: GetTimeSeriesServiceStatisticsCommandInput, cb: (err: any, data?: GetTimeSeriesServiceStatisticsCommandOutput) => void): void;
            getTimeSeriesServiceStatistics(args: GetTimeSeriesServiceStatisticsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetTimeSeriesServiceStatisticsCommandOutput) => void): void;
            /**
                * <p>Retrieves a service graph for one or more specific trace IDs.</p>
                */
            getTraceGraph(args: GetTraceGraphCommandInput, options?: __HttpHandlerOptions): Promise<GetTraceGraphCommandOutput>;
            getTraceGraph(args: GetTraceGraphCommandInput, cb: (err: any, data?: GetTraceGraphCommandOutput) => void): void;
            getTraceGraph(args: GetTraceGraphCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetTraceGraphCommandOutput) => void): void;
            /**
                * <p>Retrieves IDs and annotations for traces available for a specified time frame using an
                *       optional filter. To get the full traces, pass the trace IDs to
                *       <code>BatchGetTraces</code>.</p>
                *          <p>A filter expression can target traced requests that hit specific service nodes or
                *       edges, have errors, or come from a known user. For example, the following filter expression
                *       targets traces that pass through <code>api.example.com</code>:</p>
                *          <p>
                *             <code>service("api.example.com")</code>
                *          </p>
                *          <p>This filter expression finds traces that have an annotation named <code>account</code>
                *       with the value <code>12345</code>:</p>
                *          <p>
                *             <code>annotation.account = "12345"</code>
                *          </p>
                *          <p>For a full list of indexed fields and keywords that you can use in filter expressions,
                *       see <a href="https://docs.aws.amazon.com/xray/latest/devguide/xray-console-filters.html">Using Filter
                *         Expressions</a> in the <i>Amazon Web Services X-Ray Developer Guide</i>.</p>
                */
            getTraceSummaries(args: GetTraceSummariesCommandInput, options?: __HttpHandlerOptions): Promise<GetTraceSummariesCommandOutput>;
            getTraceSummaries(args: GetTraceSummariesCommandInput, cb: (err: any, data?: GetTraceSummariesCommandOutput) => void): void;
            getTraceSummaries(args: GetTraceSummariesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetTraceSummariesCommandOutput) => void): void;
            /**
                * <p>Returns a list of tags that are applied to the specified Amazon Web Services X-Ray group or sampling rule.</p>
                */
            listTagsForResource(args: ListTagsForResourceCommandInput, options?: __HttpHandlerOptions): Promise<ListTagsForResourceCommandOutput>;
            listTagsForResource(args: ListTagsForResourceCommandInput, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            listTagsForResource(args: ListTagsForResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            /**
                * <p>Updates the encryption configuration for X-Ray data.</p>
                */
            putEncryptionConfig(args: PutEncryptionConfigCommandInput, options?: __HttpHandlerOptions): Promise<PutEncryptionConfigCommandOutput>;
            putEncryptionConfig(args: PutEncryptionConfigCommandInput, cb: (err: any, data?: PutEncryptionConfigCommandOutput) => void): void;
            putEncryptionConfig(args: PutEncryptionConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutEncryptionConfigCommandOutput) => void): void;
            /**
                * <p>Used by the Amazon Web Services X-Ray daemon to upload telemetry.</p>
                */
            putTelemetryRecords(args: PutTelemetryRecordsCommandInput, options?: __HttpHandlerOptions): Promise<PutTelemetryRecordsCommandOutput>;
            putTelemetryRecords(args: PutTelemetryRecordsCommandInput, cb: (err: any, data?: PutTelemetryRecordsCommandOutput) => void): void;
            putTelemetryRecords(args: PutTelemetryRecordsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutTelemetryRecordsCommandOutput) => void): void;
            /**
                * <p>Uploads segment documents to Amazon Web Services X-Ray. The <a href="https://docs.aws.amazon.com/xray/index.html">X-Ray SDK</a> generates segment documents and sends them to the X-Ray daemon, which uploads them in
                *       batches. A segment document can be a completed segment, an in-progress segment, or an array of
                *       subsegments.</p>
                *          <p>Segments must include the following fields. For the full segment document schema, see
                *       <a href="https://docs.aws.amazon.com/xray/latest/devguide/xray-api-segmentdocuments.html">Amazon Web Services X-Ray
                *         Segment Documents</a> in the <i>Amazon Web Services X-Ray Developer Guide</i>.</p>
                *          <p class="title">
                *             <b>Required segment document fields</b>
                *          </p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>name</code> - The name of the service that handled the request.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>id</code> - A 64-bit identifier for the segment, unique among segments in the same trace, in 16
                *           hexadecimal digits.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>trace_id</code> - A unique identifier that connects all segments and subsegments originating from
                *           a single client request.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>start_time</code> - Time the segment or subsegment was created, in floating point seconds in
                *           epoch time, accurate to milliseconds. For example, <code>1480615200.010</code> or
                *             <code>1.480615200010E9</code>.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>end_time</code> - Time the segment or subsegment was closed. For example,
                *             <code>1480615200.090</code> or <code>1.480615200090E9</code>. Specify either an <code>end_time</code> or
                *             <code>in_progress</code>.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>in_progress</code> - Set to <code>true</code> instead of specifying an <code>end_time</code> to
                *           record that a segment has been started, but is not complete. Send an in-progress segment when your application
                *           receives a request that will take a long time to serve, to trace that the request was received. When the
                *           response is sent, send the complete segment to overwrite the in-progress segment.</p>
                *             </li>
                *          </ul>
                *          <p>A <code>trace_id</code> consists of three numbers separated by hyphens. For example,
                *       1-58406520-a006649127e371903a2de979. This includes:</p>
                *          <p class="title">
                *             <b>Trace ID Format</b>
                *          </p>
                *          <ul>
                *             <li>
                *                <p>The version number, for instance, <code>1</code>.</p>
                *             </li>
                *             <li>
                *                <p>The time of the original request, in Unix epoch time, in 8 hexadecimal digits. For
                *           example, 10:00AM December 2nd, 2016 PST in epoch time is <code>1480615200</code> seconds,
                *           or <code>58406520</code> in hexadecimal.</p>
                *             </li>
                *             <li>
                *                <p>A 96-bit identifier for the trace, globally unique, in 24 hexadecimal
                *           digits.</p>
                *             </li>
                *          </ul>
                */
            putTraceSegments(args: PutTraceSegmentsCommandInput, options?: __HttpHandlerOptions): Promise<PutTraceSegmentsCommandOutput>;
            putTraceSegments(args: PutTraceSegmentsCommandInput, cb: (err: any, data?: PutTraceSegmentsCommandOutput) => void): void;
            putTraceSegments(args: PutTraceSegmentsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutTraceSegmentsCommandOutput) => void): void;
            /**
                * <p>Applies tags to an existing Amazon Web Services X-Ray group or sampling rule.</p>
                */
            tagResource(args: TagResourceCommandInput, options?: __HttpHandlerOptions): Promise<TagResourceCommandOutput>;
            tagResource(args: TagResourceCommandInput, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            tagResource(args: TagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            /**
                * <p>Removes tags from an Amazon Web Services X-Ray group or sampling rule. You cannot edit or delete system
                *       tags (those with an <code>aws:</code> prefix).</p>
                */
            untagResource(args: UntagResourceCommandInput, options?: __HttpHandlerOptions): Promise<UntagResourceCommandOutput>;
            untagResource(args: UntagResourceCommandInput, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            untagResource(args: UntagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            /**
                * <p>Updates a group resource.</p>
                */
            updateGroup(args: UpdateGroupCommandInput, options?: __HttpHandlerOptions): Promise<UpdateGroupCommandOutput>;
            updateGroup(args: UpdateGroupCommandInput, cb: (err: any, data?: UpdateGroupCommandOutput) => void): void;
            updateGroup(args: UpdateGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateGroupCommandOutput) => void): void;
            /**
                * <p>Modifies a sampling rule's configuration.</p>
                */
            updateSamplingRule(args: UpdateSamplingRuleCommandInput, options?: __HttpHandlerOptions): Promise<UpdateSamplingRuleCommandOutput>;
            updateSamplingRule(args: UpdateSamplingRuleCommandInput, cb: (err: any, data?: UpdateSamplingRuleCommandOutput) => void): void;
            updateSamplingRule(args: UpdateSamplingRuleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateSamplingRuleCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/BatchGetTracesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { BatchGetTracesRequest, BatchGetTracesResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface BatchGetTracesCommandInput extends BatchGetTracesRequest {
    }
    export interface BatchGetTracesCommandOutput extends BatchGetTracesResult, __MetadataBearer {
    }
    /**
        * <p>Retrieves a list of traces specified by ID. Each trace is a collection of segment
        *       documents that originates from a single request. Use <code>GetTraceSummaries</code> to get a
        *       list of trace IDs.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, BatchGetTracesCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, BatchGetTracesCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new BatchGetTracesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchGetTracesCommandInput} for command's `input` shape.
        * @see {@link BatchGetTracesCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class BatchGetTracesCommand extends $Command<BatchGetTracesCommandInput, BatchGetTracesCommandOutput, XRayClientResolvedConfig> {
            readonly input: BatchGetTracesCommandInput;
            constructor(input: BatchGetTracesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchGetTracesCommandInput, BatchGetTracesCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/CreateGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateGroupRequest, CreateGroupResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface CreateGroupCommandInput extends CreateGroupRequest {
    }
    export interface CreateGroupCommandOutput extends CreateGroupResult, __MetadataBearer {
    }
    /**
        * <p>Creates a group resource with a name and a filter expression. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, CreateGroupCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, CreateGroupCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new CreateGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateGroupCommandInput} for command's `input` shape.
        * @see {@link CreateGroupCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class CreateGroupCommand extends $Command<CreateGroupCommandInput, CreateGroupCommandOutput, XRayClientResolvedConfig> {
            readonly input: CreateGroupCommandInput;
            constructor(input: CreateGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateGroupCommandInput, CreateGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/CreateSamplingRuleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateSamplingRuleRequest, CreateSamplingRuleResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface CreateSamplingRuleCommandInput extends CreateSamplingRuleRequest {
    }
    export interface CreateSamplingRuleCommandOutput extends CreateSamplingRuleResult, __MetadataBearer {
    }
    /**
        * <p>Creates a rule to control sampling behavior for instrumented applications. Services
        *          retrieve rules with <a href="https://docs.aws.amazon.com/xray/latest/api/API_GetSamplingRules.html">GetSamplingRules</a>, and evaluate each rule in ascending
        *          order of <i>priority</i> for each request. If a rule matches, the service
        *          records a trace, borrowing it from the reservoir size. After 10 seconds, the service
        *          reports back to X-Ray with <a href="https://docs.aws.amazon.com/xray/latest/api/API_GetSamplingTargets.html">GetSamplingTargets</a> to get updated versions of
        *          each in-use rule. The updated rule contains a trace quota that the service can use instead
        *          of borrowing from the reservoir.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, CreateSamplingRuleCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, CreateSamplingRuleCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new CreateSamplingRuleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateSamplingRuleCommandInput} for command's `input` shape.
        * @see {@link CreateSamplingRuleCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class CreateSamplingRuleCommand extends $Command<CreateSamplingRuleCommandInput, CreateSamplingRuleCommandOutput, XRayClientResolvedConfig> {
            readonly input: CreateSamplingRuleCommandInput;
            constructor(input: CreateSamplingRuleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateSamplingRuleCommandInput, CreateSamplingRuleCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/DeleteGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteGroupRequest, DeleteGroupResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface DeleteGroupCommandInput extends DeleteGroupRequest {
    }
    export interface DeleteGroupCommandOutput extends DeleteGroupResult, __MetadataBearer {
    }
    /**
        * <p>Deletes a group resource.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, DeleteGroupCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, DeleteGroupCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new DeleteGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteGroupCommandInput} for command's `input` shape.
        * @see {@link DeleteGroupCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class DeleteGroupCommand extends $Command<DeleteGroupCommandInput, DeleteGroupCommandOutput, XRayClientResolvedConfig> {
            readonly input: DeleteGroupCommandInput;
            constructor(input: DeleteGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteGroupCommandInput, DeleteGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/DeleteSamplingRuleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteSamplingRuleRequest, DeleteSamplingRuleResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface DeleteSamplingRuleCommandInput extends DeleteSamplingRuleRequest {
    }
    export interface DeleteSamplingRuleCommandOutput extends DeleteSamplingRuleResult, __MetadataBearer {
    }
    /**
        * <p>Deletes a sampling rule.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, DeleteSamplingRuleCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, DeleteSamplingRuleCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new DeleteSamplingRuleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteSamplingRuleCommandInput} for command's `input` shape.
        * @see {@link DeleteSamplingRuleCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class DeleteSamplingRuleCommand extends $Command<DeleteSamplingRuleCommandInput, DeleteSamplingRuleCommandOutput, XRayClientResolvedConfig> {
            readonly input: DeleteSamplingRuleCommandInput;
            constructor(input: DeleteSamplingRuleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteSamplingRuleCommandInput, DeleteSamplingRuleCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetEncryptionConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetEncryptionConfigRequest, GetEncryptionConfigResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface GetEncryptionConfigCommandInput extends GetEncryptionConfigRequest {
    }
    export interface GetEncryptionConfigCommandOutput extends GetEncryptionConfigResult, __MetadataBearer {
    }
    /**
        * <p>Retrieves the current encryption configuration for X-Ray data.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, GetEncryptionConfigCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, GetEncryptionConfigCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new GetEncryptionConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetEncryptionConfigCommandInput} for command's `input` shape.
        * @see {@link GetEncryptionConfigCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class GetEncryptionConfigCommand extends $Command<GetEncryptionConfigCommandInput, GetEncryptionConfigCommandOutput, XRayClientResolvedConfig> {
            readonly input: GetEncryptionConfigCommandInput;
            constructor(input: GetEncryptionConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetEncryptionConfigCommandInput, GetEncryptionConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetGroupRequest, GetGroupResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface GetGroupCommandInput extends GetGroupRequest {
    }
    export interface GetGroupCommandOutput extends GetGroupResult, __MetadataBearer {
    }
    /**
        * <p>Retrieves group resource details.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, GetGroupCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, GetGroupCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new GetGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetGroupCommandInput} for command's `input` shape.
        * @see {@link GetGroupCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class GetGroupCommand extends $Command<GetGroupCommandInput, GetGroupCommandOutput, XRayClientResolvedConfig> {
            readonly input: GetGroupCommandInput;
            constructor(input: GetGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetGroupCommandInput, GetGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetGroupsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetGroupsRequest, GetGroupsResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface GetGroupsCommandInput extends GetGroupsRequest {
    }
    export interface GetGroupsCommandOutput extends GetGroupsResult, __MetadataBearer {
    }
    /**
        * <p>Retrieves all active group details.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, GetGroupsCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, GetGroupsCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new GetGroupsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetGroupsCommandInput} for command's `input` shape.
        * @see {@link GetGroupsCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class GetGroupsCommand extends $Command<GetGroupsCommandInput, GetGroupsCommandOutput, XRayClientResolvedConfig> {
            readonly input: GetGroupsCommandInput;
            constructor(input: GetGroupsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetGroupsCommandInput, GetGroupsCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetInsightCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetInsightRequest, GetInsightResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface GetInsightCommandInput extends GetInsightRequest {
    }
    export interface GetInsightCommandOutput extends GetInsightResult, __MetadataBearer {
    }
    /**
        * <p>Retrieves the summary information of an insight. This includes impact to clients and
        *          root cause services, the top anomalous services, the category, the state of the insight,
        *          and the start and end time of the insight.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, GetInsightCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, GetInsightCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new GetInsightCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetInsightCommandInput} for command's `input` shape.
        * @see {@link GetInsightCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class GetInsightCommand extends $Command<GetInsightCommandInput, GetInsightCommandOutput, XRayClientResolvedConfig> {
            readonly input: GetInsightCommandInput;
            constructor(input: GetInsightCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetInsightCommandInput, GetInsightCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetInsightEventsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetInsightEventsRequest, GetInsightEventsResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface GetInsightEventsCommandInput extends GetInsightEventsRequest {
    }
    export interface GetInsightEventsCommandOutput extends GetInsightEventsResult, __MetadataBearer {
    }
    /**
        * <p>X-Ray reevaluates insights periodically until they're resolved, and records each intermediate state as an
        *          event. You can review an insight's events in the Impact Timeline on the Inspect page in the X-Ray
        *          console.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, GetInsightEventsCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, GetInsightEventsCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new GetInsightEventsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetInsightEventsCommandInput} for command's `input` shape.
        * @see {@link GetInsightEventsCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class GetInsightEventsCommand extends $Command<GetInsightEventsCommandInput, GetInsightEventsCommandOutput, XRayClientResolvedConfig> {
            readonly input: GetInsightEventsCommandInput;
            constructor(input: GetInsightEventsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetInsightEventsCommandInput, GetInsightEventsCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetInsightImpactGraphCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetInsightImpactGraphRequest, GetInsightImpactGraphResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface GetInsightImpactGraphCommandInput extends GetInsightImpactGraphRequest {
    }
    export interface GetInsightImpactGraphCommandOutput extends GetInsightImpactGraphResult, __MetadataBearer {
    }
    /**
        * <p>Retrieves a service graph structure filtered by the specified insight. The service graph is limited to only
        *          structural information. For a complete service graph, use this API with the GetServiceGraph API.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, GetInsightImpactGraphCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, GetInsightImpactGraphCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new GetInsightImpactGraphCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetInsightImpactGraphCommandInput} for command's `input` shape.
        * @see {@link GetInsightImpactGraphCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class GetInsightImpactGraphCommand extends $Command<GetInsightImpactGraphCommandInput, GetInsightImpactGraphCommandOutput, XRayClientResolvedConfig> {
            readonly input: GetInsightImpactGraphCommandInput;
            constructor(input: GetInsightImpactGraphCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetInsightImpactGraphCommandInput, GetInsightImpactGraphCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetInsightSummariesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetInsightSummariesRequest, GetInsightSummariesResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface GetInsightSummariesCommandInput extends GetInsightSummariesRequest {
    }
    export interface GetInsightSummariesCommandOutput extends GetInsightSummariesResult, __MetadataBearer {
    }
    /**
        * <p>Retrieves the summaries of all insights in the specified group matching the provided filter values.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, GetInsightSummariesCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, GetInsightSummariesCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new GetInsightSummariesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetInsightSummariesCommandInput} for command's `input` shape.
        * @see {@link GetInsightSummariesCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class GetInsightSummariesCommand extends $Command<GetInsightSummariesCommandInput, GetInsightSummariesCommandOutput, XRayClientResolvedConfig> {
            readonly input: GetInsightSummariesCommandInput;
            constructor(input: GetInsightSummariesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetInsightSummariesCommandInput, GetInsightSummariesCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetSamplingRulesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetSamplingRulesRequest, GetSamplingRulesResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface GetSamplingRulesCommandInput extends GetSamplingRulesRequest {
    }
    export interface GetSamplingRulesCommandOutput extends GetSamplingRulesResult, __MetadataBearer {
    }
    /**
        * <p>Retrieves all sampling rules.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, GetSamplingRulesCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, GetSamplingRulesCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new GetSamplingRulesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetSamplingRulesCommandInput} for command's `input` shape.
        * @see {@link GetSamplingRulesCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class GetSamplingRulesCommand extends $Command<GetSamplingRulesCommandInput, GetSamplingRulesCommandOutput, XRayClientResolvedConfig> {
            readonly input: GetSamplingRulesCommandInput;
            constructor(input: GetSamplingRulesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetSamplingRulesCommandInput, GetSamplingRulesCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetSamplingStatisticSummariesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetSamplingStatisticSummariesRequest, GetSamplingStatisticSummariesResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface GetSamplingStatisticSummariesCommandInput extends GetSamplingStatisticSummariesRequest {
    }
    export interface GetSamplingStatisticSummariesCommandOutput extends GetSamplingStatisticSummariesResult, __MetadataBearer {
    }
    /**
        * <p>Retrieves information about recent sampling results for all sampling rules.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, GetSamplingStatisticSummariesCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, GetSamplingStatisticSummariesCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new GetSamplingStatisticSummariesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetSamplingStatisticSummariesCommandInput} for command's `input` shape.
        * @see {@link GetSamplingStatisticSummariesCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class GetSamplingStatisticSummariesCommand extends $Command<GetSamplingStatisticSummariesCommandInput, GetSamplingStatisticSummariesCommandOutput, XRayClientResolvedConfig> {
            readonly input: GetSamplingStatisticSummariesCommandInput;
            constructor(input: GetSamplingStatisticSummariesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetSamplingStatisticSummariesCommandInput, GetSamplingStatisticSummariesCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetSamplingTargetsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetSamplingTargetsRequest, GetSamplingTargetsResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface GetSamplingTargetsCommandInput extends GetSamplingTargetsRequest {
    }
    export interface GetSamplingTargetsCommandOutput extends GetSamplingTargetsResult, __MetadataBearer {
    }
    /**
        * <p>Requests a sampling quota for rules that the service is using to sample requests.
        *       </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, GetSamplingTargetsCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, GetSamplingTargetsCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new GetSamplingTargetsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetSamplingTargetsCommandInput} for command's `input` shape.
        * @see {@link GetSamplingTargetsCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class GetSamplingTargetsCommand extends $Command<GetSamplingTargetsCommandInput, GetSamplingTargetsCommandOutput, XRayClientResolvedConfig> {
            readonly input: GetSamplingTargetsCommandInput;
            constructor(input: GetSamplingTargetsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetSamplingTargetsCommandInput, GetSamplingTargetsCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetServiceGraphCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetServiceGraphRequest, GetServiceGraphResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface GetServiceGraphCommandInput extends GetServiceGraphRequest {
    }
    export interface GetServiceGraphCommandOutput extends GetServiceGraphResult, __MetadataBearer {
    }
    /**
        * <p>Retrieves a document that describes services that process incoming requests, and
        *       downstream services that they call as a result. Root services process incoming requests and
        *       make calls to downstream services. Root services are applications that use the <a href="https://docs.aws.amazon.com/xray/index.html">Amazon Web Services X-Ray SDK</a>.
        *       Downstream services can be other applications, Amazon Web Services resources, HTTP web APIs, or SQL
        *       databases.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, GetServiceGraphCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, GetServiceGraphCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new GetServiceGraphCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetServiceGraphCommandInput} for command's `input` shape.
        * @see {@link GetServiceGraphCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class GetServiceGraphCommand extends $Command<GetServiceGraphCommandInput, GetServiceGraphCommandOutput, XRayClientResolvedConfig> {
            readonly input: GetServiceGraphCommandInput;
            constructor(input: GetServiceGraphCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetServiceGraphCommandInput, GetServiceGraphCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetTimeSeriesServiceStatisticsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetTimeSeriesServiceStatisticsRequest, GetTimeSeriesServiceStatisticsResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface GetTimeSeriesServiceStatisticsCommandInput extends GetTimeSeriesServiceStatisticsRequest {
    }
    export interface GetTimeSeriesServiceStatisticsCommandOutput extends GetTimeSeriesServiceStatisticsResult, __MetadataBearer {
    }
    /**
        * <p>Get an aggregation of service statistics defined by a specific time
        *             range.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, GetTimeSeriesServiceStatisticsCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, GetTimeSeriesServiceStatisticsCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new GetTimeSeriesServiceStatisticsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetTimeSeriesServiceStatisticsCommandInput} for command's `input` shape.
        * @see {@link GetTimeSeriesServiceStatisticsCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class GetTimeSeriesServiceStatisticsCommand extends $Command<GetTimeSeriesServiceStatisticsCommandInput, GetTimeSeriesServiceStatisticsCommandOutput, XRayClientResolvedConfig> {
            readonly input: GetTimeSeriesServiceStatisticsCommandInput;
            constructor(input: GetTimeSeriesServiceStatisticsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetTimeSeriesServiceStatisticsCommandInput, GetTimeSeriesServiceStatisticsCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetTraceGraphCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetTraceGraphRequest, GetTraceGraphResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface GetTraceGraphCommandInput extends GetTraceGraphRequest {
    }
    export interface GetTraceGraphCommandOutput extends GetTraceGraphResult, __MetadataBearer {
    }
    /**
        * <p>Retrieves a service graph for one or more specific trace IDs.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, GetTraceGraphCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, GetTraceGraphCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new GetTraceGraphCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetTraceGraphCommandInput} for command's `input` shape.
        * @see {@link GetTraceGraphCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class GetTraceGraphCommand extends $Command<GetTraceGraphCommandInput, GetTraceGraphCommandOutput, XRayClientResolvedConfig> {
            readonly input: GetTraceGraphCommandInput;
            constructor(input: GetTraceGraphCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetTraceGraphCommandInput, GetTraceGraphCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetTraceSummariesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetTraceSummariesRequest, GetTraceSummariesResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface GetTraceSummariesCommandInput extends GetTraceSummariesRequest {
    }
    export interface GetTraceSummariesCommandOutput extends GetTraceSummariesResult, __MetadataBearer {
    }
    /**
        * <p>Retrieves IDs and annotations for traces available for a specified time frame using an
        *       optional filter. To get the full traces, pass the trace IDs to
        *       <code>BatchGetTraces</code>.</p>
        *          <p>A filter expression can target traced requests that hit specific service nodes or
        *       edges, have errors, or come from a known user. For example, the following filter expression
        *       targets traces that pass through <code>api.example.com</code>:</p>
        *          <p>
        *             <code>service("api.example.com")</code>
        *          </p>
        *          <p>This filter expression finds traces that have an annotation named <code>account</code>
        *       with the value <code>12345</code>:</p>
        *          <p>
        *             <code>annotation.account = "12345"</code>
        *          </p>
        *          <p>For a full list of indexed fields and keywords that you can use in filter expressions,
        *       see <a href="https://docs.aws.amazon.com/xray/latest/devguide/xray-console-filters.html">Using Filter
        *         Expressions</a> in the <i>Amazon Web Services X-Ray Developer Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, GetTraceSummariesCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, GetTraceSummariesCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new GetTraceSummariesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetTraceSummariesCommandInput} for command's `input` shape.
        * @see {@link GetTraceSummariesCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class GetTraceSummariesCommand extends $Command<GetTraceSummariesCommandInput, GetTraceSummariesCommandOutput, XRayClientResolvedConfig> {
            readonly input: GetTraceSummariesCommandInput;
            constructor(input: GetTraceSummariesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetTraceSummariesCommandInput, GetTraceSummariesCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/ListTagsForResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListTagsForResourceRequest, ListTagsForResourceResponse } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface ListTagsForResourceCommandInput extends ListTagsForResourceRequest {
    }
    export interface ListTagsForResourceCommandOutput extends ListTagsForResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Returns a list of tags that are applied to the specified Amazon Web Services X-Ray group or sampling rule.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, ListTagsForResourceCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, ListTagsForResourceCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new ListTagsForResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTagsForResourceCommandInput} for command's `input` shape.
        * @see {@link ListTagsForResourceCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class ListTagsForResourceCommand extends $Command<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput, XRayClientResolvedConfig> {
            readonly input: ListTagsForResourceCommandInput;
            constructor(input: ListTagsForResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/PutEncryptionConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { PutEncryptionConfigRequest, PutEncryptionConfigResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface PutEncryptionConfigCommandInput extends PutEncryptionConfigRequest {
    }
    export interface PutEncryptionConfigCommandOutput extends PutEncryptionConfigResult, __MetadataBearer {
    }
    /**
        * <p>Updates the encryption configuration for X-Ray data.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, PutEncryptionConfigCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, PutEncryptionConfigCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new PutEncryptionConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutEncryptionConfigCommandInput} for command's `input` shape.
        * @see {@link PutEncryptionConfigCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class PutEncryptionConfigCommand extends $Command<PutEncryptionConfigCommandInput, PutEncryptionConfigCommandOutput, XRayClientResolvedConfig> {
            readonly input: PutEncryptionConfigCommandInput;
            constructor(input: PutEncryptionConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutEncryptionConfigCommandInput, PutEncryptionConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/PutTelemetryRecordsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { PutTelemetryRecordsRequest, PutTelemetryRecordsResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface PutTelemetryRecordsCommandInput extends PutTelemetryRecordsRequest {
    }
    export interface PutTelemetryRecordsCommandOutput extends PutTelemetryRecordsResult, __MetadataBearer {
    }
    /**
        * <p>Used by the Amazon Web Services X-Ray daemon to upload telemetry.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, PutTelemetryRecordsCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, PutTelemetryRecordsCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new PutTelemetryRecordsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutTelemetryRecordsCommandInput} for command's `input` shape.
        * @see {@link PutTelemetryRecordsCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class PutTelemetryRecordsCommand extends $Command<PutTelemetryRecordsCommandInput, PutTelemetryRecordsCommandOutput, XRayClientResolvedConfig> {
            readonly input: PutTelemetryRecordsCommandInput;
            constructor(input: PutTelemetryRecordsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutTelemetryRecordsCommandInput, PutTelemetryRecordsCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/PutTraceSegmentsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { PutTraceSegmentsRequest, PutTraceSegmentsResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface PutTraceSegmentsCommandInput extends PutTraceSegmentsRequest {
    }
    export interface PutTraceSegmentsCommandOutput extends PutTraceSegmentsResult, __MetadataBearer {
    }
    /**
        * <p>Uploads segment documents to Amazon Web Services X-Ray. The <a href="https://docs.aws.amazon.com/xray/index.html">X-Ray SDK</a> generates segment documents and sends them to the X-Ray daemon, which uploads them in
        *       batches. A segment document can be a completed segment, an in-progress segment, or an array of
        *       subsegments.</p>
        *          <p>Segments must include the following fields. For the full segment document schema, see
        *       <a href="https://docs.aws.amazon.com/xray/latest/devguide/xray-api-segmentdocuments.html">Amazon Web Services X-Ray
        *         Segment Documents</a> in the <i>Amazon Web Services X-Ray Developer Guide</i>.</p>
        *          <p class="title">
        *             <b>Required segment document fields</b>
        *          </p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <code>name</code> - The name of the service that handled the request.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <code>id</code> - A 64-bit identifier for the segment, unique among segments in the same trace, in 16
        *           hexadecimal digits.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <code>trace_id</code> - A unique identifier that connects all segments and subsegments originating from
        *           a single client request.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <code>start_time</code> - Time the segment or subsegment was created, in floating point seconds in
        *           epoch time, accurate to milliseconds. For example, <code>1480615200.010</code> or
        *             <code>1.480615200010E9</code>.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <code>end_time</code> - Time the segment or subsegment was closed. For example,
        *             <code>1480615200.090</code> or <code>1.480615200090E9</code>. Specify either an <code>end_time</code> or
        *             <code>in_progress</code>.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <code>in_progress</code> - Set to <code>true</code> instead of specifying an <code>end_time</code> to
        *           record that a segment has been started, but is not complete. Send an in-progress segment when your application
        *           receives a request that will take a long time to serve, to trace that the request was received. When the
        *           response is sent, send the complete segment to overwrite the in-progress segment.</p>
        *             </li>
        *          </ul>
        *          <p>A <code>trace_id</code> consists of three numbers separated by hyphens. For example,
        *       1-58406520-a006649127e371903a2de979. This includes:</p>
        *          <p class="title">
        *             <b>Trace ID Format</b>
        *          </p>
        *          <ul>
        *             <li>
        *                <p>The version number, for instance, <code>1</code>.</p>
        *             </li>
        *             <li>
        *                <p>The time of the original request, in Unix epoch time, in 8 hexadecimal digits. For
        *           example, 10:00AM December 2nd, 2016 PST in epoch time is <code>1480615200</code> seconds,
        *           or <code>58406520</code> in hexadecimal.</p>
        *             </li>
        *             <li>
        *                <p>A 96-bit identifier for the trace, globally unique, in 24 hexadecimal
        *           digits.</p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, PutTraceSegmentsCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, PutTraceSegmentsCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new PutTraceSegmentsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutTraceSegmentsCommandInput} for command's `input` shape.
        * @see {@link PutTraceSegmentsCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class PutTraceSegmentsCommand extends $Command<PutTraceSegmentsCommandInput, PutTraceSegmentsCommandOutput, XRayClientResolvedConfig> {
            readonly input: PutTraceSegmentsCommandInput;
            constructor(input: PutTraceSegmentsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutTraceSegmentsCommandInput, PutTraceSegmentsCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/TagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { TagResourceRequest, TagResourceResponse } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface TagResourceCommandInput extends TagResourceRequest {
    }
    export interface TagResourceCommandOutput extends TagResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Applies tags to an existing Amazon Web Services X-Ray group or sampling rule.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, TagResourceCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, TagResourceCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new TagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TagResourceCommandInput} for command's `input` shape.
        * @see {@link TagResourceCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class TagResourceCommand extends $Command<TagResourceCommandInput, TagResourceCommandOutput, XRayClientResolvedConfig> {
            readonly input: TagResourceCommandInput;
            constructor(input: TagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TagResourceCommandInput, TagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/UntagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UntagResourceRequest, UntagResourceResponse } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface UntagResourceCommandInput extends UntagResourceRequest {
    }
    export interface UntagResourceCommandOutput extends UntagResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Removes tags from an Amazon Web Services X-Ray group or sampling rule. You cannot edit or delete system
        *       tags (those with an <code>aws:</code> prefix).</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, UntagResourceCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, UntagResourceCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new UntagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UntagResourceCommandInput} for command's `input` shape.
        * @see {@link UntagResourceCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class UntagResourceCommand extends $Command<UntagResourceCommandInput, UntagResourceCommandOutput, XRayClientResolvedConfig> {
            readonly input: UntagResourceCommandInput;
            constructor(input: UntagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UntagResourceCommandInput, UntagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/UpdateGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UpdateGroupRequest, UpdateGroupResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface UpdateGroupCommandInput extends UpdateGroupRequest {
    }
    export interface UpdateGroupCommandOutput extends UpdateGroupResult, __MetadataBearer {
    }
    /**
        * <p>Updates a group resource.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, UpdateGroupCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, UpdateGroupCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new UpdateGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateGroupCommandInput} for command's `input` shape.
        * @see {@link UpdateGroupCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class UpdateGroupCommand extends $Command<UpdateGroupCommandInput, UpdateGroupCommandOutput, XRayClientResolvedConfig> {
            readonly input: UpdateGroupCommandInput;
            constructor(input: UpdateGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateGroupCommandInput, UpdateGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/UpdateSamplingRuleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UpdateSamplingRuleRequest, UpdateSamplingRuleResult } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient";
    export interface UpdateSamplingRuleCommandInput extends UpdateSamplingRuleRequest {
    }
    export interface UpdateSamplingRuleCommandOutput extends UpdateSamplingRuleResult, __MetadataBearer {
    }
    /**
        * <p>Modifies a sampling rule's configuration.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { XRayClient, UpdateSamplingRuleCommand } from "@aws-sdk/client-xray"; // ES Modules import
        * // const { XRayClient, UpdateSamplingRuleCommand } = require("@aws-sdk/client-xray"); // CommonJS import
        * const client = new XRayClient(config);
        * const command = new UpdateSamplingRuleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateSamplingRuleCommandInput} for command's `input` shape.
        * @see {@link UpdateSamplingRuleCommandOutput} for command's `response` shape.
        * @see {@link XRayClientResolvedConfig | config} for XRayClient's `config` shape.
        *
        */
    export class UpdateSamplingRuleCommand extends $Command<UpdateSamplingRuleCommandInput, UpdateSamplingRuleCommandOutput, XRayClientResolvedConfig> {
            readonly input: UpdateSamplingRuleCommandInput;
            constructor(input: UpdateSamplingRuleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: XRayClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateSamplingRuleCommandInput, UpdateSamplingRuleCommandOutput>;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/XRayClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { BatchGetTracesCommandInput, BatchGetTracesCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/BatchGetTracesCommand";
    import { CreateGroupCommandInput, CreateGroupCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/CreateGroupCommand";
    import { CreateSamplingRuleCommandInput, CreateSamplingRuleCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/CreateSamplingRuleCommand";
    import { DeleteGroupCommandInput, DeleteGroupCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/DeleteGroupCommand";
    import { DeleteSamplingRuleCommandInput, DeleteSamplingRuleCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/DeleteSamplingRuleCommand";
    import { GetEncryptionConfigCommandInput, GetEncryptionConfigCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetEncryptionConfigCommand";
    import { GetGroupCommandInput, GetGroupCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetGroupCommand";
    import { GetGroupsCommandInput, GetGroupsCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetGroupsCommand";
    import { GetInsightCommandInput, GetInsightCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetInsightCommand";
    import { GetInsightEventsCommandInput, GetInsightEventsCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetInsightEventsCommand";
    import { GetInsightImpactGraphCommandInput, GetInsightImpactGraphCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetInsightImpactGraphCommand";
    import { GetInsightSummariesCommandInput, GetInsightSummariesCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetInsightSummariesCommand";
    import { GetSamplingRulesCommandInput, GetSamplingRulesCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetSamplingRulesCommand";
    import { GetSamplingStatisticSummariesCommandInput, GetSamplingStatisticSummariesCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetSamplingStatisticSummariesCommand";
    import { GetSamplingTargetsCommandInput, GetSamplingTargetsCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetSamplingTargetsCommand";
    import { GetServiceGraphCommandInput, GetServiceGraphCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetServiceGraphCommand";
    import { GetTimeSeriesServiceStatisticsCommandInput, GetTimeSeriesServiceStatisticsCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetTimeSeriesServiceStatisticsCommand";
    import { GetTraceGraphCommandInput, GetTraceGraphCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetTraceGraphCommand";
    import { GetTraceSummariesCommandInput, GetTraceSummariesCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/GetTraceSummariesCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/ListTagsForResourceCommand";
    import { PutEncryptionConfigCommandInput, PutEncryptionConfigCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/PutEncryptionConfigCommand";
    import { PutTelemetryRecordsCommandInput, PutTelemetryRecordsCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/PutTelemetryRecordsCommand";
    import { PutTraceSegmentsCommandInput, PutTraceSegmentsCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/PutTraceSegmentsCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/UntagResourceCommand";
    import { UpdateGroupCommandInput, UpdateGroupCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/UpdateGroupCommand";
    import { UpdateSamplingRuleCommandInput, UpdateSamplingRuleCommandOutput } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/commands/UpdateSamplingRuleCommand";
    export type ServiceInputTypes = BatchGetTracesCommandInput | CreateGroupCommandInput | CreateSamplingRuleCommandInput | DeleteGroupCommandInput | DeleteSamplingRuleCommandInput | GetEncryptionConfigCommandInput | GetGroupCommandInput | GetGroupsCommandInput | GetInsightCommandInput | GetInsightEventsCommandInput | GetInsightImpactGraphCommandInput | GetInsightSummariesCommandInput | GetSamplingRulesCommandInput | GetSamplingStatisticSummariesCommandInput | GetSamplingTargetsCommandInput | GetServiceGraphCommandInput | GetTimeSeriesServiceStatisticsCommandInput | GetTraceGraphCommandInput | GetTraceSummariesCommandInput | ListTagsForResourceCommandInput | PutEncryptionConfigCommandInput | PutTelemetryRecordsCommandInput | PutTraceSegmentsCommandInput | TagResourceCommandInput | UntagResourceCommandInput | UpdateGroupCommandInput | UpdateSamplingRuleCommandInput;
    export type ServiceOutputTypes = BatchGetTracesCommandOutput | CreateGroupCommandOutput | CreateSamplingRuleCommandOutput | DeleteGroupCommandOutput | DeleteSamplingRuleCommandOutput | GetEncryptionConfigCommandOutput | GetGroupCommandOutput | GetGroupsCommandOutput | GetInsightCommandOutput | GetInsightEventsCommandOutput | GetInsightImpactGraphCommandOutput | GetInsightSummariesCommandOutput | GetSamplingRulesCommandOutput | GetSamplingStatisticSummariesCommandOutput | GetSamplingTargetsCommandOutput | GetServiceGraphCommandOutput | GetTimeSeriesServiceStatisticsCommandOutput | GetTraceGraphCommandOutput | GetTraceSummariesCommandOutput | ListTagsForResourceCommandOutput | PutEncryptionConfigCommandOutput | PutTelemetryRecordsCommandOutput | PutTraceSegmentsCommandOutput | TagResourceCommandOutput | UntagResourceCommandOutput | UpdateGroupCommandOutput | UpdateSamplingRuleCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type XRayClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of XRayClient class constructor that set the region, credentials and other options.
        */
    export interface XRayClientConfig extends XRayClientConfigType {
    }
    type XRayClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of XRayClient class. This is resolved and normalized from the {@link XRayClientConfig | constructor configuration interface}.
        */
    export interface XRayClientResolvedConfig extends XRayClientResolvedConfigType {
    }
    /**
        * <p>Amazon Web Services X-Ray provides APIs for managing debug traces and retrieving service maps
        *       and other data created by processing those traces.</p>
        */
    export class XRayClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, XRayClientResolvedConfig> {
            /**
                * The resolved configuration of XRayClient class. This is resolved and normalized from the {@link XRayClientConfig | constructor configuration interface}.
                */
            readonly config: XRayClientResolvedConfig;
            constructor(configuration: XRayClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { XRayServiceException as __BaseException } from "@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/XRayServiceException";
    /**
        * <p>An alias for an edge.</p>
        */
    export interface Alias {
            /**
                * <p>The canonical name of the alias.</p>
                */
            Name?: string;
            /**
                * <p>A list of names for the alias, including the canonical name.</p>
                */
            Names?: string[];
            /**
                * <p>The type of the alias.</p>
                */
            Type?: string;
    }
    export namespace Alias {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Alias) => any;
    }
    /**
        * <p>Value of a segment annotation. Has one of three value types: Number, Boolean, or String.</p>
        */
    export type AnnotationValue = AnnotationValue.BooleanValueMember | AnnotationValue.NumberValueMember | AnnotationValue.StringValueMember | AnnotationValue.$UnknownMember;
    export namespace AnnotationValue {
            /**
                * <p>Value for a Number annotation.</p>
                */
            interface NumberValueMember {
                    NumberValue: number;
                    BooleanValue?: never;
                    StringValue?: never;
                    $unknown?: never;
            }
            /**
                * <p>Value for a Boolean annotation.</p>
                */
            interface BooleanValueMember {
                    NumberValue?: never;
                    BooleanValue: boolean;
                    StringValue?: never;
                    $unknown?: never;
            }
            /**
                * <p>Value for a String annotation.</p>
                */
            interface StringValueMember {
                    NumberValue?: never;
                    BooleanValue?: never;
                    StringValue: string;
                    $unknown?: never;
            }
            interface $UnknownMember {
                    NumberValue?: never;
                    BooleanValue?: never;
                    StringValue?: never;
                    $unknown: [string, any];
            }
            interface Visitor<T> {
                    NumberValue: (value: number) => T;
                    BooleanValue: (value: boolean) => T;
                    StringValue: (value: string) => T;
                    _: (name: string, value: any) => T;
            }
            const visit: <T>(value: AnnotationValue, visitor: Visitor<T>) => T;
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AnnotationValue) => any;
    }
    /**
        * <p></p>
        */
    export interface ServiceId {
            /**
                * <p></p>
                */
            Name?: string;
            /**
                * <p></p>
                */
            Names?: string[];
            /**
                * <p></p>
                */
            AccountId?: string;
            /**
                * <p></p>
                */
            Type?: string;
    }
    export namespace ServiceId {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ServiceId) => any;
    }
    /**
        * <p>Information about a segment annotation.</p>
        */
    export interface ValueWithServiceIds {
            /**
                * <p>Values of the annotation.</p>
                */
            AnnotationValue?: AnnotationValue;
            /**
                * <p>Services to which the annotation applies.</p>
                */
            ServiceIds?: ServiceId[];
    }
    export namespace ValueWithServiceIds {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ValueWithServiceIds) => any;
    }
    /**
        * <p>The service within the service graph that has anomalously high fault rates. </p>
        */
    export interface AnomalousService {
            /**
                * <p></p>
                */
            ServiceId?: ServiceId;
    }
    export namespace AnomalousService {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AnomalousService) => any;
    }
    /**
        * <p>A list of Availability Zones corresponding to the segments in a trace.</p>
        */
    export interface AvailabilityZoneDetail {
            /**
                * <p>The name of a corresponding Availability Zone.</p>
                */
            Name?: string;
    }
    export namespace AvailabilityZoneDetail {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AvailabilityZoneDetail) => any;
    }
    export interface BatchGetTracesRequest {
            /**
                * <p>Specify the trace IDs of requests for which to retrieve segments.</p>
                */
            TraceIds: string[] | undefined;
            /**
                * <p>Pagination token.</p>
                */
            NextToken?: string;
    }
    export namespace BatchGetTracesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetTracesRequest) => any;
    }
    /**
        * <p>A segment from a trace that has been ingested by the X-Ray service. The segment can be
        *       compiled from documents uploaded with <a href="https://docs.aws.amazon.com/xray/latest/api/API_PutTraceSegments.html">PutTraceSegments</a>, or an
        *         <code>inferred</code> segment for a downstream service, generated from a subsegment sent by
        *       the service that called it.</p>
        *          <p>For the full segment document schema, see <a href="https://docs.aws.amazon.com/xray/latest/devguide/xray-api-segmentdocuments.html">Amazon Web Services X-Ray Segment
        *       Documents</a> in the <i>Amazon Web Services X-Ray Developer Guide</i>.</p>
        */
    export interface Segment {
            /**
                * <p>The segment's ID.</p>
                */
            Id?: string;
            /**
                * <p>The segment document.</p>
                */
            Document?: string;
    }
    export namespace Segment {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Segment) => any;
    }
    /**
        * <p>A collection of segment documents with matching trace IDs.</p>
        */
    export interface Trace {
            /**
                * <p>The unique identifier for the request that generated the trace's segments and
                *       subsegments.</p>
                */
            Id?: string;
            /**
                * <p>The length of time in seconds between the start time of the root segment and the end
                *       time of the last segment that completed.</p>
                */
            Duration?: number;
            /**
                * <p>LimitExceeded is set to true when the trace has exceeded one of the defined quotas. For
                *       more information about quotas, see <a href="https://docs.aws.amazon.com/general/latest/gr/xray.html">Amazon Web Services X-Ray endpoints and quotas</a>.</p>
                */
            LimitExceeded?: boolean;
            /**
                * <p>Segment documents for the segments and subsegments that comprise the trace.</p>
                */
            Segments?: Segment[];
    }
    export namespace Trace {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Trace) => any;
    }
    export interface BatchGetTracesResult {
            /**
                * <p>Full traces for the specified requests.</p>
                */
            Traces?: Trace[];
            /**
                * <p>Trace IDs of requests that haven't been processed.</p>
                */
            UnprocessedTraceIds?: string[];
            /**
                * <p>Pagination token.</p>
                */
            NextToken?: string;
    }
    export namespace BatchGetTracesResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetTracesResult) => any;
    }
    /**
        * <p>The request is missing required parameters or has invalid parameters.</p>
        */
    export class InvalidRequestException extends __BaseException {
            readonly name: "InvalidRequestException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidRequestException, __BaseException>);
    }
    /**
        * <p>The request exceeds the maximum number of requests per second.</p>
        */
    export class ThrottledException extends __BaseException {
            readonly name: "ThrottledException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ThrottledException, __BaseException>);
    }
    /**
        * <p>The structure containing configurations related to insights.</p>
        */
    export interface InsightsConfiguration {
            /**
                * <p>Set the InsightsEnabled value to true to enable insights or false to disable
                *             insights.</p>
                */
            InsightsEnabled?: boolean;
            /**
                * <p>Set the NotificationsEnabled value to true to enable insights notifications. Notifications can only be
                *             enabled on a group with InsightsEnabled set to true.</p>
                */
            NotificationsEnabled?: boolean;
    }
    export namespace InsightsConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InsightsConfiguration) => any;
    }
    /**
        * <p>A map that contains tag keys and tag values to attach to an Amazon Web Services X-Ray group or sampling
        *       rule. For more information about ways to use tags, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a>
        *       in the <i>Amazon Web Services General Reference</i>.</p>
        *          <p>The following restrictions apply to tags:</p>
        *          <ul>
        *             <li>
        *                <p>Maximum number of user-applied tags per resource: 50</p>
        *             </li>
        *             <li>
        *                <p>Tag keys and values are case sensitive.</p>
        *             </li>
        *             <li>
        *                <p>Don't use <code>aws:</code> as a prefix for keys; it's reserved for Amazon Web Services use. You
        *           cannot edit or delete system tags.</p>
        *             </li>
        *          </ul>
        */
    export interface Tag {
            /**
                * <p>A tag key, such as <code>Stage</code> or <code>Name</code>. A tag key cannot be empty. The
                *       key can be a maximum of 128 characters, and can contain only Unicode letters, numbers, or separators,
                *       or the following special characters: <code>+ - = . _ : /</code>
                *          </p>
                */
            Key: string | undefined;
            /**
                * <p>An optional tag value, such as <code>Production</code> or <code>test-only</code>. The value can be
                *       a maximum of 255 characters, and contain only Unicode letters, numbers, or separators, or the following
                *       special characters: <code>+ - = . _ : /</code>
                *          </p>
                */
            Value: string | undefined;
    }
    export namespace Tag {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Tag) => any;
    }
    export interface CreateGroupRequest {
            /**
                * <p>The case-sensitive name of the new group. Default is a reserved name and names must
                *             be unique.</p>
                */
            GroupName: string | undefined;
            /**
                * <p>The filter expression defining criteria by which to group traces.</p>
                */
            FilterExpression?: string;
            /**
                * <p>The structure containing configurations related to insights.</p>
                *             <ul>
                *             <li>
                *                     <p>The InsightsEnabled boolean can be set to true to enable insights for the
                *                     new group or false to disable insights for the new group.</p>
                *                 </li>
                *             <li>
                *                     <p>The NotifcationsEnabled boolean can be set to true to enable insights
                *                     notifications for the new group. Notifications may only be enabled on a group
                *                     with InsightsEnabled set to true.</p>
                *                 </li>
                *          </ul>
                */
            InsightsConfiguration?: InsightsConfiguration;
            /**
                * <p>A map that contains one or more tag keys and tag values to attach to an X-Ray group.
                *             For more information about ways to use tags, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services
                *                 resources</a> in the <i>Amazon Web Services General Reference</i>.</p>
                *         <p>The following restrictions apply to tags:</p>
                *         <ul>
                *             <li>
                *                 <p>Maximum number of user-applied tags per resource: 50</p>
                *             </li>
                *             <li>
                *                 <p>Maximum tag key length: 128 Unicode characters</p>
                *             </li>
                *             <li>
                *                 <p>Maximum tag value length: 256 Unicode characters</p>
                *             </li>
                *             <li>
                *                 <p>Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . :
                *                     / = + - and @</p>
                *             </li>
                *             <li>
                *                 <p>Tag keys and values are case sensitive.</p>
                *             </li>
                *             <li>
                *                 <p>Don't use <code>aws:</code> as a prefix for keys; it's reserved for Amazon Web Services
                *                     use.</p>
                *             </li>
                *          </ul>
                */
            Tags?: Tag[];
    }
    export namespace CreateGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateGroupRequest) => any;
    }
    /**
        * <p>Details and metadata for a group.</p>
        */
    export interface Group {
            /**
                * <p>The unique case-sensitive name of the group.</p>
                */
            GroupName?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the group generated based on the GroupName.</p>
                */
            GroupARN?: string;
            /**
                * <p>The filter expression defining the parameters to include traces.</p>
                */
            FilterExpression?: string;
            /**
                * <p>The structure containing configurations related to insights.</p>
                *         <ul>
                *             <li>
                *                 <p>The InsightsEnabled boolean can be set to true to enable insights for the
                *                     group or false to disable insights for the group.</p>
                *             </li>
                *             <li>
                *                 <p>The NotificationsEnabled boolean can be set to true to enable insights
                *                     notifications through Amazon EventBridge for the group.</p>
                *             </li>
                *          </ul>
                */
            InsightsConfiguration?: InsightsConfiguration;
    }
    export namespace Group {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Group) => any;
    }
    export interface CreateGroupResult {
            /**
                * <p>The group that was created. Contains the name of the group that was created, the Amazon Resource Name
                *             (ARN) of the group that was generated based on the group name, the filter expression, and the insight
                *             configuration that was assigned to the group.</p>
                */
            Group?: Group;
    }
    export namespace CreateGroupResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateGroupResult) => any;
    }
    /**
        * <p>A sampling rule that services use to decide whether to instrument a request. Rule
        *       fields can match properties of the service, or properties of a request. The service can ignore
        *       rules that don't match its properties.</p>
        */
    export interface SamplingRule {
            /**
                * <p>The name of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
                */
            RuleName?: string;
            /**
                * <p>The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
                */
            RuleARN?: string;
            /**
                * <p>Matches the ARN of the Amazon Web Services resource on which the service runs.</p>
                */
            ResourceARN: string | undefined;
            /**
                * <p>The priority of the sampling rule.</p>
                */
            Priority: number | undefined;
            /**
                * <p>The percentage of matching requests to instrument, after the reservoir is
                *       exhausted.</p>
                */
            FixedRate: number | undefined;
            /**
                * <p>A fixed number of matching requests to instrument per second, prior to applying the
                *       fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.</p>
                */
            ReservoirSize: number | undefined;
            /**
                * <p>Matches the <code>name</code> that the service uses to identify itself in segments.</p>
                */
            ServiceName: string | undefined;
            /**
                * <p>Matches the <code>origin</code> that the service uses to identify its type in segments.</p>
                */
            ServiceType: string | undefined;
            /**
                * <p>Matches the hostname from a request URL.</p>
                */
            Host: string | undefined;
            /**
                * <p>Matches the HTTP method of a request.</p>
                */
            HTTPMethod: string | undefined;
            /**
                * <p>Matches the path from a request URL.</p>
                */
            URLPath: string | undefined;
            /**
                * <p>The version of the sampling rule format (<code>1</code>).</p>
                */
            Version: number | undefined;
            /**
                * <p>Matches attributes derived from the request.</p>
                */
            Attributes?: Record<string, string>;
    }
    export namespace SamplingRule {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SamplingRule) => any;
    }
    export interface CreateSamplingRuleRequest {
            /**
                * <p>The rule definition.</p>
                */
            SamplingRule: SamplingRule | undefined;
            /**
                * <p>A map that contains one or more tag keys and tag values to attach to an X-Ray sampling
                *          rule. For more information about ways to use tags, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services
                *             resources</a> in the <i>Amazon Web Services General Reference</i>.</p>
                *          <p>The following restrictions apply to tags:</p>
                *          <ul>
                *             <li>
                *                <p>Maximum number of user-applied tags per resource: 50</p>
                *             </li>
                *             <li>
                *                <p>Maximum tag key length: 128 Unicode characters</p>
                *             </li>
                *             <li>
                *                <p>Maximum tag value length: 256 Unicode characters</p>
                *             </li>
                *             <li>
                *                <p>Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . :
                *                / = + - and @</p>
                *             </li>
                *             <li>
                *                <p>Tag keys and values are case sensitive.</p>
                *             </li>
                *             <li>
                *                <p>Don't use <code>aws:</code> as a prefix for keys; it's reserved for Amazon Web Services
                *                use.</p>
                *             </li>
                *          </ul>
                */
            Tags?: Tag[];
    }
    export namespace CreateSamplingRuleRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateSamplingRuleRequest) => any;
    }
    /**
        * <p>A <a href="https://docs.aws.amazon.com/xray/latest/api/API_SamplingRule.html">SamplingRule</a> and its metadata.</p>
        */
    export interface SamplingRuleRecord {
            /**
                * <p>The sampling rule.</p>
                */
            SamplingRule?: SamplingRule;
            /**
                * <p>When the rule was created.</p>
                */
            CreatedAt?: Date;
            /**
                * <p>When the rule was last modified.</p>
                */
            ModifiedAt?: Date;
    }
    export namespace SamplingRuleRecord {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SamplingRuleRecord) => any;
    }
    export interface CreateSamplingRuleResult {
            /**
                * <p>The saved rule definition and metadata.</p>
                */
            SamplingRuleRecord?: SamplingRuleRecord;
    }
    export namespace CreateSamplingRuleResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateSamplingRuleResult) => any;
    }
    /**
        * <p>You have reached the maximum number of sampling rules.</p>
        */
    export class RuleLimitExceededException extends __BaseException {
            readonly name: "RuleLimitExceededException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<RuleLimitExceededException, __BaseException>);
    }
    export interface DeleteGroupRequest {
            /**
                * <p>The case-sensitive name of the group.</p>
                */
            GroupName?: string;
            /**
                * <p>The ARN of the group that was generated on creation.</p>
                */
            GroupARN?: string;
    }
    export namespace DeleteGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteGroupRequest) => any;
    }
    export interface DeleteGroupResult {
    }
    export namespace DeleteGroupResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteGroupResult) => any;
    }
    export interface DeleteSamplingRuleRequest {
            /**
                * <p>The name of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
                */
            RuleName?: string;
            /**
                * <p>The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
                */
            RuleARN?: string;
    }
    export namespace DeleteSamplingRuleRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteSamplingRuleRequest) => any;
    }
    export interface DeleteSamplingRuleResult {
            /**
                * <p>The deleted rule definition and metadata.</p>
                */
            SamplingRuleRecord?: SamplingRuleRecord;
    }
    export namespace DeleteSamplingRuleResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteSamplingRuleResult) => any;
    }
    export interface GetEncryptionConfigRequest {
    }
    export namespace GetEncryptionConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetEncryptionConfigRequest) => any;
    }
    export enum EncryptionStatus {
            ACTIVE = "ACTIVE",
            UPDATING = "UPDATING"
    }
    export enum EncryptionType {
            KMS = "KMS",
            NONE = "NONE"
    }
    /**
        * <p>A configuration document that specifies encryption configuration settings.</p>
        */
    export interface EncryptionConfig {
            /**
                * <p>The ID of the KMS key used for encryption, if applicable.</p>
                */
            KeyId?: string;
            /**
                * <p>The encryption status. While the status is <code>UPDATING</code>, X-Ray may encrypt data with a combination of the new and old settings.</p>
                */
            Status?: EncryptionStatus | string;
            /**
                * <p>The type of encryption. Set to <code>KMS</code> for encryption with KMS keys. Set to <code>NONE</code> for
                *       default encryption.</p>
                */
            Type?: EncryptionType | string;
    }
    export namespace EncryptionConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EncryptionConfig) => any;
    }
    export interface GetEncryptionConfigResult {
            /**
                * <p>The encryption configuration document.</p>
                */
            EncryptionConfig?: EncryptionConfig;
    }
    export namespace GetEncryptionConfigResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetEncryptionConfigResult) => any;
    }
    export interface GetGroupRequest {
            /**
                * <p>The case-sensitive name of the group.</p>
                */
            GroupName?: string;
            /**
                * <p>The ARN of the group that was generated on creation.</p>
                */
            GroupARN?: string;
    }
    export namespace GetGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetGroupRequest) => any;
    }
    export interface GetGroupResult {
            /**
                * <p>The group that was requested. Contains the name of the group, the ARN of the group,
                *             the filter expression, and the insight configuration assigned to the group.</p>
                */
            Group?: Group;
    }
    export namespace GetGroupResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetGroupResult) => any;
    }
    export interface GetGroupsRequest {
            /**
                * <p>Pagination token.</p>
                */
            NextToken?: string;
    }
    export namespace GetGroupsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetGroupsRequest) => any;
    }
    /**
        * <p>Details for a group without metadata.</p>
        */
    export interface GroupSummary {
            /**
                * <p>The unique case-sensitive name of the group.</p>
                */
            GroupName?: string;
            /**
                * <p>The ARN of the group generated based on the GroupName.</p>
                */
            GroupARN?: string;
            /**
                * <p>The filter expression defining the parameters to include traces.</p>
                */
            FilterExpression?: string;
            /**
                * <p>The structure containing configurations related to insights.</p>
                *         <ul>
                *             <li>
                *                 <p>The InsightsEnabled boolean can be set to true to enable insights for the
                *                     group or false to disable insights for the group.</p>
                *             </li>
                *             <li>
                *                 <p>The NotificationsEnabled boolean can be set to true to enable insights notifications.
                *                     Notifications can only be enabled on a group with InsightsEnabled set to true.</p>
                *             </li>
                *          </ul>
                */
            InsightsConfiguration?: InsightsConfiguration;
    }
    export namespace GroupSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GroupSummary) => any;
    }
    export interface GetGroupsResult {
            /**
                * <p>The collection of all active groups.</p>
                */
            Groups?: GroupSummary[];
            /**
                * <p>Pagination token.</p>
                */
            NextToken?: string;
    }
    export namespace GetGroupsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetGroupsResult) => any;
    }
    export interface GetInsightRequest {
            /**
                * <p>The insight's unique identifier. Use the GetInsightSummaries action to retrieve an InsightId.</p>
                */
            InsightId: string | undefined;
    }
    export namespace GetInsightRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetInsightRequest) => any;
    }
    export enum InsightCategory {
            FAULT = "FAULT"
    }
    /**
        * <p>Statistics that describe how the incident has impacted a service.</p>
        */
    export interface RequestImpactStatistics {
            /**
                * <p>The number of requests that have resulted in a fault,</p>
                */
            FaultCount?: number;
            /**
                * <p>The number of successful requests.</p>
                */
            OkCount?: number;
            /**
                * <p>The total number of requests to the service.</p>
                */
            TotalCount?: number;
    }
    export namespace RequestImpactStatistics {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RequestImpactStatistics) => any;
    }
    export enum InsightState {
            ACTIVE = "ACTIVE",
            CLOSED = "CLOSED"
    }
    /**
        * <p>When fault rates go outside of the expected range, X-Ray creates an insight. Insights
        *          tracks emergent issues within your applications.</p>
        */
    export interface Insight {
            /**
                * <p>The insights unique identifier. </p>
                */
            InsightId?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the group that the insight belongs to.</p>
                */
            GroupARN?: string;
            /**
                * <p>The name of the group  that the insight belongs to.</p>
                */
            GroupName?: string;
            /**
                * <p></p>
                */
            RootCauseServiceId?: ServiceId;
            /**
                * <p>The categories that label and describe the type of insight.</p>
                */
            Categories?: (InsightCategory | string)[];
            /**
                * <p>The current state of the insight.</p>
                */
            State?: InsightState | string;
            /**
                * <p>The time, in Unix seconds, at which the insight began.</p>
                */
            StartTime?: Date;
            /**
                * <p>The time, in Unix seconds, at which the insight ended.</p>
                */
            EndTime?: Date;
            /**
                * <p>A brief description of the insight.</p>
                */
            Summary?: string;
            /**
                * <p>The impact statistics of the client side service. This includes the number of requests to the client service
                *          and whether the requests were faults or okay.</p>
                */
            ClientRequestImpactStatistics?: RequestImpactStatistics;
            /**
                * <p>The impact statistics of the root cause service. This includes the number of requests to the client service
                *          and whether the requests were faults or okay.</p>
                */
            RootCauseServiceRequestImpactStatistics?: RequestImpactStatistics;
            /**
                * <p>The service within the insight that is most impacted by the incident.</p>
                */
            TopAnomalousServices?: AnomalousService[];
    }
    export namespace Insight {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Insight) => any;
    }
    export interface GetInsightResult {
            /**
                * <p>The summary information of an insight.</p>
                */
            Insight?: Insight;
    }
    export namespace GetInsightResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetInsightResult) => any;
    }
    export interface GetInsightEventsRequest {
            /**
                * <p>The insight's unique identifier. Use the GetInsightSummaries action to retrieve an InsightId.</p>
                */
            InsightId: string | undefined;
            /**
                * <p>Used to retrieve at most the specified value of events.</p>
                */
            MaxResults?: number;
            /**
                * <p>Specify the pagination token returned by a previous request to retrieve the next page of events. </p>
                */
            NextToken?: string;
    }
    export namespace GetInsightEventsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetInsightEventsRequest) => any;
    }
    /**
        * <p>X-Ray reevaluates insights periodically until they are resolved, and records each intermediate state in an
        *          event. You can review incident events in the Impact Timeline on the Inspect page in the X-Ray console.</p>
        */
    export interface InsightEvent {
            /**
                * <p>A brief description of the event.</p>
                */
            Summary?: string;
            /**
                * <p>The time, in Unix seconds, at which the event was recorded.</p>
                */
            EventTime?: Date;
            /**
                * <p>The impact statistics of the client side service. This includes the number of requests to the client service
                *          and whether the requests were faults or okay.</p>
                */
            ClientRequestImpactStatistics?: RequestImpactStatistics;
            /**
                * <p>The impact statistics of the root cause service. This includes the number of requests to the client service
                *          and whether the requests were faults or okay.</p>
                */
            RootCauseServiceRequestImpactStatistics?: RequestImpactStatistics;
            /**
                * <p>The service during the event that is most impacted by the incident.</p>
                */
            TopAnomalousServices?: AnomalousService[];
    }
    export namespace InsightEvent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InsightEvent) => any;
    }
    export interface GetInsightEventsResult {
            /**
                * <p>A detailed description of the event. This includes the time of the event, client and
                *          root cause impact statistics, and the top anomalous service at the time of the
                *          event.</p>
                */
            InsightEvents?: InsightEvent[];
            /**
                * <p>Use this token to retrieve the next page of insight events.</p>
                */
            NextToken?: string;
    }
    export namespace GetInsightEventsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetInsightEventsResult) => any;
    }
    export interface GetInsightImpactGraphRequest {
            /**
                * <p>The insight's unique identifier. Use the GetInsightSummaries action to retrieve an InsightId.</p>
                */
            InsightId: string | undefined;
            /**
                * <p>The estimated start time of the insight, in Unix time seconds. The StartTime is inclusive of the value
                *          provided and can't be more than 30 days old.</p>
                */
            StartTime: Date | undefined;
            /**
                * <p>The estimated end time of the insight, in Unix time seconds. The EndTime is exclusive of the value provided.
                *          The time range between the start time and end time can't be more than six hours. </p>
                */
            EndTime: Date | undefined;
            /**
                * <p>Specify the pagination token returned by a previous request to retrieve the next page of results. </p>
                */
            NextToken?: string;
    }
    export namespace GetInsightImpactGraphRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetInsightImpactGraphRequest) => any;
    }
    /**
        * <p>The connection between two service in an insight impact graph.</p>
        */
    export interface InsightImpactGraphEdge {
            /**
                * <p>Identifier of the edge. Unique within a service map.</p>
                */
            ReferenceId?: number;
    }
    export namespace InsightImpactGraphEdge {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InsightImpactGraphEdge) => any;
    }
    /**
        * <p>Information about an application that processed requests, users that made requests, or downstream services,
        *          resources, and applications that an application used. </p>
        */
    export interface InsightImpactGraphService {
            /**
                * <p>Identifier for the service. Unique within the service map.</p>
                */
            ReferenceId?: number;
            /**
                * <p>Identifier for the service. Unique within the service map.</p>
                *          <ul>
                *             <li>
                *                <p>Amazon Web Services Resource - The type of an Amazon Web Services resource. For example, AWS::EC2::Instance for an application running
                *                on Amazon EC2 or AWS::DynamoDB::Table for an Amazon DynamoDB table that the application used. </p>
                *             </li>
                *             <li>
                *                <p>Amazon Web Services Service - The type of an Amazon Web Services service. For example, AWS::DynamoDB for downstream calls to Amazon
                *                DynamoDB that didn't target a specific table. </p>
                *             </li>
                *             <li>
                *                <p>Amazon Web Services Service - The type of an Amazon Web Services service. For example, AWS::DynamoDB for downstream calls to Amazon
                *                DynamoDB that didn't target a specific table. </p>
                *             </li>
                *             <li>
                *                <p>remote - A downstream service of indeterminate type.</p>
                *             </li>
                *          </ul>
                */
            Type?: string;
            /**
                * <p>The canonical name of the service.</p>
                */
            Name?: string;
            /**
                * <p>A list of names for the service, including the canonical name.</p>
                */
            Names?: string[];
            /**
                * <p>Identifier of the Amazon Web Services account in which the service runs.</p>
                */
            AccountId?: string;
            /**
                * <p>Connections to downstream services.</p>
                */
            Edges?: InsightImpactGraphEdge[];
    }
    export namespace InsightImpactGraphService {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InsightImpactGraphService) => any;
    }
    export interface GetInsightImpactGraphResult {
            /**
                * <p>The insight's unique identifier.</p>
                */
            InsightId?: string;
            /**
                * <p>The provided start time.</p>
                */
            StartTime?: Date;
            /**
                * <p>The provided end time. </p>
                */
            EndTime?: Date;
            /**
                * <p>The time, in Unix seconds, at which the service graph started.</p>
                */
            ServiceGraphStartTime?: Date;
            /**
                * <p>The time, in Unix seconds, at which the service graph ended.</p>
                */
            ServiceGraphEndTime?: Date;
            /**
                * <p>The Amazon Web Services instrumented services related to the insight.</p>
                */
            Services?: InsightImpactGraphService[];
            /**
                * <p>Pagination token.</p>
                */
            NextToken?: string;
    }
    export namespace GetInsightImpactGraphResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetInsightImpactGraphResult) => any;
    }
    export interface GetInsightSummariesRequest {
            /**
                * <p>The list of insight states. </p>
                */
            States?: (InsightState | string)[];
            /**
                * <p>The Amazon Resource Name (ARN) of the group. Required if the GroupName isn't provided.</p>
                */
            GroupARN?: string;
            /**
                * <p>The name of the group. Required if the GroupARN isn't provided.</p>
                */
            GroupName?: string;
            /**
                * <p>The beginning of the time frame in which the insights started. The start time can't be more than 30 days
                *          old.</p>
                */
            StartTime: Date | undefined;
            /**
                * <p>The end of the time frame in which the insights ended. The end time can't be more than 30 days old.</p>
                */
            EndTime: Date | undefined;
            /**
                * <p>The maximum number of results to display.</p>
                */
            MaxResults?: number;
            /**
                * <p>Pagination token.</p>
                */
            NextToken?: string;
    }
    export namespace GetInsightSummariesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetInsightSummariesRequest) => any;
    }
    /**
        * <p>Information that describes an insight.</p>
        */
    export interface InsightSummary {
            /**
                * <p>The insights unique identifier. </p>
                */
            InsightId?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the group that the insight belongs to.</p>
                */
            GroupARN?: string;
            /**
                * <p>The name of the group  that the insight belongs to.</p>
                */
            GroupName?: string;
            /**
                * <p></p>
                */
            RootCauseServiceId?: ServiceId;
            /**
                * <p> Categories The categories that label and describe the type of insight.</p>
                */
            Categories?: (InsightCategory | string)[];
            /**
                * <p>The current state of the insight.</p>
                */
            State?: InsightState | string;
            /**
                * <p>The time, in Unix seconds, at which the insight began.</p>
                */
            StartTime?: Date;
            /**
                * <p>The time, in Unix seconds, at which the insight ended.</p>
                */
            EndTime?: Date;
            /**
                * <p>A brief description of the insight.</p>
                */
            Summary?: string;
            /**
                * <p>The impact statistics of the client side service. This includes the number of requests
                *          to the client service and whether the requests were faults or okay. </p>
                */
            ClientRequestImpactStatistics?: RequestImpactStatistics;
            /**
                * <p>The impact statistics of the root cause service. This includes the number of requests to
                *          the client service and whether the requests were faults or okay. </p>
                */
            RootCauseServiceRequestImpactStatistics?: RequestImpactStatistics;
            /**
                * <p>The service within the insight that is most impacted by the incident.</p>
                */
            TopAnomalousServices?: AnomalousService[];
            /**
                * <p>The time, in Unix seconds, that the insight was last updated.</p>
                */
            LastUpdateTime?: Date;
    }
    export namespace InsightSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InsightSummary) => any;
    }
    export interface GetInsightSummariesResult {
            /**
                * <p>The summary of each insight within the group matching the provided filters. The summary
                *          contains the InsightID, start and end time, the root cause service, the root cause and
                *          client impact statistics, the top anomalous services, and the status of the insight.</p>
                */
            InsightSummaries?: InsightSummary[];
            /**
                * <p>Pagination token.</p>
                */
            NextToken?: string;
    }
    export namespace GetInsightSummariesResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetInsightSummariesResult) => any;
    }
    export interface GetSamplingRulesRequest {
            /**
                * <p>Pagination token.</p>
                */
            NextToken?: string;
    }
    export namespace GetSamplingRulesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetSamplingRulesRequest) => any;
    }
    export interface GetSamplingRulesResult {
            /**
                * <p>Rule definitions and metadata.</p>
                */
            SamplingRuleRecords?: SamplingRuleRecord[];
            /**
                * <p>Pagination token.</p>
                */
            NextToken?: string;
    }
    export namespace GetSamplingRulesResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetSamplingRulesResult) => any;
    }
    export interface GetSamplingStatisticSummariesRequest {
            /**
                * <p>Pagination token.</p>
                */
            NextToken?: string;
    }
    export namespace GetSamplingStatisticSummariesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetSamplingStatisticSummariesRequest) => any;
    }
    /**
        * <p>Aggregated request sampling data for a sampling rule across all services for a 10-second window.</p>
        */
    export interface SamplingStatisticSummary {
            /**
                * <p>The name of the sampling rule.</p>
                */
            RuleName?: string;
            /**
                * <p>The start time of the reporting window.</p>
                */
            Timestamp?: Date;
            /**
                * <p>The number of requests that matched the rule.</p>
                */
            RequestCount?: number;
            /**
                * <p>The number of requests recorded with borrowed reservoir quota.</p>
                */
            BorrowCount?: number;
            /**
                * <p>The number of requests recorded.</p>
                */
            SampledCount?: number;
    }
    export namespace SamplingStatisticSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SamplingStatisticSummary) => any;
    }
    export interface GetSamplingStatisticSummariesResult {
            /**
                * <p>Information about the number of requests instrumented for each sampling
                *          rule.</p>
                */
            SamplingStatisticSummaries?: SamplingStatisticSummary[];
            /**
                * <p>Pagination token.</p>
                */
            NextToken?: string;
    }
    export namespace GetSamplingStatisticSummariesResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetSamplingStatisticSummariesResult) => any;
    }
    /**
        * <p>Request sampling results for a single rule from a service. Results are for the last 10
        *       seconds unless the service has been assigned a longer reporting interval after a previous call
        *       to <a href="https://docs.aws.amazon.com/xray/latest/api/API_GetSamplingTargets.html">GetSamplingTargets</a>.</p>
        */
    export interface SamplingStatisticsDocument {
            /**
                * <p>The name of the sampling rule.</p>
                */
            RuleName: string | undefined;
            /**
                * <p>A unique identifier for the service in hexadecimal.</p>
                */
            ClientID: string | undefined;
            /**
                * <p>The current time.</p>
                */
            Timestamp: Date | undefined;
            /**
                * <p>The number of requests that matched the rule.</p>
                */
            RequestCount: number | undefined;
            /**
                * <p>The number of requests recorded.</p>
                */
            SampledCount: number | undefined;
            /**
                * <p>The number of requests recorded with borrowed reservoir quota.</p>
                */
            BorrowCount?: number;
    }
    export namespace SamplingStatisticsDocument {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SamplingStatisticsDocument) => any;
    }
    export interface GetSamplingTargetsRequest {
            /**
                * <p>Information about rules that the service is using to sample requests.</p>
                */
            SamplingStatisticsDocuments: SamplingStatisticsDocument[] | undefined;
    }
    export namespace GetSamplingTargetsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetSamplingTargetsRequest) => any;
    }
    /**
        * <p>Temporary changes to a sampling rule configuration. To meet the global sampling target for a rule, X-Ray
        *       calculates a new reservoir for each service based on the recent sampling results of all services that called
        *       <a href="https://docs.aws.amazon.com/xray/latest/api/API_GetSamplingTargets.html">GetSamplingTargets</a>.</p>
        */
    export interface SamplingTargetDocument {
            /**
                * <p>The name of the sampling rule.</p>
                */
            RuleName?: string;
            /**
                * <p>The percentage of matching requests to instrument, after the reservoir is
                *       exhausted.</p>
                */
            FixedRate?: number;
            /**
                * <p>The number of requests per second that X-Ray allocated for this service.</p>
                */
            ReservoirQuota?: number;
            /**
                * <p>When the reservoir quota expires.</p>
                */
            ReservoirQuotaTTL?: Date;
            /**
                * <p>The number of seconds for the service to wait before getting sampling targets
                *       again.</p>
                */
            Interval?: number;
    }
    export namespace SamplingTargetDocument {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SamplingTargetDocument) => any;
    }
    /**
        * <p>Sampling statistics from a call to <a href="https://docs.aws.amazon.com/xray/latest/api/API_GetSamplingTargets.html">GetSamplingTargets</a> that X-Ray
        *       could not process.</p>
        */
    export interface UnprocessedStatistics {
            /**
                * <p>The name of the sampling rule.</p>
                */
            RuleName?: string;
            /**
                * <p>The error code.</p>
                */
            ErrorCode?: string;
            /**
                * <p>The error message.</p>
                */
            Message?: string;
    }
    export namespace UnprocessedStatistics {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UnprocessedStatistics) => any;
    }
    export interface GetSamplingTargetsResult {
            /**
                * <p>Updated rules that the service should use to sample requests.</p>
                */
            SamplingTargetDocuments?: SamplingTargetDocument[];
            /**
                * <p>The last time a user changed the sampling rule configuration. If
                *          the sampling rule configuration changed since the service last retrieved it, the service
                *          should call <a href="https://docs.aws.amazon.com/xray/latest/api/API_GetSamplingRules.html">GetSamplingRules</a> to get the latest version.</p>
                */
            LastRuleModification?: Date;
            /**
                * <p>Information about <a href="https://docs.aws.amazon.com/xray/latest/api/API_SamplingStatisticsDocument.html">SamplingStatisticsDocument</a> that X-Ray could not
                *          process.</p>
                */
            UnprocessedStatistics?: UnprocessedStatistics[];
    }
    export namespace GetSamplingTargetsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetSamplingTargetsResult) => any;
    }
    export interface GetServiceGraphRequest {
            /**
                * <p>The start of the time frame for which to generate a graph.</p>
                */
            StartTime: Date | undefined;
            /**
                * <p>The end of the timeframe for which to generate a graph.</p>
                */
            EndTime: Date | undefined;
            /**
                * <p>The name of a group based on which you want to generate a graph.</p>
                */
            GroupName?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of a group based on which you want to generate a graph.</p>
                */
            GroupARN?: string;
            /**
                * <p>Pagination token.</p>
                */
            NextToken?: string;
    }
    export namespace GetServiceGraphRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetServiceGraphRequest) => any;
    }
    /**
        * <p>An entry in a histogram for a statistic. A histogram maps the range of observed values
        *       on the X axis, and the prevalence of each value on the Y axis.</p>
        */
    export interface HistogramEntry {
            /**
                * <p>The value of the entry.</p>
                */
            Value?: number;
            /**
                * <p>The prevalence of the entry.</p>
                */
            Count?: number;
    }
    export namespace HistogramEntry {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: HistogramEntry) => any;
    }
    /**
        * <p>Information about requests that failed with a 4xx Client Error status code.</p>
        */
    export interface ErrorStatistics {
            /**
                * <p>The number of requests that failed with a 419 throttling status code.</p>
                */
            ThrottleCount?: number;
            /**
                * <p>The number of requests that failed with untracked 4xx Client Error status
                *       codes.</p>
                */
            OtherCount?: number;
            /**
                * <p>The total number of requests that failed with a 4xx Client Error status code.</p>
                */
            TotalCount?: number;
    }
    export namespace ErrorStatistics {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ErrorStatistics) => any;
    }
    /**
        * <p>Information about requests that failed with a 5xx Server Error status code.</p>
        */
    export interface FaultStatistics {
            /**
                * <p>The number of requests that failed with untracked 5xx Server Error status
                *       codes.</p>
                */
            OtherCount?: number;
            /**
                * <p>The total number of requests that failed with a 5xx Server Error status code.</p>
                */
            TotalCount?: number;
    }
    export namespace FaultStatistics {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FaultStatistics) => any;
    }
    /**
        * <p>Response statistics for an edge.</p>
        */
    export interface EdgeStatistics {
            /**
                * <p>The number of requests that completed with a 2xx Success status code.</p>
                */
            OkCount?: number;
            /**
                * <p>Information about requests that failed with a 4xx Client Error status code.</p>
                */
            ErrorStatistics?: ErrorStatistics;
            /**
                * <p>Information about requests that failed with a 5xx Server Error status code.</p>
                */
            FaultStatistics?: FaultStatistics;
            /**
                * <p>The total number of completed requests.</p>
                */
            TotalCount?: number;
            /**
                * <p>The aggregate response time of completed requests.</p>
                */
            TotalResponseTime?: number;
    }
    export namespace EdgeStatistics {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EdgeStatistics) => any;
    }
    /**
        * <p>Information about a connection between two services.</p>
        */
    export interface Edge {
            /**
                * <p>Identifier of the edge. Unique within a service map.</p>
                */
            ReferenceId?: number;
            /**
                * <p>The start time of the first segment on the edge.</p>
                */
            StartTime?: Date;
            /**
                * <p>The end time of the last segment on the edge.</p>
                */
            EndTime?: Date;
            /**
                * <p>Response statistics for segments on the edge.</p>
                */
            SummaryStatistics?: EdgeStatistics;
            /**
                * <p>A histogram that maps the spread of client response times on an edge.</p>
                */
            ResponseTimeHistogram?: HistogramEntry[];
            /**
                * <p>Aliases for the edge.</p>
                */
            Aliases?: Alias[];
    }
    export namespace Edge {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Edge) => any;
    }
    /**
        * <p>Response statistics for a service.</p>
        */
    export interface ServiceStatistics {
            /**
                * <p>The number of requests that completed with a 2xx Success status code.</p>
                */
            OkCount?: number;
            /**
                * <p>Information about requests that failed with a 4xx Client Error status code.</p>
                */
            ErrorStatistics?: ErrorStatistics;
            /**
                * <p>Information about requests that failed with a 5xx Server Error status code.</p>
                */
            FaultStatistics?: FaultStatistics;
            /**
                * <p>The total number of completed requests.</p>
                */
            TotalCount?: number;
            /**
                * <p>The aggregate response time of completed requests.</p>
                */
            TotalResponseTime?: number;
    }
    export namespace ServiceStatistics {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ServiceStatistics) => any;
    }
    /**
        * <p>Information about an application that processed requests, users that made requests, or downstream services,
        *       resources, and applications that an application used.</p>
        */
    export interface Service {
            /**
                * <p>Identifier for the service. Unique within the service map.</p>
                */
            ReferenceId?: number;
            /**
                * <p>The canonical name of the service.</p>
                */
            Name?: string;
            /**
                * <p>A list of names for the service, including the canonical name.</p>
                */
            Names?: string[];
            /**
                * <p>Indicates that the service was the first service to process a request.</p>
                */
            Root?: boolean;
            /**
                * <p>Identifier of the Amazon Web Services account in which the service runs.</p>
                */
            AccountId?: string;
            /**
                * <p>The type of service.</p>
                *          <ul>
                *             <li>
                *                <p>Amazon Web Services Resource - The type of an Amazon Web Services resource. For example, <code>AWS::EC2::Instance</code> for an
                *           application running on Amazon EC2 or <code>AWS::DynamoDB::Table</code> for an Amazon DynamoDB table that the
                *           application used.</p>
                *             </li>
                *             <li>
                *                <p>Amazon Web Services Service - The type of an Amazon Web Services service. For example, <code>AWS::DynamoDB</code>
                *           for downstream calls to Amazon DynamoDB that didn't target a specific table.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>client</code> - Represents the clients that sent requests to a root
                *           service.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>remote</code> - A downstream service of indeterminate type.</p>
                *             </li>
                *          </ul>
                */
            Type?: string;
            /**
                * <p>The service's state.</p>
                */
            State?: string;
            /**
                * <p>The start time of the first segment that the service generated.</p>
                */
            StartTime?: Date;
            /**
                * <p>The end time of the last segment that the service generated.</p>
                */
            EndTime?: Date;
            /**
                * <p>Connections to downstream services.</p>
                */
            Edges?: Edge[];
            /**
                * <p>Aggregated statistics for the service.</p>
                */
            SummaryStatistics?: ServiceStatistics;
            /**
                * <p>A histogram that maps the spread of service durations.</p>
                */
            DurationHistogram?: HistogramEntry[];
            /**
                * <p>A histogram that maps the spread of service response times.</p>
                */
            ResponseTimeHistogram?: HistogramEntry[];
    }
    export namespace Service {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Service) => any;
    }
    export interface GetServiceGraphResult {
            /**
                * <p>The start of the time frame for which the graph was generated.</p>
                */
            StartTime?: Date;
            /**
                * <p>The end of the time frame for which the graph was generated.</p>
                */
            EndTime?: Date;
            /**
                * <p>The services that have processed a traced request during the specified time
                *       frame.</p>
                */
            Services?: Service[];
            /**
                * <p>A flag indicating whether the group's filter expression has been consistent, or
                *       if the returned service graph may show traces from an older version of the group's filter
                *       expression.</p>
                */
            ContainsOldGroupVersions?: boolean;
            /**
                * <p>Pagination token.</p>
                */
            NextToken?: string;
    }
    export namespace GetServiceGraphResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetServiceGraphResult) => any;
    }
    export interface GetTimeSeriesServiceStatisticsRequest {
            /**
                * <p>The start of the time frame for which to aggregate statistics.</p>
                */
            StartTime: Date | undefined;
            /**
                * <p>The end of the time frame for which to aggregate statistics.</p>
                */
            EndTime: Date | undefined;
            /**
                * <p>The case-sensitive name of the group for which to pull statistics from.</p>
                */
            GroupName?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the group for which to pull statistics from.</p>
                */
            GroupARN?: string;
            /**
                * <p>A filter expression defining entities that will be aggregated for statistics.
                *             Supports ID, service, and edge functions. If no selector expression is specified, edge
                *             statistics are returned. </p>
                */
            EntitySelectorExpression?: string;
            /**
                * <p>Aggregation period in seconds.</p>
                */
            Period?: number;
            /**
                * <p>The forecasted high and low fault count values. Forecast enabled requests require the
                *             EntitySelectorExpression ID be provided.</p>
                */
            ForecastStatistics?: boolean;
            /**
                * <p>Pagination token.</p>
                */
            NextToken?: string;
    }
    export namespace GetTimeSeriesServiceStatisticsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetTimeSeriesServiceStatisticsRequest) => any;
    }
    /**
        * <p>The predicted high and low fault count. This is used to determine if a service has
        *          become anomalous and if an insight should be created.</p>
        */
    export interface ForecastStatistics {
            /**
                * <p>The upper limit of fault counts for a service.</p>
                */
            FaultCountHigh?: number;
            /**
                * <p>The lower limit of fault counts for a service.</p>
                */
            FaultCountLow?: number;
    }
    export namespace ForecastStatistics {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ForecastStatistics) => any;
    }
    /**
        * <p>A list of TimeSeriesStatistic structures.</p>
        */
    export interface TimeSeriesServiceStatistics {
            /**
                * <p>Timestamp of the window for which statistics are aggregated.</p>
                */
            Timestamp?: Date;
            /**
                * <p>Response statistics for an edge.</p>
                */
            EdgeSummaryStatistics?: EdgeStatistics;
            /**
                * <p>Response statistics for a service.</p>
                */
            ServiceSummaryStatistics?: ServiceStatistics;
            /**
                * <p>The forecasted high and low fault count values.</p>
                */
            ServiceForecastStatistics?: ForecastStatistics;
            /**
                * <p>The response time histogram for the selected entities.</p>
                */
            ResponseTimeHistogram?: HistogramEntry[];
    }
    export namespace TimeSeriesServiceStatistics {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TimeSeriesServiceStatistics) => any;
    }
    export interface GetTimeSeriesServiceStatisticsResult {
            /**
                * <p>The collection of statistics.</p>
                */
            TimeSeriesServiceStatistics?: TimeSeriesServiceStatistics[];
            /**
                * <p>A flag indicating whether or not a group's filter expression has been consistent, or if a returned
                *             aggregation might show statistics from an older version of the group's filter expression.</p>
                */
            ContainsOldGroupVersions?: boolean;
            /**
                * <p>Pagination token.</p>
                */
            NextToken?: string;
    }
    export namespace GetTimeSeriesServiceStatisticsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetTimeSeriesServiceStatisticsResult) => any;
    }
    export interface GetTraceGraphRequest {
            /**
                * <p>Trace IDs of requests for which to generate a service graph.</p>
                */
            TraceIds: string[] | undefined;
            /**
                * <p>Pagination token.</p>
                */
            NextToken?: string;
    }
    export namespace GetTraceGraphRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetTraceGraphRequest) => any;
    }
    export interface GetTraceGraphResult {
            /**
                * <p>The services that have processed one of the specified requests.</p>
                */
            Services?: Service[];
            /**
                * <p>Pagination token.</p>
                */
            NextToken?: string;
    }
    export namespace GetTraceGraphResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetTraceGraphResult) => any;
    }
    export enum SamplingStrategyName {
            FixedRate = "FixedRate",
            PartialScan = "PartialScan"
    }
    /**
        * <p>The name and value of a sampling rule to apply to a trace summary.</p>
        */
    export interface SamplingStrategy {
            /**
                * <p>The name of a sampling rule.</p>
                */
            Name?: SamplingStrategyName | string;
            /**
                * <p>The value of a sampling rule.</p>
                */
            Value?: number;
    }
    export namespace SamplingStrategy {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SamplingStrategy) => any;
    }
    export enum TimeRangeType {
            Event = "Event",
            TraceId = "TraceId"
    }
    export interface GetTraceSummariesRequest {
            /**
                * <p>The start of the time frame for which to retrieve traces.</p>
                */
            StartTime: Date | undefined;
            /**
                * <p>The end of the time frame for which to retrieve traces.</p>
                */
            EndTime: Date | undefined;
            /**
                * <p>A parameter to indicate whether to query trace summaries by TraceId or Event time.</p>
                */
            TimeRangeType?: TimeRangeType | string;
            /**
                * <p>Set to <code>true</code> to get summaries for only a subset of available
                *       traces.</p>
                */
            Sampling?: boolean;
            /**
                * <p>A parameter to indicate whether to enable sampling on trace summaries. Input parameters are Name and
                *             Value.</p>
                */
            SamplingStrategy?: SamplingStrategy;
            /**
                * <p>Specify a filter expression to retrieve trace summaries for services or requests that
                *       meet certain requirements.</p>
                */
            FilterExpression?: string;
            /**
                * <p>Specify the pagination token returned by a previous request to retrieve the next page
                *       of results.</p>
                */
            NextToken?: string;
    }
    export namespace GetTraceSummariesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetTraceSummariesRequest) => any;
    }
    /**
        * <p>The exception associated with a root cause.</p>
        */
    export interface RootCauseException {
            /**
                * <p>The name of the exception.</p>
                */
            Name?: string;
            /**
                * <p>The message of the exception.</p>
                */
            Message?: string;
    }
    export namespace RootCauseException {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RootCauseException) => any;
    }
    /**
        * <p>A collection of segments and corresponding subsegments associated to a trace summary
        *       error.</p>
        */
    export interface ErrorRootCauseEntity {
            /**
                * <p>The name of the entity.</p>
                */
            Name?: string;
            /**
                * <p>The types and messages of the exceptions.</p>
                */
            Exceptions?: RootCauseException[];
            /**
                * <p>A flag that denotes a remote subsegment.</p>
                */
            Remote?: boolean;
    }
    export namespace ErrorRootCauseEntity {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ErrorRootCauseEntity) => any;
    }
    /**
        * <p>A collection of fields identifying the services in a trace summary error.</p>
        */
    export interface ErrorRootCauseService {
            /**
                * <p>The service name.</p>
                */
            Name?: string;
            /**
                * <p>A collection of associated service names.</p>
                */
            Names?: string[];
            /**
                * <p>The type associated to the service.</p>
                */
            Type?: string;
            /**
                * <p>The account ID associated to the service.</p>
                */
            AccountId?: string;
            /**
                * <p>The path of root cause entities found on the service. </p>
                */
            EntityPath?: ErrorRootCauseEntity[];
            /**
                * <p>A Boolean value indicating if the service is inferred from the trace.</p>
                */
            Inferred?: boolean;
    }
    export namespace ErrorRootCauseService {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ErrorRootCauseService) => any;
    }
    /**
        * <p>The root cause of a trace summary error.</p>
        */
    export interface ErrorRootCause {
            /**
                * <p>A list of services corresponding to an error. A service identifies a segment and it
                *       contains a name, account ID, type, and inferred flag.</p>
                */
            Services?: ErrorRootCauseService[];
            /**
                * <p>A flag that denotes that the root cause impacts the trace client.</p>
                */
            ClientImpacting?: boolean;
    }
    export namespace ErrorRootCause {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ErrorRootCause) => any;
    }
    /**
        * <p>A collection of segments and corresponding subsegments associated to a trace summary
        *       fault error.</p>
        */
    export interface FaultRootCauseEntity {
            /**
                * <p>The name of the entity.</p>
                */
            Name?: string;
            /**
                * <p>The types and messages of the exceptions.</p>
                */
            Exceptions?: RootCauseException[];
            /**
                * <p>A flag that denotes a remote subsegment.</p>
                */
            Remote?: boolean;
    }
    export namespace FaultRootCauseEntity {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FaultRootCauseEntity) => any;
    }
    /**
        * <p>A collection of fields identifying the services in a trace summary fault.</p>
        */
    export interface FaultRootCauseService {
            /**
                * <p>The service name.</p>
                */
            Name?: string;
            /**
                * <p>A collection of associated service names.</p>
                */
            Names?: string[];
            /**
                * <p>The type associated to the service.</p>
                */
            Type?: string;
            /**
                * <p>The account ID associated to the service.</p>
                */
            AccountId?: string;
            /**
                * <p>The path of root cause entities found on the service. </p>
                */
            EntityPath?: FaultRootCauseEntity[];
            /**
                * <p>A Boolean value indicating if the service is inferred from the trace.</p>
                */
            Inferred?: boolean;
    }
    export namespace FaultRootCauseService {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FaultRootCauseService) => any;
    }
    /**
        * <p>The root cause information for a trace summary fault.</p>
        */
    export interface FaultRootCause {
            /**
                * <p>A list of corresponding services. A service identifies a segment and it contains a
                *       name, account ID, type, and inferred flag.</p>
                */
            Services?: FaultRootCauseService[];
            /**
                * <p>A flag that denotes that the root cause impacts the trace client.</p>
                */
            ClientImpacting?: boolean;
    }
    export namespace FaultRootCause {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FaultRootCause) => any;
    }
    /**
        * <p>Information about an HTTP request.</p>
        */
    export interface Http {
            /**
                * <p>The request URL.</p>
                */
            HttpURL?: string;
            /**
                * <p>The response status.</p>
                */
            HttpStatus?: number;
            /**
                * <p>The request method.</p>
                */
            HttpMethod?: string;
            /**
                * <p>The request's user agent string.</p>
                */
            UserAgent?: string;
            /**
                * <p>The IP address of the requestor.</p>
                */
            ClientIp?: string;
    }
    export namespace Http {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Http) => any;
    }
    /**
        * <p>A list of EC2 instance IDs corresponding to the segments in a trace. </p>
        */
    export interface InstanceIdDetail {
            /**
                * <p>The ID of a corresponding EC2 instance.</p>
                */
            Id?: string;
    }
    export namespace InstanceIdDetail {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InstanceIdDetail) => any;
    }
    /**
        * <p>A list of resources ARNs corresponding to the segments in a trace.</p>
        */
    export interface ResourceARNDetail {
            /**
                * <p>The ARN of a corresponding resource.</p>
                */
            ARN?: string;
    }
    export namespace ResourceARNDetail {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResourceARNDetail) => any;
    }
    /**
        * <p>A collection of segments and corresponding subsegments associated to a response time
        *       warning.</p>
        */
    export interface ResponseTimeRootCauseEntity {
            /**
                * <p>The name of the entity.</p>
                */
            Name?: string;
            /**
                * <p>The type and messages of the exceptions.</p>
                */
            Coverage?: number;
            /**
                * <p>A flag that denotes a remote subsegment.</p>
                */
            Remote?: boolean;
    }
    export namespace ResponseTimeRootCauseEntity {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseTimeRootCauseEntity) => any;
    }
    /**
        * <p>A collection of fields identifying the service in a response time warning.</p>
        */
    export interface ResponseTimeRootCauseService {
            /**
                * <p>The service name.</p>
                */
            Name?: string;
            /**
                * <p>A collection of associated service names.</p>
                */
            Names?: string[];
            /**
                * <p>The type associated to the service.</p>
                */
            Type?: string;
            /**
                * <p>The account ID associated to the service.</p>
                */
            AccountId?: string;
            /**
                * <p>The path of root cause entities found on the service. </p>
                */
            EntityPath?: ResponseTimeRootCauseEntity[];
            /**
                * <p>A Boolean value indicating if the service is inferred from the trace.</p>
                */
            Inferred?: boolean;
    }
    export namespace ResponseTimeRootCauseService {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseTimeRootCauseService) => any;
    }
    /**
        * <p>The root cause information for a response time warning.</p>
        */
    export interface ResponseTimeRootCause {
            /**
                * <p>A list of corresponding services. A service identifies a segment and contains a name,
                *       account ID, type, and inferred flag.</p>
                */
            Services?: ResponseTimeRootCauseService[];
            /**
                * <p>A flag that denotes that the root cause impacts the trace client.</p>
                */
            ClientImpacting?: boolean;
    }
    export namespace ResponseTimeRootCause {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResponseTimeRootCause) => any;
    }
    /**
        * <p>Information about a user recorded in segment documents.</p>
        */
    export interface TraceUser {
            /**
                * <p>The user's name.</p>
                */
            UserName?: string;
            /**
                * <p>Services that the user's request hit.</p>
                */
            ServiceIds?: ServiceId[];
    }
    export namespace TraceUser {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TraceUser) => any;
    }
    /**
        * <p>Metadata generated from the segment documents in a trace.</p>
        */
    export interface TraceSummary {
            /**
                * <p>The unique identifier for the request that generated the trace's segments and
                *       subsegments.</p>
                */
            Id?: string;
            /**
                * <p>The length of time in seconds between the start time of the root segment and the end
                *       time of the last segment that completed.</p>
                */
            Duration?: number;
            /**
                * <p>The length of time in seconds between the start and end times of the root segment. If
                *       the service performs work asynchronously, the response time measures the time before the
                *       response is sent to the user, while the duration measures the amount of time before the last
                *       traced activity completes.</p>
                */
            ResponseTime?: number;
            /**
                * <p>The root segment document has a 500 series error.</p>
                */
            HasFault?: boolean;
            /**
                * <p>The root segment document has a 400 series error.</p>
                */
            HasError?: boolean;
            /**
                * <p>One or more of the segment documents has a 429 throttling error.</p>
                */
            HasThrottle?: boolean;
            /**
                * <p>One or more of the segment documents is in progress.</p>
                */
            IsPartial?: boolean;
            /**
                * <p>Information about the HTTP request served by the trace.</p>
                */
            Http?: Http;
            /**
                * <p>Annotations from the trace's segment documents.</p>
                */
            Annotations?: Record<string, ValueWithServiceIds[]>;
            /**
                * <p>Users from the trace's segment documents.</p>
                */
            Users?: TraceUser[];
            /**
                * <p>Service IDs from the trace's segment documents.</p>
                */
            ServiceIds?: ServiceId[];
            /**
                * <p>A list of resource ARNs for any resource corresponding to the trace segments.</p>
                */
            ResourceARNs?: ResourceARNDetail[];
            /**
                * <p>A list of EC2 instance IDs for any instance corresponding to the trace
                *       segments.</p>
                */
            InstanceIds?: InstanceIdDetail[];
            /**
                * <p>A list of Availability Zones for any zone corresponding to the trace segments.</p>
                */
            AvailabilityZones?: AvailabilityZoneDetail[];
            /**
                * <p>The root of a trace.</p>
                */
            EntryPoint?: ServiceId;
            /**
                * <p>A collection of FaultRootCause structures corresponding to the trace segments.</p>
                */
            FaultRootCauses?: FaultRootCause[];
            /**
                * <p>A collection of ErrorRootCause structures corresponding to the trace
                *       segments.</p>
                */
            ErrorRootCauses?: ErrorRootCause[];
            /**
                * <p>A collection of ResponseTimeRootCause structures corresponding to the trace
                *       segments.</p>
                */
            ResponseTimeRootCauses?: ResponseTimeRootCause[];
            /**
                * <p>The revision number of a trace.</p>
                */
            Revision?: number;
            /**
                * <p>The matched time stamp of a defined event.</p>
                */
            MatchedEventTime?: Date;
    }
    export namespace TraceSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TraceSummary) => any;
    }
    export interface GetTraceSummariesResult {
            /**
                * <p>Trace IDs and annotations for traces that were found in the specified time
                *       frame.</p>
                */
            TraceSummaries?: TraceSummary[];
            /**
                * <p>The start time of this page of results.</p>
                */
            ApproximateTime?: Date;
            /**
                * <p>The total number of traces processed, including traces that did not match the specified
                *       filter expression.</p>
                */
            TracesProcessedCount?: number;
            /**
                * <p>If the requested time frame contained more than one page of results, you can use this token to retrieve the
                *       next page. The first page contains the most recent results, closest to the end of the time frame.</p>
                */
            NextToken?: string;
    }
    export namespace GetTraceSummariesResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetTraceSummariesResult) => any;
    }
    export interface ListTagsForResourceRequest {
            /**
                * <p>The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.</p>
                */
            ResourceARN: string | undefined;
            /**
                * <p>A pagination token. If multiple pages of results are returned, use the <code>NextToken</code> value returned with
                *     the current page of results as the value of this parameter to get the next page of results.</p>
                */
            NextToken?: string;
    }
    export namespace ListTagsForResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceRequest) => any;
    }
    export interface ListTagsForResourceResponse {
            /**
                * <p>A list of tags, as key and value pairs, that is associated with the specified X-Ray group or sampling rule.</p>
                */
            Tags?: Tag[];
            /**
                * <p>A pagination token. If multiple pages of results are returned, use the <code>NextToken</code> value returned with
                *       the current page of results to get the next page of results.</p>
                */
            NextToken?: string;
    }
    export namespace ListTagsForResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceResponse) => any;
    }
    /**
        * <p>The resource was not found. Verify that the name or Amazon Resource Name (ARN) of the resource is
        *       correct.</p>
        */
    export class ResourceNotFoundException extends __BaseException {
            readonly name: "ResourceNotFoundException";
            readonly $fault: "client";
            Message?: string;
            ResourceName?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>);
    }
    export interface PutEncryptionConfigRequest {
            /**
                * <p>An Amazon Web Services KMS key in one of the following formats:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <b>Alias</b> - The name of the key. For example,
                *             <code>alias/MyKey</code>.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>Key ID</b> - The KMS key ID of the key. For example,
                *           <code>ae4aa6d49-a4d8-9df9-a475-4ff6d7898456</code>. Amazon Web Services X-Ray does not support asymmetric KMS keys.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>ARN</b> - The full Amazon Resource Name of the key ID or alias.
                *           For example,
                *             <code>arn:aws:kms:us-east-2:123456789012:key/ae4aa6d49-a4d8-9df9-a475-4ff6d7898456</code>.
                *           Use this format to specify a key in a different account.</p>
                *             </li>
                *          </ul>
                *          <p>Omit this key if you set <code>Type</code> to <code>NONE</code>.</p>
                */
            KeyId?: string;
            /**
                * <p>The type of encryption. Set to <code>KMS</code> to use your own key for encryption. Set
                *       to <code>NONE</code> for default encryption.</p>
                */
            Type: EncryptionType | string | undefined;
    }
    export namespace PutEncryptionConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutEncryptionConfigRequest) => any;
    }
    export interface PutEncryptionConfigResult {
            /**
                * <p>The new encryption configuration.</p>
                */
            EncryptionConfig?: EncryptionConfig;
    }
    export namespace PutEncryptionConfigResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutEncryptionConfigResult) => any;
    }
    /**
        * <p></p>
        */
    export interface BackendConnectionErrors {
            /**
                * <p></p>
                */
            TimeoutCount?: number;
            /**
                * <p></p>
                */
            ConnectionRefusedCount?: number;
            /**
                * <p></p>
                */
            HTTPCode4XXCount?: number;
            /**
                * <p></p>
                */
            HTTPCode5XXCount?: number;
            /**
                * <p></p>
                */
            UnknownHostCount?: number;
            /**
                * <p></p>
                */
            OtherCount?: number;
    }
    export namespace BackendConnectionErrors {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BackendConnectionErrors) => any;
    }
    /**
        * <p></p>
        */
    export interface TelemetryRecord {
            /**
                * <p></p>
                */
            Timestamp: Date | undefined;
            /**
                * <p></p>
                */
            SegmentsReceivedCount?: number;
            /**
                * <p></p>
                */
            SegmentsSentCount?: number;
            /**
                * <p></p>
                */
            SegmentsSpilloverCount?: number;
            /**
                * <p></p>
                */
            SegmentsRejectedCount?: number;
            /**
                * <p></p>
                */
            BackendConnectionErrors?: BackendConnectionErrors;
    }
    export namespace TelemetryRecord {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TelemetryRecord) => any;
    }
    export interface PutTelemetryRecordsRequest {
            /**
                * <p></p>
                */
            TelemetryRecords: TelemetryRecord[] | undefined;
            /**
                * <p></p>
                */
            EC2InstanceId?: string;
            /**
                * <p></p>
                */
            Hostname?: string;
            /**
                * <p></p>
                */
            ResourceARN?: string;
    }
    export namespace PutTelemetryRecordsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutTelemetryRecordsRequest) => any;
    }
    export interface PutTelemetryRecordsResult {
    }
    export namespace PutTelemetryRecordsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutTelemetryRecordsResult) => any;
    }
    export interface PutTraceSegmentsRequest {
            /**
                * <p>A string containing a JSON document defining one or more segments or
                *       subsegments.</p>
                */
            TraceSegmentDocuments: string[] | undefined;
    }
    export namespace PutTraceSegmentsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutTraceSegmentsRequest) => any;
    }
    /**
        * <p>Information about a segment that failed processing.</p>
        */
    export interface UnprocessedTraceSegment {
            /**
                * <p>The segment's ID.</p>
                */
            Id?: string;
            /**
                * <p>The error that caused processing to fail.</p>
                */
            ErrorCode?: string;
            /**
                * <p>The error message.</p>
                */
            Message?: string;
    }
    export namespace UnprocessedTraceSegment {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UnprocessedTraceSegment) => any;
    }
    export interface PutTraceSegmentsResult {
            /**
                * <p>Segments that failed processing.</p>
                */
            UnprocessedTraceSegments?: UnprocessedTraceSegment[];
    }
    export namespace PutTraceSegmentsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutTraceSegmentsResult) => any;
    }
    export interface TagResourceRequest {
            /**
                * <p>The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.</p>
                */
            ResourceARN: string | undefined;
            /**
                * <p>A map that contains one or more tag keys and tag values to attach to an X-Ray group or
                *       sampling rule. For more information about ways to use tags, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a>
                *       in the <i>Amazon Web Services General Reference</i>.</p>
                *          <p>The following restrictions apply to tags:</p>
                *          <ul>
                *             <li>
                *                <p>Maximum number of user-applied tags per resource: 50</p>
                *             </li>
                *             <li>
                *                <p>Maximum tag key length: 128 Unicode characters</p>
                *             </li>
                *             <li>
                *                <p>Maximum tag value length: 256 Unicode characters</p>
                *             </li>
                *             <li>
                *                <p>Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . :
                *           / = + - and @</p>
                *             </li>
                *             <li>
                *                <p>Tag keys and values are case sensitive.</p>
                *             </li>
                *             <li>
                *                <p>Don't use <code>aws:</code> as a prefix for keys; it's reserved for Amazon Web Services use. You
                *           cannot edit or delete system tags.</p>
                *             </li>
                *          </ul>
                */
            Tags: Tag[] | undefined;
    }
    export namespace TagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceRequest) => any;
    }
    export interface TagResourceResponse {
    }
    export namespace TagResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceResponse) => any;
    }
    /**
        * <p>You have exceeded the maximum number of tags you can apply to this resource.</p>
        */
    export class TooManyTagsException extends __BaseException {
            readonly name: "TooManyTagsException";
            readonly $fault: "client";
            Message?: string;
            ResourceName?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyTagsException, __BaseException>);
    }
    export interface UntagResourceRequest {
            /**
                * <p>The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.</p>
                */
            ResourceARN: string | undefined;
            /**
                * <p>Keys for one or more tags that you want to remove from an X-Ray group or sampling rule.</p>
                */
            TagKeys: string[] | undefined;
    }
    export namespace UntagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceRequest) => any;
    }
    export interface UntagResourceResponse {
    }
    export namespace UntagResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceResponse) => any;
    }
    export interface UpdateGroupRequest {
            /**
                * <p>The case-sensitive name of the group.</p>
                */
            GroupName?: string;
            /**
                * <p>The ARN that was generated upon creation.</p>
                */
            GroupARN?: string;
            /**
                * <p>The updated filter expression defining criteria by which to group traces.</p>
                */
            FilterExpression?: string;
            /**
                * <p>The structure containing configurations related to insights.</p>
                *         <ul>
                *             <li>
                *                 <p>The InsightsEnabled boolean can be set to true to enable insights for the
                *                     group or false to disable insights for the group.</p>
                *             </li>
                *             <li>
                *                 <p>The NotifcationsEnabled boolean can be set to true to enable insights notifications for the group.
                *                     Notifications can only be enabled on a group with InsightsEnabled set to true.</p>
                *             </li>
                *          </ul>
                */
            InsightsConfiguration?: InsightsConfiguration;
    }
    export namespace UpdateGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateGroupRequest) => any;
    }
    export interface UpdateGroupResult {
            /**
                * <p>The group that was updated. Contains the name of the group that was updated, the
                *             ARN of the group that was updated, the updated filter expression, and the updated insight
                *             configuration assigned to the group.</p>
                */
            Group?: Group;
    }
    export namespace UpdateGroupResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateGroupResult) => any;
    }
    /**
        * <p>A document specifying changes to a sampling rule's configuration.</p>
        */
    export interface SamplingRuleUpdate {
            /**
                * <p>The name of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
                */
            RuleName?: string;
            /**
                * <p>The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
                */
            RuleARN?: string;
            /**
                * <p>Matches the ARN of the Amazon Web Services resource on which the service runs.</p>
                */
            ResourceARN?: string;
            /**
                * <p>The priority of the sampling rule.</p>
                */
            Priority?: number;
            /**
                * <p>The percentage of matching requests to instrument, after the reservoir is
                *       exhausted.</p>
                */
            FixedRate?: number;
            /**
                * <p>A fixed number of matching requests to instrument per second, prior to applying the
                *       fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.</p>
                */
            ReservoirSize?: number;
            /**
                * <p>Matches the hostname from a request URL.</p>
                */
            Host?: string;
            /**
                * <p>Matches the <code>name</code> that the service uses to identify itself in segments.</p>
                */
            ServiceName?: string;
            /**
                * <p>Matches the <code>origin</code> that the service uses to identify its type in segments.</p>
                */
            ServiceType?: string;
            /**
                * <p>Matches the HTTP method of a request.</p>
                */
            HTTPMethod?: string;
            /**
                * <p>Matches the path from a request URL.</p>
                */
            URLPath?: string;
            /**
                * <p>Matches attributes derived from the request.</p>
                */
            Attributes?: Record<string, string>;
    }
    export namespace SamplingRuleUpdate {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SamplingRuleUpdate) => any;
    }
    export interface UpdateSamplingRuleRequest {
            /**
                * <p>The rule and fields to change.</p>
                */
            SamplingRuleUpdate: SamplingRuleUpdate | undefined;
    }
    export namespace UpdateSamplingRuleRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateSamplingRuleRequest) => any;
    }
    export interface UpdateSamplingRuleResult {
            /**
                * <p>The updated rule definition and metadata.</p>
                */
            SamplingRuleRecord?: SamplingRuleRecord;
    }
    export namespace UpdateSamplingRuleResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateSamplingRuleResult) => any;
    }
}

declare module '@aws-sdk/client-xray/node_modules/@aws-sdk/client-xray/dist-types/models/XRayServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from XRay service.
        */
    export class XRayServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

