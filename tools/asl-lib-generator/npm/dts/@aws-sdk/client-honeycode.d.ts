// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/smithy-client
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http

declare module '@aws-sdk/client-honeycode' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { BatchCreateTableRowsCommandInput, BatchCreateTableRowsCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/BatchCreateTableRowsCommand";
    import { BatchDeleteTableRowsCommandInput, BatchDeleteTableRowsCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/BatchDeleteTableRowsCommand";
    import { BatchUpdateTableRowsCommandInput, BatchUpdateTableRowsCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/BatchUpdateTableRowsCommand";
    import { BatchUpsertTableRowsCommandInput, BatchUpsertTableRowsCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/BatchUpsertTableRowsCommand";
    import { DescribeTableDataImportJobCommandInput, DescribeTableDataImportJobCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/DescribeTableDataImportJobCommand";
    import { GetScreenDataCommandInput, GetScreenDataCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/GetScreenDataCommand";
    import { InvokeScreenAutomationCommandInput, InvokeScreenAutomationCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/InvokeScreenAutomationCommand";
    import { ListTableColumnsCommandInput, ListTableColumnsCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/ListTableColumnsCommand";
    import { ListTableRowsCommandInput, ListTableRowsCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/ListTableRowsCommand";
    import { ListTablesCommandInput, ListTablesCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/ListTablesCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/ListTagsForResourceCommand";
    import { QueryTableRowsCommandInput, QueryTableRowsCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/QueryTableRowsCommand";
    import { StartTableDataImportJobCommandInput, StartTableDataImportJobCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/StartTableDataImportJobCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/UntagResourceCommand";
    import { HoneycodeClient } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/HoneycodeClient";
    /**
        * <p>
        *       Amazon Honeycode is a fully managed service that allows you to quickly build mobile and web apps for teamsâ€”without
        *       programming. Build Honeycode apps for managing almost anything, like projects, customers, operations, approvals,
        *       resources, and even your team.
        *     </p>
        */
    export class Honeycode extends HoneycodeClient {
            /**
                * <p>
                *             The BatchCreateTableRows API allows you to create one or more rows at the end of a table in a workbook.
                *             The API allows you to specify the values to set in some or all of the columns in the new rows.
                *         </p>
                *         <p>
                *             If a column is not explicitly set in a specific row, then the column level formula specified in the table
                *             will be applied to the new row. If there is no column level formula but the last row of the table has a
                *             formula, then that formula will be copied down to the new row. If there is no column level formula and
                *             no formula in the last row of the table, then that column will be left blank for the new rows.
                *         </p>
                */
            batchCreateTableRows(args: BatchCreateTableRowsCommandInput, options?: __HttpHandlerOptions): Promise<BatchCreateTableRowsCommandOutput>;
            batchCreateTableRows(args: BatchCreateTableRowsCommandInput, cb: (err: any, data?: BatchCreateTableRowsCommandOutput) => void): void;
            batchCreateTableRows(args: BatchCreateTableRowsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchCreateTableRowsCommandOutput) => void): void;
            /**
                * <p>
                *             The BatchDeleteTableRows API allows you to delete one or more rows from a table in a workbook.
                *             You need to specify the ids of the rows that you want to delete from the table.
                *         </p>
                */
            batchDeleteTableRows(args: BatchDeleteTableRowsCommandInput, options?: __HttpHandlerOptions): Promise<BatchDeleteTableRowsCommandOutput>;
            batchDeleteTableRows(args: BatchDeleteTableRowsCommandInput, cb: (err: any, data?: BatchDeleteTableRowsCommandOutput) => void): void;
            batchDeleteTableRows(args: BatchDeleteTableRowsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchDeleteTableRowsCommandOutput) => void): void;
            /**
                * <p>
                *             The BatchUpdateTableRows API allows you to update one or more rows in a table in a workbook.
                *         </p>
                *         <p>
                *             You can specify the values to set in some or all of the columns in the table for the specified
                *             rows.
                *             If a column is not explicitly specified in a particular row, then that column will not be updated
                *             for that row. To clear out the data in a specific cell, you need to set the value as an empty string
                *             ("").
                *         </p>
                */
            batchUpdateTableRows(args: BatchUpdateTableRowsCommandInput, options?: __HttpHandlerOptions): Promise<BatchUpdateTableRowsCommandOutput>;
            batchUpdateTableRows(args: BatchUpdateTableRowsCommandInput, cb: (err: any, data?: BatchUpdateTableRowsCommandOutput) => void): void;
            batchUpdateTableRows(args: BatchUpdateTableRowsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchUpdateTableRowsCommandOutput) => void): void;
            /**
                * <p>
                *             The BatchUpsertTableRows API allows you to upsert one or more rows in a table. The upsert
                *             operation takes a filter expression as input and evaluates it to find matching rows on the destination
                *             table. If matching rows are found, it will update the cells in the matching rows to new values specified
                *             in the request. If no matching rows are found, a new row is added at the end of the table and the cells in
                *             that row are set to the new values specified in the request.
                *         </p>
                *         <p>
                *             You can specify the values to set in some or all of the columns in the table for the
                *             matching or newly appended rows. If a column is not explicitly specified for a particular row, then that
                *             column will not be updated for that row. To clear out the data in a specific cell, you need to set the value
                *             as an empty string ("").
                *         </p>
                */
            batchUpsertTableRows(args: BatchUpsertTableRowsCommandInput, options?: __HttpHandlerOptions): Promise<BatchUpsertTableRowsCommandOutput>;
            batchUpsertTableRows(args: BatchUpsertTableRowsCommandInput, cb: (err: any, data?: BatchUpsertTableRowsCommandOutput) => void): void;
            batchUpsertTableRows(args: BatchUpsertTableRowsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchUpsertTableRowsCommandOutput) => void): void;
            /**
                * <p>
                *             The DescribeTableDataImportJob API allows you to retrieve the status and details of a table data import job.
                *         </p>
                */
            describeTableDataImportJob(args: DescribeTableDataImportJobCommandInput, options?: __HttpHandlerOptions): Promise<DescribeTableDataImportJobCommandOutput>;
            describeTableDataImportJob(args: DescribeTableDataImportJobCommandInput, cb: (err: any, data?: DescribeTableDataImportJobCommandOutput) => void): void;
            describeTableDataImportJob(args: DescribeTableDataImportJobCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeTableDataImportJobCommandOutput) => void): void;
            /**
                * <p>
                *             The GetScreenData API allows retrieval of data from a screen in a Honeycode app.
                *             The API allows setting local variables in the screen to filter, sort or otherwise affect what will be
                *             displayed on the screen.
                *         </p>
                */
            getScreenData(args: GetScreenDataCommandInput, options?: __HttpHandlerOptions): Promise<GetScreenDataCommandOutput>;
            getScreenData(args: GetScreenDataCommandInput, cb: (err: any, data?: GetScreenDataCommandOutput) => void): void;
            getScreenData(args: GetScreenDataCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetScreenDataCommandOutput) => void): void;
            /**
                * <p>
                *             The InvokeScreenAutomation API allows invoking an action defined in a screen in a Honeycode app.
                *             The API allows setting local variables, which can then be used in the automation being invoked.
                *             This allows automating the Honeycode app interactions to write, update or delete data in the workbook.
                *         </p>
                */
            invokeScreenAutomation(args: InvokeScreenAutomationCommandInput, options?: __HttpHandlerOptions): Promise<InvokeScreenAutomationCommandOutput>;
            invokeScreenAutomation(args: InvokeScreenAutomationCommandInput, cb: (err: any, data?: InvokeScreenAutomationCommandOutput) => void): void;
            invokeScreenAutomation(args: InvokeScreenAutomationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: InvokeScreenAutomationCommandOutput) => void): void;
            /**
                * <p>
                *             The ListTableColumns API allows you to retrieve a list of all the columns in a table in a workbook.
                *         </p>
                */
            listTableColumns(args: ListTableColumnsCommandInput, options?: __HttpHandlerOptions): Promise<ListTableColumnsCommandOutput>;
            listTableColumns(args: ListTableColumnsCommandInput, cb: (err: any, data?: ListTableColumnsCommandOutput) => void): void;
            listTableColumns(args: ListTableColumnsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTableColumnsCommandOutput) => void): void;
            /**
                * <p>
                *             The ListTableRows API allows you to retrieve a list of all the rows in a table in a workbook.
                *         </p>
                */
            listTableRows(args: ListTableRowsCommandInput, options?: __HttpHandlerOptions): Promise<ListTableRowsCommandOutput>;
            listTableRows(args: ListTableRowsCommandInput, cb: (err: any, data?: ListTableRowsCommandOutput) => void): void;
            listTableRows(args: ListTableRowsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTableRowsCommandOutput) => void): void;
            /**
                * <p>
                *             The ListTables API allows you to retrieve a list of all the tables in a workbook.
                *         </p>
                */
            listTables(args: ListTablesCommandInput, options?: __HttpHandlerOptions): Promise<ListTablesCommandOutput>;
            listTables(args: ListTablesCommandInput, cb: (err: any, data?: ListTablesCommandOutput) => void): void;
            listTables(args: ListTablesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTablesCommandOutput) => void): void;
            /**
                * <p>
                *             The ListTagsForResource API allows you to return a resource's tags.
                *         </p>
                */
            listTagsForResource(args: ListTagsForResourceCommandInput, options?: __HttpHandlerOptions): Promise<ListTagsForResourceCommandOutput>;
            listTagsForResource(args: ListTagsForResourceCommandInput, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            listTagsForResource(args: ListTagsForResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            /**
                * <p>
                *             The QueryTableRows API allows you to use a filter formula to query for specific rows in a table.
                *         </p>
                */
            queryTableRows(args: QueryTableRowsCommandInput, options?: __HttpHandlerOptions): Promise<QueryTableRowsCommandOutput>;
            queryTableRows(args: QueryTableRowsCommandInput, cb: (err: any, data?: QueryTableRowsCommandOutput) => void): void;
            queryTableRows(args: QueryTableRowsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: QueryTableRowsCommandOutput) => void): void;
            /**
                * <p>
                *             The StartTableDataImportJob API allows you to start an import job on a table. This API will only return
                *             the id of the job that was started. To find out the status of the import request, you need to call the
                *             DescribeTableDataImportJob API.
                *         </p>
                */
            startTableDataImportJob(args: StartTableDataImportJobCommandInput, options?: __HttpHandlerOptions): Promise<StartTableDataImportJobCommandOutput>;
            startTableDataImportJob(args: StartTableDataImportJobCommandInput, cb: (err: any, data?: StartTableDataImportJobCommandOutput) => void): void;
            startTableDataImportJob(args: StartTableDataImportJobCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: StartTableDataImportJobCommandOutput) => void): void;
            /**
                * <p>
                *             The TagResource API allows you to add tags to an ARN-able resource. Resource includes workbook, table,
                *             screen and screen-automation.
                *         </p>
                */
            tagResource(args: TagResourceCommandInput, options?: __HttpHandlerOptions): Promise<TagResourceCommandOutput>;
            tagResource(args: TagResourceCommandInput, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            tagResource(args: TagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            /**
                * <p>
                *             The UntagResource API allows you to removes tags from an ARN-able resource. Resource includes workbook, table,
                *             screen and screen-automation.
                *         </p>
                */
            untagResource(args: UntagResourceCommandInput, options?: __HttpHandlerOptions): Promise<UntagResourceCommandOutput>;
            untagResource(args: UntagResourceCommandInput, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            untagResource(args: UntagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/BatchCreateTableRowsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { HoneycodeClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/HoneycodeClient";
    import { BatchCreateTableRowsRequest, BatchCreateTableRowsResult } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/models/models_0";
    export interface BatchCreateTableRowsCommandInput extends BatchCreateTableRowsRequest {
    }
    export interface BatchCreateTableRowsCommandOutput extends BatchCreateTableRowsResult, __MetadataBearer {
    }
    /**
        * <p>
        *             The BatchCreateTableRows API allows you to create one or more rows at the end of a table in a workbook.
        *             The API allows you to specify the values to set in some or all of the columns in the new rows.
        *         </p>
        *         <p>
        *             If a column is not explicitly set in a specific row, then the column level formula specified in the table
        *             will be applied to the new row. If there is no column level formula but the last row of the table has a
        *             formula, then that formula will be copied down to the new row. If there is no column level formula and
        *             no formula in the last row of the table, then that column will be left blank for the new rows.
        *         </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { HoneycodeClient, BatchCreateTableRowsCommand } from "@aws-sdk/client-honeycode"; // ES Modules import
        * // const { HoneycodeClient, BatchCreateTableRowsCommand } = require("@aws-sdk/client-honeycode"); // CommonJS import
        * const client = new HoneycodeClient(config);
        * const command = new BatchCreateTableRowsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchCreateTableRowsCommandInput} for command's `input` shape.
        * @see {@link BatchCreateTableRowsCommandOutput} for command's `response` shape.
        * @see {@link HoneycodeClientResolvedConfig | config} for HoneycodeClient's `config` shape.
        *
        */
    export class BatchCreateTableRowsCommand extends $Command<BatchCreateTableRowsCommandInput, BatchCreateTableRowsCommandOutput, HoneycodeClientResolvedConfig> {
            readonly input: BatchCreateTableRowsCommandInput;
            constructor(input: BatchCreateTableRowsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: HoneycodeClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchCreateTableRowsCommandInput, BatchCreateTableRowsCommandOutput>;
    }
}

declare module '@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/BatchDeleteTableRowsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { HoneycodeClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/HoneycodeClient";
    import { BatchDeleteTableRowsRequest, BatchDeleteTableRowsResult } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/models/models_0";
    export interface BatchDeleteTableRowsCommandInput extends BatchDeleteTableRowsRequest {
    }
    export interface BatchDeleteTableRowsCommandOutput extends BatchDeleteTableRowsResult, __MetadataBearer {
    }
    /**
        * <p>
        *             The BatchDeleteTableRows API allows you to delete one or more rows from a table in a workbook.
        *             You need to specify the ids of the rows that you want to delete from the table.
        *         </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { HoneycodeClient, BatchDeleteTableRowsCommand } from "@aws-sdk/client-honeycode"; // ES Modules import
        * // const { HoneycodeClient, BatchDeleteTableRowsCommand } = require("@aws-sdk/client-honeycode"); // CommonJS import
        * const client = new HoneycodeClient(config);
        * const command = new BatchDeleteTableRowsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchDeleteTableRowsCommandInput} for command's `input` shape.
        * @see {@link BatchDeleteTableRowsCommandOutput} for command's `response` shape.
        * @see {@link HoneycodeClientResolvedConfig | config} for HoneycodeClient's `config` shape.
        *
        */
    export class BatchDeleteTableRowsCommand extends $Command<BatchDeleteTableRowsCommandInput, BatchDeleteTableRowsCommandOutput, HoneycodeClientResolvedConfig> {
            readonly input: BatchDeleteTableRowsCommandInput;
            constructor(input: BatchDeleteTableRowsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: HoneycodeClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchDeleteTableRowsCommandInput, BatchDeleteTableRowsCommandOutput>;
    }
}

declare module '@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/BatchUpdateTableRowsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { HoneycodeClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/HoneycodeClient";
    import { BatchUpdateTableRowsRequest, BatchUpdateTableRowsResult } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/models/models_0";
    export interface BatchUpdateTableRowsCommandInput extends BatchUpdateTableRowsRequest {
    }
    export interface BatchUpdateTableRowsCommandOutput extends BatchUpdateTableRowsResult, __MetadataBearer {
    }
    /**
        * <p>
        *             The BatchUpdateTableRows API allows you to update one or more rows in a table in a workbook.
        *         </p>
        *         <p>
        *             You can specify the values to set in some or all of the columns in the table for the specified
        *             rows.
        *             If a column is not explicitly specified in a particular row, then that column will not be updated
        *             for that row. To clear out the data in a specific cell, you need to set the value as an empty string
        *             ("").
        *         </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { HoneycodeClient, BatchUpdateTableRowsCommand } from "@aws-sdk/client-honeycode"; // ES Modules import
        * // const { HoneycodeClient, BatchUpdateTableRowsCommand } = require("@aws-sdk/client-honeycode"); // CommonJS import
        * const client = new HoneycodeClient(config);
        * const command = new BatchUpdateTableRowsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchUpdateTableRowsCommandInput} for command's `input` shape.
        * @see {@link BatchUpdateTableRowsCommandOutput} for command's `response` shape.
        * @see {@link HoneycodeClientResolvedConfig | config} for HoneycodeClient's `config` shape.
        *
        */
    export class BatchUpdateTableRowsCommand extends $Command<BatchUpdateTableRowsCommandInput, BatchUpdateTableRowsCommandOutput, HoneycodeClientResolvedConfig> {
            readonly input: BatchUpdateTableRowsCommandInput;
            constructor(input: BatchUpdateTableRowsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: HoneycodeClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchUpdateTableRowsCommandInput, BatchUpdateTableRowsCommandOutput>;
    }
}

declare module '@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/BatchUpsertTableRowsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { HoneycodeClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/HoneycodeClient";
    import { BatchUpsertTableRowsRequest, BatchUpsertTableRowsResult } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/models/models_0";
    export interface BatchUpsertTableRowsCommandInput extends BatchUpsertTableRowsRequest {
    }
    export interface BatchUpsertTableRowsCommandOutput extends BatchUpsertTableRowsResult, __MetadataBearer {
    }
    /**
        * <p>
        *             The BatchUpsertTableRows API allows you to upsert one or more rows in a table. The upsert
        *             operation takes a filter expression as input and evaluates it to find matching rows on the destination
        *             table. If matching rows are found, it will update the cells in the matching rows to new values specified
        *             in the request. If no matching rows are found, a new row is added at the end of the table and the cells in
        *             that row are set to the new values specified in the request.
        *         </p>
        *         <p>
        *             You can specify the values to set in some or all of the columns in the table for the
        *             matching or newly appended rows. If a column is not explicitly specified for a particular row, then that
        *             column will not be updated for that row. To clear out the data in a specific cell, you need to set the value
        *             as an empty string ("").
        *         </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { HoneycodeClient, BatchUpsertTableRowsCommand } from "@aws-sdk/client-honeycode"; // ES Modules import
        * // const { HoneycodeClient, BatchUpsertTableRowsCommand } = require("@aws-sdk/client-honeycode"); // CommonJS import
        * const client = new HoneycodeClient(config);
        * const command = new BatchUpsertTableRowsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchUpsertTableRowsCommandInput} for command's `input` shape.
        * @see {@link BatchUpsertTableRowsCommandOutput} for command's `response` shape.
        * @see {@link HoneycodeClientResolvedConfig | config} for HoneycodeClient's `config` shape.
        *
        */
    export class BatchUpsertTableRowsCommand extends $Command<BatchUpsertTableRowsCommandInput, BatchUpsertTableRowsCommandOutput, HoneycodeClientResolvedConfig> {
            readonly input: BatchUpsertTableRowsCommandInput;
            constructor(input: BatchUpsertTableRowsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: HoneycodeClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchUpsertTableRowsCommandInput, BatchUpsertTableRowsCommandOutput>;
    }
}

declare module '@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/DescribeTableDataImportJobCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { HoneycodeClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/HoneycodeClient";
    import { DescribeTableDataImportJobRequest, DescribeTableDataImportJobResult } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/models/models_0";
    export interface DescribeTableDataImportJobCommandInput extends DescribeTableDataImportJobRequest {
    }
    export interface DescribeTableDataImportJobCommandOutput extends DescribeTableDataImportJobResult, __MetadataBearer {
    }
    /**
        * <p>
        *             The DescribeTableDataImportJob API allows you to retrieve the status and details of a table data import job.
        *         </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { HoneycodeClient, DescribeTableDataImportJobCommand } from "@aws-sdk/client-honeycode"; // ES Modules import
        * // const { HoneycodeClient, DescribeTableDataImportJobCommand } = require("@aws-sdk/client-honeycode"); // CommonJS import
        * const client = new HoneycodeClient(config);
        * const command = new DescribeTableDataImportJobCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeTableDataImportJobCommandInput} for command's `input` shape.
        * @see {@link DescribeTableDataImportJobCommandOutput} for command's `response` shape.
        * @see {@link HoneycodeClientResolvedConfig | config} for HoneycodeClient's `config` shape.
        *
        */
    export class DescribeTableDataImportJobCommand extends $Command<DescribeTableDataImportJobCommandInput, DescribeTableDataImportJobCommandOutput, HoneycodeClientResolvedConfig> {
            readonly input: DescribeTableDataImportJobCommandInput;
            constructor(input: DescribeTableDataImportJobCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: HoneycodeClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeTableDataImportJobCommandInput, DescribeTableDataImportJobCommandOutput>;
    }
}

declare module '@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/GetScreenDataCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { HoneycodeClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/HoneycodeClient";
    import { GetScreenDataRequest, GetScreenDataResult } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/models/models_0";
    export interface GetScreenDataCommandInput extends GetScreenDataRequest {
    }
    export interface GetScreenDataCommandOutput extends GetScreenDataResult, __MetadataBearer {
    }
    /**
        * <p>
        *             The GetScreenData API allows retrieval of data from a screen in a Honeycode app.
        *             The API allows setting local variables in the screen to filter, sort or otherwise affect what will be
        *             displayed on the screen.
        *         </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { HoneycodeClient, GetScreenDataCommand } from "@aws-sdk/client-honeycode"; // ES Modules import
        * // const { HoneycodeClient, GetScreenDataCommand } = require("@aws-sdk/client-honeycode"); // CommonJS import
        * const client = new HoneycodeClient(config);
        * const command = new GetScreenDataCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetScreenDataCommandInput} for command's `input` shape.
        * @see {@link GetScreenDataCommandOutput} for command's `response` shape.
        * @see {@link HoneycodeClientResolvedConfig | config} for HoneycodeClient's `config` shape.
        *
        */
    export class GetScreenDataCommand extends $Command<GetScreenDataCommandInput, GetScreenDataCommandOutput, HoneycodeClientResolvedConfig> {
            readonly input: GetScreenDataCommandInput;
            constructor(input: GetScreenDataCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: HoneycodeClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetScreenDataCommandInput, GetScreenDataCommandOutput>;
    }
}

declare module '@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/InvokeScreenAutomationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { HoneycodeClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/HoneycodeClient";
    import { InvokeScreenAutomationRequest, InvokeScreenAutomationResult } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/models/models_0";
    export interface InvokeScreenAutomationCommandInput extends InvokeScreenAutomationRequest {
    }
    export interface InvokeScreenAutomationCommandOutput extends InvokeScreenAutomationResult, __MetadataBearer {
    }
    /**
        * <p>
        *             The InvokeScreenAutomation API allows invoking an action defined in a screen in a Honeycode app.
        *             The API allows setting local variables, which can then be used in the automation being invoked.
        *             This allows automating the Honeycode app interactions to write, update or delete data in the workbook.
        *         </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { HoneycodeClient, InvokeScreenAutomationCommand } from "@aws-sdk/client-honeycode"; // ES Modules import
        * // const { HoneycodeClient, InvokeScreenAutomationCommand } = require("@aws-sdk/client-honeycode"); // CommonJS import
        * const client = new HoneycodeClient(config);
        * const command = new InvokeScreenAutomationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link InvokeScreenAutomationCommandInput} for command's `input` shape.
        * @see {@link InvokeScreenAutomationCommandOutput} for command's `response` shape.
        * @see {@link HoneycodeClientResolvedConfig | config} for HoneycodeClient's `config` shape.
        *
        */
    export class InvokeScreenAutomationCommand extends $Command<InvokeScreenAutomationCommandInput, InvokeScreenAutomationCommandOutput, HoneycodeClientResolvedConfig> {
            readonly input: InvokeScreenAutomationCommandInput;
            constructor(input: InvokeScreenAutomationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: HoneycodeClientResolvedConfig, options?: __HttpHandlerOptions): Handler<InvokeScreenAutomationCommandInput, InvokeScreenAutomationCommandOutput>;
    }
}

declare module '@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/ListTableColumnsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { HoneycodeClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/HoneycodeClient";
    import { ListTableColumnsRequest, ListTableColumnsResult } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/models/models_0";
    export interface ListTableColumnsCommandInput extends ListTableColumnsRequest {
    }
    export interface ListTableColumnsCommandOutput extends ListTableColumnsResult, __MetadataBearer {
    }
    /**
        * <p>
        *             The ListTableColumns API allows you to retrieve a list of all the columns in a table in a workbook.
        *         </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { HoneycodeClient, ListTableColumnsCommand } from "@aws-sdk/client-honeycode"; // ES Modules import
        * // const { HoneycodeClient, ListTableColumnsCommand } = require("@aws-sdk/client-honeycode"); // CommonJS import
        * const client = new HoneycodeClient(config);
        * const command = new ListTableColumnsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTableColumnsCommandInput} for command's `input` shape.
        * @see {@link ListTableColumnsCommandOutput} for command's `response` shape.
        * @see {@link HoneycodeClientResolvedConfig | config} for HoneycodeClient's `config` shape.
        *
        */
    export class ListTableColumnsCommand extends $Command<ListTableColumnsCommandInput, ListTableColumnsCommandOutput, HoneycodeClientResolvedConfig> {
            readonly input: ListTableColumnsCommandInput;
            constructor(input: ListTableColumnsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: HoneycodeClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTableColumnsCommandInput, ListTableColumnsCommandOutput>;
    }
}

declare module '@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/ListTableRowsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { HoneycodeClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/HoneycodeClient";
    import { ListTableRowsRequest, ListTableRowsResult } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/models/models_0";
    export interface ListTableRowsCommandInput extends ListTableRowsRequest {
    }
    export interface ListTableRowsCommandOutput extends ListTableRowsResult, __MetadataBearer {
    }
    /**
        * <p>
        *             The ListTableRows API allows you to retrieve a list of all the rows in a table in a workbook.
        *         </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { HoneycodeClient, ListTableRowsCommand } from "@aws-sdk/client-honeycode"; // ES Modules import
        * // const { HoneycodeClient, ListTableRowsCommand } = require("@aws-sdk/client-honeycode"); // CommonJS import
        * const client = new HoneycodeClient(config);
        * const command = new ListTableRowsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTableRowsCommandInput} for command's `input` shape.
        * @see {@link ListTableRowsCommandOutput} for command's `response` shape.
        * @see {@link HoneycodeClientResolvedConfig | config} for HoneycodeClient's `config` shape.
        *
        */
    export class ListTableRowsCommand extends $Command<ListTableRowsCommandInput, ListTableRowsCommandOutput, HoneycodeClientResolvedConfig> {
            readonly input: ListTableRowsCommandInput;
            constructor(input: ListTableRowsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: HoneycodeClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTableRowsCommandInput, ListTableRowsCommandOutput>;
    }
}

declare module '@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/ListTablesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { HoneycodeClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/HoneycodeClient";
    import { ListTablesRequest, ListTablesResult } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/models/models_0";
    export interface ListTablesCommandInput extends ListTablesRequest {
    }
    export interface ListTablesCommandOutput extends ListTablesResult, __MetadataBearer {
    }
    /**
        * <p>
        *             The ListTables API allows you to retrieve a list of all the tables in a workbook.
        *         </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { HoneycodeClient, ListTablesCommand } from "@aws-sdk/client-honeycode"; // ES Modules import
        * // const { HoneycodeClient, ListTablesCommand } = require("@aws-sdk/client-honeycode"); // CommonJS import
        * const client = new HoneycodeClient(config);
        * const command = new ListTablesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTablesCommandInput} for command's `input` shape.
        * @see {@link ListTablesCommandOutput} for command's `response` shape.
        * @see {@link HoneycodeClientResolvedConfig | config} for HoneycodeClient's `config` shape.
        *
        */
    export class ListTablesCommand extends $Command<ListTablesCommandInput, ListTablesCommandOutput, HoneycodeClientResolvedConfig> {
            readonly input: ListTablesCommandInput;
            constructor(input: ListTablesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: HoneycodeClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTablesCommandInput, ListTablesCommandOutput>;
    }
}

declare module '@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/ListTagsForResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { HoneycodeClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/HoneycodeClient";
    import { ListTagsForResourceRequest, ListTagsForResourceResult } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/models/models_0";
    export interface ListTagsForResourceCommandInput extends ListTagsForResourceRequest {
    }
    export interface ListTagsForResourceCommandOutput extends ListTagsForResourceResult, __MetadataBearer {
    }
    /**
        * <p>
        *             The ListTagsForResource API allows you to return a resource's tags.
        *         </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { HoneycodeClient, ListTagsForResourceCommand } from "@aws-sdk/client-honeycode"; // ES Modules import
        * // const { HoneycodeClient, ListTagsForResourceCommand } = require("@aws-sdk/client-honeycode"); // CommonJS import
        * const client = new HoneycodeClient(config);
        * const command = new ListTagsForResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTagsForResourceCommandInput} for command's `input` shape.
        * @see {@link ListTagsForResourceCommandOutput} for command's `response` shape.
        * @see {@link HoneycodeClientResolvedConfig | config} for HoneycodeClient's `config` shape.
        *
        */
    export class ListTagsForResourceCommand extends $Command<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput, HoneycodeClientResolvedConfig> {
            readonly input: ListTagsForResourceCommandInput;
            constructor(input: ListTagsForResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: HoneycodeClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/QueryTableRowsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { HoneycodeClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/HoneycodeClient";
    import { QueryTableRowsRequest, QueryTableRowsResult } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/models/models_0";
    export interface QueryTableRowsCommandInput extends QueryTableRowsRequest {
    }
    export interface QueryTableRowsCommandOutput extends QueryTableRowsResult, __MetadataBearer {
    }
    /**
        * <p>
        *             The QueryTableRows API allows you to use a filter formula to query for specific rows in a table.
        *         </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { HoneycodeClient, QueryTableRowsCommand } from "@aws-sdk/client-honeycode"; // ES Modules import
        * // const { HoneycodeClient, QueryTableRowsCommand } = require("@aws-sdk/client-honeycode"); // CommonJS import
        * const client = new HoneycodeClient(config);
        * const command = new QueryTableRowsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link QueryTableRowsCommandInput} for command's `input` shape.
        * @see {@link QueryTableRowsCommandOutput} for command's `response` shape.
        * @see {@link HoneycodeClientResolvedConfig | config} for HoneycodeClient's `config` shape.
        *
        */
    export class QueryTableRowsCommand extends $Command<QueryTableRowsCommandInput, QueryTableRowsCommandOutput, HoneycodeClientResolvedConfig> {
            readonly input: QueryTableRowsCommandInput;
            constructor(input: QueryTableRowsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: HoneycodeClientResolvedConfig, options?: __HttpHandlerOptions): Handler<QueryTableRowsCommandInput, QueryTableRowsCommandOutput>;
    }
}

declare module '@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/StartTableDataImportJobCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { HoneycodeClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/HoneycodeClient";
    import { StartTableDataImportJobRequest, StartTableDataImportJobResult } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/models/models_0";
    export interface StartTableDataImportJobCommandInput extends StartTableDataImportJobRequest {
    }
    export interface StartTableDataImportJobCommandOutput extends StartTableDataImportJobResult, __MetadataBearer {
    }
    /**
        * <p>
        *             The StartTableDataImportJob API allows you to start an import job on a table. This API will only return
        *             the id of the job that was started. To find out the status of the import request, you need to call the
        *             DescribeTableDataImportJob API.
        *         </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { HoneycodeClient, StartTableDataImportJobCommand } from "@aws-sdk/client-honeycode"; // ES Modules import
        * // const { HoneycodeClient, StartTableDataImportJobCommand } = require("@aws-sdk/client-honeycode"); // CommonJS import
        * const client = new HoneycodeClient(config);
        * const command = new StartTableDataImportJobCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link StartTableDataImportJobCommandInput} for command's `input` shape.
        * @see {@link StartTableDataImportJobCommandOutput} for command's `response` shape.
        * @see {@link HoneycodeClientResolvedConfig | config} for HoneycodeClient's `config` shape.
        *
        */
    export class StartTableDataImportJobCommand extends $Command<StartTableDataImportJobCommandInput, StartTableDataImportJobCommandOutput, HoneycodeClientResolvedConfig> {
            readonly input: StartTableDataImportJobCommandInput;
            constructor(input: StartTableDataImportJobCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: HoneycodeClientResolvedConfig, options?: __HttpHandlerOptions): Handler<StartTableDataImportJobCommandInput, StartTableDataImportJobCommandOutput>;
    }
}

declare module '@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/TagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { HoneycodeClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/HoneycodeClient";
    import { TagResourceRequest, TagResourceResult } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/models/models_0";
    export interface TagResourceCommandInput extends TagResourceRequest {
    }
    export interface TagResourceCommandOutput extends TagResourceResult, __MetadataBearer {
    }
    /**
        * <p>
        *             The TagResource API allows you to add tags to an ARN-able resource. Resource includes workbook, table,
        *             screen and screen-automation.
        *         </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { HoneycodeClient, TagResourceCommand } from "@aws-sdk/client-honeycode"; // ES Modules import
        * // const { HoneycodeClient, TagResourceCommand } = require("@aws-sdk/client-honeycode"); // CommonJS import
        * const client = new HoneycodeClient(config);
        * const command = new TagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TagResourceCommandInput} for command's `input` shape.
        * @see {@link TagResourceCommandOutput} for command's `response` shape.
        * @see {@link HoneycodeClientResolvedConfig | config} for HoneycodeClient's `config` shape.
        *
        */
    export class TagResourceCommand extends $Command<TagResourceCommandInput, TagResourceCommandOutput, HoneycodeClientResolvedConfig> {
            readonly input: TagResourceCommandInput;
            constructor(input: TagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: HoneycodeClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TagResourceCommandInput, TagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/UntagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { HoneycodeClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/HoneycodeClient";
    import { UntagResourceRequest, UntagResourceResult } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/models/models_0";
    export interface UntagResourceCommandInput extends UntagResourceRequest {
    }
    export interface UntagResourceCommandOutput extends UntagResourceResult, __MetadataBearer {
    }
    /**
        * <p>
        *             The UntagResource API allows you to removes tags from an ARN-able resource. Resource includes workbook, table,
        *             screen and screen-automation.
        *         </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { HoneycodeClient, UntagResourceCommand } from "@aws-sdk/client-honeycode"; // ES Modules import
        * // const { HoneycodeClient, UntagResourceCommand } = require("@aws-sdk/client-honeycode"); // CommonJS import
        * const client = new HoneycodeClient(config);
        * const command = new UntagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UntagResourceCommandInput} for command's `input` shape.
        * @see {@link UntagResourceCommandOutput} for command's `response` shape.
        * @see {@link HoneycodeClientResolvedConfig | config} for HoneycodeClient's `config` shape.
        *
        */
    export class UntagResourceCommand extends $Command<UntagResourceCommandInput, UntagResourceCommandOutput, HoneycodeClientResolvedConfig> {
            readonly input: UntagResourceCommandInput;
            constructor(input: UntagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: HoneycodeClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UntagResourceCommandInput, UntagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/HoneycodeClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { BatchCreateTableRowsCommandInput, BatchCreateTableRowsCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/BatchCreateTableRowsCommand";
    import { BatchDeleteTableRowsCommandInput, BatchDeleteTableRowsCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/BatchDeleteTableRowsCommand";
    import { BatchUpdateTableRowsCommandInput, BatchUpdateTableRowsCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/BatchUpdateTableRowsCommand";
    import { BatchUpsertTableRowsCommandInput, BatchUpsertTableRowsCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/BatchUpsertTableRowsCommand";
    import { DescribeTableDataImportJobCommandInput, DescribeTableDataImportJobCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/DescribeTableDataImportJobCommand";
    import { GetScreenDataCommandInput, GetScreenDataCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/GetScreenDataCommand";
    import { InvokeScreenAutomationCommandInput, InvokeScreenAutomationCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/InvokeScreenAutomationCommand";
    import { ListTableColumnsCommandInput, ListTableColumnsCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/ListTableColumnsCommand";
    import { ListTableRowsCommandInput, ListTableRowsCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/ListTableRowsCommand";
    import { ListTablesCommandInput, ListTablesCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/ListTablesCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/ListTagsForResourceCommand";
    import { QueryTableRowsCommandInput, QueryTableRowsCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/QueryTableRowsCommand";
    import { StartTableDataImportJobCommandInput, StartTableDataImportJobCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/StartTableDataImportJobCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/commands/UntagResourceCommand";
    export type ServiceInputTypes = BatchCreateTableRowsCommandInput | BatchDeleteTableRowsCommandInput | BatchUpdateTableRowsCommandInput | BatchUpsertTableRowsCommandInput | DescribeTableDataImportJobCommandInput | GetScreenDataCommandInput | InvokeScreenAutomationCommandInput | ListTableColumnsCommandInput | ListTableRowsCommandInput | ListTablesCommandInput | ListTagsForResourceCommandInput | QueryTableRowsCommandInput | StartTableDataImportJobCommandInput | TagResourceCommandInput | UntagResourceCommandInput;
    export type ServiceOutputTypes = BatchCreateTableRowsCommandOutput | BatchDeleteTableRowsCommandOutput | BatchUpdateTableRowsCommandOutput | BatchUpsertTableRowsCommandOutput | DescribeTableDataImportJobCommandOutput | GetScreenDataCommandOutput | InvokeScreenAutomationCommandOutput | ListTableColumnsCommandOutput | ListTableRowsCommandOutput | ListTablesCommandOutput | ListTagsForResourceCommandOutput | QueryTableRowsCommandOutput | StartTableDataImportJobCommandOutput | TagResourceCommandOutput | UntagResourceCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type HoneycodeClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of HoneycodeClient class constructor that set the region, credentials and other options.
        */
    export interface HoneycodeClientConfig extends HoneycodeClientConfigType {
    }
    type HoneycodeClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of HoneycodeClient class. This is resolved and normalized from the {@link HoneycodeClientConfig | constructor configuration interface}.
        */
    export interface HoneycodeClientResolvedConfig extends HoneycodeClientResolvedConfigType {
    }
    /**
        * <p>
        *       Amazon Honeycode is a fully managed service that allows you to quickly build mobile and web apps for teamsâ€”without
        *       programming. Build Honeycode apps for managing almost anything, like projects, customers, operations, approvals,
        *       resources, and even your team.
        *     </p>
        */
    export class HoneycodeClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, HoneycodeClientResolvedConfig> {
            /**
                * The resolved configuration of HoneycodeClient class. This is resolved and normalized from the {@link HoneycodeClientConfig | constructor configuration interface}.
                */
            readonly config: HoneycodeClientResolvedConfig;
            constructor(configuration: HoneycodeClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { HoneycodeServiceException as __BaseException } from "@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/models/HoneycodeServiceException";
    /**
        * <p>
        *             You do not have sufficient access to perform this action. Check that the workbook is owned by you and your
        *             IAM policy allows access to the resource in the request.
        *         </p>
        */
    export class AccessDeniedException extends __BaseException {
            readonly name: "AccessDeniedException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AccessDeniedException, __BaseException>);
    }
    /**
        * <p>The automation execution did not end successfully.</p>
        */
    export class AutomationExecutionException extends __BaseException {
            readonly name: "AutomationExecutionException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AutomationExecutionException, __BaseException>);
    }
    /**
        * <p>The automation execution timed out.</p>
        */
    export class AutomationExecutionTimeoutException extends __BaseException {
            readonly name: "AutomationExecutionTimeoutException";
            readonly $fault: "server";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AutomationExecutionTimeoutException, __BaseException>);
    }
    /**
        * <p>
        *             CellInput object contains the data needed to create or update cells in a table.
        *         </p>
        *         <note>
        *             <p>
        *                 CellInput object has only a facts field or a fact field, but not both. A 400 bad request will be
        *                 thrown if both fact and facts field are present.
        *             </p>
        *         </note>
        */
    export interface CellInput {
            /**
                * <p>
                *             Fact represents the data that is entered into a cell. This data can be free text or a formula. Formulas need
                *             to start with the equals (=) sign.
                *         </p>
                */
            fact?: string;
            /**
                * <p>
                *             A list representing the values that are entered into a ROWSET cell. Facts list can have either only values
                *             or rowIDs, and rowIDs should from the same table.
                *         </p>
                */
            facts?: string[];
    }
    export namespace CellInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CellInput) => any;
    }
    /**
        * <p>
        *             Data needed to create a single row in a table as part of the BatchCreateTableRows request.
        *         </p>
        */
    export interface CreateRowData {
            /**
                * <p>
                *             An external identifier that represents the single row that is being created as part of the
                *             BatchCreateTableRows request. This can be any string that you can use to identify the row in the request.
                *             The BatchCreateTableRows API puts the batch item id in the results to allow you to link data in the
                *             request to data in the results.
                *         </p>
                */
            batchItemId: string | undefined;
            /**
                * <p>
                *             A map representing the cells to create in the new row. The key is the column id of the
                *             cell and the value is the CellInput object that represents the data to set in that cell.
                *         </p>
                */
            cellsToCreate: Record<string, CellInput> | undefined;
    }
    export namespace CreateRowData {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateRowData) => any;
    }
    export interface BatchCreateTableRowsRequest {
            /**
                * <p>The ID of the workbook where the new rows are being added.</p>
                *         <p>
                *             If a workbook with the specified ID could not be found, this API throws ResourceNotFoundException.
                *         </p>
                */
            workbookId: string | undefined;
            /**
                * <p>The ID of the table where the new rows are being added.</p>
                *         <p>
                *             If a table with the specified ID could not be found, this API throws ResourceNotFoundException.
                *         </p>
                */
            tableId: string | undefined;
            /**
                * <p>
                *             The list of rows to create at the end of the table. Each item in this list needs to have a batch item id
                *             to uniquely identify the element in the request and the cells to create for that row.
                *             You need to specify at least one item in this list.
                *         </p>
                *         <p>
                *             Note that if one of the column ids in any of the rows in the request does not exist in the table, then the
                *             request fails and no updates are made to the table.
                *         </p>
                */
            rowsToCreate: CreateRowData[] | undefined;
            /**
                * <p>
                *             The request token for performing the batch create operation.
                *             Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error
                *             like a failed network connection, you can retry the call with the same request token. The service ensures
                *             that if the first call using that request token is successfully performed, the second call will not perform
                *             the operation again.
                *         </p>
                *         <p>
                *             Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests
                *             spanning hours or days.
                *         </p>
                */
            clientRequestToken?: string;
    }
    export namespace BatchCreateTableRowsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchCreateTableRowsRequest) => any;
    }
    /**
        * <p>
        *             A single item in a batch that failed to perform the intended action because of an error preventing it from
        *             succeeding.
        *         </p>
        */
    export interface FailedBatchItem {
            /**
                * <p>
                *             The id of the batch item that failed. This is the batch item id for the BatchCreateTableRows and
                *             BatchUpsertTableRows operations and the row id for the BatchUpdateTableRows and BatchDeleteTableRows
                *             operations.
                *         </p>
                */
            id: string | undefined;
            /**
                * <p>
                *             The error message that indicates why the batch item failed.
                *         </p>
                */
            errorMessage: string | undefined;
    }
    export namespace FailedBatchItem {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FailedBatchItem) => any;
    }
    export interface BatchCreateTableRowsResult {
            /**
                * <p>The updated workbook cursor after adding the new rows at the end of the table.</p>
                */
            workbookCursor: number | undefined;
            /**
                * <p>The map of batch item id to the row id that was created for that item.</p>
                */
            createdRows: Record<string, string> | undefined;
            /**
                * <p>
                *             The list of batch items in the request that could not be added to the table. Each element in this list
                *             contains one item from the request that could not be added to the table along with the reason why
                *             that item could not be added.
                *         </p>
                */
            failedBatchItems?: FailedBatchItem[];
    }
    export namespace BatchCreateTableRowsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchCreateTableRowsResult) => any;
    }
    /**
        * <p>There were unexpected errors from the server.</p>
        */
    export class InternalServerException extends __BaseException {
            readonly name: "InternalServerException";
            readonly $fault: "server";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InternalServerException, __BaseException>);
    }
    /**
        * <p>The request timed out.</p>
        */
    export class RequestTimeoutException extends __BaseException {
            readonly name: "RequestTimeoutException";
            readonly $fault: "server";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<RequestTimeoutException, __BaseException>);
    }
    /**
        * <p>A Workbook, Table, App, Screen or Screen Automation was not found with the given ID.</p>
        */
    export class ResourceNotFoundException extends __BaseException {
            readonly name: "ResourceNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>);
    }
    /**
        * <p>
        *             The request caused service quota to be breached.
        *         </p>
        */
    export class ServiceQuotaExceededException extends __BaseException {
            readonly name: "ServiceQuotaExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ServiceQuotaExceededException, __BaseException>);
    }
    /**
        * <p>Remote service is unreachable.</p>
        */
    export class ServiceUnavailableException extends __BaseException {
            readonly name: "ServiceUnavailableException";
            readonly $fault: "server";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ServiceUnavailableException, __BaseException>);
    }
    /**
        * <p>Tps(transactions per second) rate reached.</p>
        */
    export class ThrottlingException extends __BaseException {
            readonly name: "ThrottlingException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ThrottlingException, __BaseException>);
    }
    /**
        * <p>
        *             Request is invalid. The message in the response contains details on why the request is invalid.
        *         </p>
        */
    export class ValidationException extends __BaseException {
            readonly name: "ValidationException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ValidationException, __BaseException>);
    }
    export interface BatchDeleteTableRowsRequest {
            /**
                * <p>The ID of the workbook where the rows are being deleted.</p>
                *         <p>
                *             If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
                *         </p>
                */
            workbookId: string | undefined;
            /**
                * <p>The ID of the table where the rows are being deleted.</p>
                *         <p>
                *             If a table with the specified id could not be found, this API throws ResourceNotFoundException.
                *         </p>
                */
            tableId: string | undefined;
            /**
                * <p>
                *             The list of row ids to delete from the table. You need to specify at least one row id in this list.
                *         </p>
                *         <p>
                *             Note that if one of the row ids provided in the request does not exist in the table, then the request fails
                *             and no rows are deleted from the table.
                *         </p>
                */
            rowIds: string[] | undefined;
            /**
                * <p>
                *             The request token for performing the delete action.
                *             Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error
                *             like a failed network connection, you can retry the call with the same request token. The service ensures
                *             that if the first call using that request token is successfully performed, the second call will not perform
                *             the action again.
                *         </p>
                *         <p>
                *             Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests
                *             spanning hours or days.
                *         </p>
                */
            clientRequestToken?: string;
    }
    export namespace BatchDeleteTableRowsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchDeleteTableRowsRequest) => any;
    }
    export interface BatchDeleteTableRowsResult {
            /**
                * <p>The updated workbook cursor after deleting the rows from the table.</p>
                */
            workbookCursor: number | undefined;
            /**
                * <p>
                *             The list of row ids in the request that could not be deleted from the table. Each element in this list
                *             contains one row id from the request that could not be deleted along with the reason why that item could not
                *             be deleted.
                *         </p>
                */
            failedBatchItems?: FailedBatchItem[];
    }
    export namespace BatchDeleteTableRowsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchDeleteTableRowsResult) => any;
    }
    /**
        * <p>
        *             Data needed to create a single row in a table as part of the BatchCreateTableRows request.
        *         </p>
        */
    export interface UpdateRowData {
            /**
                * <p>
                *             The id of the row that needs to be updated.
                *         </p>
                */
            rowId: string | undefined;
            /**
                * <p>
                *             A map representing the cells to update in the given row. The key is the column id of the
                *             cell and the value is the CellInput object that represents the data to set in that cell.
                *         </p>
                */
            cellsToUpdate: Record<string, CellInput> | undefined;
    }
    export namespace UpdateRowData {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateRowData) => any;
    }
    export interface BatchUpdateTableRowsRequest {
            /**
                * <p>The ID of the workbook where the rows are being updated.</p>
                *         <p>
                *             If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
                *         </p>
                */
            workbookId: string | undefined;
            /**
                * <p>The ID of the table where the rows are being updated.</p>
                *         <p>
                *             If a table with the specified id could not be found, this API throws ResourceNotFoundException.
                *         </p>
                */
            tableId: string | undefined;
            /**
                * <p>
                *             The list of rows to update in the table. Each item in this list needs to contain the row id to update
                *             along with the map of column id to cell values for each column in that row that needs to be updated.
                *             You need to specify at least one row in this list, and for each row, you need to specify at least one
                *             column to update.
                *         </p>
                *         <p>
                *             Note that if one of the row or column ids in the request does not exist in the table, then the request fails
                *             and no updates are made to the table.
                *         </p>
                */
            rowsToUpdate: UpdateRowData[] | undefined;
            /**
                * <p>
                *             The request token for performing the update action.
                *             Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error
                *             like a failed network connection, you can retry the call with the same request token. The service ensures
                *             that if the first call using that request token is successfully performed, the second call will not perform
                *             the action again.
                *         </p>
                *         <p>
                *             Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests
                *             spanning hours or days.
                *         </p>
                */
            clientRequestToken?: string;
    }
    export namespace BatchUpdateTableRowsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchUpdateTableRowsRequest) => any;
    }
    export interface BatchUpdateTableRowsResult {
            /**
                * <p>The updated workbook cursor after adding the new rows at the end of the table.</p>
                */
            workbookCursor: number | undefined;
            /**
                * <p>
                *             The list of batch items in the request that could not be updated in the table. Each element in this list
                *             contains one item from the request that could not be updated in the table along with the reason why
                *             that item could not be updated.
                *         </p>
                */
            failedBatchItems?: FailedBatchItem[];
    }
    export namespace BatchUpdateTableRowsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchUpdateTableRowsResult) => any;
    }
    /**
        * <p>
        *             An object that represents a filter formula along with the id of the context row under which the filter
        *             function needs to evaluate.
        *         </p>
        */
    export interface Filter {
            /**
                * <p>
                *             A formula representing a filter function that returns zero or more matching rows from a table. Valid
                *             formulas in this field return a list of rows from a table. The most common ways of writing a formula to
                *             return a list of rows are to use the FindRow() or Filter() functions. Any other formula that returns zero or
                *             more rows is also acceptable. For example, you can use a formula that points to a cell that contains a
                *             filter function.
                *         </p>
                */
            formula: string | undefined;
            /**
                * <p>
                *             The optional contextRowId attribute can be used to specify the row id of the context row if the filter
                *             formula contains unqualified references to table columns and needs a context row to evaluate them
                *             successfully.
                *         </p>
                */
            contextRowId?: string;
    }
    export namespace Filter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Filter) => any;
    }
    /**
        * <p>
        *             Data needed to upsert rows in a table as part of a single item in the BatchUpsertTableRows request.
        *         </p>
        */
    export interface UpsertRowData {
            /**
                * <p>
                *             An external identifier that represents a single item in the request that is being upserted as part of the
                *             BatchUpsertTableRows request. This can be any string that you can use to identify the item in the request.
                *             The BatchUpsertTableRows API puts the batch item id in the results to allow you to link data in the
                *             request to data in the results.
                *         </p>
                */
            batchItemId: string | undefined;
            /**
                * <p>
                *             The filter formula to use to find existing matching rows to update. The formula needs to return zero or more
                *             rows. If the formula returns 0 rows, then a new row will be appended in the target table. If the formula
                *             returns one or more rows, then the returned rows will be updated.
                *         </p>
                *         <p>
                *             Note that the filter formula needs to return rows from the target table for the upsert operation to succeed.
                *             If the filter formula has a syntax error or it doesn't evaluate to zero or more rows in the target table
                *             for any one item in the input list, then the entire BatchUpsertTableRows request fails and no updates are
                *             made to the table.
                *         </p>
                */
            filter: Filter | undefined;
            /**
                * <p>
                *             A map representing the cells to update for the matching rows or an appended row. The key is the column id
                *             of the cell and the value is the CellInput object that represents the data to set in that cell.
                *         </p>
                */
            cellsToUpdate: Record<string, CellInput> | undefined;
    }
    export namespace UpsertRowData {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpsertRowData) => any;
    }
    export interface BatchUpsertTableRowsRequest {
            /**
                * <p>The ID of the workbook where the rows are being upserted.</p>
                *         <p>
                *             If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
                *         </p>
                */
            workbookId: string | undefined;
            /**
                * <p>The ID of the table where the rows are being upserted.</p>
                *         <p>
                *             If a table with the specified id could not be found, this API throws ResourceNotFoundException.
                *         </p>
                */
            tableId: string | undefined;
            /**
                * <p>
                *             The list of rows to upsert in the table. Each item in this list needs to have a batch item id to uniquely
                *             identify the element in the request, a filter expression to find the rows to update for that element
                *             and the cell values to set for each column in the upserted rows. You need to specify
                *             at least one item in this list.
                *         </p>
                *         <p>
                *             Note that if one of the filter formulas in the request fails to evaluate because of an error or one of the
                *             column ids in any of the rows does not exist in the table, then the request fails
                *             and no updates are made to the table.
                *         </p>
                */
            rowsToUpsert: UpsertRowData[] | undefined;
            /**
                * <p>
                *             The request token for performing the update action.
                *             Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error
                *             like a failed network connection, you can retry the call with the same request token. The service ensures
                *             that if the first call using that request token is successfully performed, the second call will not perform
                *             the action again.
                *         </p>
                *         <p>
                *             Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests
                *             spanning hours or days.
                *         </p>
                */
            clientRequestToken?: string;
    }
    export namespace BatchUpsertTableRowsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchUpsertTableRowsRequest) => any;
    }
    export enum UpsertAction {
            Appended = "APPENDED",
            Updated = "UPDATED"
    }
    /**
        * <p>
        *             An object that represents the result of a single upsert row request.
        *         </p>
        */
    export interface UpsertRowsResult {
            /**
                * <p>
                *             The list of row ids that were changed as part of an upsert row operation. If the upsert resulted in an
                *             update, this list could potentially contain multiple rows that matched the filter and hence got updated.
                *             If the upsert resulted in an append, this list would only have the single row that was appended.
                *         </p>
                */
            rowIds: string[] | undefined;
            /**
                * <p>
                *             The result of the upsert action.
                *         </p>
                */
            upsertAction: UpsertAction | string | undefined;
    }
    export namespace UpsertRowsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpsertRowsResult) => any;
    }
    export interface BatchUpsertTableRowsResult {
            /**
                * <p>
                *             A map with the batch item id as the key and the result of the upsert operation as the value. The
                *             result of the upsert operation specifies whether existing rows were updated or a new row was appended, along
                *             with the list of row ids that were affected.
                *         </p>
                */
            rows: Record<string, UpsertRowsResult> | undefined;
            /**
                * <p>The updated workbook cursor after updating or appending rows in the table.</p>
                */
            workbookCursor: number | undefined;
            /**
                * <p>
                *             The list of batch items in the request that could not be updated or appended in the table. Each element in
                *             this list contains one item from the request that could not be updated in the table along with the reason
                *             why that item could not be updated or appended.
                *         </p>
                */
            failedBatchItems?: FailedBatchItem[];
    }
    export namespace BatchUpsertTableRowsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchUpsertTableRowsResult) => any;
    }
    export enum Format {
            Accounting = "ACCOUNTING",
            Auto = "AUTO",
            Contact = "CONTACT",
            Currency = "CURRENCY",
            Date = "DATE",
            DateTime = "DATE_TIME",
            Number = "NUMBER",
            Percentage = "PERCENTAGE",
            Rowlink = "ROWLINK",
            Rowset = "ROWSET",
            Text = "TEXT",
            Time = "TIME"
    }
    /**
        * <p>An object that represents a single cell in a table.</p>
        */
    export interface Cell {
            /**
                * <p>
                *             The formula contained in the cell. This field is empty if a cell does not have a formula.
                *         </p>
                */
            formula?: string;
            /**
                * <p>The format of the cell. If this field is empty, then the format is either not specified in the
                *         workbook or the format is set to AUTO.</p>
                */
            format?: Format | string;
            /**
                * <p>
                *             The raw value of the data contained in the cell. The raw value depends on the format of the data in the
                *             cell. However the attribute in the API return value is always a string containing the raw value.
                *         </p>
                *         <p>
                *             Cells with format DATE, DATE_TIME or TIME have the raw value as a floating point
                *             number where the whole number represents the number of days since 1/1/1900 and the fractional part
                *             represents the fraction of the day since midnight. For example, a cell with date 11/3/2020 has the raw value
                *             "44138". A cell with the time 9:00 AM has the raw value "0.375" and a cell with date/time value of
                *             11/3/2020 9:00 AM has the raw value "44138.375". Notice that even though the raw value is a number in all
                *             three cases, it is still represented as a string.
                *         </p>
                *         <p>
                *             Cells with format NUMBER, CURRENCY, PERCENTAGE and ACCOUNTING have the raw value of the data as the number
                *             representing the data being displayed. For example, the number 1.325 with two decimal places in the format
                *             will have it's raw value as "1.325" and formatted value as "1.33". A currency value for
                *             $10 will have the raw value as "10" and formatted value as "$10.00". A value representing 20% with two
                *             decimal places in the format will have its raw value as "0.2" and the formatted value as "20.00%". An
                *             accounting value of -$25 will have "-25" as the raw value and "$  (25.00)" as the formatted value.
                *         </p>
                *         <p>
                *             Cells with format TEXT will have the raw text as the raw value. For example, a cell with text "John Smith"
                *             will have "John Smith" as both the raw value and the formatted value.
                *         </p>
                *         <p>
                *             Cells with format CONTACT will have the name of the contact as a formatted value and the email address of
                *             the contact as the raw value. For example, a contact for John Smith will have "John Smith" as the
                *             formatted value and "john.smith@example.com" as the raw value.
                *         </p>
                *         <p>
                *             Cells with format ROWLINK (aka picklist) will have the first column of the linked row as the formatted value
                *             and the row id of the linked row as the raw value. For example, a cell containing a picklist to a table
                *             that displays task status might have "Completed" as the formatted value and
                *             "row:dfcefaee-5b37-4355-8f28-40c3e4ff5dd4/ca432b2f-b8eb-431d-9fb5-cbe0342f9f03" as the raw value.
                *         </p>
                *         <p>
                *             Cells with format ROWSET (aka multi-select or multi-record picklist) will by default have the first column
                *             of each of the linked rows as the formatted value in the list, and the rowset id of the linked rows as the
                *             raw value. For example, a cell containing a multi-select picklist to a table that contains items might have
                *             "Item A", "Item B" in the formatted value list and "rows:b742c1f4-6cb0-4650-a845-35eb86fcc2bb/
                *             [fdea123b-8f68-474a-aa8a-5ff87aa333af,6daf41f0-a138-4eee-89da-123086d36ecf]" as the raw value.
                *         </p>
                *         <p>
                *             Cells with format ATTACHMENT will have the name of the attachment as the formatted value and the attachment
                *             id as the raw value. For example, a cell containing an attachment named "image.jpeg" will have
                *             "image.jpeg" as the formatted value and "attachment:ca432b2f-b8eb-431d-9fb5-cbe0342f9f03" as the raw value.
                *         </p>
                *         <p>
                *             Cells with format AUTO or cells without any format that are auto-detected as one of the formats above will
                *             contain the raw and formatted values as mentioned above, based on the auto-detected formats. If there is no
                *             auto-detected format, the raw and formatted values will be the same as the data in the cell.
                *         </p>
                */
            rawValue?: string;
            /**
                * <p>
                *             The formatted value of the cell. This is the value that you see displayed in the cell in the UI.
                *         </p>
                *         <p>
                *             Note that the formatted value of a cell is always represented as a string irrespective of the data that is
                *             stored in the cell. For example, if a cell contains a date, the formatted value of the cell is the string
                *             representation of the formatted date being shown in the cell in the UI. See details in the rawValue field
                *             below for how cells of different formats will have different raw and formatted values.
                *         </p>
                */
            formattedValue?: string;
            /**
                * <p>
                *             A list of formatted values of the cell. This field is only returned when the cell is ROWSET format
                *             (aka multi-select or multi-record picklist). Values in the list are always represented as strings.
                *             The formattedValue field will be empty if this field is returned.
                *         </p>
                */
            formattedValues?: string[];
    }
    export namespace Cell {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Cell) => any;
    }
    /**
        * <p>Metadata for column in the table.</p>
        */
    export interface ColumnMetadata {
            /**
                * <p>The name of the column.</p>
                */
            name: string | undefined;
            /**
                * <p>The format of the column.</p>
                */
            format: Format | string | undefined;
    }
    export namespace ColumnMetadata {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ColumnMetadata) => any;
    }
    /**
        * <p>The data in a particular data cell defined on the screen.</p>
        */
    export interface DataItem {
            /**
                * <p>
                *             The overrideFormat is optional and is specified only if a particular row of data has a different format for
                *             the data than the default format defined on the screen or the table.
                *         </p>
                */
            overrideFormat?: Format | string;
            /**
                * <p>The raw value of the data. e.g. jsmith@example.com</p>
                */
            rawValue?: string;
            /**
                * <p>The formatted value of the data. e.g. John Smith.</p>
                */
            formattedValue?: string;
    }
    export namespace DataItem {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DataItem) => any;
    }
    export enum ImportDataCharacterEncoding {
            ISO_8859_1 = "ISO-8859-1",
            US_ASCII = "US-ASCII",
            UTF_16 = "UTF-16",
            UTF_16BE = "UTF-16BE",
            UTF_16LE = "UTF-16LE",
            UTF_8 = "UTF-8"
    }
    /**
        * <p>
        *             An object that contains the options relating to parsing delimited text as part of an import request.
        *         </p>
        */
    export interface DelimitedTextImportOptions {
            /**
                * <p>The delimiter to use for separating columns in a single row of the input.</p>
                */
            delimiter: string | undefined;
            /**
                * <p>Indicates whether the input file has a header row at the top containing the column names.</p>
                */
            hasHeaderRow?: boolean;
            /**
                * <p>A parameter to indicate whether empty rows should be ignored or be included in the import.</p>
                */
            ignoreEmptyRows?: boolean;
            /**
                * <p>The encoding of the data in the input file.</p>
                */
            dataCharacterEncoding?: ImportDataCharacterEncoding | string;
    }
    export namespace DelimitedTextImportOptions {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DelimitedTextImportOptions) => any;
    }
    export interface DescribeTableDataImportJobRequest {
            /**
                * <p>The ID of the workbook into which data was imported.</p>
                *         <p>
                *             If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
                *         </p>
                */
            workbookId: string | undefined;
            /**
                * <p>The ID of the table into which data was imported.</p>
                *         <p>
                *             If a table with the specified id could not be found, this API throws ResourceNotFoundException.
                *         </p>
                */
            tableId: string | undefined;
            /**
                * <p>The ID of the job that was returned by the StartTableDataImportJob request.</p>
                *         <p>
                *             If a job with the specified id could not be found, this API throws ResourceNotFoundException.
                *         </p>
                */
            jobId: string | undefined;
    }
    export namespace DescribeTableDataImportJobRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeTableDataImportJobRequest) => any;
    }
    export enum ErrorCode {
            AccessDenied = "ACCESS_DENIED",
            FileEmptyError = "FILE_EMPTY_ERROR",
            FileNotFoundError = "FILE_NOT_FOUND_ERROR",
            FileParsingError = "FILE_PARSING_ERROR",
            FileSizeLimitError = "FILE_SIZE_LIMIT_ERROR",
            InvalidFileTypeError = "INVALID_FILE_TYPE_ERROR",
            InvalidImportOptionsError = "INVALID_IMPORT_OPTIONS_ERROR",
            InvalidTableColumnIdError = "INVALID_TABLE_COLUMN_ID_ERROR",
            InvalidTableIdError = "INVALID_TABLE_ID_ERROR",
            InvalidUrlError = "INVALID_URL_ERROR",
            ResourceNotFoundError = "RESOURCE_NOT_FOUND_ERROR",
            SystemLimitError = "SYSTEM_LIMIT_ERROR",
            TableNotFoundError = "TABLE_NOT_FOUND_ERROR",
            UnknownError = "UNKNOWN_ERROR"
    }
    /**
        * <p>
        *             An object that contains the configuration parameters for the data source of an import request.
        *         </p>
        */
    export interface ImportDataSourceConfig {
            /**
                * <p>
                *             The URL from which source data will be downloaded for the import request.
                *         </p>
                */
            dataSourceUrl?: string;
    }
    export namespace ImportDataSourceConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImportDataSourceConfig) => any;
    }
    /**
        * <p>An object that has details about the source of the data that was submitted for import.</p>
        */
    export interface ImportDataSource {
            /**
                * <p>The configuration parameters for the data source of the import</p>
                */
            dataSourceConfig: ImportDataSourceConfig | undefined;
    }
    export namespace ImportDataSource {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImportDataSource) => any;
    }
    /**
        * <p>An object that contains the properties for importing data to a specific column in a table.</p>
        */
    export interface SourceDataColumnProperties {
            /**
                * <p>The index of the column in the input file.</p>
                */
            columnIndex?: number;
    }
    export namespace SourceDataColumnProperties {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SourceDataColumnProperties) => any;
    }
    /**
        * <p>An object that contains the options relating to the destination of the import request.</p>
        */
    export interface DestinationOptions {
            /**
                * <p>A map of the column id to the import properties for each column.</p>
                */
            columnMap?: Record<string, SourceDataColumnProperties>;
    }
    export namespace DestinationOptions {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DestinationOptions) => any;
    }
    /**
        * <p>An object that contains the options specified by the sumitter of the import request.</p>
        */
    export interface ImportOptions {
            /**
                * <p>Options relating to the destination of the import request.</p>
                */
            destinationOptions?: DestinationOptions;
            /**
                * <p>Options relating to parsing delimited text. Required if dataFormat is DELIMITED_TEXT.</p>
                */
            delimitedTextOptions?: DelimitedTextImportOptions;
    }
    export namespace ImportOptions {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImportOptions) => any;
    }
    /**
        * <p>An object that contains the attributes of the submitter of the import job.</p>
        */
    export interface ImportJobSubmitter {
            /**
                * <p>The email id of the submitter of the import job, if available.</p>
                */
            email?: string;
            /**
                * <p>The AWS user ARN of the submitter of the import job, if available.</p>
                */
            userArn?: string;
    }
    export namespace ImportJobSubmitter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImportJobSubmitter) => any;
    }
    /**
        * <p>The metadata associated with the table data import job that was submitted.</p>
        */
    export interface TableDataImportJobMetadata {
            /**
                * <p>Details about the submitter of the import request.</p>
                */
            submitter: ImportJobSubmitter | undefined;
            /**
                * <p>The timestamp when the job was submitted for import.</p>
                */
            submitTime: Date | undefined;
            /**
                * <p>The options that was specified at the time of submitting the import request.</p>
                */
            importOptions: ImportOptions | undefined;
            /**
                * <p>The source of the data that was submitted for import.</p>
                */
            dataSource: ImportDataSource | undefined;
    }
    export namespace TableDataImportJobMetadata {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TableDataImportJobMetadata) => any;
    }
    export enum TableDataImportJobStatus {
            Completed = "COMPLETED",
            Failed = "FAILED",
            InProgress = "IN_PROGRESS",
            Submitted = "SUBMITTED"
    }
    export interface DescribeTableDataImportJobResult {
            /**
                * <p>
                *             The current status of the import job.
                *         </p>
                */
            jobStatus: TableDataImportJobStatus | string | undefined;
            /**
                * <p>
                *             A message providing more details about the current status of the import job.
                *         </p>
                */
            message: string | undefined;
            /**
                * <p>
                *             The metadata about the job that was submitted for import.
                *         </p>
                */
            jobMetadata: TableDataImportJobMetadata | undefined;
            /**
                * <p>
                *             If job status is failed, error code to understand reason for the failure.
                *         </p>
                */
            errorCode?: ErrorCode | string;
    }
    export namespace DescribeTableDataImportJobResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeTableDataImportJobResult) => any;
    }
    /**
        * <p>The input variables to the app to be used by the InvokeScreenAutomation action request.</p>
        */
    export interface VariableValue {
            /**
                * <p>Raw value of the variable.</p>
                */
            rawValue: string | undefined;
    }
    export namespace VariableValue {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: VariableValue) => any;
    }
    export interface GetScreenDataRequest {
            /**
                * <p>The ID of the workbook that contains the screen.</p>
                */
            workbookId: string | undefined;
            /**
                * <p>The ID of the app that contains the screen.</p>
                */
            appId: string | undefined;
            /**
                * <p>The ID of the screen.</p>
                */
            screenId: string | undefined;
            /**
                * <p>
                *             Variables are optional and are needed only if the screen requires them to render correctly. Variables are
                *             specified as a map where the key is the name of the variable as defined on the screen. The value is an
                *             object which currently has only one property, rawValue, which holds the value of the variable to be passed
                *             to the screen.
                *         </p>
                */
            variables?: Record<string, VariableValue>;
            /**
                * <p>
                *             The number of results to be returned on a single page.
                *             Specify a number between 1 and 100. The maximum value is 100.
                *         </p>
                *         <p>
                *             This parameter is optional. If you don't specify this parameter, the default page size is 100.
                *         </p>
                */
            maxResults?: number;
            /**
                * <p>
                *             This parameter is optional. If a nextToken is not specified, the API returns the first page of data.
                *         </p>
                *         <p>
                *             Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API
                *             will throw ValidationException.
                *         </p>
                */
            nextToken?: string;
    }
    export namespace GetScreenDataRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetScreenDataRequest) => any;
    }
    /**
        * <p>A single row in the ResultSet.</p>
        */
    export interface ResultRow {
            /**
                * <p>The ID for a particular row.</p>
                */
            rowId?: string;
            /**
                * <p>List of all the data cells in a row.</p>
                */
            dataItems: DataItem[] | undefined;
    }
    export namespace ResultRow {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResultRow) => any;
    }
    /**
        * <p>
        *             ResultSet contains the results of the request for a single block or list defined on the screen.
        *         </p>
        */
    export interface ResultSet {
            /**
                * <p>
                *             List of headers for all the data cells in the block. The header identifies the name and default format of
                *             the data cell. Data cells appear in the same order in all rows as defined in the header. The names and
                *             formats are not repeated in the rows. If a particular row does not have a value for a data cell, a blank
                *             value is used.
                *         </p>
                *         <p>
                *             For example, a task list that displays the task name, due date and assigned person might have headers
                *             [ { "name": "Task Name"}, {"name": "Due Date", "format": "DATE"}, {"name": "Assigned", "format": "CONTACT"} ].
                *             Every row in the result will have the task name as the first item, due date as the second item and assigned
                *             person as the third item. If a particular task does not have a due date, that row will still have a blank
                *             value in the second element and the assigned person will still be in the third element.
                *         </p>
                */
            headers: ColumnMetadata[] | undefined;
            /**
                * <p>
                *             List of rows returned by the request. Each row has a row Id and a list of data cells in that row. The data
                *             cells will be present in the same order as they are defined in the header.
                *         </p>
                */
            rows: ResultRow[] | undefined;
    }
    export namespace ResultSet {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResultSet) => any;
    }
    export interface GetScreenDataResult {
            /**
                * <p>A map of all the rows on the screen keyed by block name.</p>
                */
            results: Record<string, ResultSet> | undefined;
            /**
                * <p>
                *             Indicates the cursor of the workbook at which the data returned by this workbook is read. Workbook cursor
                *             keeps increasing with every update and the increments are not sequential.
                *         </p>
                */
            workbookCursor: number | undefined;
            /**
                * <p>
                *             Provides the pagination token to load the next page if there are more results matching the request. If a
                *             pagination token is not present in the response, it means that all data matching the query has been loaded.
                *         </p>
                */
            nextToken?: string;
    }
    export namespace GetScreenDataResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetScreenDataResult) => any;
    }
    export enum ImportSourceDataFormat {
            DelimitedText = "DELIMITED_TEXT"
    }
    export interface InvokeScreenAutomationRequest {
            /**
                * <p>The ID of the workbook that contains the screen automation.</p>
                */
            workbookId: string | undefined;
            /**
                * <p>The ID of the app that contains the screen automation.</p>
                */
            appId: string | undefined;
            /**
                * <p>The ID of the screen that contains the screen automation.</p>
                */
            screenId: string | undefined;
            /**
                * <p>The ID of the automation action to be performed.</p>
                */
            screenAutomationId: string | undefined;
            /**
                * <p>
                *             Variables are specified as a map where the key is the name of the variable as defined on the screen. The value is an
                *             object which currently has only one property, rawValue, which holds the value of the variable to be passed
                *             to the screen. Any variables defined in a screen are required to be passed in the call.
                *         </p>
                */
            variables?: Record<string, VariableValue>;
            /**
                * <p>
                *             The row ID for the automation if the automation is defined inside a block with source or list.
                *         </p>
                */
            rowId?: string;
            /**
                * <p>
                *             The request token for performing the automation action.
                *             Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error
                *             like a failed network connection, you can retry the call with the same request token. The service ensures
                *             that if the first call using that request token is successfully performed, the second call will return the
                *             response of the previous call rather than performing the action again.
                *         </p>
                *         <p>
                *             Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests
                *             spanning hours or days.
                *         </p>
                */
            clientRequestToken?: string;
    }
    export namespace InvokeScreenAutomationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InvokeScreenAutomationRequest) => any;
    }
    export interface InvokeScreenAutomationResult {
            /**
                * <p>The updated workbook cursor after performing the automation action.</p>
                */
            workbookCursor: number | undefined;
    }
    export namespace InvokeScreenAutomationResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InvokeScreenAutomationResult) => any;
    }
    export interface ListTableColumnsRequest {
            /**
                * <p>The ID of the workbook that contains the table whose columns are being retrieved.</p>
                *         <p>
                *             If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
                *         </p>
                */
            workbookId: string | undefined;
            /**
                * <p>The ID of the table whose columns are being retrieved.</p>
                *         <p>
                *             If a table with the specified id could not be found, this API throws ResourceNotFoundException.
                *         </p>
                */
            tableId: string | undefined;
            /**
                * <p>
                *             This parameter is optional. If a nextToken is not specified, the API returns the first page of data.
                *         </p>
                *         <p>
                *             Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API
                *             will throw ValidationException.
                *         </p>
                */
            nextToken?: string;
    }
    export namespace ListTableColumnsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTableColumnsRequest) => any;
    }
    /**
        * <p>An object that contains attributes about a single column in a table</p>
        */
    export interface TableColumn {
            /**
                * <p>The id of the column in the table.</p>
                */
            tableColumnId?: string;
            /**
                * <p>The name of the column in the table.</p>
                */
            tableColumnName?: string;
            /**
                * <p>
                *             The column level format that is applied in the table. An empty value in this field means that the
                *             column format is the default value 'AUTO'.
                *         </p>
                */
            format?: Format | string;
    }
    export namespace TableColumn {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TableColumn) => any;
    }
    export interface ListTableColumnsResult {
            /**
                * <p>
                *             The list of columns in the table.
                *         </p>
                */
            tableColumns: TableColumn[] | undefined;
            /**
                * <p>
                *             Provides the pagination token to load the next page if there are more results matching the request. If a
                *             pagination token is not present in the response, it means that all data matching the request has been
                *             loaded.
                *         </p>
                */
            nextToken?: string;
            /**
                * <p>
                *             Indicates the cursor of the workbook at which the data returned by this request is read. Workbook cursor
                *             keeps increasing with every update and the increments are not sequential.
                *         </p>
                */
            workbookCursor?: number;
    }
    export namespace ListTableColumnsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTableColumnsResult) => any;
    }
    export interface ListTableRowsRequest {
            /**
                * <p>The ID of the workbook that contains the table whose rows are being retrieved.</p>
                *         <p>
                *             If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
                *         </p>
                */
            workbookId: string | undefined;
            /**
                * <p>The ID of the table whose rows are being retrieved.</p>
                *         <p>
                *             If a table with the specified id could not be found, this API throws ResourceNotFoundException.
                *         </p>
                */
            tableId: string | undefined;
            /**
                * <p>
                *             This parameter is optional. If one or more row ids are specified in this list, then only the specified
                *             row ids are returned in the result. If no row ids are specified here, then all the rows in the table are
                *             returned.
                *         </p>
                */
            rowIds?: string[];
            /**
                * <p>The maximum number of rows to return in each page of the results.</p>
                */
            maxResults?: number;
            /**
                * <p>
                *             This parameter is optional. If a nextToken is not specified, the API returns the first page of data.
                *         </p>
                *         <p>
                *             Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API
                *             will throw ValidationException.
                *         </p>
                */
            nextToken?: string;
    }
    export namespace ListTableRowsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTableRowsRequest) => any;
    }
    /**
        * <p>An object that contains attributes about a single row in a table</p>
        */
    export interface TableRow {
            /**
                * <p>The id of the row in the table.</p>
                */
            rowId: string | undefined;
            /**
                * <p>A list of cells in the table row. The cells appear in the same order as the columns of the table.
                *         </p>
                */
            cells: Cell[] | undefined;
    }
    export namespace TableRow {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TableRow) => any;
    }
    export interface ListTableRowsResult {
            /**
                * <p>
                *             The list of columns in the table whose row data is returned in the result.
                *         </p>
                */
            columnIds: string[] | undefined;
            /**
                * <p>
                *             The list of rows in the table. Note that this result is paginated, so this list contains a maximum of 100
                *             rows.
                *         </p>
                */
            rows: TableRow[] | undefined;
            /**
                * <p>
                *             The list of row ids included in the request that were not found in the table.
                *         </p>
                */
            rowIdsNotFound?: string[];
            /**
                * <p>
                *             Provides the pagination token to load the next page if there are more results matching the request. If a
                *             pagination token is not present in the response, it means that all data matching the request has been
                *             loaded.
                *         </p>
                */
            nextToken?: string;
            /**
                * <p>
                *             Indicates the cursor of the workbook at which the data returned by this request is read. Workbook cursor
                *             keeps increasing with every update and the increments are not sequential.
                *         </p>
                */
            workbookCursor: number | undefined;
    }
    export namespace ListTableRowsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTableRowsResult) => any;
    }
    export interface ListTablesRequest {
            /**
                * <p>The ID of the workbook whose tables are being retrieved.</p>
                *         <p>
                *             If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
                *         </p>
                */
            workbookId: string | undefined;
            /**
                * <p>The maximum number of tables to return in each page of the results.</p>
                */
            maxResults?: number;
            /**
                * <p>
                *             This parameter is optional. If a nextToken is not specified, the API returns the first page of data.
                *         </p>
                *         <p>
                *             Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API
                *             will throw ValidationException.
                *         </p>
                */
            nextToken?: string;
    }
    export namespace ListTablesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTablesRequest) => any;
    }
    /**
        * <p>An object representing the properties of a table in a workbook.</p>
        */
    export interface Table {
            /**
                * <p>The id of the table.</p>
                */
            tableId?: string;
            /**
                * <p>The name of the table.</p>
                */
            tableName?: string;
    }
    export namespace Table {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Table) => any;
    }
    export interface ListTablesResult {
            /**
                * <p>
                *             The list of tables in the workbook.
                *         </p>
                */
            tables: Table[] | undefined;
            /**
                * <p>
                *             Provides the pagination token to load the next page if there are more results matching the request. If a
                *             pagination token is not present in the response, it means that all data matching the request has been
                *             loaded.
                *         </p>
                */
            nextToken?: string;
            /**
                * <p>
                *             Indicates the cursor of the workbook at which the data returned by this request is read. Workbook cursor
                *             keeps increasing with every update and the increments are not sequential.
                *         </p>
                */
            workbookCursor?: number;
    }
    export namespace ListTablesResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTablesResult) => any;
    }
    export interface ListTagsForResourceRequest {
            /**
                * <p>The resource's Amazon Resource Name (ARN).</p>
                */
            resourceArn: string | undefined;
    }
    export namespace ListTagsForResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceRequest) => any;
    }
    export interface ListTagsForResourceResult {
            /**
                * <p>The resource's tags.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace ListTagsForResourceResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceResult) => any;
    }
    export interface QueryTableRowsRequest {
            /**
                * <p>The ID of the workbook whose table rows are being queried.</p>
                *         <p>
                *             If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
                *         </p>
                */
            workbookId: string | undefined;
            /**
                * <p>The ID of the table whose rows are being queried.</p>
                *         <p>
                *             If a table with the specified id could not be found, this API throws ResourceNotFoundException.
                *         </p>
                */
            tableId: string | undefined;
            /**
                * <p>An object that represents a filter formula along with the id of the context row under which the filter
                *             function needs to evaluate.</p>
                */
            filterFormula: Filter | undefined;
            /**
                * <p>The maximum number of rows to return in each page of the results.</p>
                */
            maxResults?: number;
            /**
                * <p>
                *             This parameter is optional. If a nextToken is not specified, the API returns the first page of data.
                *         </p>
                *         <p>
                *             Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API
                *             will throw ValidationException.
                *         </p>
                */
            nextToken?: string;
    }
    export namespace QueryTableRowsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: QueryTableRowsRequest) => any;
    }
    export interface QueryTableRowsResult {
            /**
                * <p>
                *             The list of columns in the table whose row data is returned in the result.
                *         </p>
                */
            columnIds: string[] | undefined;
            /**
                * <p>
                *             The list of rows in the table that match the query filter.
                *         </p>
                */
            rows: TableRow[] | undefined;
            /**
                * <p>
                *             Provides the pagination token to load the next page if there are more results matching the request. If a
                *             pagination token is not present in the response, it means that all data matching the request has been
                *             loaded.
                *         </p>
                */
            nextToken?: string;
            /**
                * <p>
                *             Indicates the cursor of the workbook at which the data returned by this request is read. Workbook cursor
                *             keeps increasing with every update and the increments are not sequential.
                *         </p>
                */
            workbookCursor: number | undefined;
    }
    export namespace QueryTableRowsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: QueryTableRowsResult) => any;
    }
    export interface StartTableDataImportJobRequest {
            /**
                * <p>The ID of the workbook where the rows are being imported.</p>
                *         <p>
                *             If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
                *         </p>
                */
            workbookId: string | undefined;
            /**
                * <p>
                *             The source of the data that is being imported. The size of source must be no larger than 100 MB.
                *             Source must have no more than 100,000 cells and no more than 1,000 rows.
                *         </p>
                */
            dataSource: ImportDataSource | undefined;
            /**
                * <p>
                *             The format of the data that is being imported. Currently the only option supported is "DELIMITED_TEXT".
                *         </p>
                */
            dataFormat: ImportSourceDataFormat | string | undefined;
            /**
                * <p>The ID of the table where the rows are being imported.</p>
                *         <p>
                *             If a table with the specified id could not be found, this API throws ResourceNotFoundException.
                *         </p>
                */
            destinationTableId: string | undefined;
            /**
                * <p>
                *             The options for customizing this import request.
                *         </p>
                */
            importOptions: ImportOptions | undefined;
            /**
                * <p>
                *             The request token for performing the update action.
                *             Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error
                *             like a failed network connection, you can retry the call with the same request token. The service ensures
                *             that if the first call using that request token is successfully performed, the second call will not perform
                *             the action again.
                *         </p>
                *         <p>
                *             Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests
                *             spanning hours or days.
                *         </p>
                */
            clientRequestToken: string | undefined;
    }
    export namespace StartTableDataImportJobRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartTableDataImportJobRequest) => any;
    }
    export interface StartTableDataImportJobResult {
            /**
                * <p>
                *             The id that is assigned to this import job. Future requests to find out the status of this import job
                *             need to send this id in the appropriate parameter in the request.
                *         </p>
                */
            jobId: string | undefined;
            /**
                * <p>
                *             The status of the import job immediately after submitting the request.
                *         </p>
                */
            jobStatus: TableDataImportJobStatus | string | undefined;
    }
    export namespace StartTableDataImportJobResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartTableDataImportJobResult) => any;
    }
    export interface TagResourceRequest {
            /**
                * <p>The resource's Amazon Resource Name (ARN).</p>
                */
            resourceArn: string | undefined;
            /**
                * <p>A list of tags to apply to the resource.</p>
                */
            tags: Record<string, string> | undefined;
    }
    export namespace TagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceRequest) => any;
    }
    export interface TagResourceResult {
    }
    export namespace TagResourceResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceResult) => any;
    }
    export interface UntagResourceRequest {
            /**
                * <p>The resource's Amazon Resource Name (ARN).</p>
                */
            resourceArn: string | undefined;
            /**
                * <p>A list of tag keys to remove from the resource.</p>
                */
            tagKeys: string[] | undefined;
    }
    export namespace UntagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceRequest) => any;
    }
    export interface UntagResourceResult {
    }
    export namespace UntagResourceResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceResult) => any;
    }
}

declare module '@aws-sdk/client-honeycode/node_modules/@aws-sdk/client-honeycode/dist-types/models/HoneycodeServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from Honeycode service.
        */
    export class HoneycodeServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

