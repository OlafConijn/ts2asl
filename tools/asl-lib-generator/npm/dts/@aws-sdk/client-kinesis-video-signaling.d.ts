// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/smithy-client
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http

declare module '@aws-sdk/client-kinesis-video-signaling' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { GetIceServerConfigCommandInput, GetIceServerConfigCommandOutput } from "@aws-sdk/client-kinesis-video-signaling/node_modules/@aws-sdk/client-kinesis-video-signaling/dist-types/commands/GetIceServerConfigCommand";
    import { SendAlexaOfferToMasterCommandInput, SendAlexaOfferToMasterCommandOutput } from "@aws-sdk/client-kinesis-video-signaling/node_modules/@aws-sdk/client-kinesis-video-signaling/dist-types/commands/SendAlexaOfferToMasterCommand";
    import { KinesisVideoSignalingClient } from "@aws-sdk/client-kinesis-video-signaling/node_modules/@aws-sdk/client-kinesis-video-signaling/dist-types/KinesisVideoSignalingClient";
    /**
        * <p>Kinesis Video Streams Signaling Service is a intermediate service that establishes a
        *             communication channel for discovering peers, transmitting offers and answers in order to
        *             establish peer-to-peer connection in webRTC technology.</p>
        */
    export class KinesisVideoSignaling extends KinesisVideoSignalingClient {
            /**
                * <p>Gets the Interactive Connectivity Establishment (ICE) server configuration
                *             information, including URIs, username, and password which can be used to configure the
                *             WebRTC connection. The ICE component uses this configuration information to setup the
                *             WebRTC connection, including authenticating with the Traversal Using Relays around NAT
                *             (TURN) relay server. </p>
                *         <p>TURN is a protocol that is used to improve the connectivity of peer-to-peer
                *             applications. By providing a cloud-based relay service, TURN ensures that a connection
                *             can be established even when one or more peers are incapable of a direct peer-to-peer
                *             connection. For more information, see <a href="https://tools.ietf.org/html/draft-uberti-rtcweb-turn-rest-00">A REST API For
                *                 Access To TURN Services</a>.</p>
                *         <p> You can invoke this API to establish a fallback mechanism in case either of the peers
                *             is unable to establish a direct peer-to-peer connection over a signaling channel. You
                *             must specify either a signaling channel ARN or the client ID in order to invoke this
                *             API.</p>
                */
            getIceServerConfig(args: GetIceServerConfigCommandInput, options?: __HttpHandlerOptions): Promise<GetIceServerConfigCommandOutput>;
            getIceServerConfig(args: GetIceServerConfigCommandInput, cb: (err: any, data?: GetIceServerConfigCommandOutput) => void): void;
            getIceServerConfig(args: GetIceServerConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetIceServerConfigCommandOutput) => void): void;
            /**
                * <p>This API allows you to connect WebRTC-enabled devices with Alexa display devices. When
                *             invoked, it sends the Alexa Session Description Protocol (SDP) offer to the master peer.
                *             The offer is delivered as soon as the master is connected to the specified signaling
                *             channel. This API returns the SDP answer from the connected master. If the master is not
                *             connected to the signaling channel, redelivery requests are made until the message
                *             expires.</p>
                */
            sendAlexaOfferToMaster(args: SendAlexaOfferToMasterCommandInput, options?: __HttpHandlerOptions): Promise<SendAlexaOfferToMasterCommandOutput>;
            sendAlexaOfferToMaster(args: SendAlexaOfferToMasterCommandInput, cb: (err: any, data?: SendAlexaOfferToMasterCommandOutput) => void): void;
            sendAlexaOfferToMaster(args: SendAlexaOfferToMasterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: SendAlexaOfferToMasterCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-kinesis-video-signaling/node_modules/@aws-sdk/client-kinesis-video-signaling/dist-types/commands/GetIceServerConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoSignalingClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video-signaling/node_modules/@aws-sdk/client-kinesis-video-signaling/dist-types/KinesisVideoSignalingClient";
    import { GetIceServerConfigRequest, GetIceServerConfigResponse } from "@aws-sdk/client-kinesis-video-signaling/node_modules/@aws-sdk/client-kinesis-video-signaling/dist-types/models/models_0";
    export interface GetIceServerConfigCommandInput extends GetIceServerConfigRequest {
    }
    export interface GetIceServerConfigCommandOutput extends GetIceServerConfigResponse, __MetadataBearer {
    }
    /**
        * <p>Gets the Interactive Connectivity Establishment (ICE) server configuration
        *             information, including URIs, username, and password which can be used to configure the
        *             WebRTC connection. The ICE component uses this configuration information to setup the
        *             WebRTC connection, including authenticating with the Traversal Using Relays around NAT
        *             (TURN) relay server. </p>
        *         <p>TURN is a protocol that is used to improve the connectivity of peer-to-peer
        *             applications. By providing a cloud-based relay service, TURN ensures that a connection
        *             can be established even when one or more peers are incapable of a direct peer-to-peer
        *             connection. For more information, see <a href="https://tools.ietf.org/html/draft-uberti-rtcweb-turn-rest-00">A REST API For
        *                 Access To TURN Services</a>.</p>
        *         <p> You can invoke this API to establish a fallback mechanism in case either of the peers
        *             is unable to establish a direct peer-to-peer connection over a signaling channel. You
        *             must specify either a signaling channel ARN or the client ID in order to invoke this
        *             API.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoSignalingClient, GetIceServerConfigCommand } from "@aws-sdk/client-kinesis-video-signaling"; // ES Modules import
        * // const { KinesisVideoSignalingClient, GetIceServerConfigCommand } = require("@aws-sdk/client-kinesis-video-signaling"); // CommonJS import
        * const client = new KinesisVideoSignalingClient(config);
        * const command = new GetIceServerConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetIceServerConfigCommandInput} for command's `input` shape.
        * @see {@link GetIceServerConfigCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoSignalingClientResolvedConfig | config} for KinesisVideoSignalingClient's `config` shape.
        *
        */
    export class GetIceServerConfigCommand extends $Command<GetIceServerConfigCommandInput, GetIceServerConfigCommandOutput, KinesisVideoSignalingClientResolvedConfig> {
            readonly input: GetIceServerConfigCommandInput;
            constructor(input: GetIceServerConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoSignalingClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetIceServerConfigCommandInput, GetIceServerConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video-signaling/node_modules/@aws-sdk/client-kinesis-video-signaling/dist-types/commands/SendAlexaOfferToMasterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisVideoSignalingClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis-video-signaling/node_modules/@aws-sdk/client-kinesis-video-signaling/dist-types/KinesisVideoSignalingClient";
    import { SendAlexaOfferToMasterRequest, SendAlexaOfferToMasterResponse } from "@aws-sdk/client-kinesis-video-signaling/node_modules/@aws-sdk/client-kinesis-video-signaling/dist-types/models/models_0";
    export interface SendAlexaOfferToMasterCommandInput extends SendAlexaOfferToMasterRequest {
    }
    export interface SendAlexaOfferToMasterCommandOutput extends SendAlexaOfferToMasterResponse, __MetadataBearer {
    }
    /**
        * <p>This API allows you to connect WebRTC-enabled devices with Alexa display devices. When
        *             invoked, it sends the Alexa Session Description Protocol (SDP) offer to the master peer.
        *             The offer is delivered as soon as the master is connected to the specified signaling
        *             channel. This API returns the SDP answer from the connected master. If the master is not
        *             connected to the signaling channel, redelivery requests are made until the message
        *             expires.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisVideoSignalingClient, SendAlexaOfferToMasterCommand } from "@aws-sdk/client-kinesis-video-signaling"; // ES Modules import
        * // const { KinesisVideoSignalingClient, SendAlexaOfferToMasterCommand } = require("@aws-sdk/client-kinesis-video-signaling"); // CommonJS import
        * const client = new KinesisVideoSignalingClient(config);
        * const command = new SendAlexaOfferToMasterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link SendAlexaOfferToMasterCommandInput} for command's `input` shape.
        * @see {@link SendAlexaOfferToMasterCommandOutput} for command's `response` shape.
        * @see {@link KinesisVideoSignalingClientResolvedConfig | config} for KinesisVideoSignalingClient's `config` shape.
        *
        */
    export class SendAlexaOfferToMasterCommand extends $Command<SendAlexaOfferToMasterCommandInput, SendAlexaOfferToMasterCommandOutput, KinesisVideoSignalingClientResolvedConfig> {
            readonly input: SendAlexaOfferToMasterCommandInput;
            constructor(input: SendAlexaOfferToMasterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisVideoSignalingClientResolvedConfig, options?: __HttpHandlerOptions): Handler<SendAlexaOfferToMasterCommandInput, SendAlexaOfferToMasterCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis-video-signaling/node_modules/@aws-sdk/client-kinesis-video-signaling/dist-types/KinesisVideoSignalingClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { GetIceServerConfigCommandInput, GetIceServerConfigCommandOutput } from "@aws-sdk/client-kinesis-video-signaling/node_modules/@aws-sdk/client-kinesis-video-signaling/dist-types/commands/GetIceServerConfigCommand";
    import { SendAlexaOfferToMasterCommandInput, SendAlexaOfferToMasterCommandOutput } from "@aws-sdk/client-kinesis-video-signaling/node_modules/@aws-sdk/client-kinesis-video-signaling/dist-types/commands/SendAlexaOfferToMasterCommand";
    export type ServiceInputTypes = GetIceServerConfigCommandInput | SendAlexaOfferToMasterCommandInput;
    export type ServiceOutputTypes = GetIceServerConfigCommandOutput | SendAlexaOfferToMasterCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type KinesisVideoSignalingClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of KinesisVideoSignalingClient class constructor that set the region, credentials and other options.
        */
    export interface KinesisVideoSignalingClientConfig extends KinesisVideoSignalingClientConfigType {
    }
    type KinesisVideoSignalingClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of KinesisVideoSignalingClient class. This is resolved and normalized from the {@link KinesisVideoSignalingClientConfig | constructor configuration interface}.
        */
    export interface KinesisVideoSignalingClientResolvedConfig extends KinesisVideoSignalingClientResolvedConfigType {
    }
    /**
        * <p>Kinesis Video Streams Signaling Service is a intermediate service that establishes a
        *             communication channel for discovering peers, transmitting offers and answers in order to
        *             establish peer-to-peer connection in webRTC technology.</p>
        */
    export class KinesisVideoSignalingClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, KinesisVideoSignalingClientResolvedConfig> {
            /**
                * The resolved configuration of KinesisVideoSignalingClient class. This is resolved and normalized from the {@link KinesisVideoSignalingClientConfig | constructor configuration interface}.
                */
            readonly config: KinesisVideoSignalingClientResolvedConfig;
            constructor(configuration: KinesisVideoSignalingClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-kinesis-video-signaling/node_modules/@aws-sdk/client-kinesis-video-signaling/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { KinesisVideoSignalingServiceException as __BaseException } from "@aws-sdk/client-kinesis-video-signaling/node_modules/@aws-sdk/client-kinesis-video-signaling/dist-types/models/KinesisVideoSignalingServiceException";
    /**
        * <p>Your request was throttled because you have exceeded the limit of allowed client
        *             calls. Try making the call later.</p>
        */
    export class ClientLimitExceededException extends __BaseException {
            readonly name: "ClientLimitExceededException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClientLimitExceededException, __BaseException>);
    }
    export enum Service {
            TURN = "TURN"
    }
    export interface GetIceServerConfigRequest {
            /**
                * <p>The ARN of the signaling channel to be used for the peer-to-peer connection between
                *             configured peers. </p>
                */
            ChannelARN: string | undefined;
            /**
                * <p>Unique identifier for the viewer. Must be unique within the signaling channel.</p>
                */
            ClientId?: string;
            /**
                * <p>Specifies the desired service. Currently, <code>TURN</code> is the only valid
                *             value.</p>
                */
            Service?: Service | string;
            /**
                * <p>An optional user ID to be associated with the credentials.</p>
                */
            Username?: string;
    }
    export namespace GetIceServerConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetIceServerConfigRequest) => any;
    }
    /**
        * <p>A structure for the ICE server connection data.</p>
        */
    export interface IceServer {
            /**
                * <p>An array of URIs, in the form specified in the <a href="https://tools.ietf.org/html/draft-petithuguenin-behave-turn-uris-03">I-D.petithuguenin-behave-turn-uris</a> spec. These URIs provide the different
                *             addresses and/or protocols that can be used to reach the TURN server.</p>
                */
            Uris?: string[];
            /**
                * <p>A username to login to the ICE server.</p>
                */
            Username?: string;
            /**
                * <p>A password to login to the ICE server.</p>
                */
            Password?: string;
            /**
                * <p>The period of time, in seconds, during which the username and password are
                *             valid.</p>
                */
            Ttl?: number;
    }
    export namespace IceServer {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: IceServer) => any;
    }
    export interface GetIceServerConfigResponse {
            /**
                * <p>The list of ICE server information objects.</p>
                */
            IceServerList?: IceServer[];
    }
    export namespace GetIceServerConfigResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetIceServerConfigResponse) => any;
    }
    /**
        * <p>The value for this input parameter is invalid.</p>
        */
    export class InvalidArgumentException extends __BaseException {
            readonly name: "InvalidArgumentException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidArgumentException, __BaseException>);
    }
    /**
        * <p>The specified client is invalid.</p>
        */
    export class InvalidClientException extends __BaseException {
            readonly name: "InvalidClientException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidClientException, __BaseException>);
    }
    /**
        * <p>The caller is not authorized to perform this operation.</p>
        */
    export class NotAuthorizedException extends __BaseException {
            readonly name: "NotAuthorizedException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NotAuthorizedException, __BaseException>);
    }
    /**
        * <p>The specified resource is not found.</p>
        */
    export class ResourceNotFoundException extends __BaseException {
            readonly name: "ResourceNotFoundException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>);
    }
    /**
        * <p>If the client session is expired. Once the client is connected, the session is valid
        *             for 45 minutes. Client should reconnect to the channel to continue sending/receiving
        *             messages.</p>
        */
    export class SessionExpiredException extends __BaseException {
            readonly name: "SessionExpiredException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SessionExpiredException, __BaseException>);
    }
    export interface SendAlexaOfferToMasterRequest {
            /**
                * <p>The ARN of the signaling channel by which Alexa and the master peer
                *             communicate.</p>
                */
            ChannelARN: string | undefined;
            /**
                * <p>The unique identifier for the sender client.</p>
                */
            SenderClientId: string | undefined;
            /**
                * <p>The base64-encoded SDP offer content.</p>
                */
            MessagePayload: string | undefined;
    }
    export namespace SendAlexaOfferToMasterRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SendAlexaOfferToMasterRequest) => any;
    }
    export interface SendAlexaOfferToMasterResponse {
            /**
                * <p>The base64-encoded SDP answer content.</p>
                */
            Answer?: string;
    }
    export namespace SendAlexaOfferToMasterResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SendAlexaOfferToMasterResponse) => any;
    }
}

declare module '@aws-sdk/client-kinesis-video-signaling/node_modules/@aws-sdk/client-kinesis-video-signaling/dist-types/models/KinesisVideoSignalingServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from KinesisVideoSignaling service.
        */
    export class KinesisVideoSignalingServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

