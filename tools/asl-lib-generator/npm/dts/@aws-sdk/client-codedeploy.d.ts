// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http
//   @aws-sdk/smithy-client

declare module '@aws-sdk/client-codedeploy' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { CodeDeployClient } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { AddTagsToOnPremisesInstancesCommandInput, AddTagsToOnPremisesInstancesCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/AddTagsToOnPremisesInstancesCommand";
    import { BatchGetApplicationRevisionsCommandInput, BatchGetApplicationRevisionsCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/BatchGetApplicationRevisionsCommand";
    import { BatchGetApplicationsCommandInput, BatchGetApplicationsCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/BatchGetApplicationsCommand";
    import { BatchGetDeploymentGroupsCommandInput, BatchGetDeploymentGroupsCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/BatchGetDeploymentGroupsCommand";
    import { BatchGetDeploymentInstancesCommandInput, BatchGetDeploymentInstancesCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/BatchGetDeploymentInstancesCommand";
    import { BatchGetDeploymentsCommandInput, BatchGetDeploymentsCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/BatchGetDeploymentsCommand";
    import { BatchGetDeploymentTargetsCommandInput, BatchGetDeploymentTargetsCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/BatchGetDeploymentTargetsCommand";
    import { BatchGetOnPremisesInstancesCommandInput, BatchGetOnPremisesInstancesCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/BatchGetOnPremisesInstancesCommand";
    import { ContinueDeploymentCommandInput, ContinueDeploymentCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ContinueDeploymentCommand";
    import { CreateApplicationCommandInput, CreateApplicationCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/CreateApplicationCommand";
    import { CreateDeploymentCommandInput, CreateDeploymentCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/CreateDeploymentCommand";
    import { CreateDeploymentConfigCommandInput, CreateDeploymentConfigCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/CreateDeploymentConfigCommand";
    import { CreateDeploymentGroupCommandInput, CreateDeploymentGroupCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/CreateDeploymentGroupCommand";
    import { DeleteApplicationCommandInput, DeleteApplicationCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/DeleteApplicationCommand";
    import { DeleteDeploymentConfigCommandInput, DeleteDeploymentConfigCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/DeleteDeploymentConfigCommand";
    import { DeleteDeploymentGroupCommandInput, DeleteDeploymentGroupCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/DeleteDeploymentGroupCommand";
    import { DeleteGitHubAccountTokenCommandInput, DeleteGitHubAccountTokenCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/DeleteGitHubAccountTokenCommand";
    import { DeleteResourcesByExternalIdCommandInput, DeleteResourcesByExternalIdCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/DeleteResourcesByExternalIdCommand";
    import { DeregisterOnPremisesInstanceCommandInput, DeregisterOnPremisesInstanceCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/DeregisterOnPremisesInstanceCommand";
    import { GetApplicationCommandInput, GetApplicationCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetApplicationCommand";
    import { GetApplicationRevisionCommandInput, GetApplicationRevisionCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetApplicationRevisionCommand";
    import { GetDeploymentCommandInput, GetDeploymentCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetDeploymentCommand";
    import { GetDeploymentConfigCommandInput, GetDeploymentConfigCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetDeploymentConfigCommand";
    import { GetDeploymentGroupCommandInput, GetDeploymentGroupCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetDeploymentGroupCommand";
    import { GetDeploymentInstanceCommandInput, GetDeploymentInstanceCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetDeploymentInstanceCommand";
    import { GetDeploymentTargetCommandInput, GetDeploymentTargetCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetDeploymentTargetCommand";
    import { GetOnPremisesInstanceCommandInput, GetOnPremisesInstanceCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetOnPremisesInstanceCommand";
    import { ListApplicationRevisionsCommandInput, ListApplicationRevisionsCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListApplicationRevisionsCommand";
    import { ListApplicationsCommandInput, ListApplicationsCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListApplicationsCommand";
    import { ListDeploymentConfigsCommandInput, ListDeploymentConfigsCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListDeploymentConfigsCommand";
    import { ListDeploymentGroupsCommandInput, ListDeploymentGroupsCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListDeploymentGroupsCommand";
    import { ListDeploymentInstancesCommandInput, ListDeploymentInstancesCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListDeploymentInstancesCommand";
    import { ListDeploymentsCommandInput, ListDeploymentsCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListDeploymentsCommand";
    import { ListDeploymentTargetsCommandInput, ListDeploymentTargetsCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListDeploymentTargetsCommand";
    import { ListGitHubAccountTokenNamesCommandInput, ListGitHubAccountTokenNamesCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListGitHubAccountTokenNamesCommand";
    import { ListOnPremisesInstancesCommandInput, ListOnPremisesInstancesCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListOnPremisesInstancesCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListTagsForResourceCommand";
    import { PutLifecycleEventHookExecutionStatusCommandInput, PutLifecycleEventHookExecutionStatusCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/PutLifecycleEventHookExecutionStatusCommand";
    import { RegisterApplicationRevisionCommandInput, RegisterApplicationRevisionCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/RegisterApplicationRevisionCommand";
    import { RegisterOnPremisesInstanceCommandInput, RegisterOnPremisesInstanceCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/RegisterOnPremisesInstanceCommand";
    import { RemoveTagsFromOnPremisesInstancesCommandInput, RemoveTagsFromOnPremisesInstancesCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/RemoveTagsFromOnPremisesInstancesCommand";
    import { SkipWaitTimeForInstanceTerminationCommandInput, SkipWaitTimeForInstanceTerminationCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/SkipWaitTimeForInstanceTerminationCommand";
    import { StopDeploymentCommandInput, StopDeploymentCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/StopDeploymentCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/UntagResourceCommand";
    import { UpdateApplicationCommandInput, UpdateApplicationCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/UpdateApplicationCommand";
    import { UpdateDeploymentGroupCommandInput, UpdateDeploymentGroupCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/UpdateDeploymentGroupCommand";
    /**
        * <fullname>AWS CodeDeploy</fullname>
        *         <p>AWS CodeDeploy is a deployment service that automates application deployments to
        *             Amazon EC2 instances, on-premises instances running in your own facility, serverless AWS
        *             Lambda functions, or applications in an Amazon ECS service.</p>
        *         <p>You can deploy a nearly unlimited variety of application content, such as an updated
        *             Lambda function, updated applications in an Amazon ECS service, code, web and
        *             configuration files, executables, packages, scripts, multimedia files, and so on. AWS
        *             CodeDeploy can deploy application content stored in Amazon S3 buckets, GitHub
        *             repositories, or Bitbucket repositories. You do not need to make changes to your
        *             existing code before you can use AWS CodeDeploy.</p>
        *         <p>AWS CodeDeploy makes it easier for you to rapidly release new features, helps you
        *             avoid downtime during application deployment, and handles the complexity of updating
        *             your applications, without many of the risks associated with error-prone manual
        *             deployments.</p>
        *         <p>
        *             <b>AWS CodeDeploy Components</b>
        *         </p>
        *         <p>Use the information in this guide to help you work with the following AWS CodeDeploy
        *             components:</p>
        *         <ul>
        *             <li>
        *                 <p>
        *                     <b>Application</b>: A name that uniquely identifies
        *                     the application you want to deploy. AWS CodeDeploy uses this name, which
        *                     functions as a container, to ensure the correct combination of revision,
        *                     deployment configuration, and deployment group are referenced during a
        *                     deployment.</p>
        *             </li>
        *             <li>
        *                 <p>
        *                     <b>Deployment group</b>: A set of individual
        *                     instances, CodeDeploy Lambda deployment configuration settings, or an Amazon ECS
        *                     service and network details. A Lambda deployment group specifies how to route
        *                     traffic to a new version of a Lambda function. An Amazon ECS deployment group
        *                     specifies the service created in Amazon ECS to deploy, a load balancer, and a
        *                     listener to reroute production traffic to an updated containerized application.
        *                     An EC2/On-premises deployment group contains individually tagged instances,
        *                     Amazon EC2 instances in Amazon EC2 Auto Scaling groups, or both. All deployment
        *                     groups can specify optional trigger, alarm, and rollback settings.</p>
        *             </li>
        *             <li>
        *                 <p>
        *                     <b>Deployment configuration</b>: A set of deployment
        *                     rules and deployment success and failure conditions used by AWS CodeDeploy
        *                     during a deployment.</p>
        *             </li>
        *             <li>
        *                 <p>
        *                     <b>Deployment</b>: The process and the components used
        *                     when updating a Lambda function, a containerized application in an Amazon ECS
        *                     service, or of installing content on one or more instances. </p>
        *             </li>
        *             <li>
        *                 <p>
        *                     <b>Application revisions</b>: For an AWS Lambda
        *                     deployment, this is an AppSpec file that specifies the Lambda function to be
        *                     updated and one or more functions to validate deployment lifecycle events. For
        *                     an Amazon ECS deployment, this is an AppSpec file that specifies the Amazon ECS
        *                     task definition, container, and port where production traffic is rerouted. For
        *                     an EC2/On-premises deployment, this is an archive file that contains source
        *                     content—source code, webpages, executable files, and deployment scripts—along
        *                     with an AppSpec file. Revisions are stored in Amazon S3 buckets or GitHub
        *                     repositories. For Amazon S3, a revision is uniquely identified by its Amazon S3
        *                     object key and its ETag, version, or both. For GitHub, a revision is uniquely
        *                     identified by its commit ID.</p>
        *             </li>
        *          </ul>
        *         <p>This guide also contains information to help you get details about the instances in
        *             your deployments, to make on-premises instances available for AWS CodeDeploy
        *             deployments, to get details about a Lambda function deployment, and to get details about
        *             Amazon ECS service deployments.</p>
        *         <p>
        *             <b>AWS CodeDeploy Information Resources</b>
        *          </p>
        *         <ul>
        *             <li>
        *                 <p>
        *                   <a href="https://docs.aws.amazon.com/codedeploy/latest/userguide">AWS CodeDeploy
        *                         User Guide</a>
        *                </p>
        *             </li>
        *             <li>
        *                 <p>
        *                   <a href="https://docs.aws.amazon.com/codedeploy/latest/APIReference/">AWS
        *                         CodeDeploy API Reference Guide</a>
        *                </p>
        *             </li>
        *             <li>
        *                 <p>
        *                   <a href="https://docs.aws.amazon.com/cli/latest/reference/deploy/index.html">AWS
        *                         CLI Reference for AWS CodeDeploy</a>
        *                </p>
        *             </li>
        *             <li>
        *                 <p>
        *                     <a href="https://forums.aws.amazon.com/forum.jspa?forumID=179">AWS CodeDeploy
        *                         Developer Forum</a>
        *                 </p>
        *             </li>
        *          </ul>
        */
    export class CodeDeploy extends CodeDeployClient {
            /**
                * <p>Adds tags to on-premises instances.</p>
                */
            addTagsToOnPremisesInstances(args: AddTagsToOnPremisesInstancesCommandInput, options?: __HttpHandlerOptions): Promise<AddTagsToOnPremisesInstancesCommandOutput>;
            addTagsToOnPremisesInstances(args: AddTagsToOnPremisesInstancesCommandInput, cb: (err: any, data?: AddTagsToOnPremisesInstancesCommandOutput) => void): void;
            addTagsToOnPremisesInstances(args: AddTagsToOnPremisesInstancesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AddTagsToOnPremisesInstancesCommandOutput) => void): void;
            /**
                * <p>Gets information about one or more application revisions. The maximum number of
                *             application revisions that can be returned is 25.</p>
                */
            batchGetApplicationRevisions(args: BatchGetApplicationRevisionsCommandInput, options?: __HttpHandlerOptions): Promise<BatchGetApplicationRevisionsCommandOutput>;
            batchGetApplicationRevisions(args: BatchGetApplicationRevisionsCommandInput, cb: (err: any, data?: BatchGetApplicationRevisionsCommandOutput) => void): void;
            batchGetApplicationRevisions(args: BatchGetApplicationRevisionsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchGetApplicationRevisionsCommandOutput) => void): void;
            /**
                * <p>Gets information about one or more applications. The maximum number of applications
                *             that can be returned is 100.</p>
                */
            batchGetApplications(args: BatchGetApplicationsCommandInput, options?: __HttpHandlerOptions): Promise<BatchGetApplicationsCommandOutput>;
            batchGetApplications(args: BatchGetApplicationsCommandInput, cb: (err: any, data?: BatchGetApplicationsCommandOutput) => void): void;
            batchGetApplications(args: BatchGetApplicationsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchGetApplicationsCommandOutput) => void): void;
            /**
                * <p>Gets information about one or more deployment groups.</p>
                */
            batchGetDeploymentGroups(args: BatchGetDeploymentGroupsCommandInput, options?: __HttpHandlerOptions): Promise<BatchGetDeploymentGroupsCommandOutput>;
            batchGetDeploymentGroups(args: BatchGetDeploymentGroupsCommandInput, cb: (err: any, data?: BatchGetDeploymentGroupsCommandOutput) => void): void;
            batchGetDeploymentGroups(args: BatchGetDeploymentGroupsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchGetDeploymentGroupsCommandOutput) => void): void;
            /**
                * @deprecated
                *
                * <note>
                *             <p> This method works, but is deprecated. Use <code>BatchGetDeploymentTargets</code>
                *                 instead. </p>
                *         </note>
                *         <p> Returns an array of one or more instances associated with a deployment. This method
                *             works with EC2/On-premises and AWS Lambda compute platforms. The newer
                *                 <code>BatchGetDeploymentTargets</code> works with all compute platforms. The maximum
                *             number of instances that can be returned is 25.</p>
                */
            batchGetDeploymentInstances(args: BatchGetDeploymentInstancesCommandInput, options?: __HttpHandlerOptions): Promise<BatchGetDeploymentInstancesCommandOutput>;
            batchGetDeploymentInstances(args: BatchGetDeploymentInstancesCommandInput, cb: (err: any, data?: BatchGetDeploymentInstancesCommandOutput) => void): void;
            batchGetDeploymentInstances(args: BatchGetDeploymentInstancesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchGetDeploymentInstancesCommandOutput) => void): void;
            /**
                * <p>Gets information about one or more deployments. The maximum number of deployments that
                *             can be returned is 25.</p>
                */
            batchGetDeployments(args: BatchGetDeploymentsCommandInput, options?: __HttpHandlerOptions): Promise<BatchGetDeploymentsCommandOutput>;
            batchGetDeployments(args: BatchGetDeploymentsCommandInput, cb: (err: any, data?: BatchGetDeploymentsCommandOutput) => void): void;
            batchGetDeployments(args: BatchGetDeploymentsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchGetDeploymentsCommandOutput) => void): void;
            /**
                * <p> Returns an array of one or more targets associated with a deployment. This method
                *             works with all compute types and should be used instead of the deprecated
                *                 <code>BatchGetDeploymentInstances</code>. The maximum number of targets that can be
                *             returned is 25.</p>
                *         <p> The type of targets returned depends on the deployment's compute platform or
                *             deployment method: </p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <b>EC2/On-premises</b>: Information about EC2 instance
                *                     targets. </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <b>AWS Lambda</b>: Information about Lambda functions
                *                     targets. </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <b>Amazon ECS</b>: Information about Amazon ECS
                *                     service targets. </p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <b>CloudFormation</b>: Information about targets of
                *                     blue/green deployments initiated by a CloudFormation stack update.</p>
                *             </li>
                *          </ul>
                */
            batchGetDeploymentTargets(args: BatchGetDeploymentTargetsCommandInput, options?: __HttpHandlerOptions): Promise<BatchGetDeploymentTargetsCommandOutput>;
            batchGetDeploymentTargets(args: BatchGetDeploymentTargetsCommandInput, cb: (err: any, data?: BatchGetDeploymentTargetsCommandOutput) => void): void;
            batchGetDeploymentTargets(args: BatchGetDeploymentTargetsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchGetDeploymentTargetsCommandOutput) => void): void;
            /**
                * <p>Gets information about one or more on-premises instances. The maximum number of
                *             on-premises instances that can be returned is 25.</p>
                */
            batchGetOnPremisesInstances(args: BatchGetOnPremisesInstancesCommandInput, options?: __HttpHandlerOptions): Promise<BatchGetOnPremisesInstancesCommandOutput>;
            batchGetOnPremisesInstances(args: BatchGetOnPremisesInstancesCommandInput, cb: (err: any, data?: BatchGetOnPremisesInstancesCommandOutput) => void): void;
            batchGetOnPremisesInstances(args: BatchGetOnPremisesInstancesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchGetOnPremisesInstancesCommandOutput) => void): void;
            /**
                * <p>For a blue/green deployment, starts the process of rerouting traffic from instances in
                *             the original environment to instances in the replacement environment without waiting for
                *             a specified wait time to elapse. (Traffic rerouting, which is achieved by registering
                *             instances in the replacement environment with the load balancer, can start as soon as
                *             all instances have a status of Ready.) </p>
                */
            continueDeployment(args: ContinueDeploymentCommandInput, options?: __HttpHandlerOptions): Promise<ContinueDeploymentCommandOutput>;
            continueDeployment(args: ContinueDeploymentCommandInput, cb: (err: any, data?: ContinueDeploymentCommandOutput) => void): void;
            continueDeployment(args: ContinueDeploymentCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ContinueDeploymentCommandOutput) => void): void;
            /**
                * <p>Creates an application.</p>
                */
            createApplication(args: CreateApplicationCommandInput, options?: __HttpHandlerOptions): Promise<CreateApplicationCommandOutput>;
            createApplication(args: CreateApplicationCommandInput, cb: (err: any, data?: CreateApplicationCommandOutput) => void): void;
            createApplication(args: CreateApplicationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateApplicationCommandOutput) => void): void;
            /**
                * <p>Deploys an application revision through the specified deployment group.</p>
                */
            createDeployment(args: CreateDeploymentCommandInput, options?: __HttpHandlerOptions): Promise<CreateDeploymentCommandOutput>;
            createDeployment(args: CreateDeploymentCommandInput, cb: (err: any, data?: CreateDeploymentCommandOutput) => void): void;
            createDeployment(args: CreateDeploymentCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateDeploymentCommandOutput) => void): void;
            /**
                * <p> Creates a deployment configuration. </p>
                */
            createDeploymentConfig(args: CreateDeploymentConfigCommandInput, options?: __HttpHandlerOptions): Promise<CreateDeploymentConfigCommandOutput>;
            createDeploymentConfig(args: CreateDeploymentConfigCommandInput, cb: (err: any, data?: CreateDeploymentConfigCommandOutput) => void): void;
            createDeploymentConfig(args: CreateDeploymentConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateDeploymentConfigCommandOutput) => void): void;
            /**
                * <p>Creates a deployment group to which application revisions are deployed.</p>
                */
            createDeploymentGroup(args: CreateDeploymentGroupCommandInput, options?: __HttpHandlerOptions): Promise<CreateDeploymentGroupCommandOutput>;
            createDeploymentGroup(args: CreateDeploymentGroupCommandInput, cb: (err: any, data?: CreateDeploymentGroupCommandOutput) => void): void;
            createDeploymentGroup(args: CreateDeploymentGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateDeploymentGroupCommandOutput) => void): void;
            /**
                * <p>Deletes an application.</p>
                */
            deleteApplication(args: DeleteApplicationCommandInput, options?: __HttpHandlerOptions): Promise<DeleteApplicationCommandOutput>;
            deleteApplication(args: DeleteApplicationCommandInput, cb: (err: any, data?: DeleteApplicationCommandOutput) => void): void;
            deleteApplication(args: DeleteApplicationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteApplicationCommandOutput) => void): void;
            /**
                * <p>Deletes a deployment configuration.</p>
                *         <note>
                *             <p>A deployment configuration cannot be deleted if it is currently in use. Predefined
                *                 configurations cannot be deleted.</p>
                *         </note>
                */
            deleteDeploymentConfig(args: DeleteDeploymentConfigCommandInput, options?: __HttpHandlerOptions): Promise<DeleteDeploymentConfigCommandOutput>;
            deleteDeploymentConfig(args: DeleteDeploymentConfigCommandInput, cb: (err: any, data?: DeleteDeploymentConfigCommandOutput) => void): void;
            deleteDeploymentConfig(args: DeleteDeploymentConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteDeploymentConfigCommandOutput) => void): void;
            /**
                * <p>Deletes a deployment group.</p>
                */
            deleteDeploymentGroup(args: DeleteDeploymentGroupCommandInput, options?: __HttpHandlerOptions): Promise<DeleteDeploymentGroupCommandOutput>;
            deleteDeploymentGroup(args: DeleteDeploymentGroupCommandInput, cb: (err: any, data?: DeleteDeploymentGroupCommandOutput) => void): void;
            deleteDeploymentGroup(args: DeleteDeploymentGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteDeploymentGroupCommandOutput) => void): void;
            /**
                * <p>Deletes a GitHub account connection.</p>
                */
            deleteGitHubAccountToken(args: DeleteGitHubAccountTokenCommandInput, options?: __HttpHandlerOptions): Promise<DeleteGitHubAccountTokenCommandOutput>;
            deleteGitHubAccountToken(args: DeleteGitHubAccountTokenCommandInput, cb: (err: any, data?: DeleteGitHubAccountTokenCommandOutput) => void): void;
            deleteGitHubAccountToken(args: DeleteGitHubAccountTokenCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteGitHubAccountTokenCommandOutput) => void): void;
            /**
                * <p>Deletes resources linked to an external ID.</p>
                */
            deleteResourcesByExternalId(args: DeleteResourcesByExternalIdCommandInput, options?: __HttpHandlerOptions): Promise<DeleteResourcesByExternalIdCommandOutput>;
            deleteResourcesByExternalId(args: DeleteResourcesByExternalIdCommandInput, cb: (err: any, data?: DeleteResourcesByExternalIdCommandOutput) => void): void;
            deleteResourcesByExternalId(args: DeleteResourcesByExternalIdCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteResourcesByExternalIdCommandOutput) => void): void;
            /**
                * <p>Deregisters an on-premises instance.</p>
                */
            deregisterOnPremisesInstance(args: DeregisterOnPremisesInstanceCommandInput, options?: __HttpHandlerOptions): Promise<DeregisterOnPremisesInstanceCommandOutput>;
            deregisterOnPremisesInstance(args: DeregisterOnPremisesInstanceCommandInput, cb: (err: any, data?: DeregisterOnPremisesInstanceCommandOutput) => void): void;
            deregisterOnPremisesInstance(args: DeregisterOnPremisesInstanceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeregisterOnPremisesInstanceCommandOutput) => void): void;
            /**
                * <p>Gets information about an application.</p>
                */
            getApplication(args: GetApplicationCommandInput, options?: __HttpHandlerOptions): Promise<GetApplicationCommandOutput>;
            getApplication(args: GetApplicationCommandInput, cb: (err: any, data?: GetApplicationCommandOutput) => void): void;
            getApplication(args: GetApplicationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetApplicationCommandOutput) => void): void;
            /**
                * <p>Gets information about an application revision.</p>
                */
            getApplicationRevision(args: GetApplicationRevisionCommandInput, options?: __HttpHandlerOptions): Promise<GetApplicationRevisionCommandOutput>;
            getApplicationRevision(args: GetApplicationRevisionCommandInput, cb: (err: any, data?: GetApplicationRevisionCommandOutput) => void): void;
            getApplicationRevision(args: GetApplicationRevisionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetApplicationRevisionCommandOutput) => void): void;
            /**
                * <p>Gets information about a deployment.</p>
                *         <note>
                *             <p> The <code>content</code> property of the <code>appSpecContent</code> object in
                *                 the returned revision is always null. Use <code>GetApplicationRevision</code> and
                *                 the <code>sha256</code> property of the returned <code>appSpecContent</code> object
                *                 to get the content of the deployment’s AppSpec file. </p>
                *         </note>
                */
            getDeployment(args: GetDeploymentCommandInput, options?: __HttpHandlerOptions): Promise<GetDeploymentCommandOutput>;
            getDeployment(args: GetDeploymentCommandInput, cb: (err: any, data?: GetDeploymentCommandOutput) => void): void;
            getDeployment(args: GetDeploymentCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetDeploymentCommandOutput) => void): void;
            /**
                * <p>Gets information about a deployment configuration.</p>
                */
            getDeploymentConfig(args: GetDeploymentConfigCommandInput, options?: __HttpHandlerOptions): Promise<GetDeploymentConfigCommandOutput>;
            getDeploymentConfig(args: GetDeploymentConfigCommandInput, cb: (err: any, data?: GetDeploymentConfigCommandOutput) => void): void;
            getDeploymentConfig(args: GetDeploymentConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetDeploymentConfigCommandOutput) => void): void;
            /**
                * <p>Gets information about a deployment group.</p>
                */
            getDeploymentGroup(args: GetDeploymentGroupCommandInput, options?: __HttpHandlerOptions): Promise<GetDeploymentGroupCommandOutput>;
            getDeploymentGroup(args: GetDeploymentGroupCommandInput, cb: (err: any, data?: GetDeploymentGroupCommandOutput) => void): void;
            getDeploymentGroup(args: GetDeploymentGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetDeploymentGroupCommandOutput) => void): void;
            /**
                * @deprecated
                *
                * <p>Gets information about an instance as part of a deployment.</p>
                */
            getDeploymentInstance(args: GetDeploymentInstanceCommandInput, options?: __HttpHandlerOptions): Promise<GetDeploymentInstanceCommandOutput>;
            getDeploymentInstance(args: GetDeploymentInstanceCommandInput, cb: (err: any, data?: GetDeploymentInstanceCommandOutput) => void): void;
            getDeploymentInstance(args: GetDeploymentInstanceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetDeploymentInstanceCommandOutput) => void): void;
            /**
                * <p> Returns information about a deployment target. </p>
                */
            getDeploymentTarget(args: GetDeploymentTargetCommandInput, options?: __HttpHandlerOptions): Promise<GetDeploymentTargetCommandOutput>;
            getDeploymentTarget(args: GetDeploymentTargetCommandInput, cb: (err: any, data?: GetDeploymentTargetCommandOutput) => void): void;
            getDeploymentTarget(args: GetDeploymentTargetCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetDeploymentTargetCommandOutput) => void): void;
            /**
                * <p> Gets information about an on-premises instance. </p>
                */
            getOnPremisesInstance(args: GetOnPremisesInstanceCommandInput, options?: __HttpHandlerOptions): Promise<GetOnPremisesInstanceCommandOutput>;
            getOnPremisesInstance(args: GetOnPremisesInstanceCommandInput, cb: (err: any, data?: GetOnPremisesInstanceCommandOutput) => void): void;
            getOnPremisesInstance(args: GetOnPremisesInstanceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetOnPremisesInstanceCommandOutput) => void): void;
            /**
                * <p>Lists information about revisions for an application.</p>
                */
            listApplicationRevisions(args: ListApplicationRevisionsCommandInput, options?: __HttpHandlerOptions): Promise<ListApplicationRevisionsCommandOutput>;
            listApplicationRevisions(args: ListApplicationRevisionsCommandInput, cb: (err: any, data?: ListApplicationRevisionsCommandOutput) => void): void;
            listApplicationRevisions(args: ListApplicationRevisionsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListApplicationRevisionsCommandOutput) => void): void;
            /**
                * <p>Lists the applications registered with the IAM user or AWS account.</p>
                */
            listApplications(args: ListApplicationsCommandInput, options?: __HttpHandlerOptions): Promise<ListApplicationsCommandOutput>;
            listApplications(args: ListApplicationsCommandInput, cb: (err: any, data?: ListApplicationsCommandOutput) => void): void;
            listApplications(args: ListApplicationsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListApplicationsCommandOutput) => void): void;
            /**
                * <p>Lists the deployment configurations with the IAM user or AWS account.</p>
                */
            listDeploymentConfigs(args: ListDeploymentConfigsCommandInput, options?: __HttpHandlerOptions): Promise<ListDeploymentConfigsCommandOutput>;
            listDeploymentConfigs(args: ListDeploymentConfigsCommandInput, cb: (err: any, data?: ListDeploymentConfigsCommandOutput) => void): void;
            listDeploymentConfigs(args: ListDeploymentConfigsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListDeploymentConfigsCommandOutput) => void): void;
            /**
                * <p>Lists the deployment groups for an application registered with the IAM user or AWS
                *             account.</p>
                */
            listDeploymentGroups(args: ListDeploymentGroupsCommandInput, options?: __HttpHandlerOptions): Promise<ListDeploymentGroupsCommandOutput>;
            listDeploymentGroups(args: ListDeploymentGroupsCommandInput, cb: (err: any, data?: ListDeploymentGroupsCommandOutput) => void): void;
            listDeploymentGroups(args: ListDeploymentGroupsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListDeploymentGroupsCommandOutput) => void): void;
            /**
                * @deprecated
                *
                * <note>
                *             <p> The newer <code>BatchGetDeploymentTargets</code> should be used instead because
                *                 it works with all compute types. <code>ListDeploymentInstances</code> throws an
                *                 exception if it is used with a compute platform other than EC2/On-premises or AWS
                *                 Lambda. </p>
                *         </note>
                *         <p> Lists the instance for a deployment associated with the IAM user or AWS account. </p>
                */
            listDeploymentInstances(args: ListDeploymentInstancesCommandInput, options?: __HttpHandlerOptions): Promise<ListDeploymentInstancesCommandOutput>;
            listDeploymentInstances(args: ListDeploymentInstancesCommandInput, cb: (err: any, data?: ListDeploymentInstancesCommandOutput) => void): void;
            listDeploymentInstances(args: ListDeploymentInstancesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListDeploymentInstancesCommandOutput) => void): void;
            /**
                * <p>Lists the deployments in a deployment group for an application registered with the IAM
                *             user or AWS account.</p>
                */
            listDeployments(args: ListDeploymentsCommandInput, options?: __HttpHandlerOptions): Promise<ListDeploymentsCommandOutput>;
            listDeployments(args: ListDeploymentsCommandInput, cb: (err: any, data?: ListDeploymentsCommandOutput) => void): void;
            listDeployments(args: ListDeploymentsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListDeploymentsCommandOutput) => void): void;
            /**
                * <p> Returns an array of target IDs that are associated a deployment. </p>
                */
            listDeploymentTargets(args: ListDeploymentTargetsCommandInput, options?: __HttpHandlerOptions): Promise<ListDeploymentTargetsCommandOutput>;
            listDeploymentTargets(args: ListDeploymentTargetsCommandInput, cb: (err: any, data?: ListDeploymentTargetsCommandOutput) => void): void;
            listDeploymentTargets(args: ListDeploymentTargetsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListDeploymentTargetsCommandOutput) => void): void;
            /**
                * <p>Lists the names of stored connections to GitHub accounts.</p>
                */
            listGitHubAccountTokenNames(args: ListGitHubAccountTokenNamesCommandInput, options?: __HttpHandlerOptions): Promise<ListGitHubAccountTokenNamesCommandOutput>;
            listGitHubAccountTokenNames(args: ListGitHubAccountTokenNamesCommandInput, cb: (err: any, data?: ListGitHubAccountTokenNamesCommandOutput) => void): void;
            listGitHubAccountTokenNames(args: ListGitHubAccountTokenNamesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListGitHubAccountTokenNamesCommandOutput) => void): void;
            /**
                * <p>Gets a list of names for one or more on-premises instances.</p>
                *         <p>Unless otherwise specified, both registered and deregistered on-premises instance
                *             names are listed. To list only registered or deregistered on-premises instance names,
                *             use the registration status parameter.</p>
                */
            listOnPremisesInstances(args: ListOnPremisesInstancesCommandInput, options?: __HttpHandlerOptions): Promise<ListOnPremisesInstancesCommandOutput>;
            listOnPremisesInstances(args: ListOnPremisesInstancesCommandInput, cb: (err: any, data?: ListOnPremisesInstancesCommandOutput) => void): void;
            listOnPremisesInstances(args: ListOnPremisesInstancesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListOnPremisesInstancesCommandOutput) => void): void;
            /**
                * <p> Returns a list of tags for the resource identified by a specified Amazon Resource
                *             Name (ARN). Tags are used to organize and categorize your CodeDeploy resources. </p>
                */
            listTagsForResource(args: ListTagsForResourceCommandInput, options?: __HttpHandlerOptions): Promise<ListTagsForResourceCommandOutput>;
            listTagsForResource(args: ListTagsForResourceCommandInput, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            listTagsForResource(args: ListTagsForResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            /**
                * <p> Sets the result of a Lambda validation function. The function validates lifecycle
                *             hooks during a deployment that uses the AWS Lambda or Amazon ECS compute platform. For
                *             AWS Lambda deployments, the available lifecycle hooks are
                *                 <code>BeforeAllowTraffic</code> and <code>AfterAllowTraffic</code>. For Amazon ECS
                *             deployments, the available lifecycle hooks are <code>BeforeInstall</code>,
                *                 <code>AfterInstall</code>, <code>AfterAllowTestTraffic</code>,
                *                 <code>BeforeAllowTraffic</code>, and <code>AfterAllowTraffic</code>. Lambda
                *             validation functions return <code>Succeeded</code> or <code>Failed</code>. For more
                *             information, see <a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/reference-appspec-file-structure-hooks.html#appspec-hooks-lambda">AppSpec 'hooks' Section for an AWS Lambda Deployment </a> and <a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/reference-appspec-file-structure-hooks.html#appspec-hooks-ecs">AppSpec 'hooks' Section for an Amazon ECS Deployment</a>.</p>
                */
            putLifecycleEventHookExecutionStatus(args: PutLifecycleEventHookExecutionStatusCommandInput, options?: __HttpHandlerOptions): Promise<PutLifecycleEventHookExecutionStatusCommandOutput>;
            putLifecycleEventHookExecutionStatus(args: PutLifecycleEventHookExecutionStatusCommandInput, cb: (err: any, data?: PutLifecycleEventHookExecutionStatusCommandOutput) => void): void;
            putLifecycleEventHookExecutionStatus(args: PutLifecycleEventHookExecutionStatusCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutLifecycleEventHookExecutionStatusCommandOutput) => void): void;
            /**
                * <p>Registers with AWS CodeDeploy a revision for the specified application.</p>
                */
            registerApplicationRevision(args: RegisterApplicationRevisionCommandInput, options?: __HttpHandlerOptions): Promise<RegisterApplicationRevisionCommandOutput>;
            registerApplicationRevision(args: RegisterApplicationRevisionCommandInput, cb: (err: any, data?: RegisterApplicationRevisionCommandOutput) => void): void;
            registerApplicationRevision(args: RegisterApplicationRevisionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RegisterApplicationRevisionCommandOutput) => void): void;
            /**
                * <p>Registers an on-premises instance.</p>
                *         <note>
                *             <p>Only one IAM ARN (an IAM session ARN or IAM user ARN) is supported in the request.
                *                 You cannot use both.</p>
                *         </note>
                */
            registerOnPremisesInstance(args: RegisterOnPremisesInstanceCommandInput, options?: __HttpHandlerOptions): Promise<RegisterOnPremisesInstanceCommandOutput>;
            registerOnPremisesInstance(args: RegisterOnPremisesInstanceCommandInput, cb: (err: any, data?: RegisterOnPremisesInstanceCommandOutput) => void): void;
            registerOnPremisesInstance(args: RegisterOnPremisesInstanceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RegisterOnPremisesInstanceCommandOutput) => void): void;
            /**
                * <p>Removes one or more tags from one or more on-premises instances.</p>
                */
            removeTagsFromOnPremisesInstances(args: RemoveTagsFromOnPremisesInstancesCommandInput, options?: __HttpHandlerOptions): Promise<RemoveTagsFromOnPremisesInstancesCommandOutput>;
            removeTagsFromOnPremisesInstances(args: RemoveTagsFromOnPremisesInstancesCommandInput, cb: (err: any, data?: RemoveTagsFromOnPremisesInstancesCommandOutput) => void): void;
            removeTagsFromOnPremisesInstances(args: RemoveTagsFromOnPremisesInstancesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RemoveTagsFromOnPremisesInstancesCommandOutput) => void): void;
            /**
                * @deprecated
                *
                * <p>In a blue/green deployment, overrides any specified wait time and starts terminating
                *             instances immediately after the traffic routing is complete.</p>
                */
            skipWaitTimeForInstanceTermination(args: SkipWaitTimeForInstanceTerminationCommandInput, options?: __HttpHandlerOptions): Promise<SkipWaitTimeForInstanceTerminationCommandOutput>;
            skipWaitTimeForInstanceTermination(args: SkipWaitTimeForInstanceTerminationCommandInput, cb: (err: any, data?: SkipWaitTimeForInstanceTerminationCommandOutput) => void): void;
            skipWaitTimeForInstanceTermination(args: SkipWaitTimeForInstanceTerminationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: SkipWaitTimeForInstanceTerminationCommandOutput) => void): void;
            /**
                * <p>Attempts to stop an ongoing deployment.</p>
                */
            stopDeployment(args: StopDeploymentCommandInput, options?: __HttpHandlerOptions): Promise<StopDeploymentCommandOutput>;
            stopDeployment(args: StopDeploymentCommandInput, cb: (err: any, data?: StopDeploymentCommandOutput) => void): void;
            stopDeployment(args: StopDeploymentCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: StopDeploymentCommandOutput) => void): void;
            /**
                * <p> Associates the list of tags in the input <code>Tags</code> parameter with the
                *             resource identified by the <code>ResourceArn</code> input parameter. </p>
                */
            tagResource(args: TagResourceCommandInput, options?: __HttpHandlerOptions): Promise<TagResourceCommandOutput>;
            tagResource(args: TagResourceCommandInput, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            tagResource(args: TagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            /**
                * <p> Disassociates a resource from a list of tags. The resource is identified by the
                *                 <code>ResourceArn</code> input parameter. The tags are identified by the list of
                *             keys in the <code>TagKeys</code> input parameter. </p>
                */
            untagResource(args: UntagResourceCommandInput, options?: __HttpHandlerOptions): Promise<UntagResourceCommandOutput>;
            untagResource(args: UntagResourceCommandInput, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            untagResource(args: UntagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            /**
                * <p>Changes the name of an application.</p>
                */
            updateApplication(args: UpdateApplicationCommandInput, options?: __HttpHandlerOptions): Promise<UpdateApplicationCommandOutput>;
            updateApplication(args: UpdateApplicationCommandInput, cb: (err: any, data?: UpdateApplicationCommandOutput) => void): void;
            updateApplication(args: UpdateApplicationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateApplicationCommandOutput) => void): void;
            /**
                * <p>Changes information about a deployment group.</p>
                */
            updateDeploymentGroup(args: UpdateDeploymentGroupCommandInput, options?: __HttpHandlerOptions): Promise<UpdateDeploymentGroupCommandOutput>;
            updateDeploymentGroup(args: UpdateDeploymentGroupCommandInput, cb: (err: any, data?: UpdateDeploymentGroupCommandOutput) => void): void;
            updateDeploymentGroup(args: UpdateDeploymentGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateDeploymentGroupCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { AddTagsToOnPremisesInstancesCommandInput, AddTagsToOnPremisesInstancesCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/AddTagsToOnPremisesInstancesCommand";
    import { BatchGetApplicationRevisionsCommandInput, BatchGetApplicationRevisionsCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/BatchGetApplicationRevisionsCommand";
    import { BatchGetApplicationsCommandInput, BatchGetApplicationsCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/BatchGetApplicationsCommand";
    import { BatchGetDeploymentGroupsCommandInput, BatchGetDeploymentGroupsCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/BatchGetDeploymentGroupsCommand";
    import { BatchGetDeploymentInstancesCommandInput, BatchGetDeploymentInstancesCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/BatchGetDeploymentInstancesCommand";
    import { BatchGetDeploymentsCommandInput, BatchGetDeploymentsCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/BatchGetDeploymentsCommand";
    import { BatchGetDeploymentTargetsCommandInput, BatchGetDeploymentTargetsCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/BatchGetDeploymentTargetsCommand";
    import { BatchGetOnPremisesInstancesCommandInput, BatchGetOnPremisesInstancesCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/BatchGetOnPremisesInstancesCommand";
    import { ContinueDeploymentCommandInput, ContinueDeploymentCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ContinueDeploymentCommand";
    import { CreateApplicationCommandInput, CreateApplicationCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/CreateApplicationCommand";
    import { CreateDeploymentCommandInput, CreateDeploymentCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/CreateDeploymentCommand";
    import { CreateDeploymentConfigCommandInput, CreateDeploymentConfigCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/CreateDeploymentConfigCommand";
    import { CreateDeploymentGroupCommandInput, CreateDeploymentGroupCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/CreateDeploymentGroupCommand";
    import { DeleteApplicationCommandInput, DeleteApplicationCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/DeleteApplicationCommand";
    import { DeleteDeploymentConfigCommandInput, DeleteDeploymentConfigCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/DeleteDeploymentConfigCommand";
    import { DeleteDeploymentGroupCommandInput, DeleteDeploymentGroupCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/DeleteDeploymentGroupCommand";
    import { DeleteGitHubAccountTokenCommandInput, DeleteGitHubAccountTokenCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/DeleteGitHubAccountTokenCommand";
    import { DeleteResourcesByExternalIdCommandInput, DeleteResourcesByExternalIdCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/DeleteResourcesByExternalIdCommand";
    import { DeregisterOnPremisesInstanceCommandInput, DeregisterOnPremisesInstanceCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/DeregisterOnPremisesInstanceCommand";
    import { GetApplicationCommandInput, GetApplicationCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetApplicationCommand";
    import { GetApplicationRevisionCommandInput, GetApplicationRevisionCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetApplicationRevisionCommand";
    import { GetDeploymentCommandInput, GetDeploymentCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetDeploymentCommand";
    import { GetDeploymentConfigCommandInput, GetDeploymentConfigCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetDeploymentConfigCommand";
    import { GetDeploymentGroupCommandInput, GetDeploymentGroupCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetDeploymentGroupCommand";
    import { GetDeploymentInstanceCommandInput, GetDeploymentInstanceCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetDeploymentInstanceCommand";
    import { GetDeploymentTargetCommandInput, GetDeploymentTargetCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetDeploymentTargetCommand";
    import { GetOnPremisesInstanceCommandInput, GetOnPremisesInstanceCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetOnPremisesInstanceCommand";
    import { ListApplicationRevisionsCommandInput, ListApplicationRevisionsCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListApplicationRevisionsCommand";
    import { ListApplicationsCommandInput, ListApplicationsCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListApplicationsCommand";
    import { ListDeploymentConfigsCommandInput, ListDeploymentConfigsCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListDeploymentConfigsCommand";
    import { ListDeploymentGroupsCommandInput, ListDeploymentGroupsCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListDeploymentGroupsCommand";
    import { ListDeploymentInstancesCommandInput, ListDeploymentInstancesCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListDeploymentInstancesCommand";
    import { ListDeploymentsCommandInput, ListDeploymentsCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListDeploymentsCommand";
    import { ListDeploymentTargetsCommandInput, ListDeploymentTargetsCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListDeploymentTargetsCommand";
    import { ListGitHubAccountTokenNamesCommandInput, ListGitHubAccountTokenNamesCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListGitHubAccountTokenNamesCommand";
    import { ListOnPremisesInstancesCommandInput, ListOnPremisesInstancesCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListOnPremisesInstancesCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListTagsForResourceCommand";
    import { PutLifecycleEventHookExecutionStatusCommandInput, PutLifecycleEventHookExecutionStatusCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/PutLifecycleEventHookExecutionStatusCommand";
    import { RegisterApplicationRevisionCommandInput, RegisterApplicationRevisionCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/RegisterApplicationRevisionCommand";
    import { RegisterOnPremisesInstanceCommandInput, RegisterOnPremisesInstanceCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/RegisterOnPremisesInstanceCommand";
    import { RemoveTagsFromOnPremisesInstancesCommandInput, RemoveTagsFromOnPremisesInstancesCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/RemoveTagsFromOnPremisesInstancesCommand";
    import { SkipWaitTimeForInstanceTerminationCommandInput, SkipWaitTimeForInstanceTerminationCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/SkipWaitTimeForInstanceTerminationCommand";
    import { StopDeploymentCommandInput, StopDeploymentCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/StopDeploymentCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/UntagResourceCommand";
    import { UpdateApplicationCommandInput, UpdateApplicationCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/UpdateApplicationCommand";
    import { UpdateDeploymentGroupCommandInput, UpdateDeploymentGroupCommandOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/UpdateDeploymentGroupCommand";
    export type ServiceInputTypes = AddTagsToOnPremisesInstancesCommandInput | BatchGetApplicationRevisionsCommandInput | BatchGetApplicationsCommandInput | BatchGetDeploymentGroupsCommandInput | BatchGetDeploymentInstancesCommandInput | BatchGetDeploymentTargetsCommandInput | BatchGetDeploymentsCommandInput | BatchGetOnPremisesInstancesCommandInput | ContinueDeploymentCommandInput | CreateApplicationCommandInput | CreateDeploymentCommandInput | CreateDeploymentConfigCommandInput | CreateDeploymentGroupCommandInput | DeleteApplicationCommandInput | DeleteDeploymentConfigCommandInput | DeleteDeploymentGroupCommandInput | DeleteGitHubAccountTokenCommandInput | DeleteResourcesByExternalIdCommandInput | DeregisterOnPremisesInstanceCommandInput | GetApplicationCommandInput | GetApplicationRevisionCommandInput | GetDeploymentCommandInput | GetDeploymentConfigCommandInput | GetDeploymentGroupCommandInput | GetDeploymentInstanceCommandInput | GetDeploymentTargetCommandInput | GetOnPremisesInstanceCommandInput | ListApplicationRevisionsCommandInput | ListApplicationsCommandInput | ListDeploymentConfigsCommandInput | ListDeploymentGroupsCommandInput | ListDeploymentInstancesCommandInput | ListDeploymentTargetsCommandInput | ListDeploymentsCommandInput | ListGitHubAccountTokenNamesCommandInput | ListOnPremisesInstancesCommandInput | ListTagsForResourceCommandInput | PutLifecycleEventHookExecutionStatusCommandInput | RegisterApplicationRevisionCommandInput | RegisterOnPremisesInstanceCommandInput | RemoveTagsFromOnPremisesInstancesCommandInput | SkipWaitTimeForInstanceTerminationCommandInput | StopDeploymentCommandInput | TagResourceCommandInput | UntagResourceCommandInput | UpdateApplicationCommandInput | UpdateDeploymentGroupCommandInput;
    export type ServiceOutputTypes = AddTagsToOnPremisesInstancesCommandOutput | BatchGetApplicationRevisionsCommandOutput | BatchGetApplicationsCommandOutput | BatchGetDeploymentGroupsCommandOutput | BatchGetDeploymentInstancesCommandOutput | BatchGetDeploymentTargetsCommandOutput | BatchGetDeploymentsCommandOutput | BatchGetOnPremisesInstancesCommandOutput | ContinueDeploymentCommandOutput | CreateApplicationCommandOutput | CreateDeploymentCommandOutput | CreateDeploymentConfigCommandOutput | CreateDeploymentGroupCommandOutput | DeleteApplicationCommandOutput | DeleteDeploymentConfigCommandOutput | DeleteDeploymentGroupCommandOutput | DeleteGitHubAccountTokenCommandOutput | DeleteResourcesByExternalIdCommandOutput | DeregisterOnPremisesInstanceCommandOutput | GetApplicationCommandOutput | GetApplicationRevisionCommandOutput | GetDeploymentCommandOutput | GetDeploymentConfigCommandOutput | GetDeploymentGroupCommandOutput | GetDeploymentInstanceCommandOutput | GetDeploymentTargetCommandOutput | GetOnPremisesInstanceCommandOutput | ListApplicationRevisionsCommandOutput | ListApplicationsCommandOutput | ListDeploymentConfigsCommandOutput | ListDeploymentGroupsCommandOutput | ListDeploymentInstancesCommandOutput | ListDeploymentTargetsCommandOutput | ListDeploymentsCommandOutput | ListGitHubAccountTokenNamesCommandOutput | ListOnPremisesInstancesCommandOutput | ListTagsForResourceCommandOutput | PutLifecycleEventHookExecutionStatusCommandOutput | RegisterApplicationRevisionCommandOutput | RegisterOnPremisesInstanceCommandOutput | RemoveTagsFromOnPremisesInstancesCommandOutput | SkipWaitTimeForInstanceTerminationCommandOutput | StopDeploymentCommandOutput | TagResourceCommandOutput | UntagResourceCommandOutput | UpdateApplicationCommandOutput | UpdateDeploymentGroupCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type CodeDeployClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of CodeDeployClient class constructor that set the region, credentials and other options.
        */
    export interface CodeDeployClientConfig extends CodeDeployClientConfigType {
    }
    type CodeDeployClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of CodeDeployClient class. This is resolved and normalized from the {@link CodeDeployClientConfig | constructor configuration interface}.
        */
    export interface CodeDeployClientResolvedConfig extends CodeDeployClientResolvedConfigType {
    }
    /**
        * <fullname>AWS CodeDeploy</fullname>
        *         <p>AWS CodeDeploy is a deployment service that automates application deployments to
        *             Amazon EC2 instances, on-premises instances running in your own facility, serverless AWS
        *             Lambda functions, or applications in an Amazon ECS service.</p>
        *         <p>You can deploy a nearly unlimited variety of application content, such as an updated
        *             Lambda function, updated applications in an Amazon ECS service, code, web and
        *             configuration files, executables, packages, scripts, multimedia files, and so on. AWS
        *             CodeDeploy can deploy application content stored in Amazon S3 buckets, GitHub
        *             repositories, or Bitbucket repositories. You do not need to make changes to your
        *             existing code before you can use AWS CodeDeploy.</p>
        *         <p>AWS CodeDeploy makes it easier for you to rapidly release new features, helps you
        *             avoid downtime during application deployment, and handles the complexity of updating
        *             your applications, without many of the risks associated with error-prone manual
        *             deployments.</p>
        *         <p>
        *             <b>AWS CodeDeploy Components</b>
        *         </p>
        *         <p>Use the information in this guide to help you work with the following AWS CodeDeploy
        *             components:</p>
        *         <ul>
        *             <li>
        *                 <p>
        *                     <b>Application</b>: A name that uniquely identifies
        *                     the application you want to deploy. AWS CodeDeploy uses this name, which
        *                     functions as a container, to ensure the correct combination of revision,
        *                     deployment configuration, and deployment group are referenced during a
        *                     deployment.</p>
        *             </li>
        *             <li>
        *                 <p>
        *                     <b>Deployment group</b>: A set of individual
        *                     instances, CodeDeploy Lambda deployment configuration settings, or an Amazon ECS
        *                     service and network details. A Lambda deployment group specifies how to route
        *                     traffic to a new version of a Lambda function. An Amazon ECS deployment group
        *                     specifies the service created in Amazon ECS to deploy, a load balancer, and a
        *                     listener to reroute production traffic to an updated containerized application.
        *                     An EC2/On-premises deployment group contains individually tagged instances,
        *                     Amazon EC2 instances in Amazon EC2 Auto Scaling groups, or both. All deployment
        *                     groups can specify optional trigger, alarm, and rollback settings.</p>
        *             </li>
        *             <li>
        *                 <p>
        *                     <b>Deployment configuration</b>: A set of deployment
        *                     rules and deployment success and failure conditions used by AWS CodeDeploy
        *                     during a deployment.</p>
        *             </li>
        *             <li>
        *                 <p>
        *                     <b>Deployment</b>: The process and the components used
        *                     when updating a Lambda function, a containerized application in an Amazon ECS
        *                     service, or of installing content on one or more instances. </p>
        *             </li>
        *             <li>
        *                 <p>
        *                     <b>Application revisions</b>: For an AWS Lambda
        *                     deployment, this is an AppSpec file that specifies the Lambda function to be
        *                     updated and one or more functions to validate deployment lifecycle events. For
        *                     an Amazon ECS deployment, this is an AppSpec file that specifies the Amazon ECS
        *                     task definition, container, and port where production traffic is rerouted. For
        *                     an EC2/On-premises deployment, this is an archive file that contains source
        *                     content—source code, webpages, executable files, and deployment scripts—along
        *                     with an AppSpec file. Revisions are stored in Amazon S3 buckets or GitHub
        *                     repositories. For Amazon S3, a revision is uniquely identified by its Amazon S3
        *                     object key and its ETag, version, or both. For GitHub, a revision is uniquely
        *                     identified by its commit ID.</p>
        *             </li>
        *          </ul>
        *         <p>This guide also contains information to help you get details about the instances in
        *             your deployments, to make on-premises instances available for AWS CodeDeploy
        *             deployments, to get details about a Lambda function deployment, and to get details about
        *             Amazon ECS service deployments.</p>
        *         <p>
        *             <b>AWS CodeDeploy Information Resources</b>
        *          </p>
        *         <ul>
        *             <li>
        *                 <p>
        *                   <a href="https://docs.aws.amazon.com/codedeploy/latest/userguide">AWS CodeDeploy
        *                         User Guide</a>
        *                </p>
        *             </li>
        *             <li>
        *                 <p>
        *                   <a href="https://docs.aws.amazon.com/codedeploy/latest/APIReference/">AWS
        *                         CodeDeploy API Reference Guide</a>
        *                </p>
        *             </li>
        *             <li>
        *                 <p>
        *                   <a href="https://docs.aws.amazon.com/cli/latest/reference/deploy/index.html">AWS
        *                         CLI Reference for AWS CodeDeploy</a>
        *                </p>
        *             </li>
        *             <li>
        *                 <p>
        *                     <a href="https://forums.aws.amazon.com/forum.jspa?forumID=179">AWS CodeDeploy
        *                         Developer Forum</a>
        *                 </p>
        *             </li>
        *          </ul>
        */
    export class CodeDeployClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, CodeDeployClientResolvedConfig> {
            /**
                * The resolved configuration of CodeDeployClient class. This is resolved and normalized from the {@link CodeDeployClientConfig | constructor configuration interface}.
                */
            readonly config: CodeDeployClientResolvedConfig;
            constructor(configuration: CodeDeployClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/AddTagsToOnPremisesInstancesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { AddTagsToOnPremisesInstancesInput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface AddTagsToOnPremisesInstancesCommandInput extends AddTagsToOnPremisesInstancesInput {
    }
    export interface AddTagsToOnPremisesInstancesCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Adds tags to on-premises instances.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, AddTagsToOnPremisesInstancesCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, AddTagsToOnPremisesInstancesCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new AddTagsToOnPremisesInstancesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link AddTagsToOnPremisesInstancesCommandInput} for command's `input` shape.
        * @see {@link AddTagsToOnPremisesInstancesCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class AddTagsToOnPremisesInstancesCommand extends $Command<AddTagsToOnPremisesInstancesCommandInput, AddTagsToOnPremisesInstancesCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: AddTagsToOnPremisesInstancesCommandInput;
            constructor(input: AddTagsToOnPremisesInstancesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<AddTagsToOnPremisesInstancesCommandInput, AddTagsToOnPremisesInstancesCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/BatchGetApplicationRevisionsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { BatchGetApplicationRevisionsInput, BatchGetApplicationRevisionsOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface BatchGetApplicationRevisionsCommandInput extends BatchGetApplicationRevisionsInput {
    }
    export interface BatchGetApplicationRevisionsCommandOutput extends BatchGetApplicationRevisionsOutput, __MetadataBearer {
    }
    /**
        * <p>Gets information about one or more application revisions. The maximum number of
        *             application revisions that can be returned is 25.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, BatchGetApplicationRevisionsCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, BatchGetApplicationRevisionsCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new BatchGetApplicationRevisionsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchGetApplicationRevisionsCommandInput} for command's `input` shape.
        * @see {@link BatchGetApplicationRevisionsCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class BatchGetApplicationRevisionsCommand extends $Command<BatchGetApplicationRevisionsCommandInput, BatchGetApplicationRevisionsCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: BatchGetApplicationRevisionsCommandInput;
            constructor(input: BatchGetApplicationRevisionsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchGetApplicationRevisionsCommandInput, BatchGetApplicationRevisionsCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/BatchGetApplicationsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { BatchGetApplicationsInput, BatchGetApplicationsOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface BatchGetApplicationsCommandInput extends BatchGetApplicationsInput {
    }
    export interface BatchGetApplicationsCommandOutput extends BatchGetApplicationsOutput, __MetadataBearer {
    }
    /**
        * <p>Gets information about one or more applications. The maximum number of applications
        *             that can be returned is 100.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, BatchGetApplicationsCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, BatchGetApplicationsCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new BatchGetApplicationsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchGetApplicationsCommandInput} for command's `input` shape.
        * @see {@link BatchGetApplicationsCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class BatchGetApplicationsCommand extends $Command<BatchGetApplicationsCommandInput, BatchGetApplicationsCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: BatchGetApplicationsCommandInput;
            constructor(input: BatchGetApplicationsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchGetApplicationsCommandInput, BatchGetApplicationsCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/BatchGetDeploymentGroupsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { BatchGetDeploymentGroupsInput, BatchGetDeploymentGroupsOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface BatchGetDeploymentGroupsCommandInput extends BatchGetDeploymentGroupsInput {
    }
    export interface BatchGetDeploymentGroupsCommandOutput extends BatchGetDeploymentGroupsOutput, __MetadataBearer {
    }
    /**
        * <p>Gets information about one or more deployment groups.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, BatchGetDeploymentGroupsCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, BatchGetDeploymentGroupsCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new BatchGetDeploymentGroupsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchGetDeploymentGroupsCommandInput} for command's `input` shape.
        * @see {@link BatchGetDeploymentGroupsCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class BatchGetDeploymentGroupsCommand extends $Command<BatchGetDeploymentGroupsCommandInput, BatchGetDeploymentGroupsCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: BatchGetDeploymentGroupsCommandInput;
            constructor(input: BatchGetDeploymentGroupsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchGetDeploymentGroupsCommandInput, BatchGetDeploymentGroupsCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/BatchGetDeploymentInstancesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { BatchGetDeploymentInstancesInput, BatchGetDeploymentInstancesOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface BatchGetDeploymentInstancesCommandInput extends BatchGetDeploymentInstancesInput {
    }
    export interface BatchGetDeploymentInstancesCommandOutput extends BatchGetDeploymentInstancesOutput, __MetadataBearer {
    }
    /**
        * @deprecated
        *
        * <note>
        *             <p> This method works, but is deprecated. Use <code>BatchGetDeploymentTargets</code>
        *                 instead. </p>
        *         </note>
        *         <p> Returns an array of one or more instances associated with a deployment. This method
        *             works with EC2/On-premises and AWS Lambda compute platforms. The newer
        *                 <code>BatchGetDeploymentTargets</code> works with all compute platforms. The maximum
        *             number of instances that can be returned is 25.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, BatchGetDeploymentInstancesCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, BatchGetDeploymentInstancesCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new BatchGetDeploymentInstancesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchGetDeploymentInstancesCommandInput} for command's `input` shape.
        * @see {@link BatchGetDeploymentInstancesCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class BatchGetDeploymentInstancesCommand extends $Command<BatchGetDeploymentInstancesCommandInput, BatchGetDeploymentInstancesCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: BatchGetDeploymentInstancesCommandInput;
            constructor(input: BatchGetDeploymentInstancesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchGetDeploymentInstancesCommandInput, BatchGetDeploymentInstancesCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/BatchGetDeploymentsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { BatchGetDeploymentsInput, BatchGetDeploymentsOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface BatchGetDeploymentsCommandInput extends BatchGetDeploymentsInput {
    }
    export interface BatchGetDeploymentsCommandOutput extends BatchGetDeploymentsOutput, __MetadataBearer {
    }
    /**
        * <p>Gets information about one or more deployments. The maximum number of deployments that
        *             can be returned is 25.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, BatchGetDeploymentsCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, BatchGetDeploymentsCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new BatchGetDeploymentsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchGetDeploymentsCommandInput} for command's `input` shape.
        * @see {@link BatchGetDeploymentsCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class BatchGetDeploymentsCommand extends $Command<BatchGetDeploymentsCommandInput, BatchGetDeploymentsCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: BatchGetDeploymentsCommandInput;
            constructor(input: BatchGetDeploymentsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchGetDeploymentsCommandInput, BatchGetDeploymentsCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/BatchGetDeploymentTargetsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { BatchGetDeploymentTargetsInput, BatchGetDeploymentTargetsOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface BatchGetDeploymentTargetsCommandInput extends BatchGetDeploymentTargetsInput {
    }
    export interface BatchGetDeploymentTargetsCommandOutput extends BatchGetDeploymentTargetsOutput, __MetadataBearer {
    }
    /**
        * <p> Returns an array of one or more targets associated with a deployment. This method
        *             works with all compute types and should be used instead of the deprecated
        *                 <code>BatchGetDeploymentInstances</code>. The maximum number of targets that can be
        *             returned is 25.</p>
        *         <p> The type of targets returned depends on the deployment's compute platform or
        *             deployment method: </p>
        *         <ul>
        *             <li>
        *                 <p>
        *                     <b>EC2/On-premises</b>: Information about EC2 instance
        *                     targets. </p>
        *             </li>
        *             <li>
        *                 <p>
        *                     <b>AWS Lambda</b>: Information about Lambda functions
        *                     targets. </p>
        *             </li>
        *             <li>
        *                 <p>
        *                     <b>Amazon ECS</b>: Information about Amazon ECS
        *                     service targets. </p>
        *             </li>
        *             <li>
        *                 <p>
        *                   <b>CloudFormation</b>: Information about targets of
        *                     blue/green deployments initiated by a CloudFormation stack update.</p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, BatchGetDeploymentTargetsCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, BatchGetDeploymentTargetsCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new BatchGetDeploymentTargetsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchGetDeploymentTargetsCommandInput} for command's `input` shape.
        * @see {@link BatchGetDeploymentTargetsCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class BatchGetDeploymentTargetsCommand extends $Command<BatchGetDeploymentTargetsCommandInput, BatchGetDeploymentTargetsCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: BatchGetDeploymentTargetsCommandInput;
            constructor(input: BatchGetDeploymentTargetsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchGetDeploymentTargetsCommandInput, BatchGetDeploymentTargetsCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/BatchGetOnPremisesInstancesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { BatchGetOnPremisesInstancesInput, BatchGetOnPremisesInstancesOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface BatchGetOnPremisesInstancesCommandInput extends BatchGetOnPremisesInstancesInput {
    }
    export interface BatchGetOnPremisesInstancesCommandOutput extends BatchGetOnPremisesInstancesOutput, __MetadataBearer {
    }
    /**
        * <p>Gets information about one or more on-premises instances. The maximum number of
        *             on-premises instances that can be returned is 25.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, BatchGetOnPremisesInstancesCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, BatchGetOnPremisesInstancesCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new BatchGetOnPremisesInstancesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchGetOnPremisesInstancesCommandInput} for command's `input` shape.
        * @see {@link BatchGetOnPremisesInstancesCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class BatchGetOnPremisesInstancesCommand extends $Command<BatchGetOnPremisesInstancesCommandInput, BatchGetOnPremisesInstancesCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: BatchGetOnPremisesInstancesCommandInput;
            constructor(input: BatchGetOnPremisesInstancesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchGetOnPremisesInstancesCommandInput, BatchGetOnPremisesInstancesCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ContinueDeploymentCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { ContinueDeploymentInput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface ContinueDeploymentCommandInput extends ContinueDeploymentInput {
    }
    export interface ContinueDeploymentCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>For a blue/green deployment, starts the process of rerouting traffic from instances in
        *             the original environment to instances in the replacement environment without waiting for
        *             a specified wait time to elapse. (Traffic rerouting, which is achieved by registering
        *             instances in the replacement environment with the load balancer, can start as soon as
        *             all instances have a status of Ready.) </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, ContinueDeploymentCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, ContinueDeploymentCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new ContinueDeploymentCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ContinueDeploymentCommandInput} for command's `input` shape.
        * @see {@link ContinueDeploymentCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class ContinueDeploymentCommand extends $Command<ContinueDeploymentCommandInput, ContinueDeploymentCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: ContinueDeploymentCommandInput;
            constructor(input: ContinueDeploymentCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ContinueDeploymentCommandInput, ContinueDeploymentCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/CreateApplicationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { CreateApplicationInput, CreateApplicationOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface CreateApplicationCommandInput extends CreateApplicationInput {
    }
    export interface CreateApplicationCommandOutput extends CreateApplicationOutput, __MetadataBearer {
    }
    /**
        * <p>Creates an application.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, CreateApplicationCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, CreateApplicationCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new CreateApplicationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateApplicationCommandInput} for command's `input` shape.
        * @see {@link CreateApplicationCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class CreateApplicationCommand extends $Command<CreateApplicationCommandInput, CreateApplicationCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: CreateApplicationCommandInput;
            constructor(input: CreateApplicationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateApplicationCommandInput, CreateApplicationCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/CreateDeploymentCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { CreateDeploymentInput, CreateDeploymentOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface CreateDeploymentCommandInput extends CreateDeploymentInput {
    }
    export interface CreateDeploymentCommandOutput extends CreateDeploymentOutput, __MetadataBearer {
    }
    /**
        * <p>Deploys an application revision through the specified deployment group.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, CreateDeploymentCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, CreateDeploymentCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new CreateDeploymentCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateDeploymentCommandInput} for command's `input` shape.
        * @see {@link CreateDeploymentCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class CreateDeploymentCommand extends $Command<CreateDeploymentCommandInput, CreateDeploymentCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: CreateDeploymentCommandInput;
            constructor(input: CreateDeploymentCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateDeploymentCommandInput, CreateDeploymentCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/CreateDeploymentConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { CreateDeploymentConfigInput, CreateDeploymentConfigOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface CreateDeploymentConfigCommandInput extends CreateDeploymentConfigInput {
    }
    export interface CreateDeploymentConfigCommandOutput extends CreateDeploymentConfigOutput, __MetadataBearer {
    }
    /**
        * <p> Creates a deployment configuration. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, CreateDeploymentConfigCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, CreateDeploymentConfigCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new CreateDeploymentConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateDeploymentConfigCommandInput} for command's `input` shape.
        * @see {@link CreateDeploymentConfigCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class CreateDeploymentConfigCommand extends $Command<CreateDeploymentConfigCommandInput, CreateDeploymentConfigCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: CreateDeploymentConfigCommandInput;
            constructor(input: CreateDeploymentConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateDeploymentConfigCommandInput, CreateDeploymentConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/CreateDeploymentGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { CreateDeploymentGroupInput, CreateDeploymentGroupOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface CreateDeploymentGroupCommandInput extends CreateDeploymentGroupInput {
    }
    export interface CreateDeploymentGroupCommandOutput extends CreateDeploymentGroupOutput, __MetadataBearer {
    }
    /**
        * <p>Creates a deployment group to which application revisions are deployed.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, CreateDeploymentGroupCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, CreateDeploymentGroupCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new CreateDeploymentGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateDeploymentGroupCommandInput} for command's `input` shape.
        * @see {@link CreateDeploymentGroupCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class CreateDeploymentGroupCommand extends $Command<CreateDeploymentGroupCommandInput, CreateDeploymentGroupCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: CreateDeploymentGroupCommandInput;
            constructor(input: CreateDeploymentGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateDeploymentGroupCommandInput, CreateDeploymentGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/DeleteApplicationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { DeleteApplicationInput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface DeleteApplicationCommandInput extends DeleteApplicationInput {
    }
    export interface DeleteApplicationCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes an application.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, DeleteApplicationCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, DeleteApplicationCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new DeleteApplicationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteApplicationCommandInput} for command's `input` shape.
        * @see {@link DeleteApplicationCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class DeleteApplicationCommand extends $Command<DeleteApplicationCommandInput, DeleteApplicationCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: DeleteApplicationCommandInput;
            constructor(input: DeleteApplicationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteApplicationCommandInput, DeleteApplicationCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/DeleteDeploymentConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { DeleteDeploymentConfigInput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface DeleteDeploymentConfigCommandInput extends DeleteDeploymentConfigInput {
    }
    export interface DeleteDeploymentConfigCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes a deployment configuration.</p>
        *         <note>
        *             <p>A deployment configuration cannot be deleted if it is currently in use. Predefined
        *                 configurations cannot be deleted.</p>
        *         </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, DeleteDeploymentConfigCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, DeleteDeploymentConfigCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new DeleteDeploymentConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteDeploymentConfigCommandInput} for command's `input` shape.
        * @see {@link DeleteDeploymentConfigCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class DeleteDeploymentConfigCommand extends $Command<DeleteDeploymentConfigCommandInput, DeleteDeploymentConfigCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: DeleteDeploymentConfigCommandInput;
            constructor(input: DeleteDeploymentConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteDeploymentConfigCommandInput, DeleteDeploymentConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/DeleteDeploymentGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { DeleteDeploymentGroupInput, DeleteDeploymentGroupOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface DeleteDeploymentGroupCommandInput extends DeleteDeploymentGroupInput {
    }
    export interface DeleteDeploymentGroupCommandOutput extends DeleteDeploymentGroupOutput, __MetadataBearer {
    }
    /**
        * <p>Deletes a deployment group.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, DeleteDeploymentGroupCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, DeleteDeploymentGroupCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new DeleteDeploymentGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteDeploymentGroupCommandInput} for command's `input` shape.
        * @see {@link DeleteDeploymentGroupCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class DeleteDeploymentGroupCommand extends $Command<DeleteDeploymentGroupCommandInput, DeleteDeploymentGroupCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: DeleteDeploymentGroupCommandInput;
            constructor(input: DeleteDeploymentGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteDeploymentGroupCommandInput, DeleteDeploymentGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/DeleteGitHubAccountTokenCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { DeleteGitHubAccountTokenInput, DeleteGitHubAccountTokenOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface DeleteGitHubAccountTokenCommandInput extends DeleteGitHubAccountTokenInput {
    }
    export interface DeleteGitHubAccountTokenCommandOutput extends DeleteGitHubAccountTokenOutput, __MetadataBearer {
    }
    /**
        * <p>Deletes a GitHub account connection.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, DeleteGitHubAccountTokenCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, DeleteGitHubAccountTokenCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new DeleteGitHubAccountTokenCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteGitHubAccountTokenCommandInput} for command's `input` shape.
        * @see {@link DeleteGitHubAccountTokenCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class DeleteGitHubAccountTokenCommand extends $Command<DeleteGitHubAccountTokenCommandInput, DeleteGitHubAccountTokenCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: DeleteGitHubAccountTokenCommandInput;
            constructor(input: DeleteGitHubAccountTokenCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteGitHubAccountTokenCommandInput, DeleteGitHubAccountTokenCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/DeleteResourcesByExternalIdCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { DeleteResourcesByExternalIdInput, DeleteResourcesByExternalIdOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface DeleteResourcesByExternalIdCommandInput extends DeleteResourcesByExternalIdInput {
    }
    export interface DeleteResourcesByExternalIdCommandOutput extends DeleteResourcesByExternalIdOutput, __MetadataBearer {
    }
    /**
        * <p>Deletes resources linked to an external ID.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, DeleteResourcesByExternalIdCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, DeleteResourcesByExternalIdCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new DeleteResourcesByExternalIdCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteResourcesByExternalIdCommandInput} for command's `input` shape.
        * @see {@link DeleteResourcesByExternalIdCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class DeleteResourcesByExternalIdCommand extends $Command<DeleteResourcesByExternalIdCommandInput, DeleteResourcesByExternalIdCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: DeleteResourcesByExternalIdCommandInput;
            constructor(input: DeleteResourcesByExternalIdCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteResourcesByExternalIdCommandInput, DeleteResourcesByExternalIdCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/DeregisterOnPremisesInstanceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { DeregisterOnPremisesInstanceInput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface DeregisterOnPremisesInstanceCommandInput extends DeregisterOnPremisesInstanceInput {
    }
    export interface DeregisterOnPremisesInstanceCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deregisters an on-premises instance.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, DeregisterOnPremisesInstanceCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, DeregisterOnPremisesInstanceCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new DeregisterOnPremisesInstanceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeregisterOnPremisesInstanceCommandInput} for command's `input` shape.
        * @see {@link DeregisterOnPremisesInstanceCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class DeregisterOnPremisesInstanceCommand extends $Command<DeregisterOnPremisesInstanceCommandInput, DeregisterOnPremisesInstanceCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: DeregisterOnPremisesInstanceCommandInput;
            constructor(input: DeregisterOnPremisesInstanceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeregisterOnPremisesInstanceCommandInput, DeregisterOnPremisesInstanceCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetApplicationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { GetApplicationInput, GetApplicationOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface GetApplicationCommandInput extends GetApplicationInput {
    }
    export interface GetApplicationCommandOutput extends GetApplicationOutput, __MetadataBearer {
    }
    /**
        * <p>Gets information about an application.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, GetApplicationCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, GetApplicationCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new GetApplicationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetApplicationCommandInput} for command's `input` shape.
        * @see {@link GetApplicationCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class GetApplicationCommand extends $Command<GetApplicationCommandInput, GetApplicationCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: GetApplicationCommandInput;
            constructor(input: GetApplicationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetApplicationCommandInput, GetApplicationCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetApplicationRevisionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { GetApplicationRevisionInput, GetApplicationRevisionOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface GetApplicationRevisionCommandInput extends GetApplicationRevisionInput {
    }
    export interface GetApplicationRevisionCommandOutput extends GetApplicationRevisionOutput, __MetadataBearer {
    }
    /**
        * <p>Gets information about an application revision.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, GetApplicationRevisionCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, GetApplicationRevisionCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new GetApplicationRevisionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetApplicationRevisionCommandInput} for command's `input` shape.
        * @see {@link GetApplicationRevisionCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class GetApplicationRevisionCommand extends $Command<GetApplicationRevisionCommandInput, GetApplicationRevisionCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: GetApplicationRevisionCommandInput;
            constructor(input: GetApplicationRevisionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetApplicationRevisionCommandInput, GetApplicationRevisionCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetDeploymentCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { GetDeploymentInput, GetDeploymentOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface GetDeploymentCommandInput extends GetDeploymentInput {
    }
    export interface GetDeploymentCommandOutput extends GetDeploymentOutput, __MetadataBearer {
    }
    /**
        * <p>Gets information about a deployment.</p>
        *         <note>
        *             <p> The <code>content</code> property of the <code>appSpecContent</code> object in
        *                 the returned revision is always null. Use <code>GetApplicationRevision</code> and
        *                 the <code>sha256</code> property of the returned <code>appSpecContent</code> object
        *                 to get the content of the deployment’s AppSpec file. </p>
        *         </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, GetDeploymentCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, GetDeploymentCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new GetDeploymentCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetDeploymentCommandInput} for command's `input` shape.
        * @see {@link GetDeploymentCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class GetDeploymentCommand extends $Command<GetDeploymentCommandInput, GetDeploymentCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: GetDeploymentCommandInput;
            constructor(input: GetDeploymentCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetDeploymentCommandInput, GetDeploymentCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetDeploymentConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { GetDeploymentConfigInput, GetDeploymentConfigOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface GetDeploymentConfigCommandInput extends GetDeploymentConfigInput {
    }
    export interface GetDeploymentConfigCommandOutput extends GetDeploymentConfigOutput, __MetadataBearer {
    }
    /**
        * <p>Gets information about a deployment configuration.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, GetDeploymentConfigCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, GetDeploymentConfigCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new GetDeploymentConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetDeploymentConfigCommandInput} for command's `input` shape.
        * @see {@link GetDeploymentConfigCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class GetDeploymentConfigCommand extends $Command<GetDeploymentConfigCommandInput, GetDeploymentConfigCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: GetDeploymentConfigCommandInput;
            constructor(input: GetDeploymentConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetDeploymentConfigCommandInput, GetDeploymentConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetDeploymentGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { GetDeploymentGroupInput, GetDeploymentGroupOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface GetDeploymentGroupCommandInput extends GetDeploymentGroupInput {
    }
    export interface GetDeploymentGroupCommandOutput extends GetDeploymentGroupOutput, __MetadataBearer {
    }
    /**
        * <p>Gets information about a deployment group.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, GetDeploymentGroupCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, GetDeploymentGroupCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new GetDeploymentGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetDeploymentGroupCommandInput} for command's `input` shape.
        * @see {@link GetDeploymentGroupCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class GetDeploymentGroupCommand extends $Command<GetDeploymentGroupCommandInput, GetDeploymentGroupCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: GetDeploymentGroupCommandInput;
            constructor(input: GetDeploymentGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetDeploymentGroupCommandInput, GetDeploymentGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetDeploymentInstanceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { GetDeploymentInstanceInput, GetDeploymentInstanceOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface GetDeploymentInstanceCommandInput extends GetDeploymentInstanceInput {
    }
    export interface GetDeploymentInstanceCommandOutput extends GetDeploymentInstanceOutput, __MetadataBearer {
    }
    /**
        * @deprecated
        *
        * <p>Gets information about an instance as part of a deployment.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, GetDeploymentInstanceCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, GetDeploymentInstanceCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new GetDeploymentInstanceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetDeploymentInstanceCommandInput} for command's `input` shape.
        * @see {@link GetDeploymentInstanceCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class GetDeploymentInstanceCommand extends $Command<GetDeploymentInstanceCommandInput, GetDeploymentInstanceCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: GetDeploymentInstanceCommandInput;
            constructor(input: GetDeploymentInstanceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetDeploymentInstanceCommandInput, GetDeploymentInstanceCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetDeploymentTargetCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { GetDeploymentTargetInput, GetDeploymentTargetOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface GetDeploymentTargetCommandInput extends GetDeploymentTargetInput {
    }
    export interface GetDeploymentTargetCommandOutput extends GetDeploymentTargetOutput, __MetadataBearer {
    }
    /**
        * <p> Returns information about a deployment target. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, GetDeploymentTargetCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, GetDeploymentTargetCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new GetDeploymentTargetCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetDeploymentTargetCommandInput} for command's `input` shape.
        * @see {@link GetDeploymentTargetCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class GetDeploymentTargetCommand extends $Command<GetDeploymentTargetCommandInput, GetDeploymentTargetCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: GetDeploymentTargetCommandInput;
            constructor(input: GetDeploymentTargetCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetDeploymentTargetCommandInput, GetDeploymentTargetCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/GetOnPremisesInstanceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { GetOnPremisesInstanceInput, GetOnPremisesInstanceOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface GetOnPremisesInstanceCommandInput extends GetOnPremisesInstanceInput {
    }
    export interface GetOnPremisesInstanceCommandOutput extends GetOnPremisesInstanceOutput, __MetadataBearer {
    }
    /**
        * <p> Gets information about an on-premises instance. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, GetOnPremisesInstanceCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, GetOnPremisesInstanceCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new GetOnPremisesInstanceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetOnPremisesInstanceCommandInput} for command's `input` shape.
        * @see {@link GetOnPremisesInstanceCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class GetOnPremisesInstanceCommand extends $Command<GetOnPremisesInstanceCommandInput, GetOnPremisesInstanceCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: GetOnPremisesInstanceCommandInput;
            constructor(input: GetOnPremisesInstanceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetOnPremisesInstanceCommandInput, GetOnPremisesInstanceCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListApplicationRevisionsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { ListApplicationRevisionsInput, ListApplicationRevisionsOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface ListApplicationRevisionsCommandInput extends ListApplicationRevisionsInput {
    }
    export interface ListApplicationRevisionsCommandOutput extends ListApplicationRevisionsOutput, __MetadataBearer {
    }
    /**
        * <p>Lists information about revisions for an application.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, ListApplicationRevisionsCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, ListApplicationRevisionsCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new ListApplicationRevisionsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListApplicationRevisionsCommandInput} for command's `input` shape.
        * @see {@link ListApplicationRevisionsCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class ListApplicationRevisionsCommand extends $Command<ListApplicationRevisionsCommandInput, ListApplicationRevisionsCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: ListApplicationRevisionsCommandInput;
            constructor(input: ListApplicationRevisionsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListApplicationRevisionsCommandInput, ListApplicationRevisionsCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListApplicationsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { ListApplicationsInput, ListApplicationsOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface ListApplicationsCommandInput extends ListApplicationsInput {
    }
    export interface ListApplicationsCommandOutput extends ListApplicationsOutput, __MetadataBearer {
    }
    /**
        * <p>Lists the applications registered with the IAM user or AWS account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, ListApplicationsCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, ListApplicationsCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new ListApplicationsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListApplicationsCommandInput} for command's `input` shape.
        * @see {@link ListApplicationsCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class ListApplicationsCommand extends $Command<ListApplicationsCommandInput, ListApplicationsCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: ListApplicationsCommandInput;
            constructor(input: ListApplicationsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListApplicationsCommandInput, ListApplicationsCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListDeploymentConfigsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { ListDeploymentConfigsInput, ListDeploymentConfigsOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface ListDeploymentConfigsCommandInput extends ListDeploymentConfigsInput {
    }
    export interface ListDeploymentConfigsCommandOutput extends ListDeploymentConfigsOutput, __MetadataBearer {
    }
    /**
        * <p>Lists the deployment configurations with the IAM user or AWS account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, ListDeploymentConfigsCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, ListDeploymentConfigsCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new ListDeploymentConfigsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListDeploymentConfigsCommandInput} for command's `input` shape.
        * @see {@link ListDeploymentConfigsCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class ListDeploymentConfigsCommand extends $Command<ListDeploymentConfigsCommandInput, ListDeploymentConfigsCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: ListDeploymentConfigsCommandInput;
            constructor(input: ListDeploymentConfigsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListDeploymentConfigsCommandInput, ListDeploymentConfigsCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListDeploymentGroupsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { ListDeploymentGroupsInput, ListDeploymentGroupsOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface ListDeploymentGroupsCommandInput extends ListDeploymentGroupsInput {
    }
    export interface ListDeploymentGroupsCommandOutput extends ListDeploymentGroupsOutput, __MetadataBearer {
    }
    /**
        * <p>Lists the deployment groups for an application registered with the IAM user or AWS
        *             account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, ListDeploymentGroupsCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, ListDeploymentGroupsCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new ListDeploymentGroupsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListDeploymentGroupsCommandInput} for command's `input` shape.
        * @see {@link ListDeploymentGroupsCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class ListDeploymentGroupsCommand extends $Command<ListDeploymentGroupsCommandInput, ListDeploymentGroupsCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: ListDeploymentGroupsCommandInput;
            constructor(input: ListDeploymentGroupsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListDeploymentGroupsCommandInput, ListDeploymentGroupsCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListDeploymentInstancesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { ListDeploymentInstancesInput, ListDeploymentInstancesOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface ListDeploymentInstancesCommandInput extends ListDeploymentInstancesInput {
    }
    export interface ListDeploymentInstancesCommandOutput extends ListDeploymentInstancesOutput, __MetadataBearer {
    }
    /**
        * @deprecated
        *
        * <note>
        *             <p> The newer <code>BatchGetDeploymentTargets</code> should be used instead because
        *                 it works with all compute types. <code>ListDeploymentInstances</code> throws an
        *                 exception if it is used with a compute platform other than EC2/On-premises or AWS
        *                 Lambda. </p>
        *         </note>
        *         <p> Lists the instance for a deployment associated with the IAM user or AWS account. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, ListDeploymentInstancesCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, ListDeploymentInstancesCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new ListDeploymentInstancesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListDeploymentInstancesCommandInput} for command's `input` shape.
        * @see {@link ListDeploymentInstancesCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class ListDeploymentInstancesCommand extends $Command<ListDeploymentInstancesCommandInput, ListDeploymentInstancesCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: ListDeploymentInstancesCommandInput;
            constructor(input: ListDeploymentInstancesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListDeploymentInstancesCommandInput, ListDeploymentInstancesCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListDeploymentsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { ListDeploymentsInput, ListDeploymentsOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface ListDeploymentsCommandInput extends ListDeploymentsInput {
    }
    export interface ListDeploymentsCommandOutput extends ListDeploymentsOutput, __MetadataBearer {
    }
    /**
        * <p>Lists the deployments in a deployment group for an application registered with the IAM
        *             user or AWS account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, ListDeploymentsCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, ListDeploymentsCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new ListDeploymentsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListDeploymentsCommandInput} for command's `input` shape.
        * @see {@link ListDeploymentsCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class ListDeploymentsCommand extends $Command<ListDeploymentsCommandInput, ListDeploymentsCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: ListDeploymentsCommandInput;
            constructor(input: ListDeploymentsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListDeploymentsCommandInput, ListDeploymentsCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListDeploymentTargetsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { ListDeploymentTargetsInput, ListDeploymentTargetsOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface ListDeploymentTargetsCommandInput extends ListDeploymentTargetsInput {
    }
    export interface ListDeploymentTargetsCommandOutput extends ListDeploymentTargetsOutput, __MetadataBearer {
    }
    /**
        * <p> Returns an array of target IDs that are associated a deployment. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, ListDeploymentTargetsCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, ListDeploymentTargetsCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new ListDeploymentTargetsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListDeploymentTargetsCommandInput} for command's `input` shape.
        * @see {@link ListDeploymentTargetsCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class ListDeploymentTargetsCommand extends $Command<ListDeploymentTargetsCommandInput, ListDeploymentTargetsCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: ListDeploymentTargetsCommandInput;
            constructor(input: ListDeploymentTargetsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListDeploymentTargetsCommandInput, ListDeploymentTargetsCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListGitHubAccountTokenNamesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { ListGitHubAccountTokenNamesInput, ListGitHubAccountTokenNamesOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface ListGitHubAccountTokenNamesCommandInput extends ListGitHubAccountTokenNamesInput {
    }
    export interface ListGitHubAccountTokenNamesCommandOutput extends ListGitHubAccountTokenNamesOutput, __MetadataBearer {
    }
    /**
        * <p>Lists the names of stored connections to GitHub accounts.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, ListGitHubAccountTokenNamesCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, ListGitHubAccountTokenNamesCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new ListGitHubAccountTokenNamesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListGitHubAccountTokenNamesCommandInput} for command's `input` shape.
        * @see {@link ListGitHubAccountTokenNamesCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class ListGitHubAccountTokenNamesCommand extends $Command<ListGitHubAccountTokenNamesCommandInput, ListGitHubAccountTokenNamesCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: ListGitHubAccountTokenNamesCommandInput;
            constructor(input: ListGitHubAccountTokenNamesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListGitHubAccountTokenNamesCommandInput, ListGitHubAccountTokenNamesCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListOnPremisesInstancesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { ListOnPremisesInstancesInput, ListOnPremisesInstancesOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface ListOnPremisesInstancesCommandInput extends ListOnPremisesInstancesInput {
    }
    export interface ListOnPremisesInstancesCommandOutput extends ListOnPremisesInstancesOutput, __MetadataBearer {
    }
    /**
        * <p>Gets a list of names for one or more on-premises instances.</p>
        *         <p>Unless otherwise specified, both registered and deregistered on-premises instance
        *             names are listed. To list only registered or deregistered on-premises instance names,
        *             use the registration status parameter.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, ListOnPremisesInstancesCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, ListOnPremisesInstancesCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new ListOnPremisesInstancesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListOnPremisesInstancesCommandInput} for command's `input` shape.
        * @see {@link ListOnPremisesInstancesCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class ListOnPremisesInstancesCommand extends $Command<ListOnPremisesInstancesCommandInput, ListOnPremisesInstancesCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: ListOnPremisesInstancesCommandInput;
            constructor(input: ListOnPremisesInstancesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListOnPremisesInstancesCommandInput, ListOnPremisesInstancesCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/ListTagsForResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { ListTagsForResourceInput, ListTagsForResourceOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface ListTagsForResourceCommandInput extends ListTagsForResourceInput {
    }
    export interface ListTagsForResourceCommandOutput extends ListTagsForResourceOutput, __MetadataBearer {
    }
    /**
        * <p> Returns a list of tags for the resource identified by a specified Amazon Resource
        *             Name (ARN). Tags are used to organize and categorize your CodeDeploy resources. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, ListTagsForResourceCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, ListTagsForResourceCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new ListTagsForResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTagsForResourceCommandInput} for command's `input` shape.
        * @see {@link ListTagsForResourceCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class ListTagsForResourceCommand extends $Command<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: ListTagsForResourceCommandInput;
            constructor(input: ListTagsForResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/PutLifecycleEventHookExecutionStatusCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { PutLifecycleEventHookExecutionStatusInput, PutLifecycleEventHookExecutionStatusOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface PutLifecycleEventHookExecutionStatusCommandInput extends PutLifecycleEventHookExecutionStatusInput {
    }
    export interface PutLifecycleEventHookExecutionStatusCommandOutput extends PutLifecycleEventHookExecutionStatusOutput, __MetadataBearer {
    }
    /**
        * <p> Sets the result of a Lambda validation function. The function validates lifecycle
        *             hooks during a deployment that uses the AWS Lambda or Amazon ECS compute platform. For
        *             AWS Lambda deployments, the available lifecycle hooks are
        *                 <code>BeforeAllowTraffic</code> and <code>AfterAllowTraffic</code>. For Amazon ECS
        *             deployments, the available lifecycle hooks are <code>BeforeInstall</code>,
        *                 <code>AfterInstall</code>, <code>AfterAllowTestTraffic</code>,
        *                 <code>BeforeAllowTraffic</code>, and <code>AfterAllowTraffic</code>. Lambda
        *             validation functions return <code>Succeeded</code> or <code>Failed</code>. For more
        *             information, see <a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/reference-appspec-file-structure-hooks.html#appspec-hooks-lambda">AppSpec 'hooks' Section for an AWS Lambda Deployment </a> and <a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/reference-appspec-file-structure-hooks.html#appspec-hooks-ecs">AppSpec 'hooks' Section for an Amazon ECS Deployment</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, PutLifecycleEventHookExecutionStatusCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, PutLifecycleEventHookExecutionStatusCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new PutLifecycleEventHookExecutionStatusCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutLifecycleEventHookExecutionStatusCommandInput} for command's `input` shape.
        * @see {@link PutLifecycleEventHookExecutionStatusCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class PutLifecycleEventHookExecutionStatusCommand extends $Command<PutLifecycleEventHookExecutionStatusCommandInput, PutLifecycleEventHookExecutionStatusCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: PutLifecycleEventHookExecutionStatusCommandInput;
            constructor(input: PutLifecycleEventHookExecutionStatusCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutLifecycleEventHookExecutionStatusCommandInput, PutLifecycleEventHookExecutionStatusCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/RegisterApplicationRevisionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { RegisterApplicationRevisionInput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface RegisterApplicationRevisionCommandInput extends RegisterApplicationRevisionInput {
    }
    export interface RegisterApplicationRevisionCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Registers with AWS CodeDeploy a revision for the specified application.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, RegisterApplicationRevisionCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, RegisterApplicationRevisionCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new RegisterApplicationRevisionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RegisterApplicationRevisionCommandInput} for command's `input` shape.
        * @see {@link RegisterApplicationRevisionCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class RegisterApplicationRevisionCommand extends $Command<RegisterApplicationRevisionCommandInput, RegisterApplicationRevisionCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: RegisterApplicationRevisionCommandInput;
            constructor(input: RegisterApplicationRevisionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RegisterApplicationRevisionCommandInput, RegisterApplicationRevisionCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/RegisterOnPremisesInstanceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { RegisterOnPremisesInstanceInput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface RegisterOnPremisesInstanceCommandInput extends RegisterOnPremisesInstanceInput {
    }
    export interface RegisterOnPremisesInstanceCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Registers an on-premises instance.</p>
        *         <note>
        *             <p>Only one IAM ARN (an IAM session ARN or IAM user ARN) is supported in the request.
        *                 You cannot use both.</p>
        *         </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, RegisterOnPremisesInstanceCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, RegisterOnPremisesInstanceCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new RegisterOnPremisesInstanceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RegisterOnPremisesInstanceCommandInput} for command's `input` shape.
        * @see {@link RegisterOnPremisesInstanceCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class RegisterOnPremisesInstanceCommand extends $Command<RegisterOnPremisesInstanceCommandInput, RegisterOnPremisesInstanceCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: RegisterOnPremisesInstanceCommandInput;
            constructor(input: RegisterOnPremisesInstanceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RegisterOnPremisesInstanceCommandInput, RegisterOnPremisesInstanceCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/RemoveTagsFromOnPremisesInstancesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { RemoveTagsFromOnPremisesInstancesInput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface RemoveTagsFromOnPremisesInstancesCommandInput extends RemoveTagsFromOnPremisesInstancesInput {
    }
    export interface RemoveTagsFromOnPremisesInstancesCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Removes one or more tags from one or more on-premises instances.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, RemoveTagsFromOnPremisesInstancesCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, RemoveTagsFromOnPremisesInstancesCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new RemoveTagsFromOnPremisesInstancesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RemoveTagsFromOnPremisesInstancesCommandInput} for command's `input` shape.
        * @see {@link RemoveTagsFromOnPremisesInstancesCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class RemoveTagsFromOnPremisesInstancesCommand extends $Command<RemoveTagsFromOnPremisesInstancesCommandInput, RemoveTagsFromOnPremisesInstancesCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: RemoveTagsFromOnPremisesInstancesCommandInput;
            constructor(input: RemoveTagsFromOnPremisesInstancesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RemoveTagsFromOnPremisesInstancesCommandInput, RemoveTagsFromOnPremisesInstancesCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/SkipWaitTimeForInstanceTerminationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { SkipWaitTimeForInstanceTerminationInput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface SkipWaitTimeForInstanceTerminationCommandInput extends SkipWaitTimeForInstanceTerminationInput {
    }
    export interface SkipWaitTimeForInstanceTerminationCommandOutput extends __MetadataBearer {
    }
    /**
        * @deprecated
        *
        * <p>In a blue/green deployment, overrides any specified wait time and starts terminating
        *             instances immediately after the traffic routing is complete.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, SkipWaitTimeForInstanceTerminationCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, SkipWaitTimeForInstanceTerminationCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new SkipWaitTimeForInstanceTerminationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link SkipWaitTimeForInstanceTerminationCommandInput} for command's `input` shape.
        * @see {@link SkipWaitTimeForInstanceTerminationCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class SkipWaitTimeForInstanceTerminationCommand extends $Command<SkipWaitTimeForInstanceTerminationCommandInput, SkipWaitTimeForInstanceTerminationCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: SkipWaitTimeForInstanceTerminationCommandInput;
            constructor(input: SkipWaitTimeForInstanceTerminationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<SkipWaitTimeForInstanceTerminationCommandInput, SkipWaitTimeForInstanceTerminationCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/StopDeploymentCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { StopDeploymentInput, StopDeploymentOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface StopDeploymentCommandInput extends StopDeploymentInput {
    }
    export interface StopDeploymentCommandOutput extends StopDeploymentOutput, __MetadataBearer {
    }
    /**
        * <p>Attempts to stop an ongoing deployment.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, StopDeploymentCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, StopDeploymentCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new StopDeploymentCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link StopDeploymentCommandInput} for command's `input` shape.
        * @see {@link StopDeploymentCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class StopDeploymentCommand extends $Command<StopDeploymentCommandInput, StopDeploymentCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: StopDeploymentCommandInput;
            constructor(input: StopDeploymentCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<StopDeploymentCommandInput, StopDeploymentCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/TagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { TagResourceInput, TagResourceOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface TagResourceCommandInput extends TagResourceInput {
    }
    export interface TagResourceCommandOutput extends TagResourceOutput, __MetadataBearer {
    }
    /**
        * <p> Associates the list of tags in the input <code>Tags</code> parameter with the
        *             resource identified by the <code>ResourceArn</code> input parameter. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, TagResourceCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, TagResourceCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new TagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TagResourceCommandInput} for command's `input` shape.
        * @see {@link TagResourceCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class TagResourceCommand extends $Command<TagResourceCommandInput, TagResourceCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: TagResourceCommandInput;
            constructor(input: TagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TagResourceCommandInput, TagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/UntagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { UntagResourceInput, UntagResourceOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface UntagResourceCommandInput extends UntagResourceInput {
    }
    export interface UntagResourceCommandOutput extends UntagResourceOutput, __MetadataBearer {
    }
    /**
        * <p> Disassociates a resource from a list of tags. The resource is identified by the
        *                 <code>ResourceArn</code> input parameter. The tags are identified by the list of
        *             keys in the <code>TagKeys</code> input parameter. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, UntagResourceCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, UntagResourceCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new UntagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UntagResourceCommandInput} for command's `input` shape.
        * @see {@link UntagResourceCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class UntagResourceCommand extends $Command<UntagResourceCommandInput, UntagResourceCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: UntagResourceCommandInput;
            constructor(input: UntagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UntagResourceCommandInput, UntagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/UpdateApplicationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { UpdateApplicationInput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface UpdateApplicationCommandInput extends UpdateApplicationInput {
    }
    export interface UpdateApplicationCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Changes the name of an application.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, UpdateApplicationCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, UpdateApplicationCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new UpdateApplicationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateApplicationCommandInput} for command's `input` shape.
        * @see {@link UpdateApplicationCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class UpdateApplicationCommand extends $Command<UpdateApplicationCommandInput, UpdateApplicationCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: UpdateApplicationCommandInput;
            constructor(input: UpdateApplicationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateApplicationCommandInput, UpdateApplicationCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/commands/UpdateDeploymentGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CodeDeployClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/CodeDeployClient";
    import { UpdateDeploymentGroupInput, UpdateDeploymentGroupOutput } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0";
    export interface UpdateDeploymentGroupCommandInput extends UpdateDeploymentGroupInput {
    }
    export interface UpdateDeploymentGroupCommandOutput extends UpdateDeploymentGroupOutput, __MetadataBearer {
    }
    /**
        * <p>Changes information about a deployment group.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CodeDeployClient, UpdateDeploymentGroupCommand } from "@aws-sdk/client-codedeploy"; // ES Modules import
        * // const { CodeDeployClient, UpdateDeploymentGroupCommand } = require("@aws-sdk/client-codedeploy"); // CommonJS import
        * const client = new CodeDeployClient(config);
        * const command = new UpdateDeploymentGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateDeploymentGroupCommandInput} for command's `input` shape.
        * @see {@link UpdateDeploymentGroupCommandOutput} for command's `response` shape.
        * @see {@link CodeDeployClientResolvedConfig | config} for CodeDeployClient's `config` shape.
        *
        */
    export class UpdateDeploymentGroupCommand extends $Command<UpdateDeploymentGroupCommandInput, UpdateDeploymentGroupCommandOutput, CodeDeployClientResolvedConfig> {
            readonly input: UpdateDeploymentGroupCommandInput;
            constructor(input: UpdateDeploymentGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CodeDeployClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateDeploymentGroupCommandInput, UpdateDeploymentGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { CodeDeployServiceException as __BaseException } from "@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/CodeDeployServiceException";
    /**
        * <p>Information about a tag.</p>
        */
    export interface Tag {
            /**
                * <p>The tag's key.</p>
                */
            Key?: string;
            /**
                * <p>The tag's value.</p>
                */
            Value?: string;
    }
    export namespace Tag {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Tag) => any;
    }
    /**
        * <p>Represents the input of, and adds tags to, an on-premises instance operation.</p>
        */
    export interface AddTagsToOnPremisesInstancesInput {
            /**
                * <p>The tag key-value pairs to add to the on-premises instances.</p>
                *         <p>Keys and values are both required. Keys cannot be null or empty strings. Value-only
                *             tags are not allowed.</p>
                */
            tags: Tag[] | undefined;
            /**
                * <p>The names of the on-premises instances to which to add tags.</p>
                */
            instanceNames: string[] | undefined;
    }
    export namespace AddTagsToOnPremisesInstancesInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AddTagsToOnPremisesInstancesInput) => any;
    }
    /**
        * <p>The maximum number of allowed on-premises instances in a single call was
        *             exceeded.</p>
        */
    export class InstanceLimitExceededException extends __BaseException {
            readonly name: "InstanceLimitExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InstanceLimitExceededException, __BaseException>);
    }
    /**
        * <p>An on-premises instance name was not specified.</p>
        */
    export class InstanceNameRequiredException extends __BaseException {
            readonly name: "InstanceNameRequiredException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InstanceNameRequiredException, __BaseException>);
    }
    /**
        * <p>The specified on-premises instance is not registered.</p>
        */
    export class InstanceNotRegisteredException extends __BaseException {
            readonly name: "InstanceNotRegisteredException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InstanceNotRegisteredException, __BaseException>);
    }
    /**
        * <p>The on-premises instance name was specified in an invalid format.</p>
        */
    export class InvalidInstanceNameException extends __BaseException {
            readonly name: "InvalidInstanceNameException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidInstanceNameException, __BaseException>);
    }
    /**
        * <p>The tag was specified in an invalid format.</p>
        */
    export class InvalidTagException extends __BaseException {
            readonly name: "InvalidTagException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidTagException, __BaseException>);
    }
    /**
        * <p>The maximum allowed number of tags was exceeded.</p>
        */
    export class TagLimitExceededException extends __BaseException {
            readonly name: "TagLimitExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TagLimitExceededException, __BaseException>);
    }
    /**
        * <p>A tag was not specified.</p>
        */
    export class TagRequiredException extends __BaseException {
            readonly name: "TagRequiredException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TagRequiredException, __BaseException>);
    }
    /**
        * <p>Information about an alarm.</p>
        */
    export interface Alarm {
            /**
                * <p>The name of the alarm. Maximum length is 255 characters. Each alarm name can be used
                *             only once in a list of alarms.</p>
                */
            name?: string;
    }
    export namespace Alarm {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Alarm) => any;
    }
    /**
        * <p>Information about alarms associated with the deployment group.</p>
        */
    export interface AlarmConfiguration {
            /**
                * <p>Indicates whether the alarm configuration is enabled.</p>
                */
            enabled?: boolean;
            /**
                * <p>Indicates whether a deployment should continue if information about the current state
                *             of alarms cannot be retrieved from Amazon CloudWatch. The default value is false.</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>true</code>: The deployment proceeds even if alarm status information
                *                     can't be retrieved from Amazon CloudWatch.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>false</code>: The deployment stops if alarm status information can't be
                *                     retrieved from Amazon CloudWatch.</p>
                *             </li>
                *          </ul>
                */
            ignorePollAlarmFailure?: boolean;
            /**
                * <p>A list of alarms configured for the deployment group. A maximum of 10 alarms can be
                *             added to a deployment group.</p>
                */
            alarms?: Alarm[];
    }
    export namespace AlarmConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AlarmConfiguration) => any;
    }
    /**
        * <p>The maximum number of alarms for a deployment group (10) was exceeded.</p>
        */
    export class AlarmsLimitExceededException extends __BaseException {
            readonly name: "AlarmsLimitExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AlarmsLimitExceededException, __BaseException>);
    }
    /**
        * <p>An application with the specified name with the IAM user or AWS account already
        *             exists.</p>
        */
    export class ApplicationAlreadyExistsException extends __BaseException {
            readonly name: "ApplicationAlreadyExistsException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ApplicationAlreadyExistsException, __BaseException>);
    }
    /**
        * <p>The application does not exist with the IAM user or AWS account.</p>
        */
    export class ApplicationDoesNotExistException extends __BaseException {
            readonly name: "ApplicationDoesNotExistException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ApplicationDoesNotExistException, __BaseException>);
    }
    export enum ComputePlatform {
            ECS = "ECS",
            LAMBDA = "Lambda",
            SERVER = "Server"
    }
    /**
        * <p>Information about an application.</p>
        */
    export interface ApplicationInfo {
            /**
                * <p>The application ID.</p>
                */
            applicationId?: string;
            /**
                * <p>The application name.</p>
                */
            applicationName?: string;
            /**
                * <p>The time at which the application was created.</p>
                */
            createTime?: Date;
            /**
                * <p>True if the user has authenticated with GitHub for the specified application.
                *             Otherwise, false.</p>
                */
            linkedToGitHub?: boolean;
            /**
                * <p>The name for a connection to a GitHub account.</p>
                */
            gitHubAccountName?: string;
            /**
                * <p>The destination platform type for deployment of the application (<code>Lambda</code>
                *             or <code>Server</code>).</p>
                */
            computePlatform?: ComputePlatform | string;
    }
    export namespace ApplicationInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ApplicationInfo) => any;
    }
    /**
        * <p>More applications were attempted to be created than are allowed.</p>
        */
    export class ApplicationLimitExceededException extends __BaseException {
            readonly name: "ApplicationLimitExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ApplicationLimitExceededException, __BaseException>);
    }
    /**
        * <p>The minimum number of required application names was not specified.</p>
        */
    export class ApplicationNameRequiredException extends __BaseException {
            readonly name: "ApplicationNameRequiredException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ApplicationNameRequiredException, __BaseException>);
    }
    export enum ApplicationRevisionSortBy {
            FirstUsedTime = "firstUsedTime",
            LastUsedTime = "lastUsedTime",
            RegisterTime = "registerTime"
    }
    /**
        * <p> A revision for an AWS Lambda or Amazon ECS deployment that is a YAML-formatted or
        *             JSON-formatted string. For AWS Lambda and Amazon ECS deployments, the revision is the
        *             same as the AppSpec file. This method replaces the deprecated <code>RawString</code>
        *             data type. </p>
        */
    export interface AppSpecContent {
            /**
                * <p> The YAML-formatted or JSON-formatted revision string. </p>
                *         <p> For an AWS Lambda deployment, the content includes a Lambda function name, the alias
                *             for its original version, and the alias for its replacement version. The deployment
                *             shifts traffic from the original version of the Lambda function to the replacement
                *             version. </p>
                *         <p> For an Amazon ECS deployment, the content includes the task name, information about
                *             the load balancer that serves traffic to the container, and more. </p>
                *         <p> For both types of deployments, the content can specify Lambda functions that run at
                *             specified hooks, such as <code>BeforeInstall</code>, during a deployment. </p>
                */
            content?: string;
            /**
                * <p> The SHA256 hash value of the revision content. </p>
                */
            sha256?: string;
    }
    export namespace AppSpecContent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AppSpecContent) => any;
    }
    /**
        * <p> The specified ARN is not supported. For example, it might be an ARN for a resource
        *             that is not expected. </p>
        */
    export class ArnNotSupportedException extends __BaseException {
            readonly name: "ArnNotSupportedException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ArnNotSupportedException, __BaseException>);
    }
    export enum AutoRollbackEvent {
            DEPLOYMENT_FAILURE = "DEPLOYMENT_FAILURE",
            DEPLOYMENT_STOP_ON_ALARM = "DEPLOYMENT_STOP_ON_ALARM",
            DEPLOYMENT_STOP_ON_REQUEST = "DEPLOYMENT_STOP_ON_REQUEST"
    }
    /**
        * <p>Information about a configuration for automatically rolling back to a previous version
        *             of an application revision when a deployment is not completed successfully.</p>
        */
    export interface AutoRollbackConfiguration {
            /**
                * <p>Indicates whether a defined automatic rollback configuration is currently
                *             enabled.</p>
                */
            enabled?: boolean;
            /**
                * <p>The event type or types that trigger a rollback.</p>
                */
            events?: (AutoRollbackEvent | string)[];
    }
    export namespace AutoRollbackConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AutoRollbackConfiguration) => any;
    }
    /**
        * <p>Information about an Auto Scaling group.</p>
        */
    export interface AutoScalingGroup {
            /**
                * <p>The Auto Scaling group name.</p>
                */
            name?: string;
            /**
                * <p>An Auto Scaling lifecycle event hook name.</p>
                */
            hook?: string;
    }
    export namespace AutoScalingGroup {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AutoScalingGroup) => any;
    }
    /**
        * <p>Information about the location of application artifacts stored in GitHub.</p>
        */
    export interface GitHubLocation {
            /**
                * <p>The GitHub account and repository pair that stores a reference to the commit that
                *             represents the bundled artifacts for the application revision. </p>
                *         <p>Specified as account/repository.</p>
                */
            repository?: string;
            /**
                * <p>The SHA1 commit ID of the GitHub commit that represents the bundled artifacts for the
                *             application revision.</p>
                */
            commitId?: string;
    }
    export namespace GitHubLocation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GitHubLocation) => any;
    }
    export enum RevisionLocationType {
            AppSpecContent = "AppSpecContent",
            GitHub = "GitHub",
            S3 = "S3",
            String = "String"
    }
    export enum BundleType {
            JSON = "JSON",
            Tar = "tar",
            TarGZip = "tgz",
            YAML = "YAML",
            Zip = "zip"
    }
    /**
        * <p>Information about the location of application artifacts stored in Amazon S3.</p>
        */
    export interface S3Location {
            /**
                * <p>The name of the Amazon S3 bucket where the application revision is stored.</p>
                */
            bucket?: string;
            /**
                * <p>The name of the Amazon S3 object that represents the bundled artifacts for the
                *             application revision.</p>
                */
            key?: string;
            /**
                * <p>The file type of the application revision. Must be one of the following:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>tar</code>: A tar archive file.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>tgz</code>: A compressed tar archive file.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>zip</code>: A zip archive file.</p>
                *             </li>
                *          </ul>
                */
            bundleType?: BundleType | string;
            /**
                * <p>A specific version of the Amazon S3 object that represents the bundled artifacts for
                *             the application revision.</p>
                *         <p>If the version is not specified, the system uses the most recent version by
                *             default.</p>
                */
            version?: string;
            /**
                * <p>The ETag of the Amazon S3 object that represents the bundled artifacts for the
                *             application revision.</p>
                *         <p>If the ETag is not specified as an input parameter, ETag validation of the object is
                *             skipped.</p>
                */
            eTag?: string;
    }
    export namespace S3Location {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: S3Location) => any;
    }
    /**
        * @deprecated
        *
        * <p>A revision for an AWS Lambda deployment that is a YAML-formatted or JSON-formatted
        *             string. For AWS Lambda deployments, the revision is the same as the AppSpec file.</p>
        */
    export interface RawString {
            /**
                * <p>The YAML-formatted or JSON-formatted revision string. It includes information about
                *             which Lambda function to update and optional Lambda functions that validate deployment
                *             lifecycle events.</p>
                */
            content?: string;
            /**
                * <p>The SHA256 hash value of the revision content.</p>
                */
            sha256?: string;
    }
    export namespace RawString {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RawString) => any;
    }
    /**
        * <p>Information about the location of an application revision.</p>
        */
    export interface RevisionLocation {
            /**
                * <p>The type of application revision:</p>
                *         <ul>
                *             <li>
                *                 <p>S3: An application revision stored in Amazon S3.</p>
                *             </li>
                *             <li>
                *                 <p>GitHub: An application revision stored in GitHub (EC2/On-premises deployments
                *                     only).</p>
                *             </li>
                *             <li>
                *                 <p>String: A YAML-formatted or JSON-formatted string (AWS Lambda deployments
                *                     only).</p>
                *             </li>
                *             <li>
                *                 <p>AppSpecContent: An <code>AppSpecContent</code> object that contains the
                *                     contents of an AppSpec file for an AWS Lambda or Amazon ECS deployment. The
                *                     content is formatted as JSON or YAML stored as a RawString.</p>
                *             </li>
                *          </ul>
                */
            revisionType?: RevisionLocationType | string;
            /**
                * <p>Information about the location of a revision stored in Amazon S3. </p>
                */
            s3Location?: S3Location;
            /**
                * <p>Information about the location of application artifacts stored in GitHub.</p>
                */
            gitHubLocation?: GitHubLocation;
            /**
                * @deprecated
                *
                * <p>Information about the location of an AWS Lambda deployment revision stored as a
                *             RawString.</p>
                */
            string?: RawString;
            /**
                * <p> The content of an AppSpec file for an AWS Lambda or Amazon ECS deployment. The
                *             content is formatted as JSON or YAML and stored as a RawString. </p>
                */
            appSpecContent?: AppSpecContent;
    }
    export namespace RevisionLocation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RevisionLocation) => any;
    }
    /**
        * <p>Represents the input of a <code>BatchGetApplicationRevisions</code> operation.</p>
        */
    export interface BatchGetApplicationRevisionsInput {
            /**
                * <p>The name of an AWS CodeDeploy application about which to get revision
                *             information.</p>
                */
            applicationName: string | undefined;
            /**
                * <p>An array of <code>RevisionLocation</code> objects that specify information to get
                *             about the application revisions, including type and location. The maximum number of
                *                 <code>RevisionLocation</code> objects you can specify is 25.</p>
                */
            revisions: RevisionLocation[] | undefined;
    }
    export namespace BatchGetApplicationRevisionsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetApplicationRevisionsInput) => any;
    }
    /**
        * <p>Information about an application revision.</p>
        */
    export interface GenericRevisionInfo {
            /**
                * <p>A comment about the revision.</p>
                */
            description?: string;
            /**
                * <p>The deployment groups for which this is the current target revision.</p>
                */
            deploymentGroups?: string[];
            /**
                * <p>When the revision was first used by AWS CodeDeploy.</p>
                */
            firstUsedTime?: Date;
            /**
                * <p>When the revision was last used by AWS CodeDeploy.</p>
                */
            lastUsedTime?: Date;
            /**
                * <p>When the revision was registered with AWS CodeDeploy.</p>
                */
            registerTime?: Date;
    }
    export namespace GenericRevisionInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GenericRevisionInfo) => any;
    }
    /**
        * <p>Information about an application revision.</p>
        */
    export interface RevisionInfo {
            /**
                * <p>Information about the location and type of an application revision.</p>
                */
            revisionLocation?: RevisionLocation;
            /**
                * <p>Information about an application revision, including usage details and associated
                *             deployment groups.</p>
                */
            genericRevisionInfo?: GenericRevisionInfo;
    }
    export namespace RevisionInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RevisionInfo) => any;
    }
    /**
        * <p>Represents the output of a <code>BatchGetApplicationRevisions</code> operation.</p>
        */
    export interface BatchGetApplicationRevisionsOutput {
            /**
                * <p>The name of the application that corresponds to the revisions.</p>
                */
            applicationName?: string;
            /**
                * <p>Information about errors that might have occurred during the API call.</p>
                */
            errorMessage?: string;
            /**
                * <p>Additional information about the revisions, including the type and location.</p>
                */
            revisions?: RevisionInfo[];
    }
    export namespace BatchGetApplicationRevisionsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetApplicationRevisionsOutput) => any;
    }
    /**
        * <p>The maximum number of names or IDs allowed for this request (100) was exceeded.</p>
        */
    export class BatchLimitExceededException extends __BaseException {
            readonly name: "BatchLimitExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<BatchLimitExceededException, __BaseException>);
    }
    /**
        * <p>The application name was specified in an invalid format.</p>
        */
    export class InvalidApplicationNameException extends __BaseException {
            readonly name: "InvalidApplicationNameException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidApplicationNameException, __BaseException>);
    }
    /**
        * <p>The revision was specified in an invalid format.</p>
        */
    export class InvalidRevisionException extends __BaseException {
            readonly name: "InvalidRevisionException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidRevisionException, __BaseException>);
    }
    /**
        * <p>The revision ID was not specified.</p>
        */
    export class RevisionRequiredException extends __BaseException {
            readonly name: "RevisionRequiredException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<RevisionRequiredException, __BaseException>);
    }
    /**
        * <p>Represents the input of a <code>BatchGetApplications</code> operation.</p>
        */
    export interface BatchGetApplicationsInput {
            /**
                * <p>A list of application names separated by spaces. The maximum number of application
                *             names you can specify is 100.</p>
                */
            applicationNames: string[] | undefined;
    }
    export namespace BatchGetApplicationsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetApplicationsInput) => any;
    }
    /**
        * <p>Represents the output of a <code>BatchGetApplications</code> operation.</p>
        */
    export interface BatchGetApplicationsOutput {
            /**
                * <p>Information about the applications.</p>
                */
            applicationsInfo?: ApplicationInfo[];
    }
    export namespace BatchGetApplicationsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetApplicationsOutput) => any;
    }
    /**
        * <p>Represents the input of a <code>BatchGetDeploymentGroups</code> operation.</p>
        */
    export interface BatchGetDeploymentGroupsInput {
            /**
                * <p>The name of an AWS CodeDeploy application associated with the applicable IAM user or
                *             AWS account.</p>
                */
            applicationName: string | undefined;
            /**
                * <p>The names of the deployment groups.</p>
                */
            deploymentGroupNames: string[] | undefined;
    }
    export namespace BatchGetDeploymentGroupsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetDeploymentGroupsInput) => any;
    }
    export enum DeploymentReadyAction {
            CONTINUE_DEPLOYMENT = "CONTINUE_DEPLOYMENT",
            STOP_DEPLOYMENT = "STOP_DEPLOYMENT"
    }
    /**
        * <p>Information about how traffic is rerouted to instances in a replacement environment in
        *             a blue/green deployment.</p>
        */
    export interface DeploymentReadyOption {
            /**
                * <p>Information about when to reroute traffic from an original environment to a
                *             replacement environment in a blue/green deployment.</p>
                *         <ul>
                *             <li>
                *                 <p>CONTINUE_DEPLOYMENT: Register new instances with the load balancer immediately
                *                     after the new application revision is installed on the instances in the
                *                     replacement environment.</p>
                *             </li>
                *             <li>
                *                 <p>STOP_DEPLOYMENT: Do not register new instances with a load balancer unless
                *                     traffic rerouting is started using <a>ContinueDeployment</a>. If
                *                     traffic rerouting is not started before the end of the specified wait period,
                *                     the deployment status is changed to Stopped.</p>
                *             </li>
                *          </ul>
                */
            actionOnTimeout?: DeploymentReadyAction | string;
            /**
                * <p>The number of minutes to wait before the status of a blue/green deployment is changed
                *             to Stopped if rerouting is not started manually. Applies only to the
                *                 <code>STOP_DEPLOYMENT</code> option for <code>actionOnTimeout</code>.</p>
                */
            waitTimeInMinutes?: number;
    }
    export namespace DeploymentReadyOption {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeploymentReadyOption) => any;
    }
    export enum GreenFleetProvisioningAction {
            COPY_AUTO_SCALING_GROUP = "COPY_AUTO_SCALING_GROUP",
            DISCOVER_EXISTING = "DISCOVER_EXISTING"
    }
    /**
        * <p>Information about the instances that belong to the replacement environment in a
        *             blue/green deployment.</p>
        */
    export interface GreenFleetProvisioningOption {
            /**
                * <p>The method used to add instances to a replacement environment.</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>DISCOVER_EXISTING</code>: Use instances that already exist or will be
                *                     created manually.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>COPY_AUTO_SCALING_GROUP</code>: Use settings from a specified Auto
                *                     Scaling group to define and create instances in a new Auto Scaling group.</p>
                *             </li>
                *          </ul>
                */
            action?: GreenFleetProvisioningAction | string;
    }
    export namespace GreenFleetProvisioningOption {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GreenFleetProvisioningOption) => any;
    }
    export enum InstanceAction {
            KEEP_ALIVE = "KEEP_ALIVE",
            TERMINATE = "TERMINATE"
    }
    /**
        * <p>Information about whether instances in the original environment are terminated when a
        *             blue/green deployment is successful. <code>BlueInstanceTerminationOption</code> does not
        *             apply to Lambda deployments. </p>
        */
    export interface BlueInstanceTerminationOption {
            /**
                * <p>The action to take on instances in the original environment after a successful
                *             blue/green deployment.</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>TERMINATE</code>: Instances are terminated after a specified wait
                *                     time.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>KEEP_ALIVE</code>: Instances are left running after they are
                *                     deregistered from the load balancer and removed from the deployment
                *                     group.</p>
                *             </li>
                *          </ul>
                */
            action?: InstanceAction | string;
            /**
                * <p>For an Amazon EC2 deployment, the number of minutes to wait after a successful
                *             blue/green deployment before terminating instances from the original environment.</p>
                *
                *         <p> For an Amazon ECS deployment, the number of minutes before deleting the original
                *             (blue) task set. During an Amazon ECS deployment, CodeDeploy shifts traffic from the
                *             original (blue) task set to a replacement (green) task set. </p>
                *
                *         <p> The maximum setting is 2880 minutes (2 days). </p>
                */
            terminationWaitTimeInMinutes?: number;
    }
    export namespace BlueInstanceTerminationOption {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BlueInstanceTerminationOption) => any;
    }
    /**
        * <p>Information about blue/green deployment options for a deployment group.</p>
        */
    export interface BlueGreenDeploymentConfiguration {
            /**
                * <p>Information about whether to terminate instances in the original fleet during a
                *             blue/green deployment.</p>
                */
            terminateBlueInstancesOnDeploymentSuccess?: BlueInstanceTerminationOption;
            /**
                * <p>Information about the action to take when newly provisioned instances are ready to
                *             receive traffic in a blue/green deployment.</p>
                */
            deploymentReadyOption?: DeploymentReadyOption;
            /**
                * <p>Information about how instances are provisioned for a replacement environment in a
                *             blue/green deployment.</p>
                */
            greenFleetProvisioningOption?: GreenFleetProvisioningOption;
    }
    export namespace BlueGreenDeploymentConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BlueGreenDeploymentConfiguration) => any;
    }
    export enum DeploymentOption {
            WITHOUT_TRAFFIC_CONTROL = "WITHOUT_TRAFFIC_CONTROL",
            WITH_TRAFFIC_CONTROL = "WITH_TRAFFIC_CONTROL"
    }
    export enum DeploymentType {
            BLUE_GREEN = "BLUE_GREEN",
            IN_PLACE = "IN_PLACE"
    }
    /**
        * <p>Information about the type of deployment, either in-place or blue/green, you want to
        *             run and whether to route deployment traffic behind a load balancer.</p>
        */
    export interface DeploymentStyle {
            /**
                * <p>Indicates whether to run an in-place deployment or a blue/green deployment.</p>
                */
            deploymentType?: DeploymentType | string;
            /**
                * <p>Indicates whether to route deployment traffic behind a load balancer.</p>
                */
            deploymentOption?: DeploymentOption | string;
    }
    export namespace DeploymentStyle {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeploymentStyle) => any;
    }
    export enum EC2TagFilterType {
            KEY_AND_VALUE = "KEY_AND_VALUE",
            KEY_ONLY = "KEY_ONLY",
            VALUE_ONLY = "VALUE_ONLY"
    }
    /**
        * <p>Information about an EC2 tag filter.</p>
        */
    export interface EC2TagFilter {
            /**
                * <p>The tag filter key.</p>
                */
            Key?: string;
            /**
                * <p>The tag filter value.</p>
                */
            Value?: string;
            /**
                * <p>The tag filter type:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>KEY_ONLY</code>: Key only.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>VALUE_ONLY</code>: Value only.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>KEY_AND_VALUE</code>: Key and value.</p>
                *             </li>
                *          </ul>
                */
            Type?: EC2TagFilterType | string;
    }
    export namespace EC2TagFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EC2TagFilter) => any;
    }
    /**
        * <p>Information about groups of EC2 instance tags.</p>
        */
    export interface EC2TagSet {
            /**
                * <p>A list that contains other lists of EC2 instance tag groups. For an instance to be
                *             included in the deployment group, it must be identified by all of the tag groups in the
                *             list.</p>
                */
            ec2TagSetList?: EC2TagFilter[][];
    }
    export namespace EC2TagSet {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EC2TagSet) => any;
    }
    /**
        * <p> Contains the service and cluster names used to identify an Amazon ECS deployment's
        *             target. </p>
        */
    export interface ECSService {
            /**
                * <p> The name of the target Amazon ECS service. </p>
                */
            serviceName?: string;
            /**
                * <p> The name of the cluster that the Amazon ECS service is associated with. </p>
                */
            clusterName?: string;
    }
    export namespace ECSService {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ECSService) => any;
    }
    export enum DeploymentStatus {
            BAKING = "Baking",
            CREATED = "Created",
            FAILED = "Failed",
            IN_PROGRESS = "InProgress",
            QUEUED = "Queued",
            READY = "Ready",
            STOPPED = "Stopped",
            SUCCEEDED = "Succeeded"
    }
    /**
        * <p>Information about the most recent attempted or successful deployment to a deployment
        *             group.</p>
        */
    export interface LastDeploymentInfo {
            /**
                * <p> The unique ID of a deployment. </p>
                */
            deploymentId?: string;
            /**
                * <p>The status of the most recent deployment.</p>
                */
            status?: DeploymentStatus | string;
            /**
                * <p>A timestamp that indicates when the most recent deployment to the deployment group was
                *             complete.</p>
                */
            endTime?: Date;
            /**
                * <p>A timestamp that indicates when the most recent deployment to the deployment group
                *             started.</p>
                */
            createTime?: Date;
    }
    export namespace LastDeploymentInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LastDeploymentInfo) => any;
    }
    /**
        * <p>Information about a load balancer in Elastic Load Balancing to use in a deployment.
        *             Instances are registered directly with a load balancer, and traffic is routed to the
        *             load balancer.</p>
        */
    export interface ELBInfo {
            /**
                * <p>For blue/green deployments, the name of the load balancer that is used to route
                *             traffic from original instances to replacement instances in a blue/green deployment. For
                *             in-place deployments, the name of the load balancer that instances are deregistered from
                *             so they are not serving traffic during a deployment, and then re-registered with after
                *             the deployment is complete.</p>
                */
            name?: string;
    }
    export namespace ELBInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ELBInfo) => any;
    }
    /**
        * <p>Information about a target group in Elastic Load Balancing to use in a deployment.
        *             Instances are registered as targets in a target group, and traffic is routed to the
        *             target group.</p>
        */
    export interface TargetGroupInfo {
            /**
                * <p>For blue/green deployments, the name of the target group that instances in the
                *             original environment are deregistered from, and instances in the replacement environment
                *             are registered with. For in-place deployments, the name of the target group that
                *             instances are deregistered from, so they are not serving traffic during a deployment,
                *             and then re-registered with after the deployment is complete. </p>
                */
            name?: string;
    }
    export namespace TargetGroupInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TargetGroupInfo) => any;
    }
    /**
        * <p> Information about a listener. The listener contains the path used to route traffic
        *             that is received from the load balancer to a target group. </p>
        */
    export interface TrafficRoute {
            /**
                * <p> The Amazon Resource Name (ARN) of one listener. The listener identifies the route
                *             between a target group and a load balancer. This is an array of strings with a maximum
                *             size of one. </p>
                */
            listenerArns?: string[];
    }
    export namespace TrafficRoute {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TrafficRoute) => any;
    }
    /**
        * <p> Information about two target groups and how traffic is routed during an Amazon ECS
        *             deployment. An optional test traffic route can be specified. </p>
        */
    export interface TargetGroupPairInfo {
            /**
                * <p> One pair of target groups. One is associated with the original task set. The second
                *             is associated with the task set that serves traffic after the deployment is complete.
                *         </p>
                */
            targetGroups?: TargetGroupInfo[];
            /**
                * <p> The path used by a load balancer to route production traffic when an Amazon ECS
                *             deployment is complete. </p>
                */
            prodTrafficRoute?: TrafficRoute;
            /**
                * <p> An optional path used by a load balancer to route test traffic after an Amazon ECS
                *             deployment. Validation can occur while test traffic is served during a deployment.
                *         </p>
                */
            testTrafficRoute?: TrafficRoute;
    }
    export namespace TargetGroupPairInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TargetGroupPairInfo) => any;
    }
    /**
        * <p>Information about the Elastic Load Balancing load balancer or target group used in a
        *             deployment.</p>
        */
    export interface LoadBalancerInfo {
            /**
                * <p>An array that contains information about the load balancer to use for load balancing
                *             in a deployment. In Elastic Load Balancing, load balancers are used with Classic Load
                *             Balancers.</p>
                *         <note>
                *             <p> Adding more than one load balancer to the array is not supported. </p>
                *         </note>
                */
            elbInfoList?: ELBInfo[];
            /**
                * <p>An array that contains information about the target group to use for load balancing in
                *             a deployment. In Elastic Load Balancing, target groups are used with Application Load
                *             Balancers.</p>
                *         <note>
                *             <p> Adding more than one target group to the array is not supported. </p>
                *         </note>
                */
            targetGroupInfoList?: TargetGroupInfo[];
            /**
                * <p> The target group pair information. This is an array of
                *                 <code>TargeGroupPairInfo</code> objects with a maximum size of one. </p>
                */
            targetGroupPairInfoList?: TargetGroupPairInfo[];
    }
    export namespace LoadBalancerInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LoadBalancerInfo) => any;
    }
    export enum TagFilterType {
            KEY_AND_VALUE = "KEY_AND_VALUE",
            KEY_ONLY = "KEY_ONLY",
            VALUE_ONLY = "VALUE_ONLY"
    }
    /**
        * <p>Information about an on-premises instance tag filter.</p>
        */
    export interface TagFilter {
            /**
                * <p>The on-premises instance tag filter key.</p>
                */
            Key?: string;
            /**
                * <p>The on-premises instance tag filter value.</p>
                */
            Value?: string;
            /**
                * <p>The on-premises instance tag filter type:</p>
                *         <ul>
                *             <li>
                *                 <p>KEY_ONLY: Key only.</p>
                *             </li>
                *             <li>
                *                 <p>VALUE_ONLY: Value only.</p>
                *             </li>
                *             <li>
                *                 <p>KEY_AND_VALUE: Key and value.</p>
                *             </li>
                *          </ul>
                */
            Type?: TagFilterType | string;
    }
    export namespace TagFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagFilter) => any;
    }
    /**
        * <p>Information about groups of on-premises instance tags.</p>
        */
    export interface OnPremisesTagSet {
            /**
                * <p>A list that contains other lists of on-premises instance tag groups. For an instance
                *             to be included in the deployment group, it must be identified by all of the tag groups
                *             in the list.</p>
                */
            onPremisesTagSetList?: TagFilter[][];
    }
    export namespace OnPremisesTagSet {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OnPremisesTagSet) => any;
    }
    export enum OutdatedInstancesStrategy {
            Ignore = "IGNORE",
            Update = "UPDATE"
    }
    export enum TriggerEventType {
            DEPLOYMENT_FAILURE = "DeploymentFailure",
            DEPLOYMENT_READY = "DeploymentReady",
            DEPLOYMENT_ROLLBACK = "DeploymentRollback",
            DEPLOYMENT_START = "DeploymentStart",
            DEPLOYMENT_STOP = "DeploymentStop",
            DEPLOYMENT_SUCCESS = "DeploymentSuccess",
            INSTANCE_FAILURE = "InstanceFailure",
            INSTANCE_READY = "InstanceReady",
            INSTANCE_START = "InstanceStart",
            INSTANCE_SUCCESS = "InstanceSuccess"
    }
    /**
        * <p>Information about notification triggers for the deployment group.</p>
        */
    export interface TriggerConfig {
            /**
                * <p>The name of the notification trigger.</p>
                */
            triggerName?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the Amazon Simple Notification Service topic through
                *             which notifications about deployment or instance events are sent.</p>
                */
            triggerTargetArn?: string;
            /**
                * <p>The event type or types for which notifications are triggered.</p>
                */
            triggerEvents?: (TriggerEventType | string)[];
    }
    export namespace TriggerConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TriggerConfig) => any;
    }
    /**
        * <p>Information about a deployment group.</p>
        */
    export interface DeploymentGroupInfo {
            /**
                * <p>The application name.</p>
                */
            applicationName?: string;
            /**
                * <p>The deployment group ID.</p>
                */
            deploymentGroupId?: string;
            /**
                * <p>The deployment group name.</p>
                */
            deploymentGroupName?: string;
            /**
                * <p>The deployment configuration name.</p>
                */
            deploymentConfigName?: string;
            /**
                * <p>The Amazon EC2 tags on which to filter. The deployment group includes EC2 instances
                *             with any of the specified tags.</p>
                */
            ec2TagFilters?: EC2TagFilter[];
            /**
                * <p>The on-premises instance tags on which to filter. The deployment group includes
                *             on-premises instances with any of the specified tags.</p>
                */
            onPremisesInstanceTagFilters?: TagFilter[];
            /**
                * <p>A list of associated Auto Scaling groups.</p>
                */
            autoScalingGroups?: AutoScalingGroup[];
            /**
                * <p>A service role Amazon Resource Name (ARN) that grants CodeDeploy permission to make
                *             calls to AWS services on your behalf. For more information, see <a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/getting-started-create-service-role.html">Create a
                *                 Service Role for AWS CodeDeploy</a> in the <i>AWS CodeDeploy User
                *                 Guide</i>.</p>
                */
            serviceRoleArn?: string;
            /**
                * <p>Information about the deployment group's target revision, including type and
                *             location.</p>
                */
            targetRevision?: RevisionLocation;
            /**
                * <p>Information about triggers associated with the deployment group.</p>
                */
            triggerConfigurations?: TriggerConfig[];
            /**
                * <p>A list of alarms associated with the deployment group.</p>
                */
            alarmConfiguration?: AlarmConfiguration;
            /**
                * <p>Information about the automatic rollback configuration associated with the deployment
                *             group.</p>
                */
            autoRollbackConfiguration?: AutoRollbackConfiguration;
            /**
                * <p>Information about the type of deployment, either in-place or blue/green, you want to
                *             run and whether to route deployment traffic behind a load balancer.</p>
                */
            deploymentStyle?: DeploymentStyle;
            /**
                * <p>Indicates what happens when new EC2 instances are launched mid-deployment and do not
                *             receive the deployed application revision.</p>
                *         <p>If this option is set to <code>UPDATE</code> or is unspecified, CodeDeploy initiates
                *             one or more 'auto-update outdated instances' deployments to apply the deployed
                *             application revision to the new EC2 instances.</p>
                *         <p>If this option is set to <code>IGNORE</code>, CodeDeploy does not initiate a
                *             deployment to update the new EC2 instances. This may result in instances having
                *             different revisions.</p>
                */
            outdatedInstancesStrategy?: OutdatedInstancesStrategy | string;
            /**
                * <p>Information about blue/green deployment options for a deployment group.</p>
                */
            blueGreenDeploymentConfiguration?: BlueGreenDeploymentConfiguration;
            /**
                * <p>Information about the load balancer to use in a deployment.</p>
                */
            loadBalancerInfo?: LoadBalancerInfo;
            /**
                * <p>Information about the most recent successful deployment to the deployment
                *             group.</p>
                */
            lastSuccessfulDeployment?: LastDeploymentInfo;
            /**
                * <p>Information about the most recent attempted deployment to the deployment group.</p>
                */
            lastAttemptedDeployment?: LastDeploymentInfo;
            /**
                * <p>Information about groups of tags applied to an EC2 instance. The deployment group
                *             includes only EC2 instances identified by all of the tag groups. Cannot be used in the
                *             same call as ec2TagFilters.</p>
                */
            ec2TagSet?: EC2TagSet;
            /**
                * <p>Information about groups of tags applied to an on-premises instance. The deployment
                *             group includes only on-premises instances identified by all the tag groups. Cannot be
                *             used in the same call as onPremisesInstanceTagFilters.</p>
                */
            onPremisesTagSet?: OnPremisesTagSet;
            /**
                * <p>The destination platform type for the deployment (<code>Lambda</code>,
                *                 <code>Server</code>, or <code>ECS</code>).</p>
                */
            computePlatform?: ComputePlatform | string;
            /**
                * <p> The target Amazon ECS services in the deployment group. This applies only to
                *             deployment groups that use the Amazon ECS compute platform. A target Amazon ECS service
                *             is specified as an Amazon ECS cluster and service name pair using the format
                *                 <code><clustername>:<servicename></code>. </p>
                */
            ecsServices?: ECSService[];
    }
    export namespace DeploymentGroupInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeploymentGroupInfo) => any;
    }
    /**
        * <p>Represents the output of a <code>BatchGetDeploymentGroups</code> operation.</p>
        */
    export interface BatchGetDeploymentGroupsOutput {
            /**
                * <p>Information about the deployment groups.</p>
                */
            deploymentGroupsInfo?: DeploymentGroupInfo[];
            /**
                * <p>Information about errors that might have occurred during the API call.</p>
                */
            errorMessage?: string;
    }
    export namespace BatchGetDeploymentGroupsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetDeploymentGroupsOutput) => any;
    }
    /**
        * <p>The deployment configuration does not exist with the IAM user or AWS account.</p>
        */
    export class DeploymentConfigDoesNotExistException extends __BaseException {
            readonly name: "DeploymentConfigDoesNotExistException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DeploymentConfigDoesNotExistException, __BaseException>);
    }
    /**
        * <p>The deployment group name was not specified.</p>
        */
    export class DeploymentGroupNameRequiredException extends __BaseException {
            readonly name: "DeploymentGroupNameRequiredException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DeploymentGroupNameRequiredException, __BaseException>);
    }
    /**
        * <p>The deployment group name was specified in an invalid format.</p>
        */
    export class InvalidDeploymentGroupNameException extends __BaseException {
            readonly name: "InvalidDeploymentGroupNameException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidDeploymentGroupNameException, __BaseException>);
    }
    /**
        * <p> Represents the input of a <code>BatchGetDeploymentInstances</code> operation. </p>
        */
    export interface BatchGetDeploymentInstancesInput {
            /**
                * <p> The unique ID of a deployment. </p>
                */
            deploymentId: string | undefined;
            /**
                * <p>The unique IDs of instances used in the deployment. The maximum number of instance IDs
                *             you can specify is 25.</p>
                */
            instanceIds: string[] | undefined;
    }
    export namespace BatchGetDeploymentInstancesInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetDeploymentInstancesInput) => any;
    }
    export enum _InstanceType {
            BLUE = "Blue",
            GREEN = "Green"
    }
    export enum LifecycleErrorCode {
            SCRIPT_FAILED = "ScriptFailed",
            SCRIPT_MISSING = "ScriptMissing",
            SCRIPT_NOT_EXECUTABLE = "ScriptNotExecutable",
            SCRIPT_TIMED_OUT = "ScriptTimedOut",
            SUCCESS = "Success",
            UNKNOWN_ERROR = "UnknownError"
    }
    /**
        * <p>Diagnostic information about executable scripts that are part of a deployment.</p>
        */
    export interface Diagnostics {
            /**
                * <p>The associated error code:</p>
                *         <ul>
                *             <li>
                *                 <p>Success: The specified script ran.</p>
                *             </li>
                *             <li>
                *                 <p>ScriptMissing: The specified script was not found in the specified
                *                     location.</p>
                *             </li>
                *             <li>
                *                 <p>ScriptNotExecutable: The specified script is not a recognized executable file
                *                     type.</p>
                *             </li>
                *             <li>
                *                 <p>ScriptTimedOut: The specified script did not finish running in the specified
                *                     time period.</p>
                *             </li>
                *             <li>
                *                 <p>ScriptFailed: The specified script failed to run as expected.</p>
                *             </li>
                *             <li>
                *                 <p>UnknownError: The specified script did not run for an unknown reason.</p>
                *             </li>
                *          </ul>
                */
            errorCode?: LifecycleErrorCode | string;
            /**
                * <p>The name of the script.</p>
                */
            scriptName?: string;
            /**
                * <p>The message associated with the error.</p>
                */
            message?: string;
            /**
                * <p>The last portion of the diagnostic log.</p>
                *         <p>If available, AWS CodeDeploy returns up to the last 4 KB of the diagnostic log.</p>
                */
            logTail?: string;
    }
    export namespace Diagnostics {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Diagnostics) => any;
    }
    export enum LifecycleEventStatus {
            FAILED = "Failed",
            IN_PROGRESS = "InProgress",
            PENDING = "Pending",
            SKIPPED = "Skipped",
            SUCCEEDED = "Succeeded",
            UNKNOWN = "Unknown"
    }
    /**
        * <p>Information about a deployment lifecycle event.</p>
        */
    export interface LifecycleEvent {
            /**
                * <p>The deployment lifecycle event name, such as <code>ApplicationStop</code>,
                *                 <code>BeforeInstall</code>, <code>AfterInstall</code>,
                *             <code>ApplicationStart</code>, or <code>ValidateService</code>.</p>
                */
            lifecycleEventName?: string;
            /**
                * <p>Diagnostic information about the deployment lifecycle event.</p>
                */
            diagnostics?: Diagnostics;
            /**
                * <p>A timestamp that indicates when the deployment lifecycle event started.</p>
                */
            startTime?: Date;
            /**
                * <p>A timestamp that indicates when the deployment lifecycle event ended.</p>
                */
            endTime?: Date;
            /**
                * <p>The deployment lifecycle event status:</p>
                *         <ul>
                *             <li>
                *                 <p>Pending: The deployment lifecycle event is pending.</p>
                *             </li>
                *             <li>
                *                 <p>InProgress: The deployment lifecycle event is in progress.</p>
                *             </li>
                *             <li>
                *                 <p>Succeeded: The deployment lifecycle event ran successfully.</p>
                *             </li>
                *             <li>
                *                 <p>Failed: The deployment lifecycle event has failed.</p>
                *             </li>
                *             <li>
                *                 <p>Skipped: The deployment lifecycle event has been skipped.</p>
                *             </li>
                *             <li>
                *                 <p>Unknown: The deployment lifecycle event is unknown.</p>
                *             </li>
                *          </ul>
                */
            status?: LifecycleEventStatus | string;
    }
    export namespace LifecycleEvent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LifecycleEvent) => any;
    }
    export enum InstanceStatus {
            FAILED = "Failed",
            IN_PROGRESS = "InProgress",
            PENDING = "Pending",
            READY = "Ready",
            SKIPPED = "Skipped",
            SUCCEEDED = "Succeeded",
            UNKNOWN = "Unknown"
    }
    /**
        * @deprecated
        *
        * <p>Information about an instance in a deployment.</p>
        */
    export interface InstanceSummary {
            /**
                * <p> The unique ID of a deployment. </p>
                */
            deploymentId?: string;
            /**
                * <p>The instance ID.</p>
                */
            instanceId?: string;
            /**
                * @deprecated
                *
                * <p>The deployment status for this instance:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>Pending</code>: The deployment is pending for this instance.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>In Progress</code>: The deployment is in progress for this
                *                     instance.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>Succeeded</code>: The deployment has succeeded for this instance.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>Failed</code>: The deployment has failed for this instance.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>Skipped</code>: The deployment has been skipped for this
                *                     instance.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>Unknown</code>: The deployment status is unknown for this
                *                     instance.</p>
                *             </li>
                *          </ul>
                */
            status?: InstanceStatus | string;
            /**
                * <p>A timestamp that indicates when the instance information was last updated.</p>
                */
            lastUpdatedAt?: Date;
            /**
                * <p>A list of lifecycle events for this instance.</p>
                */
            lifecycleEvents?: LifecycleEvent[];
            /**
                * <p>Information about which environment an instance belongs to in a blue/green
                *             deployment.</p>
                *         <ul>
                *             <li>
                *                 <p>BLUE: The instance is part of the original environment.</p>
                *             </li>
                *             <li>
                *                 <p>GREEN: The instance is part of the replacement environment.</p>
                *             </li>
                *          </ul>
                */
            instanceType?: _InstanceType | string;
    }
    export namespace InstanceSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InstanceSummary) => any;
    }
    /**
        * <p>Represents the output of a <code>BatchGetDeploymentInstances</code> operation.</p>
        */
    export interface BatchGetDeploymentInstancesOutput {
            /**
                * <p>Information about the instance.</p>
                */
            instancesSummary?: InstanceSummary[];
            /**
                * <p>Information about errors that might have occurred during the API call.</p>
                */
            errorMessage?: string;
    }
    export namespace BatchGetDeploymentInstancesOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetDeploymentInstancesOutput) => any;
    }
    /**
        * <p>The deployment with the IAM user or AWS account does not exist.</p>
        */
    export class DeploymentDoesNotExistException extends __BaseException {
            readonly name: "DeploymentDoesNotExistException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DeploymentDoesNotExistException, __BaseException>);
    }
    /**
        * <p>At least one deployment ID must be specified.</p>
        */
    export class DeploymentIdRequiredException extends __BaseException {
            readonly name: "DeploymentIdRequiredException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DeploymentIdRequiredException, __BaseException>);
    }
    /**
        * @deprecated
        *
        * <p>The instance ID was not specified.</p>
        */
    export class InstanceIdRequiredException extends __BaseException {
            readonly name: "InstanceIdRequiredException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InstanceIdRequiredException, __BaseException>);
    }
    /**
        * <p>The computePlatform is invalid. The computePlatform should be <code>Lambda</code>,
        *                 <code>Server</code>, or <code>ECS</code>.</p>
        */
    export class InvalidComputePlatformException extends __BaseException {
            readonly name: "InvalidComputePlatformException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidComputePlatformException, __BaseException>);
    }
    /**
        * <p>At least one of the deployment IDs was specified in an invalid format.</p>
        */
    export class InvalidDeploymentIdException extends __BaseException {
            readonly name: "InvalidDeploymentIdException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidDeploymentIdException, __BaseException>);
    }
    /**
        * <p> Represents the input of a <code>BatchGetDeployments</code> operation. </p>
        */
    export interface BatchGetDeploymentsInput {
            /**
                * <p> A list of deployment IDs, separated by spaces. The maximum number of deployment IDs
                *             you can specify is 25.</p>
                */
            deploymentIds: string[] | undefined;
    }
    export namespace BatchGetDeploymentsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetDeploymentsInput) => any;
    }
    export enum DeploymentCreator {
            Autoscaling = "autoscaling",
            CloudFormation = "CloudFormation",
            CloudFormationRollback = "CloudFormationRollback",
            CodeDeploy = "CodeDeploy",
            CodeDeployAutoUpdate = "CodeDeployAutoUpdate",
            CodeDeployRollback = "codeDeployRollback",
            User = "user"
    }
    /**
        * <p>Information about the deployment status of the instances in the deployment.</p>
        */
    export interface DeploymentOverview {
            /**
                * <p>The number of instances in the deployment in a pending state.</p>
                */
            Pending?: number;
            /**
                * <p>The number of instances in which the deployment is in progress.</p>
                */
            InProgress?: number;
            /**
                * <p>The number of instances in the deployment to which revisions have been successfully
                *             deployed.</p>
                */
            Succeeded?: number;
            /**
                * <p>The number of instances in the deployment in a failed state.</p>
                */
            Failed?: number;
            /**
                * <p>The number of instances in the deployment in a skipped state.</p>
                */
            Skipped?: number;
            /**
                * <p>The number of instances in a replacement environment ready to receive traffic in a
                *             blue/green deployment.</p>
                */
            Ready?: number;
    }
    export namespace DeploymentOverview {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeploymentOverview) => any;
    }
    export enum ErrorCode {
            AGENT_ISSUE = "AGENT_ISSUE",
            ALARM_ACTIVE = "ALARM_ACTIVE",
            APPLICATION_MISSING = "APPLICATION_MISSING",
            AUTOSCALING_VALIDATION_ERROR = "AUTOSCALING_VALIDATION_ERROR",
            AUTO_SCALING_CONFIGURATION = "AUTO_SCALING_CONFIGURATION",
            AUTO_SCALING_IAM_ROLE_PERMISSIONS = "AUTO_SCALING_IAM_ROLE_PERMISSIONS",
            CLOUDFORMATION_STACK_FAILURE = "CLOUDFORMATION_STACK_FAILURE",
            CODEDEPLOY_RESOURCE_CANNOT_BE_FOUND = "CODEDEPLOY_RESOURCE_CANNOT_BE_FOUND",
            CUSTOMER_APPLICATION_UNHEALTHY = "CUSTOMER_APPLICATION_UNHEALTHY",
            DEPLOYMENT_GROUP_MISSING = "DEPLOYMENT_GROUP_MISSING",
            ECS_UPDATE_ERROR = "ECS_UPDATE_ERROR",
            ELASTIC_LOAD_BALANCING_INVALID = "ELASTIC_LOAD_BALANCING_INVALID",
            ELB_INVALID_INSTANCE = "ELB_INVALID_INSTANCE",
            HEALTH_CONSTRAINTS = "HEALTH_CONSTRAINTS",
            HEALTH_CONSTRAINTS_INVALID = "HEALTH_CONSTRAINTS_INVALID",
            HOOK_EXECUTION_FAILURE = "HOOK_EXECUTION_FAILURE",
            IAM_ROLE_MISSING = "IAM_ROLE_MISSING",
            IAM_ROLE_PERMISSIONS = "IAM_ROLE_PERMISSIONS",
            INTERNAL_ERROR = "INTERNAL_ERROR",
            INVALID_ECS_SERVICE = "INVALID_ECS_SERVICE",
            INVALID_LAMBDA_CONFIGURATION = "INVALID_LAMBDA_CONFIGURATION",
            INVALID_LAMBDA_FUNCTION = "INVALID_LAMBDA_FUNCTION",
            INVALID_REVISION = "INVALID_REVISION",
            MANUAL_STOP = "MANUAL_STOP",
            MISSING_BLUE_GREEN_DEPLOYMENT_CONFIGURATION = "MISSING_BLUE_GREEN_DEPLOYMENT_CONFIGURATION",
            MISSING_ELB_INFORMATION = "MISSING_ELB_INFORMATION",
            MISSING_GITHUB_TOKEN = "MISSING_GITHUB_TOKEN",
            NO_EC2_SUBSCRIPTION = "NO_EC2_SUBSCRIPTION",
            NO_INSTANCES = "NO_INSTANCES",
            OVER_MAX_INSTANCES = "OVER_MAX_INSTANCES",
            RESOURCE_LIMIT_EXCEEDED = "RESOURCE_LIMIT_EXCEEDED",
            REVISION_MISSING = "REVISION_MISSING",
            THROTTLED = "THROTTLED",
            TIMEOUT = "TIMEOUT"
    }
    /**
        * <p>Information about a deployment error.</p>
        */
    export interface ErrorInformation {
            /**
                * <p>For more information, see <a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/error-codes.html">Error Codes for AWS
                *                 CodeDeploy</a> in the <a href="https://docs.aws.amazon.com/codedeploy/latest/userguide">AWS CodeDeploy User Guide</a>.</p>
                *         <p>The error code:</p>
                *         <ul>
                *             <li>
                *                 <p>APPLICATION_MISSING: The application was missing. This error code is most
                *                     likely raised if the application is deleted after the deployment is created, but
                *                     before it is started.</p>
                *             </li>
                *             <li>
                *                 <p>DEPLOYMENT_GROUP_MISSING: The deployment group was missing. This error code is
                *                     most likely raised if the deployment group is deleted after the deployment is
                *                     created, but before it is started.</p>
                *             </li>
                *             <li>
                *                 <p>HEALTH_CONSTRAINTS: The deployment failed on too many instances to be
                *                     successfully deployed within the instance health constraints specified.</p>
                *             </li>
                *             <li>
                *                 <p>HEALTH_CONSTRAINTS_INVALID: The revision cannot be successfully deployed
                *                     within the instance health constraints specified.</p>
                *             </li>
                *             <li>
                *                 <p>IAM_ROLE_MISSING: The service role cannot be accessed.</p>
                *             </li>
                *             <li>
                *                 <p>IAM_ROLE_PERMISSIONS: The service role does not have the correct
                *                     permissions.</p>
                *             </li>
                *             <li>
                *                 <p>INTERNAL_ERROR: There was an internal error.</p>
                *             </li>
                *             <li>
                *                 <p>NO_EC2_SUBSCRIPTION: The calling account is not subscribed to Amazon
                *                     EC2.</p>
                *             </li>
                *             <li>
                *                 <p>NO_INSTANCES: No instances were specified, or no instances can be
                *                     found.</p>
                *             </li>
                *             <li>
                *                 <p>OVER_MAX_INSTANCES: The maximum number of instances was exceeded.</p>
                *             </li>
                *             <li>
                *                 <p>THROTTLED: The operation was throttled because the calling account exceeded
                *                     the throttling limits of one or more AWS services.</p>
                *             </li>
                *             <li>
                *                 <p>TIMEOUT: The deployment has timed out.</p>
                *             </li>
                *             <li>
                *                 <p>REVISION_MISSING: The revision ID was missing. This error code is most likely
                *                     raised if the revision is deleted after the deployment is created, but before it
                *                     is started.</p>
                *             </li>
                *          </ul>
                */
            code?: ErrorCode | string;
            /**
                * <p>An accompanying error message.</p>
                */
            message?: string;
    }
    export namespace ErrorInformation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ErrorInformation) => any;
    }
    export enum FileExistsBehavior {
            DISALLOW = "DISALLOW",
            OVERWRITE = "OVERWRITE",
            RETAIN = "RETAIN"
    }
    /**
        * <p>Information about deployments related to the specified deployment.</p>
        */
    export interface RelatedDeployments {
            /**
                * <p>The deployment ID of the root deployment that triggered this deployment.</p>
                */
            autoUpdateOutdatedInstancesRootDeploymentId?: string;
            /**
                * <p>The deployment IDs of 'auto-update outdated instances' deployments triggered by this
                *             deployment.</p>
                */
            autoUpdateOutdatedInstancesDeploymentIds?: string[];
    }
    export namespace RelatedDeployments {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RelatedDeployments) => any;
    }
    /**
        * <p>Information about a deployment rollback.</p>
        */
    export interface RollbackInfo {
            /**
                * <p>The ID of the deployment rollback.</p>
                */
            rollbackDeploymentId?: string;
            /**
                * <p>The deployment ID of the deployment that was underway and triggered a rollback
                *             deployment because it failed or was stopped.</p>
                */
            rollbackTriggeringDeploymentId?: string;
            /**
                * <p>Information that describes the status of a deployment rollback (for example, whether
                *             the deployment can't be rolled back, is in progress, failed, or succeeded). </p>
                */
            rollbackMessage?: string;
    }
    export namespace RollbackInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RollbackInfo) => any;
    }
    /**
        * <p>Information about the instances to be used in the replacement environment in a
        *             blue/green deployment.</p>
        */
    export interface TargetInstances {
            /**
                * <p>The tag filter key, type, and value used to identify Amazon EC2 instances in a
                *             replacement environment for a blue/green deployment. Cannot be used in the same call as
                *                 <code>ec2TagSet</code>.</p>
                */
            tagFilters?: EC2TagFilter[];
            /**
                * <p>The names of one or more Auto Scaling groups to identify a replacement environment for
                *             a blue/green deployment.</p>
                */
            autoScalingGroups?: string[];
            /**
                * <p>Information about the groups of EC2 instance tags that an instance must be identified
                *             by in order for it to be included in the replacement environment for a blue/green
                *             deployment. Cannot be used in the same call as <code>tagFilters</code>.</p>
                */
            ec2TagSet?: EC2TagSet;
    }
    export namespace TargetInstances {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TargetInstances) => any;
    }
    /**
        * <p>Information about a deployment.</p>
        */
    export interface DeploymentInfo {
            /**
                * <p>The application name.</p>
                */
            applicationName?: string;
            /**
                * <p> The deployment group name. </p>
                */
            deploymentGroupName?: string;
            /**
                * <p> The deployment configuration name. </p>
                */
            deploymentConfigName?: string;
            /**
                * <p> The unique ID of a deployment. </p>
                */
            deploymentId?: string;
            /**
                * <p>Information about the application revision that was deployed to the deployment group
                *             before the most recent successful deployment.</p>
                */
            previousRevision?: RevisionLocation;
            /**
                * <p>Information about the location of stored application artifacts and the service from
                *             which to retrieve them.</p>
                */
            revision?: RevisionLocation;
            /**
                * <p>The current state of the deployment as a whole.</p>
                */
            status?: DeploymentStatus | string;
            /**
                * <p>Information about any error associated with this deployment.</p>
                */
            errorInformation?: ErrorInformation;
            /**
                * <p>A timestamp that indicates when the deployment was created.</p>
                */
            createTime?: Date;
            /**
                * <p>A timestamp that indicates when the deployment was deployed to the deployment
                *             group.</p>
                *         <p>In some cases, the reported value of the start time might be later than the complete
                *             time. This is due to differences in the clock settings of backend servers that
                *             participate in the deployment process.</p>
                */
            startTime?: Date;
            /**
                * <p>A timestamp that indicates when the deployment was complete.</p>
                */
            completeTime?: Date;
            /**
                * <p>A summary of the deployment status of the instances in the deployment.</p>
                */
            deploymentOverview?: DeploymentOverview;
            /**
                * <p>A comment about the deployment.</p>
                */
            description?: string;
            /**
                * <p>The means by which the deployment was created:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>user</code>: A user created the deployment.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>autoscaling</code>: Amazon EC2 Auto Scaling created the
                *                     deployment.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>codeDeployRollback</code>: A rollback process created the
                *                     deployment.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>CodeDeployAutoUpdate</code>: An auto-update process created the
                *                     deployment when it detected outdated EC2 instances.</p>
                *             </li>
                *          </ul>
                */
            creator?: DeploymentCreator | string;
            /**
                * <p> If true, then if an <code>ApplicationStop</code>, <code>BeforeBlockTraffic</code>, or
                *                 <code>AfterBlockTraffic</code> deployment lifecycle event to an instance fails, then
                *             the deployment continues to the next deployment lifecycle event. For example, if
                *                 <code>ApplicationStop</code> fails, the deployment continues with DownloadBundle. If
                *                 <code>BeforeBlockTraffic</code> fails, the deployment continues with
                *                 <code>BlockTraffic</code>. If <code>AfterBlockTraffic</code> fails, the deployment
                *             continues with <code>ApplicationStop</code>. </p>
                *
                *         <p> If false or not specified, then if a lifecycle event fails during a deployment to an
                *             instance, that deployment fails. If deployment to that instance is part of an overall
                *             deployment and the number of healthy hosts is not less than the minimum number of
                *             healthy hosts, then a deployment to the next instance is attempted. </p>
                *
                *         <p> During a deployment, the AWS CodeDeploy agent runs the scripts specified for
                *                 <code>ApplicationStop</code>, <code>BeforeBlockTraffic</code>, and
                *                 <code>AfterBlockTraffic</code> in the AppSpec file from the previous successful
                *             deployment. (All other scripts are run from the AppSpec file in the current deployment.)
                *             If one of these scripts contains an error and does not run successfully, the deployment
                *             can fail. </p>
                *
                *         <p> If the cause of the failure is a script from the last successful deployment that will
                *             never run successfully, create a new deployment and use
                *                 <code>ignoreApplicationStopFailures</code> to specify that the
                *                 <code>ApplicationStop</code>, <code>BeforeBlockTraffic</code>, and
                *                 <code>AfterBlockTraffic</code> failures should be ignored. </p>
                */
            ignoreApplicationStopFailures?: boolean;
            /**
                * <p>Information about the automatic rollback configuration associated with the
                *             deployment.</p>
                */
            autoRollbackConfiguration?: AutoRollbackConfiguration;
            /**
                * <p>Indicates whether only instances that are not running the latest application revision
                *             are to be deployed to.</p>
                */
            updateOutdatedInstancesOnly?: boolean;
            /**
                * <p>Information about a deployment rollback.</p>
                */
            rollbackInfo?: RollbackInfo;
            /**
                * <p>Information about the type of deployment, either in-place or blue/green, you want to
                *             run and whether to route deployment traffic behind a load balancer.</p>
                */
            deploymentStyle?: DeploymentStyle;
            /**
                * <p>Information about the instances that belong to the replacement environment in a
                *             blue/green deployment.</p>
                */
            targetInstances?: TargetInstances;
            /**
                * <p>Indicates whether the wait period set for the termination of instances in the original
                *             environment has started. Status is 'false' if the KEEP_ALIVE option is specified.
                *             Otherwise, 'true' as soon as the termination wait period starts.</p>
                */
            instanceTerminationWaitTimeStarted?: boolean;
            /**
                * <p>Information about blue/green deployment options for this deployment.</p>
                */
            blueGreenDeploymentConfiguration?: BlueGreenDeploymentConfiguration;
            /**
                * <p>Information about the load balancer used in the deployment.</p>
                */
            loadBalancerInfo?: LoadBalancerInfo;
            /**
                * @deprecated
                *
                * <p>Provides information about the results of a deployment, such as whether instances in
                *             the original environment in a blue/green deployment were not terminated.</p>
                */
            additionalDeploymentStatusInfo?: string;
            /**
                * <p>Information about how AWS CodeDeploy handles files that already exist in a deployment
                *             target location but weren't part of the previous successful deployment.</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>DISALLOW</code>: The deployment fails. This is also the default behavior
                *                     if no option is specified.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>OVERWRITE</code>: The version of the file from the application revision
                *                     currently being deployed replaces the version already on the instance.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>RETAIN</code>: The version of the file already on the instance is kept
                *                     and used as part of the new deployment.</p>
                *             </li>
                *          </ul>
                */
            fileExistsBehavior?: FileExistsBehavior | string;
            /**
                * <p>Messages that contain information about the status of a deployment.</p>
                */
            deploymentStatusMessages?: string[];
            /**
                * <p>The destination platform type for the deployment (<code>Lambda</code>,
                *                 <code>Server</code>, or <code>ECS</code>).</p>
                */
            computePlatform?: ComputePlatform | string;
            /**
                * <p>The unique ID for an external resource (for example, a CloudFormation stack ID) that
                *             is linked to this deployment.</p>
                */
            externalId?: string;
            /**
                * <p>Information about deployments related to the specified deployment.</p>
                */
            relatedDeployments?: RelatedDeployments;
    }
    export namespace DeploymentInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeploymentInfo) => any;
    }
    /**
        * <p> Represents the output of a <code>BatchGetDeployments</code> operation. </p>
        */
    export interface BatchGetDeploymentsOutput {
            /**
                * <p> Information about the deployments. </p>
                */
            deploymentsInfo?: DeploymentInfo[];
    }
    export namespace BatchGetDeploymentsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetDeploymentsOutput) => any;
    }
    export interface BatchGetDeploymentTargetsInput {
            /**
                * <p> The unique ID of a deployment. </p>
                */
            deploymentId?: string;
            /**
                * <p> The unique IDs of the deployment targets. The compute platform of the deployment
                *             determines the type of the targets and their formats. The maximum number of deployment
                *             target IDs you can specify is 25.</p>
                *         <ul>
                *             <li>
                *                 <p> For deployments that use the EC2/On-premises compute platform, the target IDs
                *                     are EC2 or on-premises instances IDs, and their target type is
                *                         <code>instanceTarget</code>. </p>
                *             </li>
                *             <li>
                *                 <p> For deployments that use the AWS Lambda compute platform, the target IDs are
                *                     the names of Lambda functions, and their target type is
                *                         <code>instanceTarget</code>. </p>
                *             </li>
                *             <li>
                *                 <p> For deployments that use the Amazon ECS compute platform, the target IDs are
                *                     pairs of Amazon ECS clusters and services specified using the format
                *                         <code><clustername>:<servicename></code>. Their target type is
                *                         <code>ecsTarget</code>. </p>
                *             </li>
                *             <li>
                *                 <p> For deployments that are deployed with AWS CloudFormation, the target IDs are
                *                     CloudFormation stack IDs. Their target type is
                *                     <code>cloudFormationTarget</code>. </p>
                *             </li>
                *          </ul>
                */
            targetIds?: string[];
    }
    export namespace BatchGetDeploymentTargetsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetDeploymentTargetsInput) => any;
    }
    export enum TargetStatus {
            FAILED = "Failed",
            IN_PROGRESS = "InProgress",
            PENDING = "Pending",
            READY = "Ready",
            SKIPPED = "Skipped",
            SUCCEEDED = "Succeeded",
            UNKNOWN = "Unknown"
    }
    /**
        * <p> Information about the target to be updated by an AWS CloudFormation blue/green
        *             deployment. This target type is used for all deployments initiated by a CloudFormation
        *             stack update.</p>
        */
    export interface CloudFormationTarget {
            /**
                * <p>The unique ID of an AWS CloudFormation blue/green deployment.</p>
                */
            deploymentId?: string;
            /**
                * <p> The unique ID of a deployment target that has a type
                *                 of <code>CloudFormationTarget</code>. </p>
                */
            targetId?: string;
            /**
                * <p> The date and time when the target application was updated by an AWS CloudFormation
                *             blue/green deployment. </p>
                */
            lastUpdatedAt?: Date;
            /**
                * <p> The lifecycle events of the AWS CloudFormation blue/green deployment to this target
                *             application. </p>
                */
            lifecycleEvents?: LifecycleEvent[];
            /**
                * <p> The status of an AWS CloudFormation blue/green deployment's target application.
                *         </p>
                */
            status?: TargetStatus | string;
            /**
                * <p>The resource type for the AWS CloudFormation blue/green deployment.</p>
                */
            resourceType?: string;
            /**
                * <p>The percentage of production traffic that the target version of an AWS CloudFormation
                *             blue/green deployment receives.</p>
                */
            targetVersionWeight?: number;
    }
    export namespace CloudFormationTarget {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CloudFormationTarget) => any;
    }
    export enum DeploymentTargetType {
            CLOUDFORMATION_TARGET = "CloudFormationTarget",
            ECS_TARGET = "ECSTarget",
            INSTANCE_TARGET = "InstanceTarget",
            LAMBDA_TARGET = "LambdaTarget"
    }
    export enum TargetLabel {
            BLUE = "Blue",
            GREEN = "Green"
    }
    /**
        * <p> Information about a set of Amazon ECS tasks in an AWS CodeDeploy deployment. An
        *             Amazon ECS task set includes details such as the desired number of tasks, how many tasks
        *             are running, and whether the task set serves production traffic. An AWS CodeDeploy
        *             application that uses the Amazon ECS compute platform deploys a containerized
        *             application in an Amazon ECS service as a task set. </p>
        */
    export interface ECSTaskSet {
            /**
                * <p> A unique ID of an <code>ECSTaskSet</code>. </p>
                */
            identifer?: string;
            /**
                * <p> The number of tasks in a task set. During a deployment that uses the Amazon ECS
                *             compute type, CodeDeploy instructs Amazon ECS to create a new task set and uses this
                *             value to determine how many tasks to create. After the updated task set is created,
                *             CodeDeploy shifts traffic to the new task set. </p>
                */
            desiredCount?: number;
            /**
                * <p> The number of tasks in the task set that are in the <code>PENDING</code> status
                *             during an Amazon ECS deployment. A task in the <code>PENDING</code> state is preparing
                *             to enter the <code>RUNNING</code> state. A task set enters the <code>PENDING</code>
                *             status when it launches for the first time, or when it is restarted after being in the
                *                 <code>STOPPED</code> state. </p>
                */
            pendingCount?: number;
            /**
                * <p> The number of tasks in the task set that are in the <code>RUNNING</code> status
                *             during an Amazon ECS deployment. A task in the <code>RUNNING</code> state is running and
                *             ready for use. </p>
                */
            runningCount?: number;
            /**
                * <p> The status of the task set. There are three valid task set statuses: </p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>PRIMARY</code>: Indicates the task set is serving production traffic.
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ACTIVE</code>: Indicates the task set is not serving production traffic.
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>DRAINING</code>: Indicates the tasks in the task set are being stopped and
                *                     their corresponding targets are being deregistered from their target group.
                *                 </p>
                *             </li>
                *          </ul>
                */
            status?: string;
            /**
                * <p> The percentage of traffic served by this task set. </p>
                */
            trafficWeight?: number;
            /**
                * <p> The target group associated with the task set. The target group is used by AWS
                *             CodeDeploy to manage traffic to a task set. </p>
                */
            targetGroup?: TargetGroupInfo;
            /**
                * <p> A label that identifies whether the ECS task set is an original target
                *                 (<code>BLUE</code>) or a replacement target (<code>GREEN</code>). </p>
                */
            taskSetLabel?: TargetLabel | string;
    }
    export namespace ECSTaskSet {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ECSTaskSet) => any;
    }
    /**
        * <p> Information about the target of an Amazon ECS deployment. </p>
        */
    export interface ECSTarget {
            /**
                * <p> The unique ID of a deployment. </p>
                */
            deploymentId?: string;
            /**
                * <p> The unique ID of a deployment target that has a type of <code>ecsTarget</code>.
                *         </p>
                */
            targetId?: string;
            /**
                * <p> The Amazon Resource Name (ARN) of the target. </p>
                */
            targetArn?: string;
            /**
                * <p> The date and time when the target Amazon ECS application was updated by a deployment.
                *         </p>
                */
            lastUpdatedAt?: Date;
            /**
                * <p> The lifecycle events of the deployment to this target Amazon ECS application. </p>
                */
            lifecycleEvents?: LifecycleEvent[];
            /**
                * <p> The status an Amazon ECS deployment's target ECS application. </p>
                */
            status?: TargetStatus | string;
            /**
                * <p> The <code>ECSTaskSet</code> objects associated with the ECS target. </p>
                */
            taskSetsInfo?: ECSTaskSet[];
    }
    export namespace ECSTarget {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ECSTarget) => any;
    }
    /**
        * <p> A target Amazon EC2 or on-premises instance during a deployment that uses the
        *             EC2/On-premises compute platform. </p>
        */
    export interface InstanceTarget {
            /**
                * <p> The unique ID of a deployment. </p>
                */
            deploymentId?: string;
            /**
                * <p> The unique ID of a deployment target that has a type of <code>instanceTarget</code>.
                *         </p>
                */
            targetId?: string;
            /**
                * <p> The Amazon Resource Name (ARN) of the target. </p>
                */
            targetArn?: string;
            /**
                * <p> The status an EC2/On-premises deployment's target instance. </p>
                */
            status?: TargetStatus | string;
            /**
                * <p> The date and time when the target instance was updated by a deployment. </p>
                */
            lastUpdatedAt?: Date;
            /**
                * <p> The lifecycle events of the deployment to this target instance. </p>
                */
            lifecycleEvents?: LifecycleEvent[];
            /**
                * <p> A label that identifies whether the instance is an original target
                *             (<code>BLUE</code>) or a replacement target (<code>GREEN</code>). </p>
                */
            instanceLabel?: TargetLabel | string;
    }
    export namespace InstanceTarget {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InstanceTarget) => any;
    }
    /**
        * <p> Information about a Lambda function specified in a deployment. </p>
        */
    export interface LambdaFunctionInfo {
            /**
                * <p> The name of a Lambda function. </p>
                */
            functionName?: string;
            /**
                * <p> The alias of a Lambda function. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/aliases-intro.html">AWS Lambda Function Aliases</a> in the
                *                 <i>AWS Lambda Developer Guide</i>.</p>
                */
            functionAlias?: string;
            /**
                * <p> The version of a Lambda function that production traffic points to. </p>
                */
            currentVersion?: string;
            /**
                * <p> The version of a Lambda function that production traffic points to after the Lambda
                *             function is deployed. </p>
                */
            targetVersion?: string;
            /**
                * <p> The percentage of production traffic that the target version of a Lambda function
                *             receives. </p>
                */
            targetVersionWeight?: number;
    }
    export namespace LambdaFunctionInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LambdaFunctionInfo) => any;
    }
    /**
        * <p> Information about the target AWS Lambda function during an AWS Lambda deployment.
        *         </p>
        */
    export interface LambdaTarget {
            /**
                * <p> The unique ID of a deployment. </p>
                */
            deploymentId?: string;
            /**
                * <p> The unique ID of a deployment target that has a type of <code>lambdaTarget</code>.
                *         </p>
                */
            targetId?: string;
            /**
                * <p> The Amazon Resource Name (ARN) of the target. </p>
                */
            targetArn?: string;
            /**
                * <p> The status an AWS Lambda deployment's target Lambda function. </p>
                */
            status?: TargetStatus | string;
            /**
                * <p> The date and time when the target Lambda function was updated by a deployment.
                *         </p>
                */
            lastUpdatedAt?: Date;
            /**
                * <p> The lifecycle events of the deployment to this target Lambda function. </p>
                */
            lifecycleEvents?: LifecycleEvent[];
            /**
                * <p> A <code>LambdaFunctionInfo</code> object that describes a target Lambda function.
                *         </p>
                */
            lambdaFunctionInfo?: LambdaFunctionInfo;
    }
    export namespace LambdaTarget {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LambdaTarget) => any;
    }
    /**
        * <p> Information about the deployment target. </p>
        */
    export interface DeploymentTarget {
            /**
                * <p>The deployment type that is specific to the deployment's compute platform or
                *             deployments initiated by a CloudFormation stack update.</p>
                */
            deploymentTargetType?: DeploymentTargetType | string;
            /**
                * <p> Information about the target for a deployment that uses the EC2/On-premises compute
                *             platform. </p>
                */
            instanceTarget?: InstanceTarget;
            /**
                * <p> Information about the target for a deployment that uses the AWS Lambda compute
                *             platform. </p>
                */
            lambdaTarget?: LambdaTarget;
            /**
                * <p> Information about the target for a deployment that uses the Amazon ECS compute
                *             platform. </p>
                */
            ecsTarget?: ECSTarget;
            /**
                * <p> Information about the target to be updated by an AWS CloudFormation blue/green
                *             deployment. This target type is used for all deployments initiated by a CloudFormation
                *             stack update.</p>
                */
            cloudFormationTarget?: CloudFormationTarget;
    }
    export namespace DeploymentTarget {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeploymentTarget) => any;
    }
    export interface BatchGetDeploymentTargetsOutput {
            /**
                * <p> A list of target objects for a deployment. Each target object contains details about
                *             the target, such as its status and lifecycle events. The type of the target objects
                *             depends on the deployment' compute platform. </p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <b>EC2/On-premises</b>: Each target object is an EC2
                *                     or on-premises instance. </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <b>AWS Lambda</b>: The target object is a specific
                *                     version of an AWS Lambda function. </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <b>Amazon ECS</b>: The target object is an Amazon ECS
                *                     service. </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <b>CloudFormation</b>: The target object is an AWS
                *                     CloudFormation blue/green deployment. </p>
                *             </li>
                *          </ul>
                */
            deploymentTargets?: DeploymentTarget[];
    }
    export namespace BatchGetDeploymentTargetsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetDeploymentTargetsOutput) => any;
    }
    /**
        * <p>The specified deployment has not started.</p>
        */
    export class DeploymentNotStartedException extends __BaseException {
            readonly name: "DeploymentNotStartedException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DeploymentNotStartedException, __BaseException>);
    }
    /**
        * <p> The provided target ID does not belong to the attempted deployment. </p>
        */
    export class DeploymentTargetDoesNotExistException extends __BaseException {
            readonly name: "DeploymentTargetDoesNotExistException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DeploymentTargetDoesNotExistException, __BaseException>);
    }
    /**
        * <p> A deployment target ID was not provided. </p>
        */
    export class DeploymentTargetIdRequiredException extends __BaseException {
            readonly name: "DeploymentTargetIdRequiredException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DeploymentTargetIdRequiredException, __BaseException>);
    }
    /**
        * <p> The maximum number of targets that can be associated with an Amazon ECS or AWS Lambda
        *             deployment was exceeded. The target list of both types of deployments must have exactly
        *             one item. This exception does not apply to EC2/On-premises deployments. </p>
        */
    export class DeploymentTargetListSizeExceededException extends __BaseException {
            readonly name: "DeploymentTargetListSizeExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DeploymentTargetListSizeExceededException, __BaseException>);
    }
    /**
        * @deprecated
        *
        * <p>The specified instance does not exist in the deployment group.</p>
        */
    export class InstanceDoesNotExistException extends __BaseException {
            readonly name: "InstanceDoesNotExistException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InstanceDoesNotExistException, __BaseException>);
    }
    /**
        * <p> The target ID provided was not valid. </p>
        */
    export class InvalidDeploymentTargetIdException extends __BaseException {
            readonly name: "InvalidDeploymentTargetIdException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidDeploymentTargetIdException, __BaseException>);
    }
    /**
        * <p>Represents the input of a <code>BatchGetOnPremisesInstances</code> operation.</p>
        */
    export interface BatchGetOnPremisesInstancesInput {
            /**
                * <p>The names of the on-premises instances about which to get information. The maximum
                *             number of instance names you can specify is 25.</p>
                */
            instanceNames: string[] | undefined;
    }
    export namespace BatchGetOnPremisesInstancesInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetOnPremisesInstancesInput) => any;
    }
    /**
        * <p>Information about an on-premises instance.</p>
        */
    export interface InstanceInfo {
            /**
                * <p>The name of the on-premises instance.</p>
                */
            instanceName?: string;
            /**
                * <p>The ARN of the IAM session associated with the on-premises instance.</p>
                */
            iamSessionArn?: string;
            /**
                * <p>The IAM user ARN associated with the on-premises instance.</p>
                */
            iamUserArn?: string;
            /**
                * <p>The ARN of the on-premises instance.</p>
                */
            instanceArn?: string;
            /**
                * <p>The time at which the on-premises instance was registered.</p>
                */
            registerTime?: Date;
            /**
                * <p>If the on-premises instance was deregistered, the time at which the on-premises
                *             instance was deregistered.</p>
                */
            deregisterTime?: Date;
            /**
                * <p>The tags currently associated with the on-premises instance.</p>
                */
            tags?: Tag[];
    }
    export namespace InstanceInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InstanceInfo) => any;
    }
    /**
        * <p>Represents the output of a <code>BatchGetOnPremisesInstances</code> operation.</p>
        */
    export interface BatchGetOnPremisesInstancesOutput {
            /**
                * <p>Information about the on-premises instances.</p>
                */
            instanceInfos?: InstanceInfo[];
    }
    export namespace BatchGetOnPremisesInstancesOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetOnPremisesInstancesOutput) => any;
    }
    /**
        * <p>A bucket name is required, but was not provided.</p>
        */
    export class BucketNameFilterRequiredException extends __BaseException {
            readonly name: "BucketNameFilterRequiredException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<BucketNameFilterRequiredException, __BaseException>);
    }
    export enum DeploymentWaitType {
            READY_WAIT = "READY_WAIT",
            TERMINATION_WAIT = "TERMINATION_WAIT"
    }
    export interface ContinueDeploymentInput {
            /**
                * <p> The unique ID of a blue/green deployment for which you want to start rerouting
                *             traffic to the replacement environment. </p>
                */
            deploymentId?: string;
            /**
                * <p> The status of the deployment's waiting period. <code>READY_WAIT</code> indicates that
                *             the deployment is ready to start shifting traffic. <code>TERMINATION_WAIT</code>
                *             indicates that the traffic is shifted, but the original target is not terminated.
                *         </p>
                */
            deploymentWaitType?: DeploymentWaitType | string;
    }
    export namespace ContinueDeploymentInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ContinueDeploymentInput) => any;
    }
    /**
        * <p>The deployment is already complete.</p>
        */
    export class DeploymentAlreadyCompletedException extends __BaseException {
            readonly name: "DeploymentAlreadyCompletedException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DeploymentAlreadyCompletedException, __BaseException>);
    }
    /**
        * <p>The deployment does not have a status of Ready and can't continue yet.</p>
        */
    export class DeploymentIsNotInReadyStateException extends __BaseException {
            readonly name: "DeploymentIsNotInReadyStateException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DeploymentIsNotInReadyStateException, __BaseException>);
    }
    /**
        * <p>The specified deployment status doesn't exist or cannot be determined.</p>
        */
    export class InvalidDeploymentStatusException extends __BaseException {
            readonly name: "InvalidDeploymentStatusException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidDeploymentStatusException, __BaseException>);
    }
    /**
        * <p> The wait type is invalid. </p>
        */
    export class InvalidDeploymentWaitTypeException extends __BaseException {
            readonly name: "InvalidDeploymentWaitTypeException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidDeploymentWaitTypeException, __BaseException>);
    }
    /**
        * <p>A call was submitted that is not supported for the specified deployment type.</p>
        */
    export class UnsupportedActionForDeploymentTypeException extends __BaseException {
            readonly name: "UnsupportedActionForDeploymentTypeException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UnsupportedActionForDeploymentTypeException, __BaseException>);
    }
    /**
        * <p>Represents the input of a <code>CreateApplication</code> operation.</p>
        */
    export interface CreateApplicationInput {
            /**
                * <p>The name of the application. This name must be unique with the applicable IAM user or
                *             AWS account.</p>
                */
            applicationName: string | undefined;
            /**
                * <p> The destination platform type for the deployment (<code>Lambda</code>,
                *                 <code>Server</code>, or <code>ECS</code>).</p>
                */
            computePlatform?: ComputePlatform | string;
            /**
                * <p> The metadata that you apply to CodeDeploy applications to help you organize and
                *             categorize them. Each tag consists of a key and an optional value, both of which you
                *             define. </p>
                */
            tags?: Tag[];
    }
    export namespace CreateApplicationInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateApplicationInput) => any;
    }
    /**
        * <p>Represents the output of a <code>CreateApplication</code> operation.</p>
        */
    export interface CreateApplicationOutput {
            /**
                * <p>A unique application ID.</p>
                */
            applicationId?: string;
    }
    export namespace CreateApplicationOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateApplicationOutput) => any;
    }
    /**
        * <p> The specified tags are not valid. </p>
        */
    export class InvalidTagsToAddException extends __BaseException {
            readonly name: "InvalidTagsToAddException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidTagsToAddException, __BaseException>);
    }
    /**
        * <p>Represents the input of a <code>CreateDeployment</code> operation.</p>
        */
    export interface CreateDeploymentInput {
            /**
                * <p>The name of an AWS CodeDeploy application associated with the IAM user or AWS
                *             account.</p>
                */
            applicationName: string | undefined;
            /**
                * <p>The name of the deployment group.</p>
                */
            deploymentGroupName?: string;
            /**
                * <p> The type and location of the revision to deploy. </p>
                */
            revision?: RevisionLocation;
            /**
                * <p>The name of a deployment configuration associated with the IAM user or AWS
                *             account.</p>
                *         <p>If not specified, the value configured in the deployment group is used as the default.
                *             If the deployment group does not have a deployment configuration associated with it,
                *                 <code>CodeDeployDefault</code>.<code>OneAtATime</code> is used by default.</p>
                */
            deploymentConfigName?: string;
            /**
                * <p>A comment about the deployment.</p>
                */
            description?: string;
            /**
                * <p> If true, then if an <code>ApplicationStop</code>, <code>BeforeBlockTraffic</code>, or
                *                 <code>AfterBlockTraffic</code> deployment lifecycle event to an instance fails, then
                *             the deployment continues to the next deployment lifecycle event. For example, if
                *                 <code>ApplicationStop</code> fails, the deployment continues with
                *                 <code>DownloadBundle</code>. If <code>BeforeBlockTraffic</code> fails, the
                *             deployment continues with <code>BlockTraffic</code>. If <code>AfterBlockTraffic</code>
                *             fails, the deployment continues with <code>ApplicationStop</code>. </p>
                *
                *         <p> If false or not specified, then if a lifecycle event fails during a deployment to an
                *             instance, that deployment fails. If deployment to that instance is part of an overall
                *             deployment and the number of healthy hosts is not less than the minimum number of
                *             healthy hosts, then a deployment to the next instance is attempted. </p>
                *
                *         <p> During a deployment, the AWS CodeDeploy agent runs the scripts specified for
                *                 <code>ApplicationStop</code>, <code>BeforeBlockTraffic</code>, and
                *                 <code>AfterBlockTraffic</code> in the AppSpec file from the previous successful
                *             deployment. (All other scripts are run from the AppSpec file in the current deployment.)
                *             If one of these scripts contains an error and does not run successfully, the deployment
                *             can fail. </p>
                *
                *         <p> If the cause of the failure is a script from the last successful deployment that will
                *             never run successfully, create a new deployment and use
                *                 <code>ignoreApplicationStopFailures</code> to specify that the
                *                 <code>ApplicationStop</code>, <code>BeforeBlockTraffic</code>, and
                *                 <code>AfterBlockTraffic</code> failures should be ignored. </p>
                */
            ignoreApplicationStopFailures?: boolean;
            /**
                * <p> Information about the instances that belong to the replacement environment in a
                *             blue/green deployment. </p>
                */
            targetInstances?: TargetInstances;
            /**
                * <p>Configuration information for an automatic rollback that is added when a deployment is
                *             created.</p>
                */
            autoRollbackConfiguration?: AutoRollbackConfiguration;
            /**
                * <p> Indicates whether to deploy to all instances or only to instances that are not
                *             running the latest application revision. </p>
                */
            updateOutdatedInstancesOnly?: boolean;
            /**
                * <p>Information about how AWS CodeDeploy handles files that already exist in a deployment
                *             target location but weren't part of the previous successful deployment.</p>
                *         <p>The <code>fileExistsBehavior</code> parameter takes any of the following
                *             values:</p>
                *         <ul>
                *             <li>
                *                 <p>DISALLOW: The deployment fails. This is also the default behavior if no option
                *                     is specified.</p>
                *             </li>
                *             <li>
                *                 <p>OVERWRITE: The version of the file from the application revision currently
                *                     being deployed replaces the version already on the instance.</p>
                *             </li>
                *             <li>
                *                 <p>RETAIN: The version of the file already on the instance is kept and used as
                *                     part of the new deployment.</p>
                *             </li>
                *          </ul>
                */
            fileExistsBehavior?: FileExistsBehavior | string;
    }
    export namespace CreateDeploymentInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateDeploymentInput) => any;
    }
    /**
        * <p> Represents the output of a <code>CreateDeployment</code> operation. </p>
        */
    export interface CreateDeploymentOutput {
            /**
                * <p> The unique ID of a deployment. </p>
                */
            deploymentId?: string;
    }
    export namespace CreateDeploymentOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateDeploymentOutput) => any;
    }
    /**
        * <p>The named deployment group with the IAM user or AWS account does not exist.</p>
        */
    export class DeploymentGroupDoesNotExistException extends __BaseException {
            readonly name: "DeploymentGroupDoesNotExistException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DeploymentGroupDoesNotExistException, __BaseException>);
    }
    /**
        * <p>The number of allowed deployments was exceeded.</p>
        */
    export class DeploymentLimitExceededException extends __BaseException {
            readonly name: "DeploymentLimitExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DeploymentLimitExceededException, __BaseException>);
    }
    /**
        * <p>The description is too long.</p>
        */
    export class DescriptionTooLongException extends __BaseException {
            readonly name: "DescriptionTooLongException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DescriptionTooLongException, __BaseException>);
    }
    /**
        * <p>The automatic rollback configuration was specified in an invalid format. For example,
        *             automatic rollback is enabled, but an invalid triggering event type or no event types
        *             were listed.</p>
        */
    export class InvalidAutoRollbackConfigException extends __BaseException {
            readonly name: "InvalidAutoRollbackConfigException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidAutoRollbackConfigException, __BaseException>);
    }
    /**
        * <p>The Auto Scaling group was specified in an invalid format or does not exist.</p>
        */
    export class InvalidAutoScalingGroupException extends __BaseException {
            readonly name: "InvalidAutoScalingGroupException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidAutoScalingGroupException, __BaseException>);
    }
    /**
        * <p>The deployment configuration name was specified in an invalid format.</p>
        */
    export class InvalidDeploymentConfigNameException extends __BaseException {
            readonly name: "InvalidDeploymentConfigNameException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidDeploymentConfigNameException, __BaseException>);
    }
    /**
        * <p>An invalid fileExistsBehavior option was specified to determine how AWS CodeDeploy
        *             handles files or directories that already exist in a deployment target location, but
        *             weren't part of the previous successful deployment. Valid values include "DISALLOW,"
        *             "OVERWRITE," and "RETAIN."</p>
        */
    export class InvalidFileExistsBehaviorException extends __BaseException {
            readonly name: "InvalidFileExistsBehaviorException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidFileExistsBehaviorException, __BaseException>);
    }
    /**
        * <p>The GitHub token is not valid.</p>
        */
    export class InvalidGitHubAccountTokenException extends __BaseException {
            readonly name: "InvalidGitHubAccountTokenException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidGitHubAccountTokenException, __BaseException>);
    }
    /**
        * <p>The IgnoreApplicationStopFailures value is invalid. For AWS Lambda deployments,
        *                 <code>false</code> is expected. For EC2/On-premises deployments, <code>true</code>
        *             or <code>false</code> is expected.</p>
        */
    export class InvalidIgnoreApplicationStopFailuresValueException extends __BaseException {
            readonly name: "InvalidIgnoreApplicationStopFailuresValueException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidIgnoreApplicationStopFailuresValueException, __BaseException>);
    }
    /**
        * <p>An invalid load balancer name, or no load balancer name, was specified.</p>
        */
    export class InvalidLoadBalancerInfoException extends __BaseException {
            readonly name: "InvalidLoadBalancerInfoException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidLoadBalancerInfoException, __BaseException>);
    }
    /**
        * <p>The service role ARN was specified in an invalid format. Or, if an Auto Scaling group
        *             was specified, the specified service role does not grant the appropriate permissions to
        *             Amazon EC2 Auto Scaling.</p>
        */
    export class InvalidRoleException extends __BaseException {
            readonly name: "InvalidRoleException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidRoleException, __BaseException>);
    }
    /**
        * <p>The target instance configuration is invalid. Possible causes include:</p>
        *         <ul>
        *             <li>
        *                 <p>Configuration data for target instances was entered for an in-place
        *                     deployment.</p>
        *             </li>
        *             <li>
        *                 <p>The limit of 10 tags for a tag type was exceeded.</p>
        *             </li>
        *             <li>
        *                 <p>The combined length of the tag names exceeded the limit. </p>
        *             </li>
        *             <li>
        *                 <p>A specified tag is not currently applied to any instances.</p>
        *             </li>
        *          </ul>
        */
    export class InvalidTargetInstancesException extends __BaseException {
            readonly name: "InvalidTargetInstancesException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidTargetInstancesException, __BaseException>);
    }
    /**
        * <p> The configuration that specifies how traffic is routed during a deployment is
        *             invalid.</p>
        */
    export class InvalidTrafficRoutingConfigurationException extends __BaseException {
            readonly name: "InvalidTrafficRoutingConfigurationException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidTrafficRoutingConfigurationException, __BaseException>);
    }
    /**
        * <p>The UpdateOutdatedInstancesOnly value is invalid. For AWS Lambda deployments,
        *                 <code>false</code> is expected. For EC2/On-premises deployments, <code>true</code>
        *             or <code>false</code> is expected.</p>
        */
    export class InvalidUpdateOutdatedInstancesOnlyValueException extends __BaseException {
            readonly name: "InvalidUpdateOutdatedInstancesOnlyValueException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidUpdateOutdatedInstancesOnlyValueException, __BaseException>);
    }
    /**
        * <p>The named revision does not exist with the IAM user or AWS account.</p>
        */
    export class RevisionDoesNotExistException extends __BaseException {
            readonly name: "RevisionDoesNotExistException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<RevisionDoesNotExistException, __BaseException>);
    }
    /**
        * <p>An API function was called too frequently.</p>
        */
    export class ThrottlingException extends __BaseException {
            readonly name: "ThrottlingException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ThrottlingException, __BaseException>);
    }
    export type MinimumHealthyHostsType = "FLEET_PERCENT" | "HOST_COUNT";
    /**
        * <p>Information about minimum healthy instance.</p>
        */
    export interface MinimumHealthyHosts {
            /**
                * <p>The minimum healthy instance type:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>HOST_COUNT</code>: The minimum number of healthy instances as an
                *                     absolute value.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>FLEET_PERCENT</code>: The minimum number of healthy instances as a
                *                     percentage of the total number of instances in the deployment.</p>
                *             </li>
                *          </ul>
                *         <p>In an example of nine instances, if a HOST_COUNT of six is specified, deploy to up to
                *             three instances at a time. The deployment is successful if six or more instances are
                *             deployed to successfully. Otherwise, the deployment fails. If a FLEET_PERCENT of 40 is
                *             specified, deploy to up to five instances at a time. The deployment is successful if
                *             four or more instances are deployed to successfully. Otherwise, the deployment
                *             fails.</p>
                *         <note>
                *             <p>In a call to the <code>GetDeploymentConfig</code>, CodeDeployDefault.OneAtATime
                *                 returns a minimum healthy instance type of MOST_CONCURRENCY and a value of 1. This
                *                 means a deployment to only one instance at a time. (You cannot set the type to
                *                 MOST_CONCURRENCY, only to HOST_COUNT or FLEET_PERCENT.) In addition, with
                *                 CodeDeployDefault.OneAtATime, AWS CodeDeploy attempts to ensure that all instances
                *                 but one are kept in a healthy state during the deployment. Although this allows one
                *                 instance at a time to be taken offline for a new deployment, it also means that if
                *                 the deployment to the last instance fails, the overall deployment is still
                *                 successful.</p>
                *         </note>
                *         <p>For more information, see <a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/instances-health.html">AWS CodeDeploy Instance
                *                 Health</a> in the <i>AWS CodeDeploy User Guide</i>.</p>
                */
            type?: MinimumHealthyHostsType | string;
            /**
                * <p>The minimum healthy instance value.</p>
                */
            value?: number;
    }
    export namespace MinimumHealthyHosts {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: MinimumHealthyHosts) => any;
    }
    /**
        * <p>A configuration that shifts traffic from one version of a Lambda function or ECS task
        *             set to another in two increments. The original and target Lambda function versions or
        *             ECS task sets are specified in the deployment's AppSpec file.</p>
        */
    export interface TimeBasedCanary {
            /**
                * <p>The percentage of traffic to shift in the first increment of a
                *                 <code>TimeBasedCanary</code> deployment.</p>
                */
            canaryPercentage?: number;
            /**
                * <p>The number of minutes between the first and second traffic shifts of a
                *                 <code>TimeBasedCanary</code> deployment.</p>
                */
            canaryInterval?: number;
    }
    export namespace TimeBasedCanary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TimeBasedCanary) => any;
    }
    /**
        * <p>A configuration that shifts traffic from one version of a Lambda function or ECS task
        *             set to another in equal increments, with an equal number of minutes between each
        *             increment. The original and target Lambda function versions or ECS task sets are
        *             specified in the deployment's AppSpec file.</p>
        */
    export interface TimeBasedLinear {
            /**
                * <p>The percentage of traffic that is shifted at the start of each increment of a
                *                 <code>TimeBasedLinear</code> deployment.</p>
                */
            linearPercentage?: number;
            /**
                * <p>The number of minutes between each incremental traffic shift of a
                *                 <code>TimeBasedLinear</code> deployment.</p>
                */
            linearInterval?: number;
    }
    export namespace TimeBasedLinear {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TimeBasedLinear) => any;
    }
    export enum TrafficRoutingType {
            AllAtOnce = "AllAtOnce",
            TimeBasedCanary = "TimeBasedCanary",
            TimeBasedLinear = "TimeBasedLinear"
    }
    /**
        * <p>The configuration that specifies how traffic is shifted from one version of a Lambda
        *             function to another version during an AWS Lambda deployment, or from one Amazon ECS task
        *             set to another during an Amazon ECS deployment.</p>
        */
    export interface TrafficRoutingConfig {
            /**
                * <p>The type of traffic shifting (<code>TimeBasedCanary</code> or
                *                 <code>TimeBasedLinear</code>) used by a deployment configuration.</p>
                */
            type?: TrafficRoutingType | string;
            /**
                * <p>A configuration that shifts traffic from one version of a Lambda function or ECS task
                *             set to another in two increments. The original and target Lambda function versions or
                *             ECS task sets are specified in the deployment's AppSpec file.</p>
                */
            timeBasedCanary?: TimeBasedCanary;
            /**
                * <p>A configuration that shifts traffic from one version of a Lambda function or ECS task
                *             set to another in equal increments, with an equal number of minutes between each
                *             increment. The original and target Lambda function versions or ECS task sets are
                *             specified in the deployment's AppSpec file.</p>
                */
            timeBasedLinear?: TimeBasedLinear;
    }
    export namespace TrafficRoutingConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TrafficRoutingConfig) => any;
    }
    /**
        * <p>Represents the input of a <code>CreateDeploymentConfig</code> operation.</p>
        */
    export interface CreateDeploymentConfigInput {
            /**
                * <p>The name of the deployment configuration to create.</p>
                */
            deploymentConfigName: string | undefined;
            /**
                * <p>The minimum number of healthy instances that should be available at any time during
                *             the deployment. There are two parameters expected in the input: type and value.</p>
                *         <p>The type parameter takes either of the following values:</p>
                *         <ul>
                *             <li>
                *                 <p>HOST_COUNT: The value parameter represents the minimum number of healthy
                *                     instances as an absolute value.</p>
                *             </li>
                *             <li>
                *                 <p>FLEET_PERCENT: The value parameter represents the minimum number of healthy
                *                     instances as a percentage of the total number of instances in the deployment. If
                *                     you specify FLEET_PERCENT, at the start of the deployment, AWS CodeDeploy
                *                     converts the percentage to the equivalent number of instances and rounds up
                *                     fractional instances.</p>
                *             </li>
                *          </ul>
                *         <p>The value parameter takes an integer.</p>
                *         <p>For example, to set a minimum of 95% healthy instance, specify a type of FLEET_PERCENT
                *             and a value of 95.</p>
                */
            minimumHealthyHosts?: MinimumHealthyHosts;
            /**
                * <p>The configuration that specifies how the deployment traffic is routed.</p>
                */
            trafficRoutingConfig?: TrafficRoutingConfig;
            /**
                * <p>The destination platform type for the deployment (<code>Lambda</code>,
                *                 <code>Server</code>, or <code>ECS</code>).</p>
                */
            computePlatform?: ComputePlatform | string;
    }
    export namespace CreateDeploymentConfigInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateDeploymentConfigInput) => any;
    }
    /**
        * <p>Represents the output of a <code>CreateDeploymentConfig</code> operation.</p>
        */
    export interface CreateDeploymentConfigOutput {
            /**
                * <p>A unique deployment configuration ID.</p>
                */
            deploymentConfigId?: string;
    }
    export namespace CreateDeploymentConfigOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateDeploymentConfigOutput) => any;
    }
    /**
        * <p>A deployment configuration with the specified name with the IAM user or AWS account
        *             already exists.</p>
        */
    export class DeploymentConfigAlreadyExistsException extends __BaseException {
            readonly name: "DeploymentConfigAlreadyExistsException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DeploymentConfigAlreadyExistsException, __BaseException>);
    }
    /**
        * <p>The deployment configurations limit was exceeded.</p>
        */
    export class DeploymentConfigLimitExceededException extends __BaseException {
            readonly name: "DeploymentConfigLimitExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DeploymentConfigLimitExceededException, __BaseException>);
    }
    /**
        * <p>The deployment configuration name was not specified.</p>
        */
    export class DeploymentConfigNameRequiredException extends __BaseException {
            readonly name: "DeploymentConfigNameRequiredException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DeploymentConfigNameRequiredException, __BaseException>);
    }
    /**
        * <p>The minimum healthy instance value was specified in an invalid format.</p>
        */
    export class InvalidMinimumHealthyHostValueException extends __BaseException {
            readonly name: "InvalidMinimumHealthyHostValueException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidMinimumHealthyHostValueException, __BaseException>);
    }
    /**
        * <p>Represents the input of a <code>CreateDeploymentGroup</code> operation.</p>
        */
    export interface CreateDeploymentGroupInput {
            /**
                * <p>The name of an AWS CodeDeploy application associated with the IAM user or AWS
                *             account.</p>
                */
            applicationName: string | undefined;
            /**
                * <p>The name of a new deployment group for the specified application.</p>
                */
            deploymentGroupName: string | undefined;
            /**
                * <p>If specified, the deployment configuration name can be either one of the predefined
                *             configurations provided with AWS CodeDeploy or a custom deployment configuration that
                *             you create by calling the create deployment configuration operation.</p>
                *         <p>
                *             <code>CodeDeployDefault.OneAtATime</code> is the default deployment configuration. It
                *             is used if a configuration isn't specified for the deployment or deployment
                *             group.</p>
                *         <p>For more information about the predefined deployment configurations in AWS CodeDeploy,
                *             see <a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/deployment-configurations.html">Working with
                *                 Deployment Configurations in CodeDeploy</a> in the <i>AWS CodeDeploy User
                *                 Guide</i>.</p>
                */
            deploymentConfigName?: string;
            /**
                * <p>The Amazon EC2 tags on which to filter. The deployment group includes EC2 instances
                *             with any of the specified tags. Cannot be used in the same call as ec2TagSet.</p>
                */
            ec2TagFilters?: EC2TagFilter[];
            /**
                * <p>The on-premises instance tags on which to filter. The deployment group includes
                *             on-premises instances with any of the specified tags. Cannot be used in the same call as
                *                 <code>OnPremisesTagSet</code>.</p>
                */
            onPremisesInstanceTagFilters?: TagFilter[];
            /**
                * <p>A list of associated Amazon EC2 Auto Scaling groups.</p>
                */
            autoScalingGroups?: string[];
            /**
                * <p>A service role Amazon Resource Name (ARN) that allows AWS CodeDeploy to act on the
                *             user's behalf when interacting with AWS services.</p>
                */
            serviceRoleArn: string | undefined;
            /**
                * <p>Information about triggers to create when the deployment group is created. For
                *             examples, see <a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/how-to-notify-sns.html">Create a Trigger for an
                *                 AWS CodeDeploy Event</a> in the <i>AWS CodeDeploy User
                *             Guide</i>.</p>
                */
            triggerConfigurations?: TriggerConfig[];
            /**
                * <p>Information to add about Amazon CloudWatch alarms when the deployment group is
                *             created.</p>
                */
            alarmConfiguration?: AlarmConfiguration;
            /**
                * <p>Configuration information for an automatic rollback that is added when a deployment
                *             group is created.</p>
                */
            autoRollbackConfiguration?: AutoRollbackConfiguration;
            /**
                * <p>Indicates what happens when new EC2 instances are launched mid-deployment and do not
                *             receive the deployed application revision.</p>
                *         <p>If this option is set to <code>UPDATE</code> or is unspecified, CodeDeploy initiates
                *             one or more 'auto-update outdated instances' deployments to apply the deployed
                *             application revision to the new EC2 instances.</p>
                *         <p>If this option is set to <code>IGNORE</code>, CodeDeploy does not initiate a
                *             deployment to update the new EC2 instances. This may result in instances having
                *             different revisions.</p>
                */
            outdatedInstancesStrategy?: OutdatedInstancesStrategy | string;
            /**
                * <p>Information about the type of deployment, in-place or blue/green, that you want to run
                *             and whether to route deployment traffic behind a load balancer.</p>
                */
            deploymentStyle?: DeploymentStyle;
            /**
                * <p>Information about blue/green deployment options for a deployment group.</p>
                */
            blueGreenDeploymentConfiguration?: BlueGreenDeploymentConfiguration;
            /**
                * <p>Information about the load balancer used in a deployment.</p>
                */
            loadBalancerInfo?: LoadBalancerInfo;
            /**
                * <p>Information about groups of tags applied to EC2 instances. The deployment group
                *             includes only EC2 instances identified by all the tag groups. Cannot be used in the same
                *             call as <code>ec2TagFilters</code>.</p>
                */
            ec2TagSet?: EC2TagSet;
            /**
                * <p> The target Amazon ECS services in the deployment group. This applies only to
                *             deployment groups that use the Amazon ECS compute platform. A target Amazon ECS service
                *             is specified as an Amazon ECS cluster and service name pair using the format
                *                 <code><clustername>:<servicename></code>. </p>
                */
            ecsServices?: ECSService[];
            /**
                * <p>Information about groups of tags applied to on-premises instances. The deployment
                *             group includes only on-premises instances identified by all of the tag groups. Cannot be
                *             used in the same call as <code>onPremisesInstanceTagFilters</code>.</p>
                */
            onPremisesTagSet?: OnPremisesTagSet;
            /**
                * <p> The metadata that you apply to CodeDeploy deployment groups to help you organize and
                *             categorize them. Each tag consists of a key and an optional value, both of which you
                *             define. </p>
                */
            tags?: Tag[];
    }
    export namespace CreateDeploymentGroupInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateDeploymentGroupInput) => any;
    }
    /**
        * <p>Represents the output of a <code>CreateDeploymentGroup</code> operation.</p>
        */
    export interface CreateDeploymentGroupOutput {
            /**
                * <p>A unique deployment group ID.</p>
                */
            deploymentGroupId?: string;
    }
    export namespace CreateDeploymentGroupOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateDeploymentGroupOutput) => any;
    }
    /**
        * <p>A deployment group with the specified name with the IAM user or AWS account already
        *             exists.</p>
        */
    export class DeploymentGroupAlreadyExistsException extends __BaseException {
            readonly name: "DeploymentGroupAlreadyExistsException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DeploymentGroupAlreadyExistsException, __BaseException>);
    }
    /**
        * <p> The deployment groups limit was exceeded.</p>
        */
    export class DeploymentGroupLimitExceededException extends __BaseException {
            readonly name: "DeploymentGroupLimitExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DeploymentGroupLimitExceededException, __BaseException>);
    }
    /**
        * <p> The Amazon ECS service is associated with more than one deployment groups. An Amazon
        *             ECS service can be associated with only one deployment group. </p>
        */
    export class ECSServiceMappingLimitExceededException extends __BaseException {
            readonly name: "ECSServiceMappingLimitExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ECSServiceMappingLimitExceededException, __BaseException>);
    }
    /**
        * <p>The format of the alarm configuration is invalid. Possible causes include:</p>
        *         <ul>
        *             <li>
        *                 <p>The alarm list is null.</p>
        *             </li>
        *             <li>
        *                 <p>The alarm object is null.</p>
        *             </li>
        *             <li>
        *                 <p>The alarm name is empty or null or exceeds the limit of 255 characters.</p>
        *             </li>
        *             <li>
        *                 <p>Two alarms with the same name have been specified.</p>
        *             </li>
        *             <li>
        *                 <p>The alarm configuration is enabled, but the alarm list is empty.</p>
        *             </li>
        *          </ul>
        */
    export class InvalidAlarmConfigException extends __BaseException {
            readonly name: "InvalidAlarmConfigException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidAlarmConfigException, __BaseException>);
    }
    /**
        * <p>The configuration for the blue/green deployment group was provided in an invalid
        *             format. For information about deployment configuration format, see <a>CreateDeploymentConfig</a>.</p>
        */
    export class InvalidBlueGreenDeploymentConfigurationException extends __BaseException {
            readonly name: "InvalidBlueGreenDeploymentConfigurationException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidBlueGreenDeploymentConfigurationException, __BaseException>);
    }
    /**
        * <p>An invalid deployment style was specified. Valid deployment types include "IN_PLACE"
        *             and "BLUE_GREEN." Valid deployment options include "WITH_TRAFFIC_CONTROL" and
        *             "WITHOUT_TRAFFIC_CONTROL."</p>
        */
    export class InvalidDeploymentStyleException extends __BaseException {
            readonly name: "InvalidDeploymentStyleException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidDeploymentStyleException, __BaseException>);
    }
    /**
        * <p>A call was submitted that specified both Ec2TagFilters and Ec2TagSet, but only one of
        *             these data types can be used in a single call.</p>
        */
    export class InvalidEC2TagCombinationException extends __BaseException {
            readonly name: "InvalidEC2TagCombinationException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidEC2TagCombinationException, __BaseException>);
    }
    /**
        * <p>The tag was specified in an invalid format.</p>
        */
    export class InvalidEC2TagException extends __BaseException {
            readonly name: "InvalidEC2TagException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidEC2TagException, __BaseException>);
    }
    /**
        * <p> The Amazon ECS service identifier is not valid. </p>
        */
    export class InvalidECSServiceException extends __BaseException {
            readonly name: "InvalidECSServiceException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidECSServiceException, __BaseException>);
    }
    /**
        * <p>The input was specified in an invalid format.</p>
        */
    export class InvalidInputException extends __BaseException {
            readonly name: "InvalidInputException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidInputException, __BaseException>);
    }
    /**
        * <p>A call was submitted that specified both OnPremisesTagFilters and OnPremisesTagSet,
        *             but only one of these data types can be used in a single call.</p>
        */
    export class InvalidOnPremisesTagCombinationException extends __BaseException {
            readonly name: "InvalidOnPremisesTagCombinationException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidOnPremisesTagCombinationException, __BaseException>);
    }
    /**
        * <p> A target group pair associated with this deployment is not valid. </p>
        */
    export class InvalidTargetGroupPairException extends __BaseException {
            readonly name: "InvalidTargetGroupPairException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidTargetGroupPairException, __BaseException>);
    }
    /**
        * <p>The trigger was specified in an invalid format.</p>
        */
    export class InvalidTriggerConfigException extends __BaseException {
            readonly name: "InvalidTriggerConfigException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidTriggerConfigException, __BaseException>);
    }
    /**
        * <p>The limit for lifecycle hooks was exceeded.</p>
        */
    export class LifecycleHookLimitExceededException extends __BaseException {
            readonly name: "LifecycleHookLimitExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<LifecycleHookLimitExceededException, __BaseException>);
    }
    /**
        * <p>The role ID was not specified.</p>
        */
    export class RoleRequiredException extends __BaseException {
            readonly name: "RoleRequiredException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<RoleRequiredException, __BaseException>);
    }
    /**
        * <p>The number of tag groups included in the tag set list exceeded the maximum allowed
        *             limit of 3.</p>
        */
    export class TagSetListLimitExceededException extends __BaseException {
            readonly name: "TagSetListLimitExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TagSetListLimitExceededException, __BaseException>);
    }
    /**
        * <p>The maximum allowed number of triggers was exceeded.</p>
        */
    export class TriggerTargetsLimitExceededException extends __BaseException {
            readonly name: "TriggerTargetsLimitExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TriggerTargetsLimitExceededException, __BaseException>);
    }
    /**
        * <p>Represents the input of a <code>DeleteApplication</code> operation.</p>
        */
    export interface DeleteApplicationInput {
            /**
                * <p>The name of an AWS CodeDeploy application associated with the IAM user or AWS
                *             account.</p>
                */
            applicationName: string | undefined;
    }
    export namespace DeleteApplicationInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteApplicationInput) => any;
    }
    /**
        * <p>Represents the input of a <code>DeleteDeploymentConfig</code> operation.</p>
        */
    export interface DeleteDeploymentConfigInput {
            /**
                * <p>The name of a deployment configuration associated with the IAM user or AWS
                *             account.</p>
                */
            deploymentConfigName: string | undefined;
    }
    export namespace DeleteDeploymentConfigInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteDeploymentConfigInput) => any;
    }
    /**
        * <p>The deployment configuration is still in use.</p>
        */
    export class DeploymentConfigInUseException extends __BaseException {
            readonly name: "DeploymentConfigInUseException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DeploymentConfigInUseException, __BaseException>);
    }
    /**
        * <p>An invalid operation was detected.</p>
        */
    export class InvalidOperationException extends __BaseException {
            readonly name: "InvalidOperationException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidOperationException, __BaseException>);
    }
    /**
        * <p>Represents the input of a <code>DeleteDeploymentGroup</code> operation.</p>
        */
    export interface DeleteDeploymentGroupInput {
            /**
                * <p>The name of an AWS CodeDeploy application associated with the IAM user or AWS
                *             account.</p>
                */
            applicationName: string | undefined;
            /**
                * <p>The name of a deployment group for the specified application.</p>
                */
            deploymentGroupName: string | undefined;
    }
    export namespace DeleteDeploymentGroupInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteDeploymentGroupInput) => any;
    }
    /**
        * <p>Represents the output of a <code>DeleteDeploymentGroup</code> operation.</p>
        */
    export interface DeleteDeploymentGroupOutput {
            /**
                * <p>If the output contains no data, and the corresponding deployment group contained at
                *             least one Auto Scaling group, AWS CodeDeploy successfully removed all corresponding Auto
                *             Scaling lifecycle event hooks from the Amazon EC2 instances in the Auto Scaling group.
                *             If the output contains data, AWS CodeDeploy could not remove some Auto Scaling lifecycle
                *             event hooks from the Amazon EC2 instances in the Auto Scaling group.</p>
                */
            hooksNotCleanedUp?: AutoScalingGroup[];
    }
    export namespace DeleteDeploymentGroupOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteDeploymentGroupOutput) => any;
    }
    /**
        * <p>Represents the input of a <code>DeleteGitHubAccount</code> operation.</p>
        */
    export interface DeleteGitHubAccountTokenInput {
            /**
                * <p>The name of the GitHub account connection to delete.</p>
                */
            tokenName?: string;
    }
    export namespace DeleteGitHubAccountTokenInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteGitHubAccountTokenInput) => any;
    }
    /**
        * <p>Represents the output of a <code>DeleteGitHubAccountToken</code> operation.</p>
        */
    export interface DeleteGitHubAccountTokenOutput {
            /**
                * <p>The name of the GitHub account connection that was deleted.</p>
                */
            tokenName?: string;
    }
    export namespace DeleteGitHubAccountTokenOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteGitHubAccountTokenOutput) => any;
    }
    /**
        * <p>No GitHub account connection exists with the named specified in the call.</p>
        */
    export class GitHubAccountTokenDoesNotExistException extends __BaseException {
            readonly name: "GitHubAccountTokenDoesNotExistException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<GitHubAccountTokenDoesNotExistException, __BaseException>);
    }
    /**
        * <p>The call is missing a required GitHub account connection name.</p>
        */
    export class GitHubAccountTokenNameRequiredException extends __BaseException {
            readonly name: "GitHubAccountTokenNameRequiredException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<GitHubAccountTokenNameRequiredException, __BaseException>);
    }
    /**
        * <p>The format of the specified GitHub account connection name is invalid.</p>
        */
    export class InvalidGitHubAccountTokenNameException extends __BaseException {
            readonly name: "InvalidGitHubAccountTokenNameException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidGitHubAccountTokenNameException, __BaseException>);
    }
    /**
        * <p>The API used does not support the deployment.</p>
        */
    export class OperationNotSupportedException extends __BaseException {
            readonly name: "OperationNotSupportedException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<OperationNotSupportedException, __BaseException>);
    }
    /**
        * <p>The specified resource could not be validated.</p>
        */
    export class ResourceValidationException extends __BaseException {
            readonly name: "ResourceValidationException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceValidationException, __BaseException>);
    }
    export interface DeleteResourcesByExternalIdInput {
            /**
                * <p>The unique ID of an external resource (for example, a CloudFormation stack ID) that is
                *             linked to one or more CodeDeploy resources.</p>
                */
            externalId?: string;
    }
    export namespace DeleteResourcesByExternalIdInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteResourcesByExternalIdInput) => any;
    }
    export interface DeleteResourcesByExternalIdOutput {
    }
    export namespace DeleteResourcesByExternalIdOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteResourcesByExternalIdOutput) => any;
    }
    /**
        * <p>Represents the input of a <code>DeregisterOnPremisesInstance</code> operation.</p>
        */
    export interface DeregisterOnPremisesInstanceInput {
            /**
                * <p>The name of the on-premises instance to deregister.</p>
                */
            instanceName: string | undefined;
    }
    export namespace DeregisterOnPremisesInstanceInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeregisterOnPremisesInstanceInput) => any;
    }
    /**
        * <p>Represents the input of a <code>GetApplication</code> operation.</p>
        */
    export interface GetApplicationInput {
            /**
                * <p>The name of an AWS CodeDeploy application associated with the IAM user or AWS
                *             account.</p>
                */
            applicationName: string | undefined;
    }
    export namespace GetApplicationInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetApplicationInput) => any;
    }
    /**
        * <p>Represents the output of a <code>GetApplication</code> operation.</p>
        */
    export interface GetApplicationOutput {
            /**
                * <p>Information about the application.</p>
                */
            application?: ApplicationInfo;
    }
    export namespace GetApplicationOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetApplicationOutput) => any;
    }
    /**
        * <p>Represents the input of a <code>GetApplicationRevision</code> operation.</p>
        */
    export interface GetApplicationRevisionInput {
            /**
                * <p>The name of the application that corresponds to the revision.</p>
                */
            applicationName: string | undefined;
            /**
                * <p>Information about the application revision to get, including type and location.</p>
                */
            revision: RevisionLocation | undefined;
    }
    export namespace GetApplicationRevisionInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetApplicationRevisionInput) => any;
    }
    /**
        * <p>Represents the output of a <code>GetApplicationRevision</code> operation.</p>
        */
    export interface GetApplicationRevisionOutput {
            /**
                * <p>The name of the application that corresponds to the revision.</p>
                */
            applicationName?: string;
            /**
                * <p>Additional information about the revision, including type and location.</p>
                */
            revision?: RevisionLocation;
            /**
                * <p>General information about the revision.</p>
                */
            revisionInfo?: GenericRevisionInfo;
    }
    export namespace GetApplicationRevisionOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetApplicationRevisionOutput) => any;
    }
    /**
        * <p>Represents the input of a <code>GetDeployment</code> operation.</p>
        */
    export interface GetDeploymentInput {
            /**
                * <p> The unique ID of a deployment associated with the IAM user or AWS account. </p>
                */
            deploymentId: string | undefined;
    }
    export namespace GetDeploymentInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetDeploymentInput) => any;
    }
    /**
        * <p>Represents the output of a <code>GetDeployment</code> operation.</p>
        */
    export interface GetDeploymentOutput {
            /**
                * <p>Information about the deployment.</p>
                */
            deploymentInfo?: DeploymentInfo;
    }
    export namespace GetDeploymentOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetDeploymentOutput) => any;
    }
    /**
        * <p>Represents the input of a <code>GetDeploymentConfig</code> operation.</p>
        */
    export interface GetDeploymentConfigInput {
            /**
                * <p>The name of a deployment configuration associated with the IAM user or AWS
                *             account.</p>
                */
            deploymentConfigName: string | undefined;
    }
    export namespace GetDeploymentConfigInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetDeploymentConfigInput) => any;
    }
    /**
        * <p>Information about a deployment configuration.</p>
        */
    export interface DeploymentConfigInfo {
            /**
                * <p>The deployment configuration ID.</p>
                */
            deploymentConfigId?: string;
            /**
                * <p>The deployment configuration name.</p>
                */
            deploymentConfigName?: string;
            /**
                * <p>Information about the number or percentage of minimum healthy instance.</p>
                */
            minimumHealthyHosts?: MinimumHealthyHosts;
            /**
                * <p>The time at which the deployment configuration was created.</p>
                */
            createTime?: Date;
            /**
                * <p>The destination platform type for the deployment (<code>Lambda</code>,
                *                 <code>Server</code>, or <code>ECS</code>).</p>
                */
            computePlatform?: ComputePlatform | string;
            /**
                * <p>The configuration that specifies how the deployment traffic is routed. Used for
                *             deployments with a Lambda or ECS compute platform only.</p>
                */
            trafficRoutingConfig?: TrafficRoutingConfig;
    }
    export namespace DeploymentConfigInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeploymentConfigInfo) => any;
    }
    /**
        * <p>Represents the output of a <code>GetDeploymentConfig</code> operation.</p>
        */
    export interface GetDeploymentConfigOutput {
            /**
                * <p>Information about the deployment configuration.</p>
                */
            deploymentConfigInfo?: DeploymentConfigInfo;
    }
    export namespace GetDeploymentConfigOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetDeploymentConfigOutput) => any;
    }
    /**
        * <p>Represents the input of a <code>GetDeploymentGroup</code> operation.</p>
        */
    export interface GetDeploymentGroupInput {
            /**
                * <p>The name of an AWS CodeDeploy application associated with the IAM user or AWS
                *             account.</p>
                */
            applicationName: string | undefined;
            /**
                * <p>The name of a deployment group for the specified application.</p>
                */
            deploymentGroupName: string | undefined;
    }
    export namespace GetDeploymentGroupInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetDeploymentGroupInput) => any;
    }
    /**
        * <p>Represents the output of a <code>GetDeploymentGroup</code> operation.</p>
        */
    export interface GetDeploymentGroupOutput {
            /**
                * <p>Information about the deployment group.</p>
                */
            deploymentGroupInfo?: DeploymentGroupInfo;
    }
    export namespace GetDeploymentGroupOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetDeploymentGroupOutput) => any;
    }
    /**
        * <p> Represents the input of a <code>GetDeploymentInstance</code> operation. </p>
        */
    export interface GetDeploymentInstanceInput {
            /**
                * <p> The unique ID of a deployment. </p>
                */
            deploymentId: string | undefined;
            /**
                * <p> The unique ID of an instance in the deployment group. </p>
                */
            instanceId: string | undefined;
    }
    export namespace GetDeploymentInstanceInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetDeploymentInstanceInput) => any;
    }
    /**
        * <p> Represents the output of a <code>GetDeploymentInstance</code> operation. </p>
        */
    export interface GetDeploymentInstanceOutput {
            /**
                * @deprecated
                *
                * <p> Information about the instance. </p>
                */
            instanceSummary?: InstanceSummary;
    }
    export namespace GetDeploymentInstanceOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetDeploymentInstanceOutput) => any;
    }
    export interface GetDeploymentTargetInput {
            /**
                * <p> The unique ID of a deployment. </p>
                */
            deploymentId?: string;
            /**
                * <p> The unique ID of a deployment target. </p>
                */
            targetId?: string;
    }
    export namespace GetDeploymentTargetInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetDeploymentTargetInput) => any;
    }
    export interface GetDeploymentTargetOutput {
            /**
                * <p> A deployment target that contains information about a deployment such as its status,
                *             lifecycle events, and when it was last updated. It also contains metadata about the
                *             deployment target. The deployment target metadata depends on the deployment target's
                *             type (<code>instanceTarget</code>, <code>lambdaTarget</code>, or
                *             <code>ecsTarget</code>). </p>
                */
            deploymentTarget?: DeploymentTarget;
    }
    export namespace GetDeploymentTargetOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetDeploymentTargetOutput) => any;
    }
    /**
        * <p> Represents the input of a <code>GetOnPremisesInstance</code> operation. </p>
        */
    export interface GetOnPremisesInstanceInput {
            /**
                * <p> The name of the on-premises instance about which to get information. </p>
                */
            instanceName: string | undefined;
    }
    export namespace GetOnPremisesInstanceInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetOnPremisesInstanceInput) => any;
    }
    /**
        * <p> Represents the output of a <code>GetOnPremisesInstance</code> operation. </p>
        */
    export interface GetOnPremisesInstanceOutput {
            /**
                * <p> Information about the on-premises instance. </p>
                */
            instanceInfo?: InstanceInfo;
    }
    export namespace GetOnPremisesInstanceOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetOnPremisesInstanceOutput) => any;
    }
    /**
        * <p>The bucket name either doesn't exist or was specified in an invalid format.</p>
        */
    export class InvalidBucketNameFilterException extends __BaseException {
            readonly name: "InvalidBucketNameFilterException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidBucketNameFilterException, __BaseException>);
    }
    /**
        * <p>The deployed state filter was specified in an invalid format.</p>
        */
    export class InvalidDeployedStateFilterException extends __BaseException {
            readonly name: "InvalidDeployedStateFilterException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidDeployedStateFilterException, __BaseException>);
    }
    /**
        * <p>The specified key prefix filter was specified in an invalid format.</p>
        */
    export class InvalidKeyPrefixFilterException extends __BaseException {
            readonly name: "InvalidKeyPrefixFilterException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidKeyPrefixFilterException, __BaseException>);
    }
    /**
        * <p>The next token was specified in an invalid format.</p>
        */
    export class InvalidNextTokenException extends __BaseException {
            readonly name: "InvalidNextTokenException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidNextTokenException, __BaseException>);
    }
    /**
        * <p>The column name to sort by is either not present or was specified in an invalid
        *             format.</p>
        */
    export class InvalidSortByException extends __BaseException {
            readonly name: "InvalidSortByException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidSortByException, __BaseException>);
    }
    /**
        * <p>The sort order was specified in an invalid format.</p>
        */
    export class InvalidSortOrderException extends __BaseException {
            readonly name: "InvalidSortOrderException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidSortOrderException, __BaseException>);
    }
    export enum ListStateFilterAction {
            Exclude = "exclude",
            Ignore = "ignore",
            Include = "include"
    }
    export enum SortOrder {
            Ascending = "ascending",
            Descending = "descending"
    }
    /**
        * <p> Represents the input of a <code>ListApplicationRevisions</code> operation. </p>
        */
    export interface ListApplicationRevisionsInput {
            /**
                * <p> The name of an AWS CodeDeploy application associated with the IAM user or AWS
                *             account. </p>
                */
            applicationName: string | undefined;
            /**
                * <p>The column name to use to sort the list results:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>registerTime</code>: Sort by the time the revisions were registered with
                *                     AWS CodeDeploy.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>firstUsedTime</code>: Sort by the time the revisions were first used in
                *                     a deployment.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>lastUsedTime</code>: Sort by the time the revisions were last used in a
                *                     deployment.</p>
                *             </li>
                *          </ul>
                *         <p> If not specified or set to null, the results are returned in an arbitrary order.
                *         </p>
                */
            sortBy?: ApplicationRevisionSortBy | string;
            /**
                * <p> The order in which to sort the list results: </p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>ascending</code>: ascending order.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>descending</code>: descending order.</p>
                *             </li>
                *          </ul>
                *         <p>If not specified, the results are sorted in ascending order.</p>
                *         <p>If set to null, the results are sorted in an arbitrary order.</p>
                */
            sortOrder?: SortOrder | string;
            /**
                * <p> An Amazon S3 bucket name to limit the search for revisions. </p>
                *         <p> If set to null, all of the user's buckets are searched. </p>
                */
            s3Bucket?: string;
            /**
                * <p> A key prefix for the set of Amazon S3 objects to limit the search for revisions.
                *         </p>
                */
            s3KeyPrefix?: string;
            /**
                * <p> Whether to list revisions based on whether the revision is the target revision of a
                *             deployment group: </p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>include</code>: List revisions that are target revisions of a deployment
                *                     group.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>exclude</code>: Do not list revisions that are target revisions of a
                *                     deployment group.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>ignore</code>: List all revisions.</p>
                *             </li>
                *          </ul>
                */
            deployed?: ListStateFilterAction | string;
            /**
                * <p>An identifier returned from the previous <code>ListApplicationRevisions</code> call.
                *             It can be used to return the next set of applications in the list.</p>
                */
            nextToken?: string;
    }
    export namespace ListApplicationRevisionsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListApplicationRevisionsInput) => any;
    }
    /**
        * <p>Represents the output of a <code>ListApplicationRevisions</code> operation.</p>
        */
    export interface ListApplicationRevisionsOutput {
            /**
                * <p>A list of locations that contain the matching revisions.</p>
                */
            revisions?: RevisionLocation[];
            /**
                * <p>If a large amount of information is returned, an identifier is also returned. It can
                *             be used in a subsequent list application revisions call to return the next set of
                *             application revisions in the list.</p>
                */
            nextToken?: string;
    }
    export namespace ListApplicationRevisionsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListApplicationRevisionsOutput) => any;
    }
    /**
        * <p>Represents the input of a <code>ListApplications</code> operation.</p>
        */
    export interface ListApplicationsInput {
            /**
                * <p>An identifier returned from the previous list applications call. It can be used to
                *             return the next set of applications in the list.</p>
                */
            nextToken?: string;
    }
    export namespace ListApplicationsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListApplicationsInput) => any;
    }
    /**
        * <p>Represents the output of a ListApplications operation.</p>
        */
    export interface ListApplicationsOutput {
            /**
                * <p>A list of application names.</p>
                */
            applications?: string[];
            /**
                * <p>If a large amount of information is returned, an identifier is also returned. It can
                *             be used in a subsequent list applications call to return the next set of applications in
                *             the list.</p>
                */
            nextToken?: string;
    }
    export namespace ListApplicationsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListApplicationsOutput) => any;
    }
    /**
        * <p>Represents the input of a <code>ListDeploymentConfigs</code> operation.</p>
        */
    export interface ListDeploymentConfigsInput {
            /**
                * <p>An identifier returned from the previous <code>ListDeploymentConfigs</code> call. It
                *             can be used to return the next set of deployment configurations in the list. </p>
                */
            nextToken?: string;
    }
    export namespace ListDeploymentConfigsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDeploymentConfigsInput) => any;
    }
    /**
        * <p>Represents the output of a <code>ListDeploymentConfigs</code> operation.</p>
        */
    export interface ListDeploymentConfigsOutput {
            /**
                * <p>A list of deployment configurations, including built-in configurations such as
                *                 <code>CodeDeployDefault.OneAtATime</code>.</p>
                */
            deploymentConfigsList?: string[];
            /**
                * <p>If a large amount of information is returned, an identifier is also returned. It can
                *             be used in a subsequent list deployment configurations call to return the next set of
                *             deployment configurations in the list.</p>
                */
            nextToken?: string;
    }
    export namespace ListDeploymentConfigsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDeploymentConfigsOutput) => any;
    }
    /**
        * <p>Represents the input of a <code>ListDeploymentGroups</code> operation.</p>
        */
    export interface ListDeploymentGroupsInput {
            /**
                * <p>The name of an AWS CodeDeploy application associated with the IAM user or AWS
                *             account.</p>
                */
            applicationName: string | undefined;
            /**
                * <p>An identifier returned from the previous list deployment groups call. It can be used
                *             to return the next set of deployment groups in the list.</p>
                */
            nextToken?: string;
    }
    export namespace ListDeploymentGroupsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDeploymentGroupsInput) => any;
    }
    /**
        * <p>Represents the output of a <code>ListDeploymentGroups</code> operation.</p>
        */
    export interface ListDeploymentGroupsOutput {
            /**
                * <p>The application name.</p>
                */
            applicationName?: string;
            /**
                * <p>A list of deployment group names.</p>
                */
            deploymentGroups?: string[];
            /**
                * <p>If a large amount of information is returned, an identifier is also returned. It can
                *             be used in a subsequent list deployment groups call to return the next set of deployment
                *             groups in the list.</p>
                */
            nextToken?: string;
    }
    export namespace ListDeploymentGroupsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDeploymentGroupsOutput) => any;
    }
    /**
        * <p>An instance type was specified for an in-place deployment. Instance types are
        *             supported for blue/green deployments only.</p>
        */
    export class InvalidDeploymentInstanceTypeException extends __BaseException {
            readonly name: "InvalidDeploymentInstanceTypeException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidDeploymentInstanceTypeException, __BaseException>);
    }
    /**
        * <p>The specified instance status does not exist.</p>
        */
    export class InvalidInstanceStatusException extends __BaseException {
            readonly name: "InvalidInstanceStatusException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidInstanceStatusException, __BaseException>);
    }
    /**
        * <p>An invalid instance type was specified for instances in a blue/green deployment. Valid
        *             values include "Blue" for an original environment and "Green" for a replacement
        *             environment.</p>
        */
    export class InvalidInstanceTypeException extends __BaseException {
            readonly name: "InvalidInstanceTypeException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidInstanceTypeException, __BaseException>);
    }
    /**
        * <p> The target filter name is invalid. </p>
        */
    export class InvalidTargetFilterNameException extends __BaseException {
            readonly name: "InvalidTargetFilterNameException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidTargetFilterNameException, __BaseException>);
    }
    /**
        * <p> Represents the input of a <code>ListDeploymentInstances</code> operation. </p>
        */
    export interface ListDeploymentInstancesInput {
            /**
                * <p> The unique ID of a deployment. </p>
                */
            deploymentId: string | undefined;
            /**
                * <p>An identifier returned from the previous list deployment instances call. It can be
                *             used to return the next set of deployment instances in the list.</p>
                */
            nextToken?: string;
            /**
                * <p>A subset of instances to list by status:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>Pending</code>: Include those instances with pending deployments.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>InProgress</code>: Include those instances where deployments are still
                *                     in progress.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>Succeeded</code>: Include those instances with successful
                *                     deployments.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>Failed</code>: Include those instances with failed deployments.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>Skipped</code>: Include those instances with skipped deployments.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>Unknown</code>: Include those instances with deployments in an unknown
                *                     state.</p>
                *             </li>
                *          </ul>
                */
            instanceStatusFilter?: (InstanceStatus | string)[];
            /**
                * <p>The set of instances in a blue/green deployment, either those in the original
                *             environment ("BLUE") or those in the replacement environment ("GREEN"), for which you
                *             want to view instance information.</p>
                */
            instanceTypeFilter?: (_InstanceType | string)[];
    }
    export namespace ListDeploymentInstancesInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDeploymentInstancesInput) => any;
    }
    /**
        * <p>Represents the output of a <code>ListDeploymentInstances</code> operation.</p>
        */
    export interface ListDeploymentInstancesOutput {
            /**
                * <p>A list of instance IDs.</p>
                */
            instancesList?: string[];
            /**
                * <p>If a large amount of information is returned, an identifier is also returned. It can
                *             be used in a subsequent list deployment instances call to return the next set of
                *             deployment instances in the list.</p>
                */
            nextToken?: string;
    }
    export namespace ListDeploymentInstancesOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDeploymentInstancesOutput) => any;
    }
    /**
        * <p>The external ID was specified in an invalid format.</p>
        */
    export class InvalidExternalIdException extends __BaseException {
            readonly name: "InvalidExternalIdException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidExternalIdException, __BaseException>);
    }
    /**
        * <p>The specified time range was specified in an invalid format.</p>
        */
    export class InvalidTimeRangeException extends __BaseException {
            readonly name: "InvalidTimeRangeException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidTimeRangeException, __BaseException>);
    }
    /**
        * <p>Information about a time range.</p>
        */
    export interface TimeRange {
            /**
                * <p>The start time of the time range.</p>
                *         <note>
                *             <p>Specify null to leave the start time open-ended.</p>
                *         </note>
                */
            start?: Date;
            /**
                * <p>The end time of the time range.</p>
                *         <note>
                *             <p>Specify null to leave the end time open-ended.</p>
                *         </note>
                */
            end?: Date;
    }
    export namespace TimeRange {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TimeRange) => any;
    }
    /**
        * <p>Represents the input of a <code>ListDeployments</code> operation.</p>
        */
    export interface ListDeploymentsInput {
            /**
                * <p>The name of an AWS CodeDeploy application associated with the IAM user or AWS
                *             account.</p>
                *         <note>
                *             <p>If <code>applicationName</code> is specified, then
                *                     <code>deploymentGroupName</code> must be specified. If it is not specified, then
                *                     <code>deploymentGroupName</code> must not be specified. </p>
                *         </note>
                */
            applicationName?: string;
            /**
                * <p>The name of a deployment group for the specified application.</p>
                *         <note>
                *             <p>If <code>deploymentGroupName</code> is specified, then
                *                     <code>applicationName</code> must be specified. If it is not specified, then
                *                     <code>applicationName</code> must not be specified. </p>
                *         </note>
                */
            deploymentGroupName?: string;
            /**
                * <p>The unique ID of an external resource for returning deployments linked to the external
                *             resource.</p>
                */
            externalId?: string;
            /**
                * <p>A subset of deployments to list by status:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>Created</code>: Include created deployments in the resulting
                *                     list.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>Queued</code>: Include queued deployments in the resulting list.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>In Progress</code>: Include in-progress deployments in the resulting
                *                     list.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>Succeeded</code>: Include successful deployments in the resulting
                *                     list.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>Failed</code>: Include failed deployments in the resulting list.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>Stopped</code>: Include stopped deployments in the resulting
                *                     list.</p>
                *             </li>
                *          </ul>
                */
            includeOnlyStatuses?: (DeploymentStatus | string)[];
            /**
                * <p>A time range (start and end) for returning a subset of the list of deployments.</p>
                */
            createTimeRange?: TimeRange;
            /**
                * <p>An identifier returned from the previous list deployments call. It can be used to
                *             return the next set of deployments in the list.</p>
                */
            nextToken?: string;
    }
    export namespace ListDeploymentsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDeploymentsInput) => any;
    }
    /**
        * <p>Represents the output of a <code>ListDeployments</code> operation.</p>
        */
    export interface ListDeploymentsOutput {
            /**
                * <p>A list of deployment IDs.</p>
                */
            deployments?: string[];
            /**
                * <p>If a large amount of information is returned, an identifier is also returned. It can
                *             be used in a subsequent list deployments call to return the next set of deployments in
                *             the list.</p>
                */
            nextToken?: string;
    }
    export namespace ListDeploymentsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDeploymentsOutput) => any;
    }
    export enum TargetFilterName {
            SERVER_INSTANCE_LABEL = "ServerInstanceLabel",
            TARGET_STATUS = "TargetStatus"
    }
    export interface ListDeploymentTargetsInput {
            /**
                * <p> The unique ID of a deployment. </p>
                */
            deploymentId?: string;
            /**
                * <p> A token identifier returned from the previous <code>ListDeploymentTargets</code>
                *             call. It can be used to return the next set of deployment targets in the list. </p>
                */
            nextToken?: string;
            /**
                * <p> A key used to filter the returned targets. The two valid values are:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>TargetStatus</code> - A <code>TargetStatus</code> filter string can be
                *                         <code>Failed</code>, <code>InProgress</code>, <code>Pending</code>,
                *                         <code>Ready</code>, <code>Skipped</code>, <code>Succeeded</code>, or
                *                         <code>Unknown</code>. </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ServerInstanceLabel</code> - A <code>ServerInstanceLabel</code> filter
                *                     string can be <code>Blue</code> or <code>Green</code>. </p>
                *             </li>
                *          </ul>
                */
            targetFilters?: Record<string, string[]>;
    }
    export namespace ListDeploymentTargetsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDeploymentTargetsInput) => any;
    }
    export interface ListDeploymentTargetsOutput {
            /**
                * <p> The unique IDs of deployment targets. </p>
                */
            targetIds?: string[];
            /**
                * <p> If a large amount of information is returned, a token identifier is also returned. It
                *             can be used in a subsequent <code>ListDeploymentTargets</code> call to return the next
                *             set of deployment targets in the list. </p>
                */
            nextToken?: string;
    }
    export namespace ListDeploymentTargetsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListDeploymentTargetsOutput) => any;
    }
    /**
        * <p>Represents the input of a <code>ListGitHubAccountTokenNames</code> operation.</p>
        */
    export interface ListGitHubAccountTokenNamesInput {
            /**
                * <p>An identifier returned from the previous <code>ListGitHubAccountTokenNames</code>
                *             call. It can be used to return the next set of names in the list. </p>
                */
            nextToken?: string;
    }
    export namespace ListGitHubAccountTokenNamesInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListGitHubAccountTokenNamesInput) => any;
    }
    /**
        * <p>Represents the output of a <code>ListGitHubAccountTokenNames</code> operation.</p>
        */
    export interface ListGitHubAccountTokenNamesOutput {
            /**
                * <p>A list of names of connections to GitHub accounts.</p>
                */
            tokenNameList?: string[];
            /**
                * <p>If a large amount of information is returned, an identifier is also returned. It can
                *             be used in a subsequent <code>ListGitHubAccountTokenNames</code> call to return the next
                *             set of names in the list. </p>
                */
            nextToken?: string;
    }
    export namespace ListGitHubAccountTokenNamesOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListGitHubAccountTokenNamesOutput) => any;
    }
    /**
        * <p>The registration status was specified in an invalid format.</p>
        */
    export class InvalidRegistrationStatusException extends __BaseException {
            readonly name: "InvalidRegistrationStatusException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidRegistrationStatusException, __BaseException>);
    }
    /**
        * <p>The tag filter was specified in an invalid format.</p>
        */
    export class InvalidTagFilterException extends __BaseException {
            readonly name: "InvalidTagFilterException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidTagFilterException, __BaseException>);
    }
    export enum RegistrationStatus {
            Deregistered = "Deregistered",
            Registered = "Registered"
    }
    /**
        * <p>Represents the input of a <code>ListOnPremisesInstances</code> operation.</p>
        */
    export interface ListOnPremisesInstancesInput {
            /**
                * <p>The registration status of the on-premises instances:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>Deregistered</code>: Include deregistered on-premises instances in the
                *                     resulting list.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>Registered</code>: Include registered on-premises instances in the
                *                     resulting list.</p>
                *             </li>
                *          </ul>
                */
            registrationStatus?: RegistrationStatus | string;
            /**
                * <p>The on-premises instance tags that are used to restrict the on-premises instance names
                *             returned.</p>
                */
            tagFilters?: TagFilter[];
            /**
                * <p>An identifier returned from the previous list on-premises instances call. It can be
                *             used to return the next set of on-premises instances in the list.</p>
                */
            nextToken?: string;
    }
    export namespace ListOnPremisesInstancesInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListOnPremisesInstancesInput) => any;
    }
    /**
        * <p>Represents the output of the list on-premises instances operation.</p>
        */
    export interface ListOnPremisesInstancesOutput {
            /**
                * <p>The list of matching on-premises instance names.</p>
                */
            instanceNames?: string[];
            /**
                * <p>If a large amount of information is returned, an identifier is also returned. It can
                *             be used in a subsequent list on-premises instances call to return the next set of
                *             on-premises instances in the list.</p>
                */
            nextToken?: string;
    }
    export namespace ListOnPremisesInstancesOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListOnPremisesInstancesOutput) => any;
    }
    /**
        * <p> The specified ARN is not in a valid format. </p>
        */
    export class InvalidArnException extends __BaseException {
            readonly name: "InvalidArnException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidArnException, __BaseException>);
    }
    export interface ListTagsForResourceInput {
            /**
                * <p> The ARN of a CodeDeploy resource. <code>ListTagsForResource</code> returns all the
                *             tags associated with the resource that is identified by the <code>ResourceArn</code>.
                *         </p>
                */
            ResourceArn: string | undefined;
            /**
                * <p>An identifier returned from the previous <code>ListTagsForResource</code> call. It can
                *             be used to return the next set of applications in the list.</p>
                */
            NextToken?: string;
    }
    export namespace ListTagsForResourceInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceInput) => any;
    }
    export interface ListTagsForResourceOutput {
            /**
                * <p> A list of tags returned by <code>ListTagsForResource</code>. The tags are associated
                *             with the resource identified by the input <code>ResourceArn</code> parameter. </p>
                */
            Tags?: Tag[];
            /**
                * <p>If a large amount of information is returned, an identifier is also returned. It can
                *             be used in a subsequent list application revisions call to return the next set of
                *             application revisions in the list.</p>
                */
            NextToken?: string;
    }
    export namespace ListTagsForResourceOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceOutput) => any;
    }
    /**
        * <p> The ARN of a resource is required, but was not found. </p>
        */
    export class ResourceArnRequiredException extends __BaseException {
            readonly name: "ResourceArnRequiredException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceArnRequiredException, __BaseException>);
    }
    /**
        * <p>A lifecycle event hook is invalid. Review the <code>hooks</code> section in your
        *             AppSpec file to ensure the lifecycle events and <code>hooks</code> functions are
        *             valid.</p>
        */
    export class InvalidLifecycleEventHookExecutionIdException extends __BaseException {
            readonly name: "InvalidLifecycleEventHookExecutionIdException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidLifecycleEventHookExecutionIdException, __BaseException>);
    }
    /**
        * <p>The result of a Lambda validation function that verifies a lifecycle event is invalid.
        *             It should return <code>Succeeded</code> or <code>Failed</code>.</p>
        */
    export class InvalidLifecycleEventHookExecutionStatusException extends __BaseException {
            readonly name: "InvalidLifecycleEventHookExecutionStatusException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidLifecycleEventHookExecutionStatusException, __BaseException>);
    }
    /**
        * <p>An attempt to return the status of an already completed lifecycle event
        *             occurred.</p>
        */
    export class LifecycleEventAlreadyCompletedException extends __BaseException {
            readonly name: "LifecycleEventAlreadyCompletedException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<LifecycleEventAlreadyCompletedException, __BaseException>);
    }
    export interface PutLifecycleEventHookExecutionStatusInput {
            /**
                * <p> The unique ID of a deployment. Pass this ID to a Lambda function that validates a
                *             deployment lifecycle event. </p>
                */
            deploymentId?: string;
            /**
                * <p> The execution ID of a deployment's lifecycle hook. A deployment lifecycle hook is
                *             specified in the <code>hooks</code> section of the AppSpec file. </p>
                */
            lifecycleEventHookExecutionId?: string;
            /**
                * <p>The result of a Lambda function that validates a deployment lifecycle event.
                *                 <code>Succeeded</code> and <code>Failed</code> are the only valid values for
                *                 <code>status</code>.</p>
                */
            status?: LifecycleEventStatus | string;
    }
    export namespace PutLifecycleEventHookExecutionStatusInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutLifecycleEventHookExecutionStatusInput) => any;
    }
    export interface PutLifecycleEventHookExecutionStatusOutput {
            /**
                * <p>The execution ID of the lifecycle event hook. A hook is specified in the
                *                 <code>hooks</code> section of the deployment's AppSpec file.</p>
                */
            lifecycleEventHookExecutionId?: string;
    }
    export namespace PutLifecycleEventHookExecutionStatusOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutLifecycleEventHookExecutionStatusOutput) => any;
    }
    /**
        * <p>Represents the input of a RegisterApplicationRevision operation.</p>
        */
    export interface RegisterApplicationRevisionInput {
            /**
                * <p>The name of an AWS CodeDeploy application associated with the IAM user or AWS
                *             account.</p>
                */
            applicationName: string | undefined;
            /**
                * <p>A comment about the revision.</p>
                */
            description?: string;
            /**
                * <p>Information about the application revision to register, including type and
                *             location.</p>
                */
            revision: RevisionLocation | undefined;
    }
    export namespace RegisterApplicationRevisionInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RegisterApplicationRevisionInput) => any;
    }
    /**
        * <p>No IAM ARN was included in the request. You must use an IAM session ARN or IAM user
        *             ARN in the request.</p>
        */
    export class IamArnRequiredException extends __BaseException {
            readonly name: "IamArnRequiredException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<IamArnRequiredException, __BaseException>);
    }
    /**
        * <p>The request included an IAM session ARN that has already been used to register a
        *             different instance.</p>
        */
    export class IamSessionArnAlreadyRegisteredException extends __BaseException {
            readonly name: "IamSessionArnAlreadyRegisteredException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<IamSessionArnAlreadyRegisteredException, __BaseException>);
    }
    /**
        * <p>The specified IAM user ARN is already registered with an on-premises instance.</p>
        */
    export class IamUserArnAlreadyRegisteredException extends __BaseException {
            readonly name: "IamUserArnAlreadyRegisteredException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<IamUserArnAlreadyRegisteredException, __BaseException>);
    }
    /**
        * <p>An IAM user ARN was not specified.</p>
        */
    export class IamUserArnRequiredException extends __BaseException {
            readonly name: "IamUserArnRequiredException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<IamUserArnRequiredException, __BaseException>);
    }
    /**
        * <p>The specified on-premises instance name is already registered.</p>
        */
    export class InstanceNameAlreadyRegisteredException extends __BaseException {
            readonly name: "InstanceNameAlreadyRegisteredException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InstanceNameAlreadyRegisteredException, __BaseException>);
    }
    /**
        * <p>The IAM session ARN was specified in an invalid format.</p>
        */
    export class InvalidIamSessionArnException extends __BaseException {
            readonly name: "InvalidIamSessionArnException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidIamSessionArnException, __BaseException>);
    }
    /**
        * <p>The IAM user ARN was specified in an invalid format.</p>
        */
    export class InvalidIamUserArnException extends __BaseException {
            readonly name: "InvalidIamUserArnException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidIamUserArnException, __BaseException>);
    }
    /**
        * <p>Both an IAM user ARN and an IAM session ARN were included in the request. Use only one
        *             ARN type.</p>
        */
    export class MultipleIamArnsProvidedException extends __BaseException {
            readonly name: "MultipleIamArnsProvidedException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<MultipleIamArnsProvidedException, __BaseException>);
    }
    /**
        * <p>Represents the input of the register on-premises instance operation.</p>
        */
    export interface RegisterOnPremisesInstanceInput {
            /**
                * <p>The name of the on-premises instance to register.</p>
                */
            instanceName: string | undefined;
            /**
                * <p>The ARN of the IAM session to associate with the on-premises instance.</p>
                */
            iamSessionArn?: string;
            /**
                * <p>The ARN of the IAM user to associate with the on-premises instance.</p>
                */
            iamUserArn?: string;
    }
    export namespace RegisterOnPremisesInstanceInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RegisterOnPremisesInstanceInput) => any;
    }
    /**
        * <p>Represents the input of a <code>RemoveTagsFromOnPremisesInstances</code>
        *             operation.</p>
        */
    export interface RemoveTagsFromOnPremisesInstancesInput {
            /**
                * <p>The tag key-value pairs to remove from the on-premises instances.</p>
                */
            tags: Tag[] | undefined;
            /**
                * <p>The names of the on-premises instances from which to remove tags.</p>
                */
            instanceNames: string[] | undefined;
    }
    export namespace RemoveTagsFromOnPremisesInstancesInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RemoveTagsFromOnPremisesInstancesInput) => any;
    }
    export interface SkipWaitTimeForInstanceTerminationInput {
            /**
                * <p> The unique ID of a blue/green deployment for which you want to skip the instance
                *             termination wait time. </p>
                */
            deploymentId?: string;
    }
    export namespace SkipWaitTimeForInstanceTerminationInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SkipWaitTimeForInstanceTerminationInput) => any;
    }
    /**
        * <p> Represents the input of a <code>StopDeployment</code> operation. </p>
        */
    export interface StopDeploymentInput {
            /**
                * <p> The unique ID of a deployment. </p>
                */
            deploymentId: string | undefined;
            /**
                * <p> Indicates, when a deployment is stopped, whether instances that have been updated
                *             should be rolled back to the previous version of the application revision. </p>
                */
            autoRollbackEnabled?: boolean;
    }
    export namespace StopDeploymentInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StopDeploymentInput) => any;
    }
    export enum StopStatus {
            PENDING = "Pending",
            SUCCEEDED = "Succeeded"
    }
    /**
        * <p> Represents the output of a <code>StopDeployment</code> operation. </p>
        */
    export interface StopDeploymentOutput {
            /**
                * <p>The status of the stop deployment operation:</p>
                *         <ul>
                *             <li>
                *                 <p>Pending: The stop operation is pending.</p>
                *             </li>
                *             <li>
                *                 <p>Succeeded: The stop operation was successful.</p>
                *             </li>
                *          </ul>
                */
            status?: StopStatus | string;
            /**
                * <p>An accompanying status message.</p>
                */
            statusMessage?: string;
    }
    export namespace StopDeploymentOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StopDeploymentOutput) => any;
    }
    export interface TagResourceInput {
            /**
                * <p> The ARN of a resource, such as a CodeDeploy application or deployment group. </p>
                */
            ResourceArn: string | undefined;
            /**
                * <p> A list of tags that <code>TagResource</code> associates with a resource. The resource
                *             is identified by the <code>ResourceArn</code> input parameter. </p>
                */
            Tags: Tag[] | undefined;
    }
    export namespace TagResourceInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceInput) => any;
    }
    export interface TagResourceOutput {
    }
    export namespace TagResourceOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceOutput) => any;
    }
    export interface UntagResourceInput {
            /**
                * <p> The Amazon Resource Name (ARN) that specifies from which resource to disassociate the
                *             tags with the keys in the <code>TagKeys</code> input parameter. </p>
                */
            ResourceArn: string | undefined;
            /**
                * <p> A list of keys of <code>Tag</code> objects. The <code>Tag</code> objects identified
                *             by the keys are disassociated from the resource specified by the
                *                 <code>ResourceArn</code> input parameter. </p>
                */
            TagKeys: string[] | undefined;
    }
    export namespace UntagResourceInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceInput) => any;
    }
    export interface UntagResourceOutput {
    }
    export namespace UntagResourceOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceOutput) => any;
    }
    /**
        * <p>Represents the input of an <code>UpdateApplication</code> operation.</p>
        */
    export interface UpdateApplicationInput {
            /**
                * <p>The current name of the application you want to change.</p>
                */
            applicationName?: string;
            /**
                * <p>The new name to give the application.</p>
                */
            newApplicationName?: string;
    }
    export namespace UpdateApplicationInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateApplicationInput) => any;
    }
    /**
        * <p>Represents the input of an <code>UpdateDeploymentGroup</code> operation.</p>
        */
    export interface UpdateDeploymentGroupInput {
            /**
                * <p>The application name that corresponds to the deployment group to update.</p>
                */
            applicationName: string | undefined;
            /**
                * <p>The current name of the deployment group.</p>
                */
            currentDeploymentGroupName: string | undefined;
            /**
                * <p>The new name of the deployment group, if you want to change it.</p>
                */
            newDeploymentGroupName?: string;
            /**
                * <p>The replacement deployment configuration name to use, if you want to change it.</p>
                */
            deploymentConfigName?: string;
            /**
                * <p>The replacement set of Amazon EC2 tags on which to filter, if you want to change them.
                *             To keep the existing tags, enter their names. To remove tags, do not enter any tag
                *             names.</p>
                */
            ec2TagFilters?: EC2TagFilter[];
            /**
                * <p>The replacement set of on-premises instance tags on which to filter, if you want to
                *             change them. To keep the existing tags, enter their names. To remove tags, do not enter
                *             any tag names.</p>
                */
            onPremisesInstanceTagFilters?: TagFilter[];
            /**
                * <p>The replacement list of Auto Scaling groups to be included in the deployment group, if
                *             you want to change them. To keep the Auto Scaling groups, enter their names. To remove
                *             Auto Scaling groups, do not enter any Auto Scaling group names.</p>
                */
            autoScalingGroups?: string[];
            /**
                * <p>A replacement ARN for the service role, if you want to change it.</p>
                */
            serviceRoleArn?: string;
            /**
                * <p>Information about triggers to change when the deployment group is updated. For
                *             examples, see <a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/how-to-notify-edit.html">Edit a Trigger in a
                *                 CodeDeploy Deployment Group</a> in the <i>AWS CodeDeploy User
                *                 Guide</i>.</p>
                */
            triggerConfigurations?: TriggerConfig[];
            /**
                * <p>Information to add or change about Amazon CloudWatch alarms when the deployment group
                *             is updated.</p>
                */
            alarmConfiguration?: AlarmConfiguration;
            /**
                * <p>Information for an automatic rollback configuration that is added or changed when a
                *             deployment group is updated.</p>
                */
            autoRollbackConfiguration?: AutoRollbackConfiguration;
            /**
                * <p>Indicates what happens when new EC2 instances are launched mid-deployment and do not
                *             receive the deployed application revision.</p>
                *         <p>If this option is set to <code>UPDATE</code> or is unspecified, CodeDeploy initiates
                *             one or more 'auto-update outdated instances' deployments to apply the deployed
                *             application revision to the new EC2 instances.</p>
                *         <p>If this option is set to <code>IGNORE</code>, CodeDeploy does not initiate a
                *             deployment to update the new EC2 instances. This may result in instances having
                *             different revisions.</p>
                */
            outdatedInstancesStrategy?: OutdatedInstancesStrategy | string;
            /**
                * <p>Information about the type of deployment, either in-place or blue/green, you want to
                *             run and whether to route deployment traffic behind a load balancer.</p>
                */
            deploymentStyle?: DeploymentStyle;
            /**
                * <p>Information about blue/green deployment options for a deployment group.</p>
                */
            blueGreenDeploymentConfiguration?: BlueGreenDeploymentConfiguration;
            /**
                * <p>Information about the load balancer used in a deployment.</p>
                */
            loadBalancerInfo?: LoadBalancerInfo;
            /**
                * <p>Information about groups of tags applied to on-premises instances. The deployment
                *             group includes only EC2 instances identified by all the tag groups.</p>
                */
            ec2TagSet?: EC2TagSet;
            /**
                * <p> The target Amazon ECS services in the deployment group. This applies only to
                *             deployment groups that use the Amazon ECS compute platform. A target Amazon ECS service
                *             is specified as an Amazon ECS cluster and service name pair using the format
                *                 <code><clustername>:<servicename></code>. </p>
                */
            ecsServices?: ECSService[];
            /**
                * <p>Information about an on-premises instance tag set. The deployment group includes only
                *             on-premises instances identified by all the tag groups.</p>
                */
            onPremisesTagSet?: OnPremisesTagSet;
    }
    export namespace UpdateDeploymentGroupInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateDeploymentGroupInput) => any;
    }
    /**
        * <p>Represents the output of an <code>UpdateDeploymentGroup</code> operation.</p>
        */
    export interface UpdateDeploymentGroupOutput {
            /**
                * <p>If the output contains no data, and the corresponding deployment group contained at
                *             least one Auto Scaling group, AWS CodeDeploy successfully removed all corresponding Auto
                *             Scaling lifecycle event hooks from the AWS account. If the output contains data, AWS
                *             CodeDeploy could not remove some Auto Scaling lifecycle event hooks from the AWS
                *             account.</p>
                */
            hooksNotCleanedUp?: AutoScalingGroup[];
    }
    export namespace UpdateDeploymentGroupOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateDeploymentGroupOutput) => any;
    }
}

declare module '@aws-sdk/client-codedeploy/node_modules/@aws-sdk/client-codedeploy/dist-types/models/CodeDeployServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from CodeDeploy service.
        */
    export class CodeDeployServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

