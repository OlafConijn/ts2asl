// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/smithy-client
//   @aws-sdk/config-resolver
//   @aws-sdk/eventstream-serde-config-resolver
//   @aws-sdk/middleware-eventstream
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http
//   stream

declare module '@aws-sdk/client-lex-runtime-v2' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { DeleteSessionCommandInput, DeleteSessionCommandOutput } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/commands/DeleteSessionCommand";
    import { GetSessionCommandInput, GetSessionCommandOutput } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/commands/GetSessionCommand";
    import { PutSessionCommandInput, PutSessionCommandOutput } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/commands/PutSessionCommand";
    import { RecognizeTextCommandInput, RecognizeTextCommandOutput } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/commands/RecognizeTextCommand";
    import { RecognizeUtteranceCommandInput, RecognizeUtteranceCommandOutput } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/commands/RecognizeUtteranceCommand";
    import { StartConversationCommandInput, StartConversationCommandOutput } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/commands/StartConversationCommand";
    import { LexRuntimeV2Client } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/LexRuntimeV2Client";
    /**
        * <p></p>
        */
    export class LexRuntimeV2 extends LexRuntimeV2Client {
            /**
                * <p>Removes session information for a specified bot, alias, and user ID. </p>
                *          <p>You can use this operation to restart a conversation with a bot.
                *          When you remove a session, the entire history of the session is removed
                *          so that you can start again.</p>
                *          <p>You don't need to delete a session. Sessions have a time limit and
                *          will expire. Set the session time limit when you create the bot. The
                *          default is 5 minutes, but you can specify anything between 1 minute and
                *          24 hours.</p>
                *          <p>If you specify a bot or alias ID that doesn't exist, you receive a
                *             <code>BadRequestException.</code>
                *          </p>
                *          <p>If the locale doesn't exist in the bot, or if the locale hasn't been
                *          enables for the alias, you receive a
                *          <code>BadRequestException</code>.</p>
                */
            deleteSession(args: DeleteSessionCommandInput, options?: __HttpHandlerOptions): Promise<DeleteSessionCommandOutput>;
            deleteSession(args: DeleteSessionCommandInput, cb: (err: any, data?: DeleteSessionCommandOutput) => void): void;
            deleteSession(args: DeleteSessionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteSessionCommandOutput) => void): void;
            /**
                * <p>Returns session information for a specified bot, alias, and
                *          user.</p>
                *          <p>For example, you can use this operation to retrieve session
                *          information for a user that has left a long-running session in
                *          use.</p>
                *          <p>If the bot, alias, or session identifier doesn't exist, Amazon Lex V2
                *          returns a <code>BadRequestException</code>. If the locale doesn't exist
                *          or is not enabled for the alias, you receive a
                *             <code>BadRequestException</code>.</p>
                */
            getSession(args: GetSessionCommandInput, options?: __HttpHandlerOptions): Promise<GetSessionCommandOutput>;
            getSession(args: GetSessionCommandInput, cb: (err: any, data?: GetSessionCommandOutput) => void): void;
            getSession(args: GetSessionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetSessionCommandOutput) => void): void;
            /**
                * <p>Creates a new session or modifies an existing session with an Amazon Lex V2
                *          bot. Use this operation to enable your application to set the state of
                *          the bot.</p>
                */
            putSession(args: PutSessionCommandInput, options?: __HttpHandlerOptions): Promise<PutSessionCommandOutput>;
            putSession(args: PutSessionCommandInput, cb: (err: any, data?: PutSessionCommandOutput) => void): void;
            putSession(args: PutSessionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutSessionCommandOutput) => void): void;
            /**
                * <p>Sends user input to Amazon Lex V2. Client applications use this API to send
                *          requests to Amazon Lex V2 at runtime. Amazon Lex V2 then interprets the user input
                *          using the machine learning model that it build for the bot.</p>
                *          <p>In response, Amazon Lex V2 returns the next message to convey to the user
                *          and an optional response card to display.</p>
                *          <p>If the optional post-fulfillment response is specified, the messages
                *          are returned as follows. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_PostFulfillmentStatusSpecification.html">PostFulfillmentStatusSpecification</a>.</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <b>Success message</b> - Returned if
                *                the Lambda function completes successfully and the intent state is
                *                fulfilled or ready fulfillment if the message is present.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>Failed message</b> - The failed
                *                message is returned if the Lambda function throws an exception or
                *                if the Lambda function returns a failed intent state without a
                *                message.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>Timeout message</b> - If you
                *                don't configure a timeout message and a timeout, and the Lambda
                *                function doesn't return within 30 seconds, the timeout message is
                *                returned. If you configure a timeout, the timeout message is
                *                returned when the period times out. </p>
                *             </li>
                *          </ul>
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/streaming-progress.html#progress-complete.html">Completion message</a>.</p>
                */
            recognizeText(args: RecognizeTextCommandInput, options?: __HttpHandlerOptions): Promise<RecognizeTextCommandOutput>;
            recognizeText(args: RecognizeTextCommandInput, cb: (err: any, data?: RecognizeTextCommandOutput) => void): void;
            recognizeText(args: RecognizeTextCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RecognizeTextCommandOutput) => void): void;
            /**
                * <p>Sends user input to Amazon Lex V2. You can send text or speech. Clients use
                *          this API to send text and audio requests to Amazon Lex V2 at runtime. Amazon Lex V2
                *          interprets the user input using the machine learning model built for
                *          the bot.</p>
                *          <p>The following request fields must be compressed with gzip and then
                *          base64 encoded before you send them to Amazon Lex V2. </p>
                *          <ul>
                *             <li>
                *                <p>requestAttributes</p>
                *             </li>
                *             <li>
                *                <p>sessionState</p>
                *             </li>
                *          </ul>
                *          <p>The following response fields are compressed using gzip and then
                *          base64 encoded by Amazon Lex V2. Before you can use these fields, you must
                *          decode and decompress them. </p>
                *          <ul>
                *             <li>
                *                <p>inputTranscript</p>
                *             </li>
                *             <li>
                *                <p>interpretations</p>
                *             </li>
                *             <li>
                *                <p>messages</p>
                *             </li>
                *             <li>
                *                <p>requestAttributes</p>
                *             </li>
                *             <li>
                *                <p>sessionState</p>
                *             </li>
                *          </ul>
                *          <p>The example contains a Java application that compresses and encodes
                *          a Java object to send to Amazon Lex V2, and a second that decodes and
                *          decompresses a response from Amazon Lex V2.</p>
                *          <p>If the optional post-fulfillment response is specified, the messages
                *          are returned as follows. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_PostFulfillmentStatusSpecification.html">PostFulfillmentStatusSpecification</a>.</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <b>Success message</b> - Returned if
                *                the Lambda function completes successfully and the intent state is
                *                fulfilled or ready fulfillment if the message is present.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>Failed message</b> - The failed
                *                message is returned if the Lambda function throws an exception or
                *                if the Lambda function returns a failed intent state without a
                *                message.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>Timeout message</b> - If you
                *                don't configure a timeout message and a timeout, and the Lambda
                *                function doesn't return within 30 seconds, the timeout message is
                *                returned. If you configure a timeout, the timeout message is
                *                returned when the period times out. </p>
                *             </li>
                *          </ul>
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/streaming-progress.html#progress-complete.html">Completion message</a>.</p>
                */
            recognizeUtterance(args: RecognizeUtteranceCommandInput, options?: __HttpHandlerOptions): Promise<RecognizeUtteranceCommandOutput>;
            recognizeUtterance(args: RecognizeUtteranceCommandInput, cb: (err: any, data?: RecognizeUtteranceCommandOutput) => void): void;
            recognizeUtterance(args: RecognizeUtteranceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RecognizeUtteranceCommandOutput) => void): void;
            /**
                * <p>Starts an HTTP/2 bidirectional event stream that enables you to send
                *          audio, text, or DTMF input in real time. After your application starts
                *          a conversation, users send input to Amazon Lex V2 as a stream of events. Amazon Lex V2
                *          processes the incoming events and responds with streaming text or audio
                *          events.
                *       </p>
                *          <p>Audio input must be in the following format: <code>audio/lpcm
                *             sample-rate=8000 sample-size-bits=16 channel-count=1;
                *             is-big-endian=false</code>.</p>
                *          <p>If the optional post-fulfillment response is specified, the messages
                *          are returned as follows. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_PostFulfillmentStatusSpecification.html">PostFulfillmentStatusSpecification</a>.</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <b>Success message</b> - Returned if
                *                the Lambda function completes successfully and the intent state is
                *                fulfilled or ready fulfillment if the message is present.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>Failed message</b> - The failed
                *                message is returned if the Lambda function throws an exception or
                *                if the Lambda function returns a failed intent state without a
                *                message.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>Timeout message</b> - If you
                *                don't configure a timeout message and a timeout, and the Lambda
                *                function doesn't return within 30 seconds, the timeout message is
                *                returned. If you configure a timeout, the timeout message is
                *                returned when the period times out. </p>
                *             </li>
                *          </ul>
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/streaming-progress.html#progress-complete.html">Completion message</a>.</p>
                *          <p>If the optional update message is configured, it is played at the
                *          specified frequency while the Lambda function is running and the update
                *          message state is active. If the fulfillment update message is not
                *          active, the Lambda function runs with a 30 second timeout. </p>
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/streaming-progress.html#progress-update.html">Update message </a>
                *          </p>
                *          <p>The <code>StartConversation</code> operation is supported only in
                *          the following SDKs: </p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <a href="https://docs.aws.amazon.com/goto/SdkForCpp/runtime.lex.v2-2020-08-07/StartConversation">AWS SDK for C++</a>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <a href="https://docs.aws.amazon.com/goto/SdkForJavaV2/runtime.lex.v2-2020-08-07/StartConversation">AWS SDK for Java V2</a>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <a href="https://docs.aws.amazon.com/goto/SdkForRubyV3/runtime.lex.v2-2020-08-07/StartConversation">AWS SDK for Ruby V3</a>
                *                </p>
                *             </li>
                *          </ul>
                */
            startConversation(args: StartConversationCommandInput, options?: __HttpHandlerOptions): Promise<StartConversationCommandOutput>;
            startConversation(args: StartConversationCommandInput, cb: (err: any, data?: StartConversationCommandOutput) => void): void;
            startConversation(args: StartConversationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: StartConversationCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/commands/DeleteSessionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexRuntimeV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/LexRuntimeV2Client";
    import { DeleteSessionRequest, DeleteSessionResponse } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/models/models_0";
    export interface DeleteSessionCommandInput extends DeleteSessionRequest {
    }
    export interface DeleteSessionCommandOutput extends DeleteSessionResponse, __MetadataBearer {
    }
    /**
        * <p>Removes session information for a specified bot, alias, and user ID. </p>
        *          <p>You can use this operation to restart a conversation with a bot.
        *          When you remove a session, the entire history of the session is removed
        *          so that you can start again.</p>
        *          <p>You don't need to delete a session. Sessions have a time limit and
        *          will expire. Set the session time limit when you create the bot. The
        *          default is 5 minutes, but you can specify anything between 1 minute and
        *          24 hours.</p>
        *          <p>If you specify a bot or alias ID that doesn't exist, you receive a
        *             <code>BadRequestException.</code>
        *          </p>
        *          <p>If the locale doesn't exist in the bot, or if the locale hasn't been
        *          enables for the alias, you receive a
        *          <code>BadRequestException</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexRuntimeV2Client, DeleteSessionCommand } from "@aws-sdk/client-lex-runtime-v2"; // ES Modules import
        * // const { LexRuntimeV2Client, DeleteSessionCommand } = require("@aws-sdk/client-lex-runtime-v2"); // CommonJS import
        * const client = new LexRuntimeV2Client(config);
        * const command = new DeleteSessionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteSessionCommandInput} for command's `input` shape.
        * @see {@link DeleteSessionCommandOutput} for command's `response` shape.
        * @see {@link LexRuntimeV2ClientResolvedConfig | config} for LexRuntimeV2Client's `config` shape.
        *
        */
    export class DeleteSessionCommand extends $Command<DeleteSessionCommandInput, DeleteSessionCommandOutput, LexRuntimeV2ClientResolvedConfig> {
            readonly input: DeleteSessionCommandInput;
            constructor(input: DeleteSessionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexRuntimeV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteSessionCommandInput, DeleteSessionCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/commands/GetSessionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexRuntimeV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/LexRuntimeV2Client";
    import { GetSessionRequest, GetSessionResponse } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/models/models_0";
    export interface GetSessionCommandInput extends GetSessionRequest {
    }
    export interface GetSessionCommandOutput extends GetSessionResponse, __MetadataBearer {
    }
    /**
        * <p>Returns session information for a specified bot, alias, and
        *          user.</p>
        *          <p>For example, you can use this operation to retrieve session
        *          information for a user that has left a long-running session in
        *          use.</p>
        *          <p>If the bot, alias, or session identifier doesn't exist, Amazon Lex V2
        *          returns a <code>BadRequestException</code>. If the locale doesn't exist
        *          or is not enabled for the alias, you receive a
        *             <code>BadRequestException</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexRuntimeV2Client, GetSessionCommand } from "@aws-sdk/client-lex-runtime-v2"; // ES Modules import
        * // const { LexRuntimeV2Client, GetSessionCommand } = require("@aws-sdk/client-lex-runtime-v2"); // CommonJS import
        * const client = new LexRuntimeV2Client(config);
        * const command = new GetSessionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetSessionCommandInput} for command's `input` shape.
        * @see {@link GetSessionCommandOutput} for command's `response` shape.
        * @see {@link LexRuntimeV2ClientResolvedConfig | config} for LexRuntimeV2Client's `config` shape.
        *
        */
    export class GetSessionCommand extends $Command<GetSessionCommandInput, GetSessionCommandOutput, LexRuntimeV2ClientResolvedConfig> {
            readonly input: GetSessionCommandInput;
            constructor(input: GetSessionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexRuntimeV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetSessionCommandInput, GetSessionCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/commands/PutSessionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexRuntimeV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/LexRuntimeV2Client";
    import { PutSessionRequest, PutSessionResponse } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/models/models_0";
    export interface PutSessionCommandInput extends PutSessionRequest {
    }
    export interface PutSessionCommandOutput extends PutSessionResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a new session or modifies an existing session with an Amazon Lex V2
        *          bot. Use this operation to enable your application to set the state of
        *          the bot.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexRuntimeV2Client, PutSessionCommand } from "@aws-sdk/client-lex-runtime-v2"; // ES Modules import
        * // const { LexRuntimeV2Client, PutSessionCommand } = require("@aws-sdk/client-lex-runtime-v2"); // CommonJS import
        * const client = new LexRuntimeV2Client(config);
        * const command = new PutSessionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutSessionCommandInput} for command's `input` shape.
        * @see {@link PutSessionCommandOutput} for command's `response` shape.
        * @see {@link LexRuntimeV2ClientResolvedConfig | config} for LexRuntimeV2Client's `config` shape.
        *
        */
    export class PutSessionCommand extends $Command<PutSessionCommandInput, PutSessionCommandOutput, LexRuntimeV2ClientResolvedConfig> {
            readonly input: PutSessionCommandInput;
            constructor(input: PutSessionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexRuntimeV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutSessionCommandInput, PutSessionCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/commands/RecognizeTextCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexRuntimeV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/LexRuntimeV2Client";
    import { RecognizeTextRequest, RecognizeTextResponse } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/models/models_0";
    export interface RecognizeTextCommandInput extends RecognizeTextRequest {
    }
    export interface RecognizeTextCommandOutput extends RecognizeTextResponse, __MetadataBearer {
    }
    /**
        * <p>Sends user input to Amazon Lex V2. Client applications use this API to send
        *          requests to Amazon Lex V2 at runtime. Amazon Lex V2 then interprets the user input
        *          using the machine learning model that it build for the bot.</p>
        *          <p>In response, Amazon Lex V2 returns the next message to convey to the user
        *          and an optional response card to display.</p>
        *          <p>If the optional post-fulfillment response is specified, the messages
        *          are returned as follows. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_PostFulfillmentStatusSpecification.html">PostFulfillmentStatusSpecification</a>.</p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <b>Success message</b> - Returned if
        *                the Lambda function completes successfully and the intent state is
        *                fulfilled or ready fulfillment if the message is present.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <b>Failed message</b> - The failed
        *                message is returned if the Lambda function throws an exception or
        *                if the Lambda function returns a failed intent state without a
        *                message.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <b>Timeout message</b> - If you
        *                don't configure a timeout message and a timeout, and the Lambda
        *                function doesn't return within 30 seconds, the timeout message is
        *                returned. If you configure a timeout, the timeout message is
        *                returned when the period times out. </p>
        *             </li>
        *          </ul>
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/streaming-progress.html#progress-complete.html">Completion message</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexRuntimeV2Client, RecognizeTextCommand } from "@aws-sdk/client-lex-runtime-v2"; // ES Modules import
        * // const { LexRuntimeV2Client, RecognizeTextCommand } = require("@aws-sdk/client-lex-runtime-v2"); // CommonJS import
        * const client = new LexRuntimeV2Client(config);
        * const command = new RecognizeTextCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RecognizeTextCommandInput} for command's `input` shape.
        * @see {@link RecognizeTextCommandOutput} for command's `response` shape.
        * @see {@link LexRuntimeV2ClientResolvedConfig | config} for LexRuntimeV2Client's `config` shape.
        *
        */
    export class RecognizeTextCommand extends $Command<RecognizeTextCommandInput, RecognizeTextCommandOutput, LexRuntimeV2ClientResolvedConfig> {
            readonly input: RecognizeTextCommandInput;
            constructor(input: RecognizeTextCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexRuntimeV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RecognizeTextCommandInput, RecognizeTextCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/commands/RecognizeUtteranceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexRuntimeV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/LexRuntimeV2Client";
    import { RecognizeUtteranceRequest, RecognizeUtteranceResponse } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/models/models_0";
    type RecognizeUtteranceCommandInputType = Omit<RecognizeUtteranceRequest, "inputStream"> & {
            /**
                * For *`RecognizeUtteranceRequest["inputStream"]`*, see {@link RecognizeUtteranceRequest.inputStream}.
                */
            inputStream?: RecognizeUtteranceRequest["inputStream"] | string | Uint8Array | Buffer;
    };
    /**
        * This interface extends from `RecognizeUtteranceRequest` interface. There are more parameters than `inputStream` defined in {@link RecognizeUtteranceRequest}
        */
    export interface RecognizeUtteranceCommandInput extends RecognizeUtteranceCommandInputType {
    }
    export interface RecognizeUtteranceCommandOutput extends RecognizeUtteranceResponse, __MetadataBearer {
    }
    /**
        * <p>Sends user input to Amazon Lex V2. You can send text or speech. Clients use
        *          this API to send text and audio requests to Amazon Lex V2 at runtime. Amazon Lex V2
        *          interprets the user input using the machine learning model built for
        *          the bot.</p>
        *          <p>The following request fields must be compressed with gzip and then
        *          base64 encoded before you send them to Amazon Lex V2. </p>
        *          <ul>
        *             <li>
        *                <p>requestAttributes</p>
        *             </li>
        *             <li>
        *                <p>sessionState</p>
        *             </li>
        *          </ul>
        *          <p>The following response fields are compressed using gzip and then
        *          base64 encoded by Amazon Lex V2. Before you can use these fields, you must
        *          decode and decompress them. </p>
        *          <ul>
        *             <li>
        *                <p>inputTranscript</p>
        *             </li>
        *             <li>
        *                <p>interpretations</p>
        *             </li>
        *             <li>
        *                <p>messages</p>
        *             </li>
        *             <li>
        *                <p>requestAttributes</p>
        *             </li>
        *             <li>
        *                <p>sessionState</p>
        *             </li>
        *          </ul>
        *          <p>The example contains a Java application that compresses and encodes
        *          a Java object to send to Amazon Lex V2, and a second that decodes and
        *          decompresses a response from Amazon Lex V2.</p>
        *          <p>If the optional post-fulfillment response is specified, the messages
        *          are returned as follows. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_PostFulfillmentStatusSpecification.html">PostFulfillmentStatusSpecification</a>.</p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <b>Success message</b> - Returned if
        *                the Lambda function completes successfully and the intent state is
        *                fulfilled or ready fulfillment if the message is present.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <b>Failed message</b> - The failed
        *                message is returned if the Lambda function throws an exception or
        *                if the Lambda function returns a failed intent state without a
        *                message.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <b>Timeout message</b> - If you
        *                don't configure a timeout message and a timeout, and the Lambda
        *                function doesn't return within 30 seconds, the timeout message is
        *                returned. If you configure a timeout, the timeout message is
        *                returned when the period times out. </p>
        *             </li>
        *          </ul>
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/streaming-progress.html#progress-complete.html">Completion message</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexRuntimeV2Client, RecognizeUtteranceCommand } from "@aws-sdk/client-lex-runtime-v2"; // ES Modules import
        * // const { LexRuntimeV2Client, RecognizeUtteranceCommand } = require("@aws-sdk/client-lex-runtime-v2"); // CommonJS import
        * const client = new LexRuntimeV2Client(config);
        * const command = new RecognizeUtteranceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RecognizeUtteranceCommandInput} for command's `input` shape.
        * @see {@link RecognizeUtteranceCommandOutput} for command's `response` shape.
        * @see {@link LexRuntimeV2ClientResolvedConfig | config} for LexRuntimeV2Client's `config` shape.
        *
        */
    export class RecognizeUtteranceCommand extends $Command<RecognizeUtteranceCommandInput, RecognizeUtteranceCommandOutput, LexRuntimeV2ClientResolvedConfig> {
            readonly input: RecognizeUtteranceCommandInput;
            constructor(input: RecognizeUtteranceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexRuntimeV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RecognizeUtteranceCommandInput, RecognizeUtteranceCommandOutput>;
    }
    export {};
}

declare module '@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/commands/StartConversationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { LexRuntimeV2ClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/LexRuntimeV2Client";
    import { StartConversationRequest, StartConversationResponse } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/models/models_0";
    export interface StartConversationCommandInput extends StartConversationRequest {
    }
    export interface StartConversationCommandOutput extends StartConversationResponse, __MetadataBearer {
    }
    /**
        * <p>Starts an HTTP/2 bidirectional event stream that enables you to send
        *          audio, text, or DTMF input in real time. After your application starts
        *          a conversation, users send input to Amazon Lex V2 as a stream of events. Amazon Lex V2
        *          processes the incoming events and responds with streaming text or audio
        *          events.
        *       </p>
        *          <p>Audio input must be in the following format: <code>audio/lpcm
        *             sample-rate=8000 sample-size-bits=16 channel-count=1;
        *             is-big-endian=false</code>.</p>
        *          <p>If the optional post-fulfillment response is specified, the messages
        *          are returned as follows. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_PostFulfillmentStatusSpecification.html">PostFulfillmentStatusSpecification</a>.</p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <b>Success message</b> - Returned if
        *                the Lambda function completes successfully and the intent state is
        *                fulfilled or ready fulfillment if the message is present.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <b>Failed message</b> - The failed
        *                message is returned if the Lambda function throws an exception or
        *                if the Lambda function returns a failed intent state without a
        *                message.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <b>Timeout message</b> - If you
        *                don't configure a timeout message and a timeout, and the Lambda
        *                function doesn't return within 30 seconds, the timeout message is
        *                returned. If you configure a timeout, the timeout message is
        *                returned when the period times out. </p>
        *             </li>
        *          </ul>
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/streaming-progress.html#progress-complete.html">Completion message</a>.</p>
        *          <p>If the optional update message is configured, it is played at the
        *          specified frequency while the Lambda function is running and the update
        *          message state is active. If the fulfillment update message is not
        *          active, the Lambda function runs with a 30 second timeout. </p>
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/streaming-progress.html#progress-update.html">Update message </a>
        *          </p>
        *          <p>The <code>StartConversation</code> operation is supported only in
        *          the following SDKs: </p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <a href="https://docs.aws.amazon.com/goto/SdkForCpp/runtime.lex.v2-2020-08-07/StartConversation">AWS SDK for C++</a>
        *                </p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a href="https://docs.aws.amazon.com/goto/SdkForJavaV2/runtime.lex.v2-2020-08-07/StartConversation">AWS SDK for Java V2</a>
        *                </p>
        *             </li>
        *             <li>
        *                <p>
        *                   <a href="https://docs.aws.amazon.com/goto/SdkForRubyV3/runtime.lex.v2-2020-08-07/StartConversation">AWS SDK for Ruby V3</a>
        *                </p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { LexRuntimeV2Client, StartConversationCommand } from "@aws-sdk/client-lex-runtime-v2"; // ES Modules import
        * // const { LexRuntimeV2Client, StartConversationCommand } = require("@aws-sdk/client-lex-runtime-v2"); // CommonJS import
        * const client = new LexRuntimeV2Client(config);
        * const command = new StartConversationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link StartConversationCommandInput} for command's `input` shape.
        * @see {@link StartConversationCommandOutput} for command's `response` shape.
        * @see {@link LexRuntimeV2ClientResolvedConfig | config} for LexRuntimeV2Client's `config` shape.
        *
        */
    export class StartConversationCommand extends $Command<StartConversationCommandInput, StartConversationCommandOutput, LexRuntimeV2ClientResolvedConfig> {
            readonly input: StartConversationCommandInput;
            constructor(input: StartConversationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: LexRuntimeV2ClientResolvedConfig, options?: __HttpHandlerOptions): Handler<StartConversationCommandInput, StartConversationCommandOutput>;
    }
}

declare module '@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/LexRuntimeV2Client' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { EventStreamSerdeInputConfig, EventStreamSerdeResolvedConfig } from "@aws-sdk/eventstream-serde-config-resolver";
    import { EventStreamInputConfig, EventStreamResolvedConfig } from "@aws-sdk/middleware-eventstream";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, EventStreamPayloadHandlerProvider as __EventStreamPayloadHandlerProvider, EventStreamSerdeProvider as __EventStreamSerdeProvider, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { DeleteSessionCommandInput, DeleteSessionCommandOutput } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/commands/DeleteSessionCommand";
    import { GetSessionCommandInput, GetSessionCommandOutput } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/commands/GetSessionCommand";
    import { PutSessionCommandInput, PutSessionCommandOutput } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/commands/PutSessionCommand";
    import { RecognizeTextCommandInput, RecognizeTextCommandOutput } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/commands/RecognizeTextCommand";
    import { RecognizeUtteranceCommandInput, RecognizeUtteranceCommandOutput } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/commands/RecognizeUtteranceCommand";
    import { StartConversationCommandInput, StartConversationCommandOutput } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/commands/StartConversationCommand";
    export type ServiceInputTypes = DeleteSessionCommandInput | GetSessionCommandInput | PutSessionCommandInput | RecognizeTextCommandInput | RecognizeUtteranceCommandInput | StartConversationCommandInput;
    export type ServiceOutputTypes = DeleteSessionCommandOutput | GetSessionCommandOutput | PutSessionCommandOutput | RecognizeTextCommandOutput | RecognizeUtteranceCommandOutput | StartConversationCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The function that provides necessary utilities for handling request event stream.
                * @internal
                */
            eventStreamPayloadHandlerProvider?: __EventStreamPayloadHandlerProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The function that provides necessary utilities for generating and parsing event stream
                */
            eventStreamSerdeProvider?: __EventStreamSerdeProvider;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type LexRuntimeV2ClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & EventStreamInputConfig & UserAgentInputConfig & EventStreamSerdeInputConfig;
    /**
        * The configuration interface of LexRuntimeV2Client class constructor that set the region, credentials and other options.
        */
    export interface LexRuntimeV2ClientConfig extends LexRuntimeV2ClientConfigType {
    }
    type LexRuntimeV2ClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & EventStreamResolvedConfig & UserAgentResolvedConfig & EventStreamSerdeResolvedConfig;
    /**
        * The resolved configuration interface of LexRuntimeV2Client class. This is resolved and normalized from the {@link LexRuntimeV2ClientConfig | constructor configuration interface}.
        */
    export interface LexRuntimeV2ClientResolvedConfig extends LexRuntimeV2ClientResolvedConfigType {
    }
    /**
        * <p></p>
        */
    export class LexRuntimeV2Client extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, LexRuntimeV2ClientResolvedConfig> {
            /**
                * The resolved configuration of LexRuntimeV2Client class. This is resolved and normalized from the {@link LexRuntimeV2ClientConfig | constructor configuration interface}.
                */
            readonly config: LexRuntimeV2ClientResolvedConfig;
            constructor(configuration: LexRuntimeV2ClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { Readable } from "stream";
    import { LexRuntimeV2ServiceException as __BaseException } from "@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/models/LexRuntimeV2ServiceException";
    /**
        * <p></p>
        */
    export class AccessDeniedException extends __BaseException {
            readonly name: "AccessDeniedException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AccessDeniedException, __BaseException>);
    }
    /**
        * <p>The time that a context is active. You can specify the time to live
        *          in seconds or in conversation turns.</p>
        */
    export interface ActiveContextTimeToLive {
            /**
                * <p>The number of seconds that the context is active. You can specify
                *          between 5 and 86400 seconds (24 hours).</p>
                */
            timeToLiveInSeconds: number | undefined;
            /**
                * <p>The number of turns that the context is active. You can specify up
                *          to 20 turns. Each request and response from the bot is a turn.</p>
                */
            turnsToLive: number | undefined;
    }
    export namespace ActiveContextTimeToLive {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ActiveContextTimeToLive) => any;
    }
    /**
        * <p>Contains information about the contexts that a user is using in a
        *          session. You can configure Amazon Lex V2 to set a context when an intent is
        *          fulfilled, or you can set a context using the , , or  operations.</p>
        *          <p>Use a context to indicate to Amazon Lex V2 intents that should be used as
        *          follow-up intents. For example, if the active context is
        *             <code>order-fulfilled</code>, only intents that have
        *             <code>order-fulfilled</code> configured as a trigger are considered
        *          for follow up.</p>
        */
    export interface ActiveContext {
            /**
                * <p>The name of the context.</p>
                */
            name: string | undefined;
            /**
                * <p>Indicates the number of turns or seconds that the context is active.
                *          Once the time to live expires, the context is no longer returned in a
                *          response.</p>
                */
            timeToLive: ActiveContextTimeToLive | undefined;
            /**
                * <p>A list of contexts active for the request. A context can be
                *          activated when a previous intent is fulfilled, or by including the
                *          context in the request.</p>
                *          <p>If you don't specify a list of contexts, Amazon Lex V2 will use the current
                *          list of contexts for the session. If you specify an empty list, all
                *          contexts for the session are cleared. </p>
                */
            contextAttributes: Record<string, string> | undefined;
    }
    export namespace ActiveContext {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ActiveContext) => any;
    }
    /**
        * <p>Represents a chunk of audio sent from the client application to
        *          Amazon Lex V2. The audio is all or part of an utterance from the user.</p>
        *          <p>Amazon Lex V2 accumulates audio chunks until it recognizes a natural pause
        *          in speech before processing the input.</p>
        */
    export interface AudioInputEvent {
            /**
                * <p>An encoded stream of audio.</p>
                */
            audioChunk?: Uint8Array;
            /**
                * <p>The encoding used for the audio chunk. You must use 8 KHz PCM 16-bit
                *          mono-channel little-endian format. The value of the field should
                *          be:</p>
                *          <p>
                *             <code>audio/lpcm; sample-rate=8000; sample-size-bits=16;
                *             channel-count=1; is-big-endian=false</code>
                *          </p>
                */
            contentType: string | undefined;
            /**
                * <p>A unique identifier that your application assigns to the event. You
                *          can use this to identify events in logs.</p>
                */
            eventId?: string;
            /**
                * <p>A timestamp set by the client of the date and time that the event
                *          was sent to Amazon Lex V2.</p>
                */
            clientTimestampMillis?: number;
    }
    export namespace AudioInputEvent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AudioInputEvent) => any;
    }
    /**
        * <p>An event sent from Amazon Lex V2 to your client application containing audio
        *          to play to the user. </p>
        */
    export interface AudioResponseEvent {
            /**
                * <p>A chunk of the audio to play. </p>
                */
            audioChunk?: Uint8Array;
            /**
                * <p>The encoding of the audio chunk. This is the same as the encoding
                *          configure in the <code>contentType</code> field of the
                *             <code>ConfigurationEvent</code>.</p>
                */
            contentType?: string;
            /**
                * <p>A unique identifier of the event sent by Amazon Lex V2. The identifier is in
                *          the form <code>RESPONSE-N</code>, where N is a number starting with one
                *          and incremented for each event sent by Amazon Lex V2 in the current
                *          session.</p>
                */
            eventId?: string;
    }
    export namespace AudioResponseEvent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AudioResponseEvent) => any;
    }
    /**
        * <p></p>
        */
    export class ConflictException extends __BaseException {
            readonly name: "ConflictException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ConflictException, __BaseException>);
    }
    export interface DeleteSessionRequest {
            /**
                * <p>The identifier of the bot that contains the session data.</p>
                */
            botId: string | undefined;
            /**
                * <p>The alias identifier in use for the bot that contains the session
                *          data.</p>
                */
            botAliasId: string | undefined;
            /**
                * <p>The locale where the session is in use.</p>
                */
            localeId: string | undefined;
            /**
                * <p>The identifier of the session to delete.</p>
                */
            sessionId: string | undefined;
    }
    export namespace DeleteSessionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteSessionRequest) => any;
    }
    export interface DeleteSessionResponse {
            /**
                * <p>The identifier of the bot that contained the session data.</p>
                */
            botId?: string;
            /**
                * <p>The alias identifier in use for the bot that contained the session
                *          data.</p>
                */
            botAliasId?: string;
            /**
                * <p>The locale where the session was used.</p>
                */
            localeId?: string;
            /**
                * <p>The identifier of the deleted session.</p>
                */
            sessionId?: string;
    }
    export namespace DeleteSessionResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteSessionResponse) => any;
    }
    /**
        * <p></p>
        */
    export class InternalServerException extends __BaseException {
            readonly name: "InternalServerException";
            readonly $fault: "server";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InternalServerException, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class ResourceNotFoundException extends __BaseException {
            readonly name: "ResourceNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class ThrottlingException extends __BaseException {
            readonly name: "ThrottlingException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ThrottlingException, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class ValidationException extends __BaseException {
            readonly name: "ValidationException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ValidationException, __BaseException>);
    }
    export interface GetSessionRequest {
            /**
                * <p>The identifier of the bot that contains the session data.</p>
                */
            botId: string | undefined;
            /**
                * <p>The alias identifier in use for the bot that contains the session
                *          data.</p>
                */
            botAliasId: string | undefined;
            /**
                * <p>The locale where the session is in use.</p>
                */
            localeId: string | undefined;
            /**
                * <p>The identifier of the session to return.</p>
                */
            sessionId: string | undefined;
    }
    export namespace GetSessionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetSessionRequest) => any;
    }
    export enum ConfirmationState {
            CONFIRMED = "Confirmed",
            DENIED = "Denied",
            NONE = "None"
    }
    export enum Shape {
            LIST = "List",
            SCALAR = "Scalar"
    }
    /**
        * <p>The value of a slot.</p>
        */
    export interface Value {
            /**
                * <p>The text of the utterance from the user that was entered for the
                *          slot.</p>
                */
            originalValue?: string;
            /**
                * <p>The value that Amazon Lex V2 determines for the slot. The actual value
                *          depends on the setting of the value selection strategy for the bot. You
                *          can choose to use the value entered by the user, or you can have Amazon Lex V2
                *          choose the first value in the <code>resolvedValues</code> list.</p>
                */
            interpretedValue: string | undefined;
            /**
                * <p>A list of additional values that have been recognized for the
                *          slot.</p>
                */
            resolvedValues?: string[];
    }
    export namespace Value {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Value) => any;
    }
    export enum IntentState {
            FAILED = "Failed",
            FULFILLED = "Fulfilled",
            FULFILLMENT_IN_PROGRESS = "FulfillmentInProgress",
            IN_PROGRESS = "InProgress",
            READY_FOR_FULFILLMENT = "ReadyForFulfillment",
            WAITING = "Waiting"
    }
    /**
        * <p>Provides a score that indicates the confidence that Amazon Lex V2 has that
        *          an intent is the one that satisfies the user's intent.</p>
        */
    export interface ConfidenceScore {
            /**
                * <p>A score that indicates how confident Amazon Lex V2 is that an intent
                *          satisfies the user's intent. Ranges between 0.00 and 1.00. Higher
                *          scores indicate higher confidence.</p>
                */
            score?: number;
    }
    export namespace ConfidenceScore {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ConfidenceScore) => any;
    }
    export enum SentimentType {
            MIXED = "MIXED",
            NEGATIVE = "NEGATIVE",
            NEUTRAL = "NEUTRAL",
            POSITIVE = "POSITIVE"
    }
    /**
        * <p>The individual sentiment responses for the utterance.</p>
        */
    export interface SentimentScore {
            /**
                * <p>The level of confidence that Amazon Comprehend has in the accuracy
                *          of its detection of the <code>POSITIVE</code> sentiment.</p>
                */
            positive?: number;
            /**
                * <p>The level of confidence that Amazon Comprehend has in the accuracy
                *          of its detection of the <code>NEGATIVE</code> sentiment.</p>
                */
            negative?: number;
            /**
                * <p>The level of confidence that Amazon Comprehend has in the accuracy
                *          of its detection of the <code>NEUTRAL</code> sentiment.</p>
                */
            neutral?: number;
            /**
                * <p>The level of confidence that Amazon Comprehend has in the accuracy
                *          of its detection of the <code>MIXED</code> sentiment.</p>
                */
            mixed?: number;
    }
    export namespace SentimentScore {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SentimentScore) => any;
    }
    /**
        * <p>Provides information about the sentiment expressed in a user's
        *          response in a conversation. Sentiments are determined using Amazon
        *          Comprehend. Sentiments are only returned if they are enabled for the
        *          bot.</p>
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-sentiment.html">
        *             Determine Sentiment </a> in the <i>Amazon Comprehend
        *             developer guide</i>.</p>
        */
    export interface SentimentResponse {
            /**
                * <p>The overall sentiment expressed in the user's response. This is the
                *          sentiment most likely expressed by the user based on the analysis by
                *          Amazon Comprehend.</p>
                */
            sentiment?: SentimentType | string;
            /**
                * <p>The individual sentiment responses for the utterance.</p>
                */
            sentimentScore?: SentimentScore;
    }
    export namespace SentimentResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SentimentResponse) => any;
    }
    export enum MessageContentType {
            CUSTOM_PAYLOAD = "CustomPayload",
            IMAGE_RESPONSE_CARD = "ImageResponseCard",
            PLAIN_TEXT = "PlainText",
            SSML = "SSML"
    }
    /**
        * <p>A button that appears on a response card show to the user.</p>
        */
    export interface Button {
            /**
                * <p>The text that is displayed on the button.</p>
                */
            text: string | undefined;
            /**
                * <p>The value returned to Amazon Lex V2 when a user chooses the button.</p>
                */
            value: string | undefined;
    }
    export namespace Button {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Button) => any;
    }
    /**
        * <p>A card that is shown to the user by a messaging platform. You define
        *          the contents of the card, the card is displayed by the platform. </p>
        *          <p>When you use a response card, the response from the user is
        *          constrained to the text associated with a button on the card.</p>
        */
    export interface ImageResponseCard {
            /**
                * <p>The title to display on the response card. The format of the title
                *          is determined by the platform displaying the response card.</p>
                */
            title: string | undefined;
            /**
                * <p>The subtitle to display on the response card. The format of the
                *          subtitle is determined by the platform displaying the response
                *          card.</p>
                */
            subtitle?: string;
            /**
                * <p>The URL of an image to display on the response card. The image URL
                *          must be publicly available so that the platform displaying the response
                *          card has access to the image.</p>
                */
            imageUrl?: string;
            /**
                * <p>A list of buttons that should be displayed on the response card. The
                *          arrangement of the buttons is determined by the platform that displays
                *          the button.</p>
                */
            buttons?: Button[];
    }
    export namespace ImageResponseCard {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImageResponseCard) => any;
    }
    /**
        * <p>Container for text that is returned to the customer..</p>
        */
    export interface Message {
            /**
                * <p>The text of the message.</p>
                */
            content?: string;
            /**
                * <p>Indicates the type of response.</p>
                */
            contentType: MessageContentType | string | undefined;
            /**
                * <p>A card that is shown to the user by a messaging platform. You define
                *          the contents of the card, the card is displayed by the platform. </p>
                *          <p>When you use a response card, the response from the user is
                *          constrained to the text associated with a button on the card.</p>
                */
            imageResponseCard?: ImageResponseCard;
    }
    export namespace Message {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Message) => any;
    }
    export enum StyleType {
            DEFAULT = "Default",
            SPELL_BY_LETTER = "SpellByLetter",
            SPELL_BY_WORD = "SpellByWord"
    }
    export enum DialogActionType {
            CLOSE = "Close",
            CONFIRM_INTENT = "ConfirmIntent",
            DELEGATE = "Delegate",
            ELICIT_INTENT = "ElicitIntent",
            ELICIT_SLOT = "ElicitSlot",
            NONE = "None"
    }
    /**
        * <p>The next action that Amazon Lex V2 should take.</p>
        */
    export interface DialogAction {
            /**
                * <p>The next action that the bot should take in its interaction with the
                *          user. The possible values are:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>Close</code> - Indicates that there will not be a
                *                response from the user. For example, the statement "Your order
                *                has been placed" does not require a response.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ConfirmIntent</code> - The next action is asking the
                *                user if the intent is complete and ready to be fulfilled. This is
                *                a yes/no question such as "Place the order?"</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>Delegate</code> - The next action is determined by
                *                Amazon Lex V2.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ElicitSlot</code> - The next action is to elicit a slot
                *                value from the user.</p>
                *             </li>
                *          </ul>
                */
            type: DialogActionType | string | undefined;
            /**
                * <p>The name of the slot that should be elicited from the user.</p>
                */
            slotToElicit?: string;
            /**
                * <p>Configures the slot to use spell-by-letter or spell-by-word style.
                *          When you use a style on a slot, users can spell out their input to make
                *          it clear to your bot.</p>
                *          <ul>
                *             <li>
                *                <p>Spell by letter - "b" "o" "b"</p>
                *             </li>
                *             <li>
                *                <p>Spell by word - "b as in boy" "o as in oscar" "b as in
                *                boy"</p>
                *             </li>
                *          </ul>
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/using-spelling.html">
                *             Using spelling to enter slot values </a>.</p>
                */
            slotElicitationStyle?: StyleType | string;
    }
    export namespace DialogAction {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DialogAction) => any;
    }
    /**
        * <p>Provides the phrase that Amazon Lex V2 should look for in the user's input
        *          to the bot.</p>
        */
    export interface RuntimeHintValue {
            /**
                * <p>The phrase that Amazon Lex V2 should look for in the user's input to the
                *          bot.</p>
                */
            phrase: string | undefined;
    }
    export namespace RuntimeHintValue {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RuntimeHintValue) => any;
    }
    /**
        * <p>Provides an array of phrases that should be given preference when
        *          resolving values for a slot.</p>
        */
    export interface RuntimeHintDetails {
            /**
                * <p>One or more strings that Amazon Lex V2 should look for in the input to the
                *          bot. Each phrase is given preference when deciding on slot
                *          values.</p>
                */
            runtimeHintValues: RuntimeHintValue[] | undefined;
    }
    export namespace RuntimeHintDetails {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RuntimeHintDetails) => any;
    }
    /**
        * <p>You can provide Amazon Lex V2 with hints to the phrases that a customer is
        *          likely to use for a slot. When a slot with hints is resolved, the
        *          phrases in the runtime hints are preferred in the resolution. You can
        *          provide hints for a maximum of 100 intents. You can provide a maximum
        *          of 100 slots.</p>
        *          <p>Before you can use runtime hints with an existing bot, you must
        *          first rebuild the bot.</p>
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/using-hints.xml">Using hints to improve
        *             accuracy</a>.</p>
        */
    export interface RuntimeHints {
            /**
                * <p>A list of the slots in the intent that should have runtime hints
                *          added, and the phrases that should be added for each slot.</p>
                *          <p>The first level of the <code>slotHints</code> map is the name of the
                *          intent. The second level is the name of the slot within the intent. For
                *          more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/using-hints.xml">Using hints to improve
                *             accuracy</a>.</p>
                *          <p>The intent name and slot name must exist.</p>
                */
            slotHints?: Record<string, Record<string, RuntimeHintDetails>>;
    }
    export namespace RuntimeHints {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RuntimeHints) => any;
    }
    /**
        * <p></p>
        */
    export class BadGatewayException extends __BaseException {
            readonly name: "BadGatewayException";
            readonly $fault: "server";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<BadGatewayException, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class DependencyFailedException extends __BaseException {
            readonly name: "DependencyFailedException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DependencyFailedException, __BaseException>);
    }
    export interface PutSessionResponse {
            /**
                * <p>The type of response. Same as the type specified in the
                *             <code>responseContentType</code> field in the request.</p>
                */
            contentType?: string;
            /**
                * <p>A list of messages that were last sent to the user. The messages are
                *          ordered based on how you return the messages from you Lambda function
                *          or the order that the messages are defined in the bot.</p>
                */
            messages?: string;
            /**
                * <p>Represents the current state of the dialog between the user and the
                *          bot.</p>
                *          <p>Use this to determine the progress of the conversation and what the
                *          next action may be.</p>
                */
            sessionState?: string;
            /**
                * <p>Request-specific information passed between the client application
                *          and Amazon Lex V2. These are the same as the <code>requestAttribute</code>
                *          parameter in the call to the <code>PutSession</code> operation.</p>
                */
            requestAttributes?: string;
            /**
                * <p>The identifier of the session that received the data.</p>
                */
            sessionId?: string;
            /**
                * <p>If the requested content type was audio, the audio version of the
                *          message to convey to the user.</p>
                */
            audioStream?: Readable | ReadableStream | Blob;
    }
    export namespace PutSessionResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutSessionResponse) => any;
    }
    export interface RecognizeUtteranceRequest {
            /**
                * <p>The identifier of the bot that should receive the request.</p>
                */
            botId: string | undefined;
            /**
                * <p>The alias identifier in use for the bot that should receive the
                *          request.</p>
                */
            botAliasId: string | undefined;
            /**
                * <p>The locale where the session is in use.</p>
                */
            localeId: string | undefined;
            /**
                * <p>The identifier of the session in use.</p>
                */
            sessionId: string | undefined;
            /**
                * <p>Sets the state of the session with the user. You can use this to set
                *          the current intent, attributes, context, and dialog action. Use the
                *          dialog action to determine the next step that Amazon Lex V2 should use in the
                *          conversation with the user.</p>
                *          <p>The <code>sessionState</code> field must be compressed using gzip
                *          and then base64 encoded before sending to Amazon Lex V2.</p>
                */
            sessionState?: string;
            /**
                * <p>Request-specific information passed between the client application
                *          and Amazon Lex V2 </p>
                *          <p>The namespace <code>x-amz-lex:</code> is reserved for special
                *          attributes. Don't create any request attributes for prefix
                *             <code>x-amz-lex:</code>.</p>
                *          <p>The <code>requestAttributes</code> field must be compressed using
                *          gzip and then base64 encoded before sending to Amazon Lex V2.</p>
                */
            requestAttributes?: string;
            /**
                * <p>Indicates the format for audio input or that the content is text.
                *          The header must start with one of the following prefixes:</p>
                *          <ul>
                *             <li>
                *                <p>PCM format, audio data must be in little-endian byte
                *                order.</p>
                *                <ul>
                *                   <li>
                *                      <p>audio/l16; rate=16000; channels=1</p>
                *                   </li>
                *                   <li>
                *                      <p>audio/x-l16; sample-rate=16000; channel-count=1</p>
                *                   </li>
                *                   <li>
                *                      <p>audio/lpcm; sample-rate=8000; sample-size-bits=16;
                *                      channel-count=1; is-big-endian=false</p>
                *                   </li>
                *                </ul>
                *             </li>
                *             <li>
                *                <p>Opus format</p>
                *                <ul>
                *                   <li>
                *                      <p>audio/x-cbr-opus-with-preamble;preamble-size=0;bit-rate=256000;frame-size-milliseconds=4</p>
                *                   </li>
                *                </ul>
                *             </li>
                *             <li>
                *                <p>Text format</p>
                *                <ul>
                *                   <li>
                *                      <p>text/plain; charset=utf-8</p>
                *                   </li>
                *                </ul>
                *             </li>
                *          </ul>
                */
            requestContentType: string | undefined;
            /**
                * <p>The message that Amazon Lex V2 returns in the response can be either text or
                *          speech based on the <code>responseContentType</code> value.</p>
                *          <ul>
                *             <li>
                *                <p>If the value is <code>text/plain;charset=utf-8</code>, Amazon Lex V2
                *                returns text in the response.</p>
                *             </li>
                *             <li>
                *                <p>If the value begins with <code>audio/</code>, Amazon Lex V2 returns
                *                speech in the response. Amazon Lex V2 uses Amazon Polly to generate the speech
                *                using the configuration that you specified in the
                *                   <code>requestContentType</code> parameter. For example, if you
                *                specify <code>audio/mpeg</code> as the value, Amazon Lex V2 returns
                *                speech in the MPEG format.</p>
                *             </li>
                *             <li>
                *                <p>If the value is <code>audio/pcm</code>, the speech returned is
                *                   <code>audio/pcm</code> at 16 KHz in 16-bit, little-endian
                *                format.</p>
                *             </li>
                *             <li>
                *                <p>The following are the accepted values:</p>
                *                <ul>
                *                   <li>
                *                      <p>audio/mpeg</p>
                *                   </li>
                *                   <li>
                *                      <p>audio/ogg</p>
                *                   </li>
                *                   <li>
                *                      <p>audio/pcm (16 KHz)</p>
                *                   </li>
                *                   <li>
                *                      <p>audio/* (defaults to mpeg)</p>
                *                   </li>
                *                   <li>
                *                      <p>text/plain; charset=utf-8</p>
                *                   </li>
                *                </ul>
                *             </li>
                *          </ul>
                */
            responseContentType?: string;
            /**
                * <p>User input in PCM or Opus audio format or text format as described
                *          in the <code>requestContentType</code> parameter.</p>
                */
            inputStream?: Readable | ReadableStream | Blob;
    }
    export namespace RecognizeUtteranceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RecognizeUtteranceRequest) => any;
    }
    export interface RecognizeUtteranceResponse {
            /**
                * <p>Indicates whether the input mode to the operation was text or
                *          speech.
                *       </p>
                */
            inputMode?: string;
            /**
                * <p>Content type as specified in the <code>responseContentType</code> in
                *          the request.</p>
                */
            contentType?: string;
            /**
                * <p>A list of messages that were last sent to the user. The messages are
                *          ordered based on the order that you returned the messages from your
                *          Lambda function or the order that the messages are defined in the
                *          bot.</p>
                *          <p>The <code>messages</code> field is compressed with gzip and then
                *          base64 encoded. Before you can use the contents of the field, you must
                *          decode and decompress the contents. See the example for a simple
                *          function to decode and decompress the contents.</p>
                */
            messages?: string;
            /**
                * <p>A list of intents that Amazon Lex V2 determined might satisfy the user's
                *          utterance.</p>
                *          <p>Each interpretation includes the intent, a score that indicates how
                *          confident Amazon Lex V2 is that the interpretation is the correct one, and an
                *          optional sentiment response that indicates the sentiment expressed in
                *          the utterance.</p>
                *          <p>The <code>interpretations</code> field is compressed with gzip and
                *          then base64 encoded. Before you can use the contents of the field, you
                *          must decode and decompress the contents. See the example for a simple
                *          function to decode and decompress the contents.</p>
                */
            interpretations?: string;
            /**
                * <p>Represents the current state of the dialog between the user and the
                *          bot.</p>
                *          <p>Use this to determine the progress of the conversation and what the
                *          next action might be.</p>
                *          <p>The <code>sessionState</code> field is compressed with gzip and then
                *          base64 encoded. Before you can use the contents of the field, you must
                *          decode and decompress the contents. See the example for a simple
                *          function to decode and decompress the contents.</p>
                */
            sessionState?: string;
            /**
                * <p>The attributes sent in the request.</p>
                *          <p>The <code>requestAttributes</code> field is compressed with gzip and
                *          then base64 encoded. Before you can use the contents of the field, you
                *          must decode and decompress the contents.</p>
                */
            requestAttributes?: string;
            /**
                * <p>The identifier of the session in use.</p>
                */
            sessionId?: string;
            /**
                * <p>The text used to process the request.</p>
                *          <p>If the input was an audio stream, the <code>inputTranscript</code>
                *          field contains the text extracted from the audio stream. This is the
                *          text that is actually processed to recognize intents and slot values.
                *          You can use this information to determine if Amazon Lex V2 is correctly
                *          processing the audio that you send.</p>
                *          <p>The <code>inputTranscript</code> field is compressed with gzip and
                *          then base64 encoded. Before you can use the contents of the field, you
                *          must decode and decompress the contents. See the example for a simple
                *          function to decode and decompress the contents.</p>
                */
            inputTranscript?: string;
            /**
                * <p>The prompt or statement to send to the user. This is based on the
                *          bot configuration and context. For example, if Amazon Lex V2 did not understand
                *          the user intent, it sends the <code>clarificationPrompt</code>
                *          configured for the bot. If the intent requires confirmation before
                *          taking the fulfillment action, it sends the
                *             <code>confirmationPrompt</code>. Another example: Suppose that the
                *          Lambda function successfully fulfilled the intent, and sent a message
                *          to convey to the user. Then Amazon Lex V2 sends that message in the
                *          response.</p>
                */
            audioStream?: Readable | ReadableStream | Blob;
    }
    export namespace RecognizeUtteranceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RecognizeUtteranceResponse) => any;
    }
    export enum ConversationMode {
            AUDIO = "AUDIO",
            TEXT = "TEXT"
    }
    /**
        * <p>A notification from the client that it is disconnecting from Amazon Lex V2.
        *          Sending a <code>DisconnectionEvent</code> event is optional, but can
        *          help identify a conversation in logs.</p>
        */
    export interface DisconnectionEvent {
            /**
                * <p>A unique identifier that your application assigns to the event. You
                *          can use this to identify events in logs.</p>
                */
            eventId?: string;
            /**
                * <p>A timestamp set by the client of the date and time that the event
                *          was sent to Amazon Lex V2.</p>
                */
            clientTimestampMillis?: number;
    }
    export namespace DisconnectionEvent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DisconnectionEvent) => any;
    }
    /**
        * <p>A DTMF character sent from the client application. DTMF characters
        *          are typically sent from a phone keypad to represent numbers. For
        *          example, you can have Amazon Lex V2 process a credit card number input from a
        *          phone.</p>
        */
    export interface DTMFInputEvent {
            /**
                * <p>The DTMF character that the user pressed. The allowed characters are
                *          A - D, 0 - 9, # and *.</p>
                */
            inputCharacter: string | undefined;
            /**
                * <p>A unique identifier that your application assigns to the event. You
                *          can use this to identify events in logs.</p>
                */
            eventId?: string;
            /**
                * <p>A timestamp set by the client of the date and time that the event
                *          was sent to Amazon Lex V2.</p>
                */
            clientTimestampMillis?: number;
    }
    export namespace DTMFInputEvent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DTMFInputEvent) => any;
    }
    /**
        * <p>Event sent from the client application to Amazon Lex V2 to indicate that
        *          playback of audio is complete and that Amazon Lex V2 should start processing
        *          the user's input.</p>
        */
    export interface PlaybackCompletionEvent {
            /**
                * <p>A unique identifier that your application assigns to the event. You
                *          can use this to identify events in logs.</p>
                */
            eventId?: string;
            /**
                * <p>A timestamp set by the client of the date and time that the event
                *          was sent to Amazon Lex V2.</p>
                */
            clientTimestampMillis?: number;
    }
    export namespace PlaybackCompletionEvent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PlaybackCompletionEvent) => any;
    }
    /**
        * <p>The event sent from your client application to Amazon Lex V2 with text input
        *          from the user.</p>
        */
    export interface TextInputEvent {
            /**
                * <p>The text from the user. Amazon Lex V2 processes this as a complete
                *          statement.</p>
                */
            text: string | undefined;
            /**
                * <p>A unique identifier that your application assigns to the event. You
                *          can use this to identify events in logs.</p>
                */
            eventId?: string;
            /**
                * <p>A timestamp set by the client of the date and time that the event
                *          was sent to Amazon Lex V2.</p>
                */
            clientTimestampMillis?: number;
    }
    export namespace TextInputEvent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TextInputEvent) => any;
    }
    /**
        * <p>Event that Amazon Lex V2 sends to indicate that the stream is still open
        *          between the client application and Amazon Lex V2 </p>
        */
    export interface HeartbeatEvent {
            /**
                * <p>A unique identifier of the event sent by Amazon Lex V2. The identifier is in
                *          the form <code>RESPONSE-N</code>, where N is a number starting with one
                *          and incremented for each event sent by Amazon Lex V2 in the current
                *          session.</p>
                */
            eventId?: string;
    }
    export namespace HeartbeatEvent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: HeartbeatEvent) => any;
    }
    export enum InputMode {
            DTMF = "DTMF",
            SPEECH = "Speech",
            TEXT = "Text"
    }
    export enum PlaybackInterruptionReason {
            DTMF_START_DETECTED = "DTMF_START_DETECTED",
            TEXT_DETECTED = "TEXT_DETECTED",
            VOICE_START_DETECTED = "VOICE_START_DETECTED"
    }
    /**
        * <p>Event sent from Amazon Lex V2 to indicate to the client application should
        *          stop playback of audio. For example, if the client is playing a prompt
        *          that asks for the user's telephone number, the user might start to say
        *          the phone number before the prompt is complete. Amazon Lex V2 sends this event
        *          to the client application to indicate that the user is responding and
        *          that Amazon Lex V2 is processing their input.</p>
        */
    export interface PlaybackInterruptionEvent {
            /**
                * <p>Indicates the type of user input that Amazon Lex V2 detected.</p>
                */
            eventReason?: PlaybackInterruptionReason | string;
            /**
                * <p>The identifier of the event that contained the audio, DTMF, or text
                *          that caused the interruption.</p>
                */
            causedByEventId?: string;
            /**
                * <p>A unique identifier of the event sent by Amazon Lex V2. The identifier is in
                *          the form <code>RESPONSE-N</code>, where N is a number starting with one
                *          and incremented for each event sent by Amazon Lex V2 in the current
                *          session.</p>
                */
            eventId?: string;
    }
    export namespace PlaybackInterruptionEvent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PlaybackInterruptionEvent) => any;
    }
    /**
        * <p>The event sent from Amazon Lex V2 to your application with text to present
        *          to the user.</p>
        */
    export interface TextResponseEvent {
            /**
                * <p>A list of messages to send to the user. Messages are ordered based
                *          on the order that you returned the messages from your Lambda function
                *          or the order that the messages are defined in the bot.</p>
                */
            messages?: Message[];
            /**
                * <p>A unique identifier of the event sent by Amazon Lex V2. The identifier is in
                *          the form <code>RESPONSE-N</code>, where N is a number starting with one
                *          and incremented for each event sent by Amazon Lex V2 in the current
                *          session.</p>
                */
            eventId?: string;
    }
    export namespace TextResponseEvent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TextResponseEvent) => any;
    }
    /**
        * <p>Event sent from Amazon Lex V2 to your client application that contains a
        *          transcript of voice audio. </p>
        */
    export interface TranscriptEvent {
            /**
                * <p>The transcript of the voice audio from the user.</p>
                */
            transcript?: string;
            /**
                * <p>A unique identifier of the event sent by Amazon Lex V2. The identifier is in
                *          the form <code>RESPONSE-N</code>, where N is a number starting with one
                *          and incremented for each event sent by Amazon Lex V2 in the current
                *          session.</p>
                */
            eventId?: string;
    }
    export namespace TranscriptEvent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TranscriptEvent) => any;
    }
    /**
        * <p>A value that Amazon Lex V2 uses to fulfill an intent. </p>
        */
    export interface Slot {
            /**
                * <p>The current value of the slot.</p>
                */
            value?: Value;
            /**
                * <p>When the <code>shape</code> value is <code>List</code>, it indicates
                *          that the <code>values</code> field contains a list of slot values. When
                *          the value is <code>Scalar</code>, it indicates that the
                *             <code>value</code> field contains a single value.</p>
                */
            shape?: Shape | string;
            /**
                * <p>A list of one or more values that the user provided for the slot.
                *          For example, if a for a slot that elicits pizza toppings, the values
                *          might be "pepperoni" and "pineapple." </p>
                */
            values?: Slot[];
    }
    export namespace Slot {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Slot) => any;
    }
    /**
        * <p>The current intent that Amazon Lex V2 is attempting to fulfill.</p>
        */
    export interface Intent {
            /**
                * <p>The name of the intent.</p>
                */
            name: string | undefined;
            /**
                * <p>A map of all of the slots for the intent. The name of the slot maps
                *          to the value of the slot. If a slot has not been filled, the value is
                *          null.</p>
                */
            slots?: Record<string, Slot>;
            /**
                * <p>Contains fulfillment information for the intent. </p>
                */
            state?: IntentState | string;
            /**
                * <p>Contains information about whether fulfillment of the intent has
                *          been confirmed.</p>
                */
            confirmationState?: ConfirmationState | string;
    }
    export namespace Intent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Intent) => any;
    }
    /**
        * <p>An intent that Amazon Lex V2 determined might satisfy the user's utterance.
        *          The intents are ordered by the confidence score. </p>
        */
    export interface Interpretation {
            /**
                * <p>Determines the threshold where Amazon Lex V2 will insert the
                *             <code>AMAZON.FallbackIntent</code>,
                *             <code>AMAZON.KendraSearchIntent</code>, or both when returning
                *          alternative intents in a response. <code>AMAZON.FallbackIntent</code>
                *          and <code>AMAZON.KendraSearchIntent</code> are only inserted if they
                *          are configured for the bot.</p>
                */
            nluConfidence?: ConfidenceScore;
            /**
                * <p>The sentiment expressed in an utterance. </p>
                *          <p>When the bot is configured to send utterances to Amazon Comprehend
                *          for sentiment analysis, this field contains the result of the
                *          analysis.</p>
                */
            sentimentResponse?: SentimentResponse;
            /**
                * <p>A list of intents that might satisfy the user's utterance. The
                *          intents are ordered by the confidence score.</p>
                */
            intent?: Intent;
    }
    export namespace Interpretation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Interpretation) => any;
    }
    /**
        * <p>The state of the user's session with Amazon Lex V2.</p>
        */
    export interface SessionState {
            /**
                * <p>The next step that Amazon Lex V2 should take in the conversation with a
                *          user.</p>
                */
            dialogAction?: DialogAction;
            /**
                * <p>The active intent that Amazon Lex V2 is processing.</p>
                */
            intent?: Intent;
            /**
                * <p>One or more contexts that indicate to Amazon Lex V2 the context of a
                *          request. When a context is active, Amazon Lex V2 considers intents with the
                *          matching context as a trigger as the next intent in a session.</p>
                */
            activeContexts?: ActiveContext[];
            /**
                * <p>Map of key/value pairs representing session-specific context
                *          information. It contains application information passed between Amazon Lex V2
                *          and a client application.</p>
                */
            sessionAttributes?: Record<string, string>;
            /**
                * <p>A unique identifier for a specific request.</p>
                */
            originatingRequestId?: string;
            /**
                * <p>Hints for phrases that a customer is likely to use
                *       for a slot. Amazon Lex V2 uses the hints to help determine the correct
                *       value of a slot.</p>
                */
            runtimeHints?: RuntimeHints;
    }
    export namespace SessionState {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SessionState) => any;
    }
    /**
        * <p>The initial event sent from the application to Amazon Lex V2 to configure
        *          the conversation, including session and request attributes and the
        *          response content type.</p>
        */
    export interface ConfigurationEvent {
            /**
                * <p>Request-specific information passed between the client application
                *          and Amazon Lex V2.</p>
                *          <p>The namespace <code>x-amz-lex:</code> is reserved for special
                *          attributes. Don't create any request attributes for prefix
                *             <code>x-amz-lex:</code>.</p>
                */
            requestAttributes?: Record<string, string>;
            /**
                * <p>The message that Amazon Lex V2 returns in the response can be either text or
                *          speech based on the <code>responseContentType</code> value.</p>
                *          <ul>
                *             <li>
                *                <p>If the value is <code>text/plain;charset=utf-8</code>, Amazon Lex V2
                *                returns text in the response.</p>
                *             </li>
                *             <li>
                *                <p>If the value begins with <code>audio/</code>, Amazon Lex V2 returns
                *                speech in the response. Amazon Lex V2 uses Amazon Polly to generate the speech
                *                using the configuration that you specified in the
                *                   <code>requestContentType</code> parameter. For example, if you
                *                specify <code>audio/mpeg</code> as the value, Amazon Lex V2 returns
                *                speech in the MPEG format.</p>
                *             </li>
                *             <li>
                *                <p>If the value is <code>audio/pcm</code>, the speech returned is
                *                audio/pcm in 16-bit, little-endian format.</p>
                *             </li>
                *             <li>
                *                <p>The following are the accepted values:</p>
                *                <ul>
                *                   <li>
                *                      <p>audio/mpeg</p>
                *                   </li>
                *                   <li>
                *                      <p>audio/ogg</p>
                *                   </li>
                *                   <li>
                *                      <p>audio/pcm</p>
                *                   </li>
                *                   <li>
                *                      <p>audio/* (defaults to mpeg)</p>
                *                   </li>
                *                   <li>
                *                      <p>text/plain; charset=utf-8</p>
                *                   </li>
                *                </ul>
                *             </li>
                *          </ul>
                */
            responseContentType: string | undefined;
            /**
                * <p>The state of the user's session with Amazon Lex V2.</p>
                */
            sessionState?: SessionState;
            /**
                * <p>A list of messages to send to the user.</p>
                */
            welcomeMessages?: Message[];
            /**
                * <p>Determines whether Amazon Lex V2 should send audio responses to the client
                *          application.
                *       </p>
                *          <p>Set this field to false when the client is operating in a playback
                *          mode where audio responses are played to the user. If the client isn't
                *          operating in playback mode, such as a text chat application, set this
                *          to true so that Amazon Lex V2 doesn't wait for the prompt to finish playing on
                *          the client.</p>
                */
            disablePlayback?: boolean;
            /**
                * <p>A unique identifier that your application assigns to the event. You
                *          can use this to identify events in logs.</p>
                */
            eventId?: string;
            /**
                * <p>A timestamp set by the client of the date and time that the event
                *          was sent to Amazon Lex V2.</p>
                */
            clientTimestampMillis?: number;
    }
    export namespace ConfigurationEvent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ConfigurationEvent) => any;
    }
    export interface PutSessionRequest {
            /**
                * <p>The identifier of the bot that receives the session data.</p>
                */
            botId: string | undefined;
            /**
                * <p>The alias identifier of the bot that receives the session
                *          data.</p>
                */
            botAliasId: string | undefined;
            /**
                * <p>The locale where the session is in use.</p>
                */
            localeId: string | undefined;
            /**
                * <p>The identifier of the session that receives the session data.</p>
                */
            sessionId: string | undefined;
            /**
                * <p>A list of messages to send to the user. Messages are sent in the
                *          order that they are defined in the list.</p>
                */
            messages?: Message[];
            /**
                * <p>Sets the state of the session with the user. You can use this to set
                *          the current intent, attributes, context, and dialog action. Use the
                *          dialog action to determine the next step that Amazon Lex V2 should use in the
                *          conversation with the user.</p>
                */
            sessionState: SessionState | undefined;
            /**
                * <p>Request-specific information passed between Amazon Lex V2 and the client
                *          application.</p>
                *          <p>The namespace <code>x-amz-lex:</code> is reserved for special
                *          attributes. Don't create any request attributes with the prefix
                *             <code>x-amz-lex:</code>.</p>
                */
            requestAttributes?: Record<string, string>;
            /**
                * <p>The message that Amazon Lex V2 returns in the response can be either text or
                *          speech depending on the value of this parameter. </p>
                *          <ul>
                *             <li>
                *                <p>If the value is <code>text/plain; charset=utf-8</code>, Amazon Lex V2
                *                returns text in the response.</p>
                *             </li>
                *          </ul>
                */
            responseContentType?: string;
    }
    export namespace PutSessionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutSessionRequest) => any;
    }
    export interface RecognizeTextRequest {
            /**
                * <p>The identifier of the bot that processes the request.</p>
                */
            botId: string | undefined;
            /**
                * <p>The alias identifier in use for the bot that processes the
                *          request.</p>
                */
            botAliasId: string | undefined;
            /**
                * <p>The locale where the session is in use.</p>
                */
            localeId: string | undefined;
            /**
                * <p>The identifier of the user session that is having the
                *          conversation.</p>
                */
            sessionId: string | undefined;
            /**
                * <p>The text that the user entered. Amazon Lex V2 interprets this text.</p>
                */
            text: string | undefined;
            /**
                * <p>The current state of the dialog between the user and the bot.</p>
                */
            sessionState?: SessionState;
            /**
                * <p>Request-specific information passed between the client application
                *          and Amazon Lex V2 </p>
                *          <p>The namespace <code>x-amz-lex:</code> is reserved for special
                *          attributes. Don't create any request attributes with the prefix
                *             <code>x-amz-lex:</code>.</p>
                */
            requestAttributes?: Record<string, string>;
    }
    export namespace RecognizeTextRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RecognizeTextRequest) => any;
    }
    /**
        * <p>Represents a stream of events between your application and
        *          Amazon Lex V2.</p>
        */
    export type StartConversationRequestEventStream = StartConversationRequestEventStream.AudioInputEventMember | StartConversationRequestEventStream.ConfigurationEventMember | StartConversationRequestEventStream.DTMFInputEventMember | StartConversationRequestEventStream.DisconnectionEventMember | StartConversationRequestEventStream.PlaybackCompletionEventMember | StartConversationRequestEventStream.TextInputEventMember | StartConversationRequestEventStream.$UnknownMember;
    export namespace StartConversationRequestEventStream {
            /**
                * <p>Configuration information sent from your client application to
                *          Amazon Lex V2</p>
                */
            interface ConfigurationEventMember {
                    ConfigurationEvent: ConfigurationEvent;
                    AudioInputEvent?: never;
                    DTMFInputEvent?: never;
                    TextInputEvent?: never;
                    PlaybackCompletionEvent?: never;
                    DisconnectionEvent?: never;
                    $unknown?: never;
            }
            /**
                * <p>Speech audio sent from your client application to Amazon Lex V2. Audio
                *          starts accumulating when Amazon Lex V2 identifies a voice and continues until a
                *          natural pause in the speech is found before processing.</p>
                */
            interface AudioInputEventMember {
                    ConfigurationEvent?: never;
                    AudioInputEvent: AudioInputEvent;
                    DTMFInputEvent?: never;
                    TextInputEvent?: never;
                    PlaybackCompletionEvent?: never;
                    DisconnectionEvent?: never;
                    $unknown?: never;
            }
            /**
                * <p>DTMF information sent to Amazon Lex V2 by your application. Amazon Lex V2
                *          accumulates the DMTF information from when the user sends the first
                *          character and ends</p>
                *          <ul>
                *             <li>
                *                <p>when there's a pause longer that the value configured for the
                *                end timeout.</p>
                *             </li>
                *             <li>
                *                <p>when there's a digit that is the configured end
                *                character.</p>
                *             </li>
                *             <li>
                *                <p>when Amazon Lex V2 accumulates characters equal to the maximum DTMF
                *                character configuration.</p>
                *             </li>
                *          </ul>
                */
            interface DTMFInputEventMember {
                    ConfigurationEvent?: never;
                    AudioInputEvent?: never;
                    DTMFInputEvent: DTMFInputEvent;
                    TextInputEvent?: never;
                    PlaybackCompletionEvent?: never;
                    DisconnectionEvent?: never;
                    $unknown?: never;
            }
            /**
                * <p>Text sent from your client application to Amazon Lex V2. Each
                *             <code>TextInputEvent</code> is processed individually.</p>
                */
            interface TextInputEventMember {
                    ConfigurationEvent?: never;
                    AudioInputEvent?: never;
                    DTMFInputEvent?: never;
                    TextInputEvent: TextInputEvent;
                    PlaybackCompletionEvent?: never;
                    DisconnectionEvent?: never;
                    $unknown?: never;
            }
            /**
                * <p>Event sent from the client application to Amazon Lex V2 to indicate that it
                *          has finished playing audio and that Amazon Lex V2 should start listening for
                *          user input.</p>
                */
            interface PlaybackCompletionEventMember {
                    ConfigurationEvent?: never;
                    AudioInputEvent?: never;
                    DTMFInputEvent?: never;
                    TextInputEvent?: never;
                    PlaybackCompletionEvent: PlaybackCompletionEvent;
                    DisconnectionEvent?: never;
                    $unknown?: never;
            }
            /**
                * <p>Event sent from the client application to indicate to Amazon Lex V2 that the
                *          conversation is over.</p>
                */
            interface DisconnectionEventMember {
                    ConfigurationEvent?: never;
                    AudioInputEvent?: never;
                    DTMFInputEvent?: never;
                    TextInputEvent?: never;
                    PlaybackCompletionEvent?: never;
                    DisconnectionEvent: DisconnectionEvent;
                    $unknown?: never;
            }
            interface $UnknownMember {
                    ConfigurationEvent?: never;
                    AudioInputEvent?: never;
                    DTMFInputEvent?: never;
                    TextInputEvent?: never;
                    PlaybackCompletionEvent?: never;
                    DisconnectionEvent?: never;
                    $unknown: [string, any];
            }
            interface Visitor<T> {
                    ConfigurationEvent: (value: ConfigurationEvent) => T;
                    AudioInputEvent: (value: AudioInputEvent) => T;
                    DTMFInputEvent: (value: DTMFInputEvent) => T;
                    TextInputEvent: (value: TextInputEvent) => T;
                    PlaybackCompletionEvent: (value: PlaybackCompletionEvent) => T;
                    DisconnectionEvent: (value: DisconnectionEvent) => T;
                    _: (name: string, value: any) => T;
            }
            const visit: <T>(value: StartConversationRequestEventStream, visitor: Visitor<T>) => T;
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartConversationRequestEventStream) => any;
    }
    export interface StartConversationRequest {
            /**
                * <p>The identifier of the bot to process the request.</p>
                */
            botId: string | undefined;
            /**
                * <p>The alias identifier in use for the bot that processes the
                *          request.</p>
                */
            botAliasId: string | undefined;
            /**
                * <p>The locale where the session is in use.</p>
                */
            localeId: string | undefined;
            /**
                * <p>The identifier of the user session that is having the
                *          conversation.</p>
                */
            sessionId: string | undefined;
            /**
                * <p>The conversation type that you are using the Amazon Lex V2. If the
                *          conversation mode is <code>AUDIO</code> you can send both audio and
                *          DTMF information. If the mode is <code>TEXT</code> you can only send
                *          text.</p>
                */
            conversationMode?: ConversationMode | string;
            /**
                * <p>Represents the stream of events to Amazon Lex V2 from your application. The
                *          events are encoded as HTTP/2 data frames.</p>
                */
            requestEventStream: AsyncIterable<StartConversationRequestEventStream> | undefined;
    }
    export namespace StartConversationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartConversationRequest) => any;
    }
    export interface GetSessionResponse {
            /**
                * <p>The identifier of the returned session.</p>
                */
            sessionId?: string;
            /**
                * <p>A list of messages that were last sent to the user. The messages are
                *          ordered based on the order that your returned the messages from your
                *          Lambda function or the order that messages are defined in the bot.
                *       </p>
                */
            messages?: Message[];
            /**
                * <p>A list of intents that Amazon Lex V2 determined might satisfy the user's
                *          utterance. </p>
                *          <p>Each interpretation includes the intent, a score that indicates how
                *          confident Amazon Lex V2 is that the interpretation is the correct one, and an
                *          optional sentiment response that indicates the sentiment expressed in
                *          the utterance.</p>
                */
            interpretations?: Interpretation[];
            /**
                * <p>Represents the current state of the dialog between the user and the
                *          bot.</p>
                *          <p>You can use this to determine the progress of the conversation and
                *          what the next action might be.</p>
                */
            sessionState?: SessionState;
    }
    export namespace GetSessionResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetSessionResponse) => any;
    }
    /**
        * <p>Contains the current state of the conversation between the client
        *          application and Amazon Lex V2.</p>
        */
    export interface IntentResultEvent {
            /**
                * <p>Indicates whether the input to the operation was text or
                *          speech.</p>
                */
            inputMode?: InputMode | string;
            /**
                * <p>A list of intents that Amazon Lex V2 determined might satisfy the user's
                *          utterance.</p>
                *
                *          <p>Each interpretation includes the intent, a score that indicates how
                *          confident Amazon Lex V2 is that the interpretation is the correct one, and an
                *          optional sentiment response that indicates the sentiment expressed in
                *          the utterance.</p>
                */
            interpretations?: Interpretation[];
            /**
                * <p>The state of the user's session with Amazon Lex V2.</p>
                */
            sessionState?: SessionState;
            /**
                * <p>The attributes sent in the request.</p>
                */
            requestAttributes?: Record<string, string>;
            /**
                * <p>The identifier of the session in use.</p>
                */
            sessionId?: string;
            /**
                * <p>A unique identifier of the event sent by Amazon Lex V2. The identifier is in
                *          the form <code>RESPONSE-N</code>, where N is a number starting with one
                *          and incremented for each event sent by Amazon Lex V2 in the current
                *          session.</p>
                */
            eventId?: string;
    }
    export namespace IntentResultEvent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: IntentResultEvent) => any;
    }
    export interface RecognizeTextResponse {
            /**
                * <p>A list of messages last sent to the user. The messages are ordered
                *          based on the order that you returned the messages from your Lambda
                *          function or the order that the messages are defined in the bot.</p>
                */
            messages?: Message[];
            /**
                * <p>Represents the current state of the dialog between the user and the
                *          bot. </p>
                *          <p>Use this to determine the progress of the conversation and what the
                *          next action may be.</p>
                */
            sessionState?: SessionState;
            /**
                * <p>A list of intents that Amazon Lex V2 determined might satisfy the user's
                *          utterance. </p>
                *          <p>Each interpretation includes the intent, a score that indicates now
                *          confident Amazon Lex V2 is that the interpretation is the correct one, and an
                *          optional sentiment response that indicates the sentiment expressed in
                *          the utterance.</p>
                */
            interpretations?: Interpretation[];
            /**
                * <p>The attributes sent in the request.</p>
                */
            requestAttributes?: Record<string, string>;
            /**
                * <p>The identifier of the session in use.</p>
                */
            sessionId?: string;
    }
    export namespace RecognizeTextResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RecognizeTextResponse) => any;
    }
    /**
        * <p>Represents a stream of events between Amazon Lex V2 and your
        *          application.</p>
        */
    export type StartConversationResponseEventStream = StartConversationResponseEventStream.AccessDeniedExceptionMember | StartConversationResponseEventStream.AudioResponseEventMember | StartConversationResponseEventStream.BadGatewayExceptionMember | StartConversationResponseEventStream.ConflictExceptionMember | StartConversationResponseEventStream.DependencyFailedExceptionMember | StartConversationResponseEventStream.HeartbeatEventMember | StartConversationResponseEventStream.IntentResultEventMember | StartConversationResponseEventStream.InternalServerExceptionMember | StartConversationResponseEventStream.PlaybackInterruptionEventMember | StartConversationResponseEventStream.ResourceNotFoundExceptionMember | StartConversationResponseEventStream.TextResponseEventMember | StartConversationResponseEventStream.ThrottlingExceptionMember | StartConversationResponseEventStream.TranscriptEventMember | StartConversationResponseEventStream.ValidationExceptionMember | StartConversationResponseEventStream.$UnknownMember;
    export namespace StartConversationResponseEventStream {
            /**
                * <p>Event sent from Amazon Lex V2 to indicate to the client application should
                *          stop playback of audio. For example, if the client is playing a prompt
                *          that asks for the user's telephone number, the user might start to say
                *          the phone number before the prompt is complete. Amazon Lex V2 sends this event
                *          to the client application to indicate that the user is responding and
                *          that Amazon Lex V2 is processing their input.</p>
                */
            interface PlaybackInterruptionEventMember {
                    PlaybackInterruptionEvent: PlaybackInterruptionEvent;
                    TranscriptEvent?: never;
                    IntentResultEvent?: never;
                    TextResponseEvent?: never;
                    AudioResponseEvent?: never;
                    HeartbeatEvent?: never;
                    AccessDeniedException?: never;
                    ResourceNotFoundException?: never;
                    ValidationException?: never;
                    ThrottlingException?: never;
                    InternalServerException?: never;
                    ConflictException?: never;
                    DependencyFailedException?: never;
                    BadGatewayException?: never;
                    $unknown?: never;
            }
            /**
                * <p>Event sent from Amazon Lex V2 to your client application that contains a
                *          transcript of voice audio. </p>
                */
            interface TranscriptEventMember {
                    PlaybackInterruptionEvent?: never;
                    TranscriptEvent: TranscriptEvent;
                    IntentResultEvent?: never;
                    TextResponseEvent?: never;
                    AudioResponseEvent?: never;
                    HeartbeatEvent?: never;
                    AccessDeniedException?: never;
                    ResourceNotFoundException?: never;
                    ValidationException?: never;
                    ThrottlingException?: never;
                    InternalServerException?: never;
                    ConflictException?: never;
                    DependencyFailedException?: never;
                    BadGatewayException?: never;
                    $unknown?: never;
            }
            /**
                * <p>Event sent from Amazon Lex V2 to the client application containing the
                *          current state of the conversation between the user and Amazon Lex V2.</p>
                */
            interface IntentResultEventMember {
                    PlaybackInterruptionEvent?: never;
                    TranscriptEvent?: never;
                    IntentResultEvent: IntentResultEvent;
                    TextResponseEvent?: never;
                    AudioResponseEvent?: never;
                    HeartbeatEvent?: never;
                    AccessDeniedException?: never;
                    ResourceNotFoundException?: never;
                    ValidationException?: never;
                    ThrottlingException?: never;
                    InternalServerException?: never;
                    ConflictException?: never;
                    DependencyFailedException?: never;
                    BadGatewayException?: never;
                    $unknown?: never;
            }
            /**
                * <p>The event sent from Amazon Lex V2 to your application with text to present
                *          to the user.</p>
                */
            interface TextResponseEventMember {
                    PlaybackInterruptionEvent?: never;
                    TranscriptEvent?: never;
                    IntentResultEvent?: never;
                    TextResponseEvent: TextResponseEvent;
                    AudioResponseEvent?: never;
                    HeartbeatEvent?: never;
                    AccessDeniedException?: never;
                    ResourceNotFoundException?: never;
                    ValidationException?: never;
                    ThrottlingException?: never;
                    InternalServerException?: never;
                    ConflictException?: never;
                    DependencyFailedException?: never;
                    BadGatewayException?: never;
                    $unknown?: never;
            }
            /**
                * <p>An event sent from Amazon Lex V2 to your client application containing audio
                *          to play to the user. </p>
                */
            interface AudioResponseEventMember {
                    PlaybackInterruptionEvent?: never;
                    TranscriptEvent?: never;
                    IntentResultEvent?: never;
                    TextResponseEvent?: never;
                    AudioResponseEvent: AudioResponseEvent;
                    HeartbeatEvent?: never;
                    AccessDeniedException?: never;
                    ResourceNotFoundException?: never;
                    ValidationException?: never;
                    ThrottlingException?: never;
                    InternalServerException?: never;
                    ConflictException?: never;
                    DependencyFailedException?: never;
                    BadGatewayException?: never;
                    $unknown?: never;
            }
            /**
                * <p>Event that Amazon Lex V2 sends to indicate that the stream is still open
                *          between the client application and Amazon Lex V2 </p>
                */
            interface HeartbeatEventMember {
                    PlaybackInterruptionEvent?: never;
                    TranscriptEvent?: never;
                    IntentResultEvent?: never;
                    TextResponseEvent?: never;
                    AudioResponseEvent?: never;
                    HeartbeatEvent: HeartbeatEvent;
                    AccessDeniedException?: never;
                    ResourceNotFoundException?: never;
                    ValidationException?: never;
                    ThrottlingException?: never;
                    InternalServerException?: never;
                    ConflictException?: never;
                    DependencyFailedException?: never;
                    BadGatewayException?: never;
                    $unknown?: never;
            }
            /**
                * <p>Exception thrown when the credentials passed with the request are
                *          invalid or expired. Also thrown when the credentials in the request do
                *          not have permission to access the <code>StartConversation</code>
                *          operation.</p>
                */
            interface AccessDeniedExceptionMember {
                    PlaybackInterruptionEvent?: never;
                    TranscriptEvent?: never;
                    IntentResultEvent?: never;
                    TextResponseEvent?: never;
                    AudioResponseEvent?: never;
                    HeartbeatEvent?: never;
                    AccessDeniedException: AccessDeniedException;
                    ResourceNotFoundException?: never;
                    ValidationException?: never;
                    ThrottlingException?: never;
                    InternalServerException?: never;
                    ConflictException?: never;
                    DependencyFailedException?: never;
                    BadGatewayException?: never;
                    $unknown?: never;
            }
            /**
                * <p>Exception thrown if one of the input parameters points to a resource
                *          that does not exist. For example, if the bot ID specified does not
                *          exist.</p>
                */
            interface ResourceNotFoundExceptionMember {
                    PlaybackInterruptionEvent?: never;
                    TranscriptEvent?: never;
                    IntentResultEvent?: never;
                    TextResponseEvent?: never;
                    AudioResponseEvent?: never;
                    HeartbeatEvent?: never;
                    AccessDeniedException?: never;
                    ResourceNotFoundException: ResourceNotFoundException;
                    ValidationException?: never;
                    ThrottlingException?: never;
                    InternalServerException?: never;
                    ConflictException?: never;
                    DependencyFailedException?: never;
                    BadGatewayException?: never;
                    $unknown?: never;
            }
            /**
                * <p>Exception thrown when one or more parameters could not be validated.
                *          The <code>message</code> contains the name of the field that isn't
                *          valid.</p>
                */
            interface ValidationExceptionMember {
                    PlaybackInterruptionEvent?: never;
                    TranscriptEvent?: never;
                    IntentResultEvent?: never;
                    TextResponseEvent?: never;
                    AudioResponseEvent?: never;
                    HeartbeatEvent?: never;
                    AccessDeniedException?: never;
                    ResourceNotFoundException?: never;
                    ValidationException: ValidationException;
                    ThrottlingException?: never;
                    InternalServerException?: never;
                    ConflictException?: never;
                    DependencyFailedException?: never;
                    BadGatewayException?: never;
                    $unknown?: never;
            }
            /**
                * <p>Exception thrown when your application exceeds the maximum number of
                *          concurrent requests. </p>
                */
            interface ThrottlingExceptionMember {
                    PlaybackInterruptionEvent?: never;
                    TranscriptEvent?: never;
                    IntentResultEvent?: never;
                    TextResponseEvent?: never;
                    AudioResponseEvent?: never;
                    HeartbeatEvent?: never;
                    AccessDeniedException?: never;
                    ResourceNotFoundException?: never;
                    ValidationException?: never;
                    ThrottlingException: ThrottlingException;
                    InternalServerException?: never;
                    ConflictException?: never;
                    DependencyFailedException?: never;
                    BadGatewayException?: never;
                    $unknown?: never;
            }
            /**
                * <p>An error occurred with Amazon Lex V2.</p>
                */
            interface InternalServerExceptionMember {
                    PlaybackInterruptionEvent?: never;
                    TranscriptEvent?: never;
                    IntentResultEvent?: never;
                    TextResponseEvent?: never;
                    AudioResponseEvent?: never;
                    HeartbeatEvent?: never;
                    AccessDeniedException?: never;
                    ResourceNotFoundException?: never;
                    ValidationException?: never;
                    ThrottlingException?: never;
                    InternalServerException: InternalServerException;
                    ConflictException?: never;
                    DependencyFailedException?: never;
                    BadGatewayException?: never;
                    $unknown?: never;
            }
            /**
                * <p>Exception thrown when two clients are using the same AWS account,
                *          Amazon Lex V2 bot, and session ID.</p>
                */
            interface ConflictExceptionMember {
                    PlaybackInterruptionEvent?: never;
                    TranscriptEvent?: never;
                    IntentResultEvent?: never;
                    TextResponseEvent?: never;
                    AudioResponseEvent?: never;
                    HeartbeatEvent?: never;
                    AccessDeniedException?: never;
                    ResourceNotFoundException?: never;
                    ValidationException?: never;
                    ThrottlingException?: never;
                    InternalServerException?: never;
                    ConflictException: ConflictException;
                    DependencyFailedException?: never;
                    BadGatewayException?: never;
                    $unknown?: never;
            }
            /**
                * <p></p>
                */
            interface DependencyFailedExceptionMember {
                    PlaybackInterruptionEvent?: never;
                    TranscriptEvent?: never;
                    IntentResultEvent?: never;
                    TextResponseEvent?: never;
                    AudioResponseEvent?: never;
                    HeartbeatEvent?: never;
                    AccessDeniedException?: never;
                    ResourceNotFoundException?: never;
                    ValidationException?: never;
                    ThrottlingException?: never;
                    InternalServerException?: never;
                    ConflictException?: never;
                    DependencyFailedException: DependencyFailedException;
                    BadGatewayException?: never;
                    $unknown?: never;
            }
            /**
                * <p></p>
                */
            interface BadGatewayExceptionMember {
                    PlaybackInterruptionEvent?: never;
                    TranscriptEvent?: never;
                    IntentResultEvent?: never;
                    TextResponseEvent?: never;
                    AudioResponseEvent?: never;
                    HeartbeatEvent?: never;
                    AccessDeniedException?: never;
                    ResourceNotFoundException?: never;
                    ValidationException?: never;
                    ThrottlingException?: never;
                    InternalServerException?: never;
                    ConflictException?: never;
                    DependencyFailedException?: never;
                    BadGatewayException: BadGatewayException;
                    $unknown?: never;
            }
            interface $UnknownMember {
                    PlaybackInterruptionEvent?: never;
                    TranscriptEvent?: never;
                    IntentResultEvent?: never;
                    TextResponseEvent?: never;
                    AudioResponseEvent?: never;
                    HeartbeatEvent?: never;
                    AccessDeniedException?: never;
                    ResourceNotFoundException?: never;
                    ValidationException?: never;
                    ThrottlingException?: never;
                    InternalServerException?: never;
                    ConflictException?: never;
                    DependencyFailedException?: never;
                    BadGatewayException?: never;
                    $unknown: [string, any];
            }
            interface Visitor<T> {
                    PlaybackInterruptionEvent: (value: PlaybackInterruptionEvent) => T;
                    TranscriptEvent: (value: TranscriptEvent) => T;
                    IntentResultEvent: (value: IntentResultEvent) => T;
                    TextResponseEvent: (value: TextResponseEvent) => T;
                    AudioResponseEvent: (value: AudioResponseEvent) => T;
                    HeartbeatEvent: (value: HeartbeatEvent) => T;
                    AccessDeniedException: (value: AccessDeniedException) => T;
                    ResourceNotFoundException: (value: ResourceNotFoundException) => T;
                    ValidationException: (value: ValidationException) => T;
                    ThrottlingException: (value: ThrottlingException) => T;
                    InternalServerException: (value: InternalServerException) => T;
                    ConflictException: (value: ConflictException) => T;
                    DependencyFailedException: (value: DependencyFailedException) => T;
                    BadGatewayException: (value: BadGatewayException) => T;
                    _: (name: string, value: any) => T;
            }
            const visit: <T>(value: StartConversationResponseEventStream, visitor: Visitor<T>) => T;
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartConversationResponseEventStream) => any;
    }
    export interface StartConversationResponse {
            /**
                * <p>Represents the stream of events from Amazon Lex V2 to your application. The
                *          events are encoded as HTTP/2 data frames.</p>
                */
            responseEventStream?: AsyncIterable<StartConversationResponseEventStream>;
    }
    export namespace StartConversationResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartConversationResponse) => any;
    }
}

declare module '@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/client-lex-runtime-v2/dist-types/models/LexRuntimeV2ServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from LexRuntimeV2 service.
        */
    export class LexRuntimeV2ServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

