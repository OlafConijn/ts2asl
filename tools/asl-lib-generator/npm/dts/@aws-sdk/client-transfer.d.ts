// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/smithy-client
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http

declare module '@aws-sdk/client-transfer' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { CreateAccessCommandInput, CreateAccessCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/CreateAccessCommand";
    import { CreateServerCommandInput, CreateServerCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/CreateServerCommand";
    import { CreateUserCommandInput, CreateUserCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/CreateUserCommand";
    import { CreateWorkflowCommandInput, CreateWorkflowCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/CreateWorkflowCommand";
    import { DeleteAccessCommandInput, DeleteAccessCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DeleteAccessCommand";
    import { DeleteServerCommandInput, DeleteServerCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DeleteServerCommand";
    import { DeleteSshPublicKeyCommandInput, DeleteSshPublicKeyCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DeleteSshPublicKeyCommand";
    import { DeleteUserCommandInput, DeleteUserCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DeleteUserCommand";
    import { DeleteWorkflowCommandInput, DeleteWorkflowCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DeleteWorkflowCommand";
    import { DescribeAccessCommandInput, DescribeAccessCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DescribeAccessCommand";
    import { DescribeExecutionCommandInput, DescribeExecutionCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DescribeExecutionCommand";
    import { DescribeSecurityPolicyCommandInput, DescribeSecurityPolicyCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DescribeSecurityPolicyCommand";
    import { DescribeServerCommandInput, DescribeServerCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DescribeServerCommand";
    import { DescribeUserCommandInput, DescribeUserCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DescribeUserCommand";
    import { DescribeWorkflowCommandInput, DescribeWorkflowCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DescribeWorkflowCommand";
    import { ImportSshPublicKeyCommandInput, ImportSshPublicKeyCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ImportSshPublicKeyCommand";
    import { ListAccessesCommandInput, ListAccessesCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ListAccessesCommand";
    import { ListExecutionsCommandInput, ListExecutionsCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ListExecutionsCommand";
    import { ListSecurityPoliciesCommandInput, ListSecurityPoliciesCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ListSecurityPoliciesCommand";
    import { ListServersCommandInput, ListServersCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ListServersCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ListTagsForResourceCommand";
    import { ListUsersCommandInput, ListUsersCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ListUsersCommand";
    import { ListWorkflowsCommandInput, ListWorkflowsCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ListWorkflowsCommand";
    import { SendWorkflowStepStateCommandInput, SendWorkflowStepStateCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/SendWorkflowStepStateCommand";
    import { StartServerCommandInput, StartServerCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/StartServerCommand";
    import { StopServerCommandInput, StopServerCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/StopServerCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/TagResourceCommand";
    import { TestIdentityProviderCommandInput, TestIdentityProviderCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/TestIdentityProviderCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/UntagResourceCommand";
    import { UpdateAccessCommandInput, UpdateAccessCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/UpdateAccessCommand";
    import { UpdateServerCommandInput, UpdateServerCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/UpdateServerCommand";
    import { UpdateUserCommandInput, UpdateUserCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/UpdateUserCommand";
    import { TransferClient } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    /**
        * <p>Amazon Web Services Transfer Family is a fully managed service that enables the transfer of files over the
        *       File Transfer Protocol (FTP), File Transfer Protocol over SSL (FTPS), or Secure Shell (SSH)
        *       File Transfer Protocol (SFTP) directly into and out of Amazon Simple Storage Service (Amazon
        *       S3). Amazon Web Services helps you seamlessly migrate your file transfer workflows to Amazon Web Services Transfer Family by
        *       integrating with existing authentication systems, and providing DNS routing with Amazon Route
        *       53 so nothing changes for your customers and partners, or their applications. With your data
        *       in Amazon S3, you can use it with Amazon Web Services services for processing, analytics, machine learning,
        *       and archiving. Getting started with Amazon Web Services Transfer Family is easy since there is no
        *       infrastructure to buy and set up.</p>
        */
    export class Transfer extends TransferClient {
            /**
                * <p>Used by administrators to choose which groups in the directory should have access to
                *       upload and download files over the enabled protocols using Amazon Web Services Transfer Family. For example, a
                *       Microsoft Active Directory might contain 50,000 users, but only a small fraction might need
                *       the ability to transfer files to the server. An administrator can use
                *         <code>CreateAccess</code> to limit the access to the correct set of users who need this
                *       ability.</p>
                */
            createAccess(args: CreateAccessCommandInput, options?: __HttpHandlerOptions): Promise<CreateAccessCommandOutput>;
            createAccess(args: CreateAccessCommandInput, cb: (err: any, data?: CreateAccessCommandOutput) => void): void;
            createAccess(args: CreateAccessCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateAccessCommandOutput) => void): void;
            /**
                * <p>Instantiates an auto-scaling virtual server based on the selected file transfer protocol
                *       in Amazon Web Services. When you make updates to your file transfer protocol-enabled server or when you work
                *       with users, use the service-generated <code>ServerId</code> property that is assigned to the
                *       newly created server.</p>
                */
            createServer(args: CreateServerCommandInput, options?: __HttpHandlerOptions): Promise<CreateServerCommandOutput>;
            createServer(args: CreateServerCommandInput, cb: (err: any, data?: CreateServerCommandOutput) => void): void;
            createServer(args: CreateServerCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateServerCommandOutput) => void): void;
            /**
                * <p>Creates a user and associates them with an existing file transfer protocol-enabled server.
                *       You can only create and associate users with servers that have the
                *         <code>IdentityProviderType</code> set to <code>SERVICE_MANAGED</code>. Using parameters for
                *         <code>CreateUser</code>, you can specify the user name, set the home directory, store the
                *       user's public key, and assign the user's Amazon Web Services Identity and Access Management (IAM)
                *       role. You can also optionally add a session policy, and assign metadata with tags that can
                *       be used to group and search for users.</p>
                */
            createUser(args: CreateUserCommandInput, options?: __HttpHandlerOptions): Promise<CreateUserCommandOutput>;
            createUser(args: CreateUserCommandInput, cb: (err: any, data?: CreateUserCommandOutput) => void): void;
            createUser(args: CreateUserCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateUserCommandOutput) => void): void;
            /**
                * <p>
                *       Allows you to create a workflow with specified steps and step details the workflow invokes after file transfer completes.
                *       After creating a workflow, you can associate the workflow created with any transfer servers by specifying the <code>workflow-details</code> field in <code>CreateServer</code> and <code>UpdateServer</code> operations.
                *     </p>
                */
            createWorkflow(args: CreateWorkflowCommandInput, options?: __HttpHandlerOptions): Promise<CreateWorkflowCommandOutput>;
            createWorkflow(args: CreateWorkflowCommandInput, cb: (err: any, data?: CreateWorkflowCommandOutput) => void): void;
            createWorkflow(args: CreateWorkflowCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateWorkflowCommandOutput) => void): void;
            /**
                * <p>Allows you to delete the access specified in the <code>ServerID</code> and
                *       <code>ExternalID</code> parameters.</p>
                */
            deleteAccess(args: DeleteAccessCommandInput, options?: __HttpHandlerOptions): Promise<DeleteAccessCommandOutput>;
            deleteAccess(args: DeleteAccessCommandInput, cb: (err: any, data?: DeleteAccessCommandOutput) => void): void;
            deleteAccess(args: DeleteAccessCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteAccessCommandOutput) => void): void;
            /**
                * <p>Deletes the file transfer protocol-enabled server that you specify.</p>
                *
                *          <p>No response returns from this operation.</p>
                */
            deleteServer(args: DeleteServerCommandInput, options?: __HttpHandlerOptions): Promise<DeleteServerCommandOutput>;
            deleteServer(args: DeleteServerCommandInput, cb: (err: any, data?: DeleteServerCommandOutput) => void): void;
            deleteServer(args: DeleteServerCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteServerCommandOutput) => void): void;
            /**
                * <p>Deletes a user's Secure Shell (SSH) public key.</p>
                */
            deleteSshPublicKey(args: DeleteSshPublicKeyCommandInput, options?: __HttpHandlerOptions): Promise<DeleteSshPublicKeyCommandOutput>;
            deleteSshPublicKey(args: DeleteSshPublicKeyCommandInput, cb: (err: any, data?: DeleteSshPublicKeyCommandOutput) => void): void;
            deleteSshPublicKey(args: DeleteSshPublicKeyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteSshPublicKeyCommandOutput) => void): void;
            /**
                * <p>Deletes the user belonging to a file transfer protocol-enabled server you specify.</p>
                *
                *          <p>No response returns from this operation.</p>
                *
                *          <note>
                *             <p>When you delete a user from a server, the user's information is lost.</p>
                *          </note>
                */
            deleteUser(args: DeleteUserCommandInput, options?: __HttpHandlerOptions): Promise<DeleteUserCommandOutput>;
            deleteUser(args: DeleteUserCommandInput, cb: (err: any, data?: DeleteUserCommandOutput) => void): void;
            deleteUser(args: DeleteUserCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteUserCommandOutput) => void): void;
            /**
                * <p>Deletes the specified workflow.</p>
                */
            deleteWorkflow(args: DeleteWorkflowCommandInput, options?: __HttpHandlerOptions): Promise<DeleteWorkflowCommandOutput>;
            deleteWorkflow(args: DeleteWorkflowCommandInput, cb: (err: any, data?: DeleteWorkflowCommandOutput) => void): void;
            deleteWorkflow(args: DeleteWorkflowCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteWorkflowCommandOutput) => void): void;
            /**
                * <p>Describes the access that is assigned to the specific file transfer protocol-enabled
                *       server, as identified by its <code>ServerId</code> property and its
                *       <code>ExternalID</code>.</p>
                *
                *          <p>The response from this call returns the properties of the access that is associated with
                *       the <code>ServerId</code> value that was specified.</p>
                */
            describeAccess(args: DescribeAccessCommandInput, options?: __HttpHandlerOptions): Promise<DescribeAccessCommandOutput>;
            describeAccess(args: DescribeAccessCommandInput, cb: (err: any, data?: DescribeAccessCommandOutput) => void): void;
            describeAccess(args: DescribeAccessCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeAccessCommandOutput) => void): void;
            /**
                * <p>You can use <code>DescribeExecution</code> to check the details of the execution of the specified workflow.</p>
                */
            describeExecution(args: DescribeExecutionCommandInput, options?: __HttpHandlerOptions): Promise<DescribeExecutionCommandOutput>;
            describeExecution(args: DescribeExecutionCommandInput, cb: (err: any, data?: DescribeExecutionCommandOutput) => void): void;
            describeExecution(args: DescribeExecutionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeExecutionCommandOutput) => void): void;
            /**
                * <p>Describes the security policy that is attached to your file transfer protocol-enabled
                *       server. The response contains a description of the security policy's properties. For more
                *       information about security policies, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/security-policies.html">Working with security
                *         policies</a>.</p>
                */
            describeSecurityPolicy(args: DescribeSecurityPolicyCommandInput, options?: __HttpHandlerOptions): Promise<DescribeSecurityPolicyCommandOutput>;
            describeSecurityPolicy(args: DescribeSecurityPolicyCommandInput, cb: (err: any, data?: DescribeSecurityPolicyCommandOutput) => void): void;
            describeSecurityPolicy(args: DescribeSecurityPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeSecurityPolicyCommandOutput) => void): void;
            /**
                * <p>Describes a file transfer protocol-enabled server that you specify by passing the
                *         <code>ServerId</code> parameter.</p>
                *
                *          <p>The response contains a description of a server's properties. When you set
                *         <code>EndpointType</code> to VPC, the response will contain the
                *       <code>EndpointDetails</code>.</p>
                */
            describeServer(args: DescribeServerCommandInput, options?: __HttpHandlerOptions): Promise<DescribeServerCommandOutput>;
            describeServer(args: DescribeServerCommandInput, cb: (err: any, data?: DescribeServerCommandOutput) => void): void;
            describeServer(args: DescribeServerCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeServerCommandOutput) => void): void;
            /**
                * <p>Describes the user assigned to the specific file transfer protocol-enabled server, as
                *       identified by its <code>ServerId</code> property.</p>
                *
                *          <p>The response from this call returns the properties of the user associated with the
                *         <code>ServerId</code> value that was specified.</p>
                */
            describeUser(args: DescribeUserCommandInput, options?: __HttpHandlerOptions): Promise<DescribeUserCommandOutput>;
            describeUser(args: DescribeUserCommandInput, cb: (err: any, data?: DescribeUserCommandOutput) => void): void;
            describeUser(args: DescribeUserCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeUserCommandOutput) => void): void;
            /**
                * <p>Describes the specified workflow.</p>
                */
            describeWorkflow(args: DescribeWorkflowCommandInput, options?: __HttpHandlerOptions): Promise<DescribeWorkflowCommandOutput>;
            describeWorkflow(args: DescribeWorkflowCommandInput, cb: (err: any, data?: DescribeWorkflowCommandOutput) => void): void;
            describeWorkflow(args: DescribeWorkflowCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeWorkflowCommandOutput) => void): void;
            /**
                * <p>Adds a Secure Shell (SSH) public key to a user account identified by a
                *         <code>UserName</code> value assigned to the specific file transfer protocol-enabled server,
                *       identified by <code>ServerId</code>.</p>
                *
                *          <p>The response returns the <code>UserName</code> value, the <code>ServerId</code> value, and
                *       the name of the <code>SshPublicKeyId</code>.</p>
                */
            importSshPublicKey(args: ImportSshPublicKeyCommandInput, options?: __HttpHandlerOptions): Promise<ImportSshPublicKeyCommandOutput>;
            importSshPublicKey(args: ImportSshPublicKeyCommandInput, cb: (err: any, data?: ImportSshPublicKeyCommandOutput) => void): void;
            importSshPublicKey(args: ImportSshPublicKeyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ImportSshPublicKeyCommandOutput) => void): void;
            /**
                * <p>Lists the details for all the accesses you have on your server.</p>
                */
            listAccesses(args: ListAccessesCommandInput, options?: __HttpHandlerOptions): Promise<ListAccessesCommandOutput>;
            listAccesses(args: ListAccessesCommandInput, cb: (err: any, data?: ListAccessesCommandOutput) => void): void;
            listAccesses(args: ListAccessesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListAccessesCommandOutput) => void): void;
            /**
                * <p>Lists all executions for the specified workflow.</p>
                */
            listExecutions(args: ListExecutionsCommandInput, options?: __HttpHandlerOptions): Promise<ListExecutionsCommandOutput>;
            listExecutions(args: ListExecutionsCommandInput, cb: (err: any, data?: ListExecutionsCommandOutput) => void): void;
            listExecutions(args: ListExecutionsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListExecutionsCommandOutput) => void): void;
            /**
                * <p>Lists the security policies that are attached to your file transfer protocol-enabled
                *       servers.</p>
                */
            listSecurityPolicies(args: ListSecurityPoliciesCommandInput, options?: __HttpHandlerOptions): Promise<ListSecurityPoliciesCommandOutput>;
            listSecurityPolicies(args: ListSecurityPoliciesCommandInput, cb: (err: any, data?: ListSecurityPoliciesCommandOutput) => void): void;
            listSecurityPolicies(args: ListSecurityPoliciesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListSecurityPoliciesCommandOutput) => void): void;
            /**
                * <p>Lists the file transfer protocol-enabled servers that are associated with your Amazon Web Services
                *       account.</p>
                */
            listServers(args: ListServersCommandInput, options?: __HttpHandlerOptions): Promise<ListServersCommandOutput>;
            listServers(args: ListServersCommandInput, cb: (err: any, data?: ListServersCommandOutput) => void): void;
            listServers(args: ListServersCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListServersCommandOutput) => void): void;
            /**
                * <p>Lists all of the tags associated with the Amazon Resource Name (ARN) that you specify. The
                *       resource can be a user, server, or role.</p>
                */
            listTagsForResource(args: ListTagsForResourceCommandInput, options?: __HttpHandlerOptions): Promise<ListTagsForResourceCommandOutput>;
            listTagsForResource(args: ListTagsForResourceCommandInput, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            listTagsForResource(args: ListTagsForResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            /**
                * <p>Lists the users for a file transfer protocol-enabled server that you specify by passing
                *       the <code>ServerId</code> parameter.</p>
                */
            listUsers(args: ListUsersCommandInput, options?: __HttpHandlerOptions): Promise<ListUsersCommandOutput>;
            listUsers(args: ListUsersCommandInput, cb: (err: any, data?: ListUsersCommandOutput) => void): void;
            listUsers(args: ListUsersCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListUsersCommandOutput) => void): void;
            /**
                * <p>Lists all of your workflows.</p>
                */
            listWorkflows(args: ListWorkflowsCommandInput, options?: __HttpHandlerOptions): Promise<ListWorkflowsCommandOutput>;
            listWorkflows(args: ListWorkflowsCommandInput, cb: (err: any, data?: ListWorkflowsCommandOutput) => void): void;
            listWorkflows(args: ListWorkflowsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListWorkflowsCommandOutput) => void): void;
            /**
                * <p>Sends a callback for asynchronous custom steps.</p>
                *          <p>
                *       The <code>ExecutionId</code>, <code>WorkflowId</code>, and <code>Token</code> are passed to the target resource during execution of a custom step of a workflow.
                *       You must include those with their callback as well as providing a status.
                *     </p>
                */
            sendWorkflowStepState(args: SendWorkflowStepStateCommandInput, options?: __HttpHandlerOptions): Promise<SendWorkflowStepStateCommandOutput>;
            sendWorkflowStepState(args: SendWorkflowStepStateCommandInput, cb: (err: any, data?: SendWorkflowStepStateCommandOutput) => void): void;
            sendWorkflowStepState(args: SendWorkflowStepStateCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: SendWorkflowStepStateCommandOutput) => void): void;
            /**
                * <p>Changes the state of a file transfer protocol-enabled server from <code>OFFLINE</code> to
                *         <code>ONLINE</code>. It has no impact on a server that is already <code>ONLINE</code>. An
                *         <code>ONLINE</code> server can accept and process file transfer jobs.</p>
                *
                *          <p>The state of <code>STARTING</code> indicates that the server is in an intermediate state,
                *       either not fully able to respond, or not fully online. The values of <code>START_FAILED</code>
                *       can indicate an error condition.</p>
                *
                *          <p>No response is returned from this call.</p>
                */
            startServer(args: StartServerCommandInput, options?: __HttpHandlerOptions): Promise<StartServerCommandOutput>;
            startServer(args: StartServerCommandInput, cb: (err: any, data?: StartServerCommandOutput) => void): void;
            startServer(args: StartServerCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: StartServerCommandOutput) => void): void;
            /**
                * <p>Changes the state of a file transfer protocol-enabled server from <code>ONLINE</code> to
                *         <code>OFFLINE</code>. An <code>OFFLINE</code> server cannot accept and process file transfer
                *       jobs. Information tied to your server, such as server and user properties, are not affected by
                *       stopping your server.</p>
                *
                *          <note>
                *             <p>Stopping the server will not reduce or impact your file transfer protocol endpoint
                *         billing; you must delete the server to stop being billed.</p>
                *          </note>
                *
                *          <p>The state of <code>STOPPING</code> indicates that the server is in an intermediate state,
                *       either not fully able to respond, or not fully offline. The values of <code>STOP_FAILED</code>
                *       can indicate an error condition.</p>
                *
                *          <p>No response is returned from this call.</p>
                */
            stopServer(args: StopServerCommandInput, options?: __HttpHandlerOptions): Promise<StopServerCommandOutput>;
            stopServer(args: StopServerCommandInput, cb: (err: any, data?: StopServerCommandOutput) => void): void;
            stopServer(args: StopServerCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: StopServerCommandOutput) => void): void;
            /**
                * <p>Attaches a key-value pair to a resource, as identified by its Amazon Resource Name (ARN).
                *       Resources are users, servers, roles, and other entities.</p>
                *
                *          <p>There is no response returned from this call.</p>
                */
            tagResource(args: TagResourceCommandInput, options?: __HttpHandlerOptions): Promise<TagResourceCommandOutput>;
            tagResource(args: TagResourceCommandInput, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            tagResource(args: TagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            /**
                * <p>If the <code>IdentityProviderType</code> of a file transfer protocol-enabled server is
                *         <code>AWS_DIRECTORY_SERVICE</code> or <code>API_Gateway</code>, tests whether your identity
                *       provider is set up successfully. We highly recommend that you call this operation to test your
                *       authentication method as soon as you create your server. By doing so, you can troubleshoot
                *       issues with the identity provider integration to ensure that your users can successfully use
                *       the service.</p>
                *          <p>
                *       The <code>ServerId</code> and <code>UserName</code> parameters are required. The <code>ServerProtocol</code>, <code>SourceIp</code>, and <code>UserPassword</code> are all optional.
                *     </p>
                *          <note>
                *             <p>
                *         You cannot use <code>TestIdentityProvider</code> if the <code>IdentityProviderType</code> of your server is <code>SERVICE_MANAGED</code>.
                *       </p>
                *          </note>
                *          <ul>
                *             <li>
                *                <p>
                *         If you provide any incorrect values for any parameters, the <code>Response</code> field is empty.
                *       </p>
                *             </li>
                *             <li>
                *                <p>
                *         If you provide a server ID for a server that uses service-managed users, you get an error:
                *       </p>
                *                <p>
                *                   <code>
                *         An error occurred (InvalidRequestException) when calling the TestIdentityProvider operation: s-<i>server-ID</i> not configured for external auth
                *       </code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *           If you enter a Server ID for the <code>--server-id</code> parameter that does not identify an actual Transfer server, you receive the following error:
                *         </p>
                *                <p>
                *                   <code>An error occurred (ResourceNotFoundException) when calling the TestIdentityProvider operation: Unknown server</code>
                *                </p>
                *             </li>
                *          </ul>
                */
            testIdentityProvider(args: TestIdentityProviderCommandInput, options?: __HttpHandlerOptions): Promise<TestIdentityProviderCommandOutput>;
            testIdentityProvider(args: TestIdentityProviderCommandInput, cb: (err: any, data?: TestIdentityProviderCommandOutput) => void): void;
            testIdentityProvider(args: TestIdentityProviderCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TestIdentityProviderCommandOutput) => void): void;
            /**
                * <p>Detaches a key-value pair from a resource, as identified by its Amazon Resource Name
                *       (ARN). Resources are users, servers, roles, and other entities.</p>
                *
                *          <p>No response is returned from this call.</p>
                */
            untagResource(args: UntagResourceCommandInput, options?: __HttpHandlerOptions): Promise<UntagResourceCommandOutput>;
            untagResource(args: UntagResourceCommandInput, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            untagResource(args: UntagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            /**
                * <p>Allows you to update parameters for the access specified in the <code>ServerID</code> and
                *       <code>ExternalID</code> parameters.</p>
                */
            updateAccess(args: UpdateAccessCommandInput, options?: __HttpHandlerOptions): Promise<UpdateAccessCommandOutput>;
            updateAccess(args: UpdateAccessCommandInput, cb: (err: any, data?: UpdateAccessCommandOutput) => void): void;
            updateAccess(args: UpdateAccessCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateAccessCommandOutput) => void): void;
            /**
                * <p>Updates the file transfer protocol-enabled server's properties after that server has
                *       been created.</p>
                *
                *          <p>The <code>UpdateServer</code> call returns the <code>ServerId</code> of the server you
                *       updated.</p>
                */
            updateServer(args: UpdateServerCommandInput, options?: __HttpHandlerOptions): Promise<UpdateServerCommandOutput>;
            updateServer(args: UpdateServerCommandInput, cb: (err: any, data?: UpdateServerCommandOutput) => void): void;
            updateServer(args: UpdateServerCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateServerCommandOutput) => void): void;
            /**
                * <p>Assigns new properties to a user. Parameters you pass modify any or all of the following:
                *       the home directory, role, and policy for the <code>UserName</code> and <code>ServerId</code>
                *       you specify.</p>
                *
                *          <p>The response returns the <code>ServerId</code> and the <code>UserName</code> for the
                *       updated user.</p>
                */
            updateUser(args: UpdateUserCommandInput, options?: __HttpHandlerOptions): Promise<UpdateUserCommandOutput>;
            updateUser(args: UpdateUserCommandInput, cb: (err: any, data?: UpdateUserCommandOutput) => void): void;
            updateUser(args: UpdateUserCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateUserCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/CreateAccessCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateAccessRequest, CreateAccessResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface CreateAccessCommandInput extends CreateAccessRequest {
    }
    export interface CreateAccessCommandOutput extends CreateAccessResponse, __MetadataBearer {
    }
    /**
        * <p>Used by administrators to choose which groups in the directory should have access to
        *       upload and download files over the enabled protocols using Amazon Web Services Transfer Family. For example, a
        *       Microsoft Active Directory might contain 50,000 users, but only a small fraction might need
        *       the ability to transfer files to the server. An administrator can use
        *         <code>CreateAccess</code> to limit the access to the correct set of users who need this
        *       ability.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, CreateAccessCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, CreateAccessCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new CreateAccessCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateAccessCommandInput} for command's `input` shape.
        * @see {@link CreateAccessCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class CreateAccessCommand extends $Command<CreateAccessCommandInput, CreateAccessCommandOutput, TransferClientResolvedConfig> {
            readonly input: CreateAccessCommandInput;
            constructor(input: CreateAccessCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateAccessCommandInput, CreateAccessCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/CreateServerCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateServerRequest, CreateServerResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface CreateServerCommandInput extends CreateServerRequest {
    }
    export interface CreateServerCommandOutput extends CreateServerResponse, __MetadataBearer {
    }
    /**
        * <p>Instantiates an auto-scaling virtual server based on the selected file transfer protocol
        *       in Amazon Web Services. When you make updates to your file transfer protocol-enabled server or when you work
        *       with users, use the service-generated <code>ServerId</code> property that is assigned to the
        *       newly created server.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, CreateServerCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, CreateServerCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new CreateServerCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateServerCommandInput} for command's `input` shape.
        * @see {@link CreateServerCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class CreateServerCommand extends $Command<CreateServerCommandInput, CreateServerCommandOutput, TransferClientResolvedConfig> {
            readonly input: CreateServerCommandInput;
            constructor(input: CreateServerCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateServerCommandInput, CreateServerCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/CreateUserCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateUserRequest, CreateUserResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface CreateUserCommandInput extends CreateUserRequest {
    }
    export interface CreateUserCommandOutput extends CreateUserResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a user and associates them with an existing file transfer protocol-enabled server.
        *       You can only create and associate users with servers that have the
        *         <code>IdentityProviderType</code> set to <code>SERVICE_MANAGED</code>. Using parameters for
        *         <code>CreateUser</code>, you can specify the user name, set the home directory, store the
        *       user's public key, and assign the user's Amazon Web Services Identity and Access Management (IAM)
        *       role. You can also optionally add a session policy, and assign metadata with tags that can
        *       be used to group and search for users.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, CreateUserCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, CreateUserCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new CreateUserCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateUserCommandInput} for command's `input` shape.
        * @see {@link CreateUserCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class CreateUserCommand extends $Command<CreateUserCommandInput, CreateUserCommandOutput, TransferClientResolvedConfig> {
            readonly input: CreateUserCommandInput;
            constructor(input: CreateUserCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateUserCommandInput, CreateUserCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/CreateWorkflowCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateWorkflowRequest, CreateWorkflowResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface CreateWorkflowCommandInput extends CreateWorkflowRequest {
    }
    export interface CreateWorkflowCommandOutput extends CreateWorkflowResponse, __MetadataBearer {
    }
    /**
        * <p>
        *       Allows you to create a workflow with specified steps and step details the workflow invokes after file transfer completes.
        *       After creating a workflow, you can associate the workflow created with any transfer servers by specifying the <code>workflow-details</code> field in <code>CreateServer</code> and <code>UpdateServer</code> operations.
        *     </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, CreateWorkflowCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, CreateWorkflowCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new CreateWorkflowCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateWorkflowCommandInput} for command's `input` shape.
        * @see {@link CreateWorkflowCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class CreateWorkflowCommand extends $Command<CreateWorkflowCommandInput, CreateWorkflowCommandOutput, TransferClientResolvedConfig> {
            readonly input: CreateWorkflowCommandInput;
            constructor(input: CreateWorkflowCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateWorkflowCommandInput, CreateWorkflowCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DeleteAccessCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteAccessRequest } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface DeleteAccessCommandInput extends DeleteAccessRequest {
    }
    export interface DeleteAccessCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Allows you to delete the access specified in the <code>ServerID</code> and
        *       <code>ExternalID</code> parameters.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, DeleteAccessCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, DeleteAccessCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new DeleteAccessCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteAccessCommandInput} for command's `input` shape.
        * @see {@link DeleteAccessCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class DeleteAccessCommand extends $Command<DeleteAccessCommandInput, DeleteAccessCommandOutput, TransferClientResolvedConfig> {
            readonly input: DeleteAccessCommandInput;
            constructor(input: DeleteAccessCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteAccessCommandInput, DeleteAccessCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DeleteServerCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteServerRequest } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface DeleteServerCommandInput extends DeleteServerRequest {
    }
    export interface DeleteServerCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes the file transfer protocol-enabled server that you specify.</p>
        *
        *          <p>No response returns from this operation.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, DeleteServerCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, DeleteServerCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new DeleteServerCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteServerCommandInput} for command's `input` shape.
        * @see {@link DeleteServerCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class DeleteServerCommand extends $Command<DeleteServerCommandInput, DeleteServerCommandOutput, TransferClientResolvedConfig> {
            readonly input: DeleteServerCommandInput;
            constructor(input: DeleteServerCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteServerCommandInput, DeleteServerCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DeleteSshPublicKeyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteSshPublicKeyRequest } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface DeleteSshPublicKeyCommandInput extends DeleteSshPublicKeyRequest {
    }
    export interface DeleteSshPublicKeyCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes a user's Secure Shell (SSH) public key.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, DeleteSshPublicKeyCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, DeleteSshPublicKeyCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new DeleteSshPublicKeyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteSshPublicKeyCommandInput} for command's `input` shape.
        * @see {@link DeleteSshPublicKeyCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class DeleteSshPublicKeyCommand extends $Command<DeleteSshPublicKeyCommandInput, DeleteSshPublicKeyCommandOutput, TransferClientResolvedConfig> {
            readonly input: DeleteSshPublicKeyCommandInput;
            constructor(input: DeleteSshPublicKeyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteSshPublicKeyCommandInput, DeleteSshPublicKeyCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DeleteUserCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteUserRequest } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface DeleteUserCommandInput extends DeleteUserRequest {
    }
    export interface DeleteUserCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes the user belonging to a file transfer protocol-enabled server you specify.</p>
        *
        *          <p>No response returns from this operation.</p>
        *
        *          <note>
        *             <p>When you delete a user from a server, the user's information is lost.</p>
        *          </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, DeleteUserCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, DeleteUserCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new DeleteUserCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteUserCommandInput} for command's `input` shape.
        * @see {@link DeleteUserCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class DeleteUserCommand extends $Command<DeleteUserCommandInput, DeleteUserCommandOutput, TransferClientResolvedConfig> {
            readonly input: DeleteUserCommandInput;
            constructor(input: DeleteUserCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteUserCommandInput, DeleteUserCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DeleteWorkflowCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteWorkflowRequest } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface DeleteWorkflowCommandInput extends DeleteWorkflowRequest {
    }
    export interface DeleteWorkflowCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes the specified workflow.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, DeleteWorkflowCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, DeleteWorkflowCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new DeleteWorkflowCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteWorkflowCommandInput} for command's `input` shape.
        * @see {@link DeleteWorkflowCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class DeleteWorkflowCommand extends $Command<DeleteWorkflowCommandInput, DeleteWorkflowCommandOutput, TransferClientResolvedConfig> {
            readonly input: DeleteWorkflowCommandInput;
            constructor(input: DeleteWorkflowCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteWorkflowCommandInput, DeleteWorkflowCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DescribeAccessCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeAccessRequest, DescribeAccessResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface DescribeAccessCommandInput extends DescribeAccessRequest {
    }
    export interface DescribeAccessCommandOutput extends DescribeAccessResponse, __MetadataBearer {
    }
    /**
        * <p>Describes the access that is assigned to the specific file transfer protocol-enabled
        *       server, as identified by its <code>ServerId</code> property and its
        *       <code>ExternalID</code>.</p>
        *
        *          <p>The response from this call returns the properties of the access that is associated with
        *       the <code>ServerId</code> value that was specified.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, DescribeAccessCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, DescribeAccessCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new DescribeAccessCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeAccessCommandInput} for command's `input` shape.
        * @see {@link DescribeAccessCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class DescribeAccessCommand extends $Command<DescribeAccessCommandInput, DescribeAccessCommandOutput, TransferClientResolvedConfig> {
            readonly input: DescribeAccessCommandInput;
            constructor(input: DescribeAccessCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeAccessCommandInput, DescribeAccessCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DescribeExecutionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeExecutionRequest, DescribeExecutionResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface DescribeExecutionCommandInput extends DescribeExecutionRequest {
    }
    export interface DescribeExecutionCommandOutput extends DescribeExecutionResponse, __MetadataBearer {
    }
    /**
        * <p>You can use <code>DescribeExecution</code> to check the details of the execution of the specified workflow.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, DescribeExecutionCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, DescribeExecutionCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new DescribeExecutionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeExecutionCommandInput} for command's `input` shape.
        * @see {@link DescribeExecutionCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class DescribeExecutionCommand extends $Command<DescribeExecutionCommandInput, DescribeExecutionCommandOutput, TransferClientResolvedConfig> {
            readonly input: DescribeExecutionCommandInput;
            constructor(input: DescribeExecutionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeExecutionCommandInput, DescribeExecutionCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DescribeSecurityPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeSecurityPolicyRequest, DescribeSecurityPolicyResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface DescribeSecurityPolicyCommandInput extends DescribeSecurityPolicyRequest {
    }
    export interface DescribeSecurityPolicyCommandOutput extends DescribeSecurityPolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Describes the security policy that is attached to your file transfer protocol-enabled
        *       server. The response contains a description of the security policy's properties. For more
        *       information about security policies, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/security-policies.html">Working with security
        *         policies</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, DescribeSecurityPolicyCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, DescribeSecurityPolicyCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new DescribeSecurityPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeSecurityPolicyCommandInput} for command's `input` shape.
        * @see {@link DescribeSecurityPolicyCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class DescribeSecurityPolicyCommand extends $Command<DescribeSecurityPolicyCommandInput, DescribeSecurityPolicyCommandOutput, TransferClientResolvedConfig> {
            readonly input: DescribeSecurityPolicyCommandInput;
            constructor(input: DescribeSecurityPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeSecurityPolicyCommandInput, DescribeSecurityPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DescribeServerCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeServerRequest, DescribeServerResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface DescribeServerCommandInput extends DescribeServerRequest {
    }
    export interface DescribeServerCommandOutput extends DescribeServerResponse, __MetadataBearer {
    }
    /**
        * <p>Describes a file transfer protocol-enabled server that you specify by passing the
        *         <code>ServerId</code> parameter.</p>
        *
        *          <p>The response contains a description of a server's properties. When you set
        *         <code>EndpointType</code> to VPC, the response will contain the
        *       <code>EndpointDetails</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, DescribeServerCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, DescribeServerCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new DescribeServerCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeServerCommandInput} for command's `input` shape.
        * @see {@link DescribeServerCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class DescribeServerCommand extends $Command<DescribeServerCommandInput, DescribeServerCommandOutput, TransferClientResolvedConfig> {
            readonly input: DescribeServerCommandInput;
            constructor(input: DescribeServerCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeServerCommandInput, DescribeServerCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DescribeUserCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeUserRequest, DescribeUserResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface DescribeUserCommandInput extends DescribeUserRequest {
    }
    export interface DescribeUserCommandOutput extends DescribeUserResponse, __MetadataBearer {
    }
    /**
        * <p>Describes the user assigned to the specific file transfer protocol-enabled server, as
        *       identified by its <code>ServerId</code> property.</p>
        *
        *          <p>The response from this call returns the properties of the user associated with the
        *         <code>ServerId</code> value that was specified.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, DescribeUserCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, DescribeUserCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new DescribeUserCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeUserCommandInput} for command's `input` shape.
        * @see {@link DescribeUserCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class DescribeUserCommand extends $Command<DescribeUserCommandInput, DescribeUserCommandOutput, TransferClientResolvedConfig> {
            readonly input: DescribeUserCommandInput;
            constructor(input: DescribeUserCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeUserCommandInput, DescribeUserCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DescribeWorkflowCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeWorkflowRequest, DescribeWorkflowResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface DescribeWorkflowCommandInput extends DescribeWorkflowRequest {
    }
    export interface DescribeWorkflowCommandOutput extends DescribeWorkflowResponse, __MetadataBearer {
    }
    /**
        * <p>Describes the specified workflow.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, DescribeWorkflowCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, DescribeWorkflowCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new DescribeWorkflowCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeWorkflowCommandInput} for command's `input` shape.
        * @see {@link DescribeWorkflowCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class DescribeWorkflowCommand extends $Command<DescribeWorkflowCommandInput, DescribeWorkflowCommandOutput, TransferClientResolvedConfig> {
            readonly input: DescribeWorkflowCommandInput;
            constructor(input: DescribeWorkflowCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeWorkflowCommandInput, DescribeWorkflowCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ImportSshPublicKeyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ImportSshPublicKeyRequest, ImportSshPublicKeyResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface ImportSshPublicKeyCommandInput extends ImportSshPublicKeyRequest {
    }
    export interface ImportSshPublicKeyCommandOutput extends ImportSshPublicKeyResponse, __MetadataBearer {
    }
    /**
        * <p>Adds a Secure Shell (SSH) public key to a user account identified by a
        *         <code>UserName</code> value assigned to the specific file transfer protocol-enabled server,
        *       identified by <code>ServerId</code>.</p>
        *
        *          <p>The response returns the <code>UserName</code> value, the <code>ServerId</code> value, and
        *       the name of the <code>SshPublicKeyId</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, ImportSshPublicKeyCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, ImportSshPublicKeyCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new ImportSshPublicKeyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ImportSshPublicKeyCommandInput} for command's `input` shape.
        * @see {@link ImportSshPublicKeyCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class ImportSshPublicKeyCommand extends $Command<ImportSshPublicKeyCommandInput, ImportSshPublicKeyCommandOutput, TransferClientResolvedConfig> {
            readonly input: ImportSshPublicKeyCommandInput;
            constructor(input: ImportSshPublicKeyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ImportSshPublicKeyCommandInput, ImportSshPublicKeyCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ListAccessesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListAccessesRequest, ListAccessesResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface ListAccessesCommandInput extends ListAccessesRequest {
    }
    export interface ListAccessesCommandOutput extends ListAccessesResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the details for all the accesses you have on your server.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, ListAccessesCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, ListAccessesCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new ListAccessesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListAccessesCommandInput} for command's `input` shape.
        * @see {@link ListAccessesCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class ListAccessesCommand extends $Command<ListAccessesCommandInput, ListAccessesCommandOutput, TransferClientResolvedConfig> {
            readonly input: ListAccessesCommandInput;
            constructor(input: ListAccessesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListAccessesCommandInput, ListAccessesCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ListExecutionsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListExecutionsRequest, ListExecutionsResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface ListExecutionsCommandInput extends ListExecutionsRequest {
    }
    export interface ListExecutionsCommandOutput extends ListExecutionsResponse, __MetadataBearer {
    }
    /**
        * <p>Lists all executions for the specified workflow.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, ListExecutionsCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, ListExecutionsCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new ListExecutionsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListExecutionsCommandInput} for command's `input` shape.
        * @see {@link ListExecutionsCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class ListExecutionsCommand extends $Command<ListExecutionsCommandInput, ListExecutionsCommandOutput, TransferClientResolvedConfig> {
            readonly input: ListExecutionsCommandInput;
            constructor(input: ListExecutionsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListExecutionsCommandInput, ListExecutionsCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ListSecurityPoliciesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListSecurityPoliciesRequest, ListSecurityPoliciesResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface ListSecurityPoliciesCommandInput extends ListSecurityPoliciesRequest {
    }
    export interface ListSecurityPoliciesCommandOutput extends ListSecurityPoliciesResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the security policies that are attached to your file transfer protocol-enabled
        *       servers.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, ListSecurityPoliciesCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, ListSecurityPoliciesCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new ListSecurityPoliciesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListSecurityPoliciesCommandInput} for command's `input` shape.
        * @see {@link ListSecurityPoliciesCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class ListSecurityPoliciesCommand extends $Command<ListSecurityPoliciesCommandInput, ListSecurityPoliciesCommandOutput, TransferClientResolvedConfig> {
            readonly input: ListSecurityPoliciesCommandInput;
            constructor(input: ListSecurityPoliciesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListSecurityPoliciesCommandInput, ListSecurityPoliciesCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ListServersCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListServersRequest, ListServersResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface ListServersCommandInput extends ListServersRequest {
    }
    export interface ListServersCommandOutput extends ListServersResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the file transfer protocol-enabled servers that are associated with your Amazon Web Services
        *       account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, ListServersCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, ListServersCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new ListServersCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListServersCommandInput} for command's `input` shape.
        * @see {@link ListServersCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class ListServersCommand extends $Command<ListServersCommandInput, ListServersCommandOutput, TransferClientResolvedConfig> {
            readonly input: ListServersCommandInput;
            constructor(input: ListServersCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListServersCommandInput, ListServersCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ListTagsForResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListTagsForResourceRequest, ListTagsForResourceResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface ListTagsForResourceCommandInput extends ListTagsForResourceRequest {
    }
    export interface ListTagsForResourceCommandOutput extends ListTagsForResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Lists all of the tags associated with the Amazon Resource Name (ARN) that you specify. The
        *       resource can be a user, server, or role.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, ListTagsForResourceCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, ListTagsForResourceCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new ListTagsForResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTagsForResourceCommandInput} for command's `input` shape.
        * @see {@link ListTagsForResourceCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class ListTagsForResourceCommand extends $Command<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput, TransferClientResolvedConfig> {
            readonly input: ListTagsForResourceCommandInput;
            constructor(input: ListTagsForResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ListUsersCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListUsersRequest, ListUsersResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface ListUsersCommandInput extends ListUsersRequest {
    }
    export interface ListUsersCommandOutput extends ListUsersResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the users for a file transfer protocol-enabled server that you specify by passing
        *       the <code>ServerId</code> parameter.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, ListUsersCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, ListUsersCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new ListUsersCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListUsersCommandInput} for command's `input` shape.
        * @see {@link ListUsersCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class ListUsersCommand extends $Command<ListUsersCommandInput, ListUsersCommandOutput, TransferClientResolvedConfig> {
            readonly input: ListUsersCommandInput;
            constructor(input: ListUsersCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListUsersCommandInput, ListUsersCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ListWorkflowsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListWorkflowsRequest, ListWorkflowsResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface ListWorkflowsCommandInput extends ListWorkflowsRequest {
    }
    export interface ListWorkflowsCommandOutput extends ListWorkflowsResponse, __MetadataBearer {
    }
    /**
        * <p>Lists all of your workflows.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, ListWorkflowsCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, ListWorkflowsCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new ListWorkflowsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListWorkflowsCommandInput} for command's `input` shape.
        * @see {@link ListWorkflowsCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class ListWorkflowsCommand extends $Command<ListWorkflowsCommandInput, ListWorkflowsCommandOutput, TransferClientResolvedConfig> {
            readonly input: ListWorkflowsCommandInput;
            constructor(input: ListWorkflowsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListWorkflowsCommandInput, ListWorkflowsCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/SendWorkflowStepStateCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { SendWorkflowStepStateRequest, SendWorkflowStepStateResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface SendWorkflowStepStateCommandInput extends SendWorkflowStepStateRequest {
    }
    export interface SendWorkflowStepStateCommandOutput extends SendWorkflowStepStateResponse, __MetadataBearer {
    }
    /**
        * <p>Sends a callback for asynchronous custom steps.</p>
        *          <p>
        *       The <code>ExecutionId</code>, <code>WorkflowId</code>, and <code>Token</code> are passed to the target resource during execution of a custom step of a workflow.
        *       You must include those with their callback as well as providing a status.
        *     </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, SendWorkflowStepStateCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, SendWorkflowStepStateCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new SendWorkflowStepStateCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link SendWorkflowStepStateCommandInput} for command's `input` shape.
        * @see {@link SendWorkflowStepStateCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class SendWorkflowStepStateCommand extends $Command<SendWorkflowStepStateCommandInput, SendWorkflowStepStateCommandOutput, TransferClientResolvedConfig> {
            readonly input: SendWorkflowStepStateCommandInput;
            constructor(input: SendWorkflowStepStateCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<SendWorkflowStepStateCommandInput, SendWorkflowStepStateCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/StartServerCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { StartServerRequest } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface StartServerCommandInput extends StartServerRequest {
    }
    export interface StartServerCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Changes the state of a file transfer protocol-enabled server from <code>OFFLINE</code> to
        *         <code>ONLINE</code>. It has no impact on a server that is already <code>ONLINE</code>. An
        *         <code>ONLINE</code> server can accept and process file transfer jobs.</p>
        *
        *          <p>The state of <code>STARTING</code> indicates that the server is in an intermediate state,
        *       either not fully able to respond, or not fully online. The values of <code>START_FAILED</code>
        *       can indicate an error condition.</p>
        *
        *          <p>No response is returned from this call.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, StartServerCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, StartServerCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new StartServerCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link StartServerCommandInput} for command's `input` shape.
        * @see {@link StartServerCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class StartServerCommand extends $Command<StartServerCommandInput, StartServerCommandOutput, TransferClientResolvedConfig> {
            readonly input: StartServerCommandInput;
            constructor(input: StartServerCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<StartServerCommandInput, StartServerCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/StopServerCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { StopServerRequest } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface StopServerCommandInput extends StopServerRequest {
    }
    export interface StopServerCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Changes the state of a file transfer protocol-enabled server from <code>ONLINE</code> to
        *         <code>OFFLINE</code>. An <code>OFFLINE</code> server cannot accept and process file transfer
        *       jobs. Information tied to your server, such as server and user properties, are not affected by
        *       stopping your server.</p>
        *
        *          <note>
        *             <p>Stopping the server will not reduce or impact your file transfer protocol endpoint
        *         billing; you must delete the server to stop being billed.</p>
        *          </note>
        *
        *          <p>The state of <code>STOPPING</code> indicates that the server is in an intermediate state,
        *       either not fully able to respond, or not fully offline. The values of <code>STOP_FAILED</code>
        *       can indicate an error condition.</p>
        *
        *          <p>No response is returned from this call.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, StopServerCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, StopServerCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new StopServerCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link StopServerCommandInput} for command's `input` shape.
        * @see {@link StopServerCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class StopServerCommand extends $Command<StopServerCommandInput, StopServerCommandOutput, TransferClientResolvedConfig> {
            readonly input: StopServerCommandInput;
            constructor(input: StopServerCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<StopServerCommandInput, StopServerCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/TagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { TagResourceRequest } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface TagResourceCommandInput extends TagResourceRequest {
    }
    export interface TagResourceCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Attaches a key-value pair to a resource, as identified by its Amazon Resource Name (ARN).
        *       Resources are users, servers, roles, and other entities.</p>
        *
        *          <p>There is no response returned from this call.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, TagResourceCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, TagResourceCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new TagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TagResourceCommandInput} for command's `input` shape.
        * @see {@link TagResourceCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class TagResourceCommand extends $Command<TagResourceCommandInput, TagResourceCommandOutput, TransferClientResolvedConfig> {
            readonly input: TagResourceCommandInput;
            constructor(input: TagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TagResourceCommandInput, TagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/TestIdentityProviderCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { TestIdentityProviderRequest, TestIdentityProviderResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface TestIdentityProviderCommandInput extends TestIdentityProviderRequest {
    }
    export interface TestIdentityProviderCommandOutput extends TestIdentityProviderResponse, __MetadataBearer {
    }
    /**
        * <p>If the <code>IdentityProviderType</code> of a file transfer protocol-enabled server is
        *         <code>AWS_DIRECTORY_SERVICE</code> or <code>API_Gateway</code>, tests whether your identity
        *       provider is set up successfully. We highly recommend that you call this operation to test your
        *       authentication method as soon as you create your server. By doing so, you can troubleshoot
        *       issues with the identity provider integration to ensure that your users can successfully use
        *       the service.</p>
        *          <p>
        *       The <code>ServerId</code> and <code>UserName</code> parameters are required. The <code>ServerProtocol</code>, <code>SourceIp</code>, and <code>UserPassword</code> are all optional.
        *     </p>
        *          <note>
        *             <p>
        *         You cannot use <code>TestIdentityProvider</code> if the <code>IdentityProviderType</code> of your server is <code>SERVICE_MANAGED</code>.
        *       </p>
        *          </note>
        *          <ul>
        *             <li>
        *                <p>
        *         If you provide any incorrect values for any parameters, the <code>Response</code> field is empty.
        *       </p>
        *             </li>
        *             <li>
        *                <p>
        *         If you provide a server ID for a server that uses service-managed users, you get an error:
        *       </p>
        *                <p>
        *                   <code>
        *         An error occurred (InvalidRequestException) when calling the TestIdentityProvider operation: s-<i>server-ID</i> not configured for external auth
        *       </code>
        *                </p>
        *             </li>
        *             <li>
        *                <p>
        *           If you enter a Server ID for the <code>--server-id</code> parameter that does not identify an actual Transfer server, you receive the following error:
        *         </p>
        *                <p>
        *                   <code>An error occurred (ResourceNotFoundException) when calling the TestIdentityProvider operation: Unknown server</code>
        *                </p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, TestIdentityProviderCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, TestIdentityProviderCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new TestIdentityProviderCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TestIdentityProviderCommandInput} for command's `input` shape.
        * @see {@link TestIdentityProviderCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class TestIdentityProviderCommand extends $Command<TestIdentityProviderCommandInput, TestIdentityProviderCommandOutput, TransferClientResolvedConfig> {
            readonly input: TestIdentityProviderCommandInput;
            constructor(input: TestIdentityProviderCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TestIdentityProviderCommandInput, TestIdentityProviderCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/UntagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UntagResourceRequest } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface UntagResourceCommandInput extends UntagResourceRequest {
    }
    export interface UntagResourceCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Detaches a key-value pair from a resource, as identified by its Amazon Resource Name
        *       (ARN). Resources are users, servers, roles, and other entities.</p>
        *
        *          <p>No response is returned from this call.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, UntagResourceCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, UntagResourceCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new UntagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UntagResourceCommandInput} for command's `input` shape.
        * @see {@link UntagResourceCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class UntagResourceCommand extends $Command<UntagResourceCommandInput, UntagResourceCommandOutput, TransferClientResolvedConfig> {
            readonly input: UntagResourceCommandInput;
            constructor(input: UntagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UntagResourceCommandInput, UntagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/UpdateAccessCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UpdateAccessRequest, UpdateAccessResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface UpdateAccessCommandInput extends UpdateAccessRequest {
    }
    export interface UpdateAccessCommandOutput extends UpdateAccessResponse, __MetadataBearer {
    }
    /**
        * <p>Allows you to update parameters for the access specified in the <code>ServerID</code> and
        *       <code>ExternalID</code> parameters.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, UpdateAccessCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, UpdateAccessCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new UpdateAccessCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateAccessCommandInput} for command's `input` shape.
        * @see {@link UpdateAccessCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class UpdateAccessCommand extends $Command<UpdateAccessCommandInput, UpdateAccessCommandOutput, TransferClientResolvedConfig> {
            readonly input: UpdateAccessCommandInput;
            constructor(input: UpdateAccessCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateAccessCommandInput, UpdateAccessCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/UpdateServerCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UpdateServerRequest, UpdateServerResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface UpdateServerCommandInput extends UpdateServerRequest {
    }
    export interface UpdateServerCommandOutput extends UpdateServerResponse, __MetadataBearer {
    }
    /**
        * <p>Updates the file transfer protocol-enabled server's properties after that server has
        *       been created.</p>
        *
        *          <p>The <code>UpdateServer</code> call returns the <code>ServerId</code> of the server you
        *       updated.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, UpdateServerCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, UpdateServerCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new UpdateServerCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateServerCommandInput} for command's `input` shape.
        * @see {@link UpdateServerCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class UpdateServerCommand extends $Command<UpdateServerCommandInput, UpdateServerCommandOutput, TransferClientResolvedConfig> {
            readonly input: UpdateServerCommandInput;
            constructor(input: UpdateServerCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateServerCommandInput, UpdateServerCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/UpdateUserCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UpdateUserRequest, UpdateUserResponse } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient";
    export interface UpdateUserCommandInput extends UpdateUserRequest {
    }
    export interface UpdateUserCommandOutput extends UpdateUserResponse, __MetadataBearer {
    }
    /**
        * <p>Assigns new properties to a user. Parameters you pass modify any or all of the following:
        *       the home directory, role, and policy for the <code>UserName</code> and <code>ServerId</code>
        *       you specify.</p>
        *
        *          <p>The response returns the <code>ServerId</code> and the <code>UserName</code> for the
        *       updated user.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TransferClient, UpdateUserCommand } from "@aws-sdk/client-transfer"; // ES Modules import
        * // const { TransferClient, UpdateUserCommand } = require("@aws-sdk/client-transfer"); // CommonJS import
        * const client = new TransferClient(config);
        * const command = new UpdateUserCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateUserCommandInput} for command's `input` shape.
        * @see {@link UpdateUserCommandOutput} for command's `response` shape.
        * @see {@link TransferClientResolvedConfig | config} for TransferClient's `config` shape.
        *
        */
    export class UpdateUserCommand extends $Command<UpdateUserCommandInput, UpdateUserCommandOutput, TransferClientResolvedConfig> {
            readonly input: UpdateUserCommandInput;
            constructor(input: UpdateUserCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TransferClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateUserCommandInput, UpdateUserCommandOutput>;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/TransferClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { CreateAccessCommandInput, CreateAccessCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/CreateAccessCommand";
    import { CreateServerCommandInput, CreateServerCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/CreateServerCommand";
    import { CreateUserCommandInput, CreateUserCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/CreateUserCommand";
    import { CreateWorkflowCommandInput, CreateWorkflowCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/CreateWorkflowCommand";
    import { DeleteAccessCommandInput, DeleteAccessCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DeleteAccessCommand";
    import { DeleteServerCommandInput, DeleteServerCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DeleteServerCommand";
    import { DeleteSshPublicKeyCommandInput, DeleteSshPublicKeyCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DeleteSshPublicKeyCommand";
    import { DeleteUserCommandInput, DeleteUserCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DeleteUserCommand";
    import { DeleteWorkflowCommandInput, DeleteWorkflowCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DeleteWorkflowCommand";
    import { DescribeAccessCommandInput, DescribeAccessCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DescribeAccessCommand";
    import { DescribeExecutionCommandInput, DescribeExecutionCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DescribeExecutionCommand";
    import { DescribeSecurityPolicyCommandInput, DescribeSecurityPolicyCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DescribeSecurityPolicyCommand";
    import { DescribeServerCommandInput, DescribeServerCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DescribeServerCommand";
    import { DescribeUserCommandInput, DescribeUserCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DescribeUserCommand";
    import { DescribeWorkflowCommandInput, DescribeWorkflowCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/DescribeWorkflowCommand";
    import { ImportSshPublicKeyCommandInput, ImportSshPublicKeyCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ImportSshPublicKeyCommand";
    import { ListAccessesCommandInput, ListAccessesCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ListAccessesCommand";
    import { ListExecutionsCommandInput, ListExecutionsCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ListExecutionsCommand";
    import { ListSecurityPoliciesCommandInput, ListSecurityPoliciesCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ListSecurityPoliciesCommand";
    import { ListServersCommandInput, ListServersCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ListServersCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ListTagsForResourceCommand";
    import { ListUsersCommandInput, ListUsersCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ListUsersCommand";
    import { ListWorkflowsCommandInput, ListWorkflowsCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/ListWorkflowsCommand";
    import { SendWorkflowStepStateCommandInput, SendWorkflowStepStateCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/SendWorkflowStepStateCommand";
    import { StartServerCommandInput, StartServerCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/StartServerCommand";
    import { StopServerCommandInput, StopServerCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/StopServerCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/TagResourceCommand";
    import { TestIdentityProviderCommandInput, TestIdentityProviderCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/TestIdentityProviderCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/UntagResourceCommand";
    import { UpdateAccessCommandInput, UpdateAccessCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/UpdateAccessCommand";
    import { UpdateServerCommandInput, UpdateServerCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/UpdateServerCommand";
    import { UpdateUserCommandInput, UpdateUserCommandOutput } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/commands/UpdateUserCommand";
    export type ServiceInputTypes = CreateAccessCommandInput | CreateServerCommandInput | CreateUserCommandInput | CreateWorkflowCommandInput | DeleteAccessCommandInput | DeleteServerCommandInput | DeleteSshPublicKeyCommandInput | DeleteUserCommandInput | DeleteWorkflowCommandInput | DescribeAccessCommandInput | DescribeExecutionCommandInput | DescribeSecurityPolicyCommandInput | DescribeServerCommandInput | DescribeUserCommandInput | DescribeWorkflowCommandInput | ImportSshPublicKeyCommandInput | ListAccessesCommandInput | ListExecutionsCommandInput | ListSecurityPoliciesCommandInput | ListServersCommandInput | ListTagsForResourceCommandInput | ListUsersCommandInput | ListWorkflowsCommandInput | SendWorkflowStepStateCommandInput | StartServerCommandInput | StopServerCommandInput | TagResourceCommandInput | TestIdentityProviderCommandInput | UntagResourceCommandInput | UpdateAccessCommandInput | UpdateServerCommandInput | UpdateUserCommandInput;
    export type ServiceOutputTypes = CreateAccessCommandOutput | CreateServerCommandOutput | CreateUserCommandOutput | CreateWorkflowCommandOutput | DeleteAccessCommandOutput | DeleteServerCommandOutput | DeleteSshPublicKeyCommandOutput | DeleteUserCommandOutput | DeleteWorkflowCommandOutput | DescribeAccessCommandOutput | DescribeExecutionCommandOutput | DescribeSecurityPolicyCommandOutput | DescribeServerCommandOutput | DescribeUserCommandOutput | DescribeWorkflowCommandOutput | ImportSshPublicKeyCommandOutput | ListAccessesCommandOutput | ListExecutionsCommandOutput | ListSecurityPoliciesCommandOutput | ListServersCommandOutput | ListTagsForResourceCommandOutput | ListUsersCommandOutput | ListWorkflowsCommandOutput | SendWorkflowStepStateCommandOutput | StartServerCommandOutput | StopServerCommandOutput | TagResourceCommandOutput | TestIdentityProviderCommandOutput | UntagResourceCommandOutput | UpdateAccessCommandOutput | UpdateServerCommandOutput | UpdateUserCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type TransferClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of TransferClient class constructor that set the region, credentials and other options.
        */
    export interface TransferClientConfig extends TransferClientConfigType {
    }
    type TransferClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of TransferClient class. This is resolved and normalized from the {@link TransferClientConfig | constructor configuration interface}.
        */
    export interface TransferClientResolvedConfig extends TransferClientResolvedConfigType {
    }
    /**
        * <p>Amazon Web Services Transfer Family is a fully managed service that enables the transfer of files over the
        *       File Transfer Protocol (FTP), File Transfer Protocol over SSL (FTPS), or Secure Shell (SSH)
        *       File Transfer Protocol (SFTP) directly into and out of Amazon Simple Storage Service (Amazon
        *       S3). Amazon Web Services helps you seamlessly migrate your file transfer workflows to Amazon Web Services Transfer Family by
        *       integrating with existing authentication systems, and providing DNS routing with Amazon Route
        *       53 so nothing changes for your customers and partners, or their applications. With your data
        *       in Amazon S3, you can use it with Amazon Web Services services for processing, analytics, machine learning,
        *       and archiving. Getting started with Amazon Web Services Transfer Family is easy since there is no
        *       infrastructure to buy and set up.</p>
        */
    export class TransferClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, TransferClientResolvedConfig> {
            /**
                * The resolved configuration of TransferClient class. This is resolved and normalized from the {@link TransferClientConfig | constructor configuration interface}.
                */
            readonly config: TransferClientResolvedConfig;
            constructor(configuration: TransferClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { TransferServiceException as __BaseException } from "@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/TransferServiceException";
    /**
        * <p>You do not have sufficient access to perform this action.</p>
        */
    export class AccessDeniedException extends __BaseException {
            readonly name: "AccessDeniedException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AccessDeniedException, __BaseException>);
    }
    /**
        * <p>This exception is thrown when the <code>UpdateServer</code> is called for a file transfer
        *       protocol-enabled server that has VPC as the endpoint type and the server's
        *         <code>VpcEndpointID</code> is not in the available state.</p>
        */
    export class ConflictException extends __BaseException {
            readonly name: "ConflictException";
            readonly $fault: "client";
            Message: string | undefined;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ConflictException, __BaseException>);
    }
    /**
        * <p>Reserved for future use.</p>
        *          <p>
        *
        *     </p>
        */
    export interface EfsFileLocation {
            /**
                * <p>The ID of the file system, assigned by Amazon EFS.</p>
                */
            FileSystemId?: string;
            /**
                * <p>The pathname for the folder being used by a workflow.</p>
                */
            Path?: string;
    }
    export namespace EfsFileLocation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EfsFileLocation) => any;
    }
    /**
        * <p>Specifies the customer input S3 file location. If it is used inside <code>copyStepDetails.DestinationFileLocation</code>, it should be the S3 copy destination.</p>
        *          <p>
        *       You need to provide the bucket and key.
        *       The key can represent either a path or a file.
        *       This is determined by whether or not you end the key value with the forward slash (/) character.
        *       If the final character is "/", then your file is copied to the folder, and its name does not change.
        *       If, rather, the final character is alphanumeric, your uploaded file is renamed to the path value. In this case, if a file with that name already exists, it is overwritten.
        *     </p>
        *          <p>For example, if your path is <code>shared-files/bob/</code>, your uploaded files are copied to the <code>shared-files/bob/</code>, folder.
        *       If your path is <code>shared-files/today</code>, each uploaded file is copied to the <code>shared-files</code> folder and named <code>today</code>:
        *       each upload overwrites the previous version of the <i>bob</i> file.</p>
        */
    export interface S3InputFileLocation {
            /**
                * <p>Specifies the S3 bucket for the customer input file.</p>
                */
            Bucket?: string;
            /**
                * <p>The name assigned to the file when it was created in S3. You use the object key to retrieve the object.</p>
                */
            Key?: string;
    }
    export namespace S3InputFileLocation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: S3InputFileLocation) => any;
    }
    /**
        * <p>Specifies the location for the file being copied. Only applicable for the Copy type of workflow steps.</p>
        */
    export interface InputFileLocation {
            /**
                * <p>Specifies the details for the S3 file being copied.</p>
                */
            S3FileLocation?: S3InputFileLocation;
            /**
                * <p>Reserved for future use.</p>
                */
            EfsFileLocation?: EfsFileLocation;
    }
    export namespace InputFileLocation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InputFileLocation) => any;
    }
    export enum OverwriteExisting {
            FALSE = "FALSE",
            TRUE = "TRUE"
    }
    /**
        * <p>Each step type has its own <code>StepDetails</code> structure.</p>
        */
    export interface CopyStepDetails {
            /**
                * <p>The name of the step, used as an identifier.</p>
                */
            Name?: string;
            /**
                * <p>Specifies the location for the file being copied. Only applicable for Copy type workflow
                *       steps. Use <code>${Transfer:username}</code> in this field to parametrize the destination
                *       prefix by username.</p>
                */
            DestinationFileLocation?: InputFileLocation;
            /**
                * <p>A flag that indicates whether or not to overwrite an existing file of the same name.
                *       The default is <code>FALSE</code>.</p>
                */
            OverwriteExisting?: OverwriteExisting | string;
            /**
                * <p>Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file
                *     for the workflow.</p>
                *          <ul>
                *             <li>
                *                <p>Enter <code>${previous.file}</code> to use the previous file as the input.
                *           In this case, this workflow step uses the output file from the previous workflow step as input.
                *           This is the default value.</p>
                *             </li>
                *             <li>
                *                <p>Enter <code>${original.file}</code> to use the originally-uploaded file location as input for this step.</p>
                *             </li>
                *          </ul>
                */
            SourceFileLocation?: string;
    }
    export namespace CopyStepDetails {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CopyStepDetails) => any;
    }
    /**
        * <p>Represents an object that contains entries and targets for
        *         <code>HomeDirectoryMappings</code>.</p>
        *          <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p>
        *          <p>
        *             <code>[ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
        *          </p>
        */
    export interface HomeDirectoryMapEntry {
            /**
                * <p>Represents an entry for <code>HomeDirectoryMappings</code>.</p>
                */
            Entry: string | undefined;
            /**
                * <p>Represents the map target that is used in a <code>HomeDirectorymapEntry</code>.</p>
                */
            Target: string | undefined;
    }
    export namespace HomeDirectoryMapEntry {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: HomeDirectoryMapEntry) => any;
    }
    export enum HomeDirectoryType {
            LOGICAL = "LOGICAL",
            PATH = "PATH"
    }
    /**
        * <p>The full POSIX identity, including user ID (<code>Uid</code>), group ID
        *       (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
        *       your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
        *       files and directories in your file system determine the level of access your users get when
        *       transferring files into and out of your Amazon EFS file systems.</p>
        */
    export interface PosixProfile {
            /**
                * <p>The POSIX user ID used for all EFS operations by this user.</p>
                */
            Uid: number | undefined;
            /**
                * <p>The POSIX group ID used for all EFS operations by this user.</p>
                */
            Gid: number | undefined;
            /**
                * <p>The secondary POSIX group IDs used for all EFS operations by this user.</p>
                */
            SecondaryGids?: number[];
    }
    export namespace PosixProfile {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PosixProfile) => any;
    }
    export interface CreateAccessRequest {
            /**
                * <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
                *          <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
                */
            HomeDirectory?: string;
            /**
                * <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
                *     If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
                *     If you set it <code>LOGICAL</code>, you need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
                *     S3 or EFS paths visible to your users.</p>
                */
            HomeDirectoryType?: HomeDirectoryType | string;
            /**
                * <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
                *       be visible to your user and how you want to make them visible. You must specify the
                *         <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
                *       is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
                *       only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity
                *       and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
                *       can only be set when <code>HomeDirectoryType</code> is set to
                *       <i>LOGICAL</i>.</p>
                *          <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
                *          <p>
                *             <code>[ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ]</code>
                *          </p>
                *          <p>In most cases, you can use this value instead of the session policy to lock down your
                *       user to the designated home directory ("<code>chroot</code>"). To do this, you can set
                *         <code>Entry</code> to <code>/</code> and set <code>Target</code> to the
                *         <code>HomeDirectory</code> parameter value.</p>
                *          <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p>
                *          <p>
                *             <code>[ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
                *          </p>
                */
            HomeDirectoryMappings?: HomeDirectoryMapEntry[];
            /**
                * <p>A session policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user
                *      access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include <code>${Transfer:UserName}</code>,
                *      <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
                *
                *          <note>
                *             <p>This only applies when the domain of <code>ServerId</code> is S3. EFS does not use session policies.</p>
                *             <p>For session policies, Amazon Web Services Transfer Family stores the policy as a JSON blob, instead
                *         of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass
                *         it in the <code>Policy</code> argument.</p>
                *             <p>For an example of a session policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/session-policy.html">Example
                *           session policy</a>.</p>
                *             <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>Amazon Web Services Security Token Service API
                *           Reference</i>.</p>
                *          </note>
                */
            Policy?: string;
            /**
                * <p>The full POSIX identity, including user ID (<code>Uid</code>), group ID
                *       (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
                *       your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
                *       files and directories in your file system determine the level of access your users get when
                *       transferring files into and out of your Amazon EFS file systems.</p>
                */
            PosixProfile?: PosixProfile;
            /**
                * <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
                *       file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
                *       files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
                *       server to access your resources when servicing your users' transfer requests.</p>
                */
            Role: string | undefined;
            /**
                * <p>A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.</p>
                */
            ServerId: string | undefined;
            /**
                * <p>A unique identifier that is required to identify specific groups within your directory.
                *     The users of the group that you associate have access to your Amazon S3 or Amazon EFS
                *     resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name,
                *     you can view the SID values by running the following command using Windows PowerShell.</p>
                *
                *          <p>
                *             <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamAccountName,ObjectSid</code>
                *          </p>
                *
                *          <p>In that command, replace <i>YourGroupName</i> with the name of your Active Directory group.</p>
                *
                *          <p>The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces.
                *     You can also include underscores or any of the following characters: =,.@:/-</p>
                */
            ExternalId: string | undefined;
    }
    export namespace CreateAccessRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateAccessRequest) => any;
    }
    export interface CreateAccessResponse {
            /**
                * <p>The ID of the server that the user is attached to.</p>
                */
            ServerId: string | undefined;
            /**
                * <p>The external ID of the group whose users have access to your Amazon S3 or Amazon EFS
                *       resources over the enabled protocols using Amazon Web Services Transfer Family.</p>
                */
            ExternalId: string | undefined;
    }
    export namespace CreateAccessResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateAccessResponse) => any;
    }
    /**
        * <p>This exception is thrown when an error occurs in the Amazon Web ServicesTransfer Family service.</p>
        */
    export class InternalServiceError extends __BaseException {
            readonly name: "InternalServiceError";
            readonly $fault: "server";
            Message: string | undefined;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InternalServiceError, __BaseException>);
    }
    /**
        * <p>This exception is thrown when the client submits a malformed request.</p>
        */
    export class InvalidRequestException extends __BaseException {
            readonly name: "InvalidRequestException";
            readonly $fault: "client";
            Message: string | undefined;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidRequestException, __BaseException>);
    }
    /**
        * <p>The requested resource does not exist.</p>
        */
    export class ResourceExistsException extends __BaseException {
            readonly name: "ResourceExistsException";
            readonly $fault: "client";
            Message: string | undefined;
            Resource: string | undefined;
            ResourceType: string | undefined;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceExistsException, __BaseException>);
    }
    /**
        * <p>This exception is thrown when a resource is not found by the Amazon Web ServicesTransfer Family
        *       service.</p>
        */
    export class ResourceNotFoundException extends __BaseException {
            readonly name: "ResourceNotFoundException";
            readonly $fault: "client";
            Message: string | undefined;
            Resource: string | undefined;
            ResourceType: string | undefined;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>);
    }
    /**
        * <p>The request has failed because the Amazon Web ServicesTransfer Family service is not available.</p>
        */
    export class ServiceUnavailableException extends __BaseException {
            readonly name: "ServiceUnavailableException";
            readonly $fault: "server";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ServiceUnavailableException, __BaseException>);
    }
    export enum Domain {
            EFS = "EFS",
            S3 = "S3"
    }
    /**
        * <p>The virtual private cloud (VPC) endpoint settings that are configured for your file
        *       transfer protocol-enabled server. With a VPC endpoint, you can restrict access to your server
        *       and resources only within your VPC. To control incoming internet traffic, invoke the
        *         <code>UpdateServer</code> API and attach an Elastic IP address to your server's
        *       endpoint.</p>
        *          <note>
        *             <p> After May 19, 2021, you won't be able to create a server using
        *           <code>EndpointType=VPC_ENDPOINT</code> in your Amazon Web Servicesaccount if your account hasn't already
        *       done so before May 19, 2021. If you have already created servers with
        *       <code>EndpointType=VPC_ENDPOINT</code> in your Amazon Web Servicesaccount on or before May 19, 2021,
        *         you will not be affected. After this date, use
        *         <code>EndpointType</code>=<code>VPC</code>.</p>
        *
        *             <p>For more information, see
        *         https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.</p>
        *          </note>
        */
    export interface EndpointDetails {
            /**
                * <p>A list of address allocation IDs that are required to attach an Elastic IP address to your
                *       server's endpoint.</p>
                *
                *          <note>
                *
                *             <p>This property can only be set when <code>EndpointType</code> is set to <code>VPC</code>
                *         and it is only valid in the <code>UpdateServer</code> API.</p>
                *          </note>
                */
            AddressAllocationIds?: string[];
            /**
                * <p>A list of subnet IDs that are required to host your server endpoint in your VPC.</p>
                *
                *          <note>
                *             <p>This property can only be set when <code>EndpointType</code> is set to
                *         <code>VPC</code>.</p>
                *          </note>
                */
            SubnetIds?: string[];
            /**
                * <p>The ID of the VPC endpoint.</p>
                *
                *          <note>
                *             <p>This property can only be set when <code>EndpointType</code> is set to
                *           <code>VPC_ENDPOINT</code>.</p>
                *
                *             <p>For more information, see
                *         https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.</p>
                *          </note>
                */
            VpcEndpointId?: string;
            /**
                * <p>The VPC ID of the VPC in which a server's endpoint will be hosted.</p>
                *
                *          <note>
                *             <p>This property can only be set when <code>EndpointType</code> is set to
                *         <code>VPC</code>.</p>
                *          </note>
                */
            VpcId?: string;
            /**
                * <p>A list of security groups IDs that are available to attach to your server's
                *       endpoint.</p>
                *
                *          <note>
                *             <p>This property can only be set when <code>EndpointType</code> is set to
                *         <code>VPC</code>.</p>
                *
                *             <p>You can edit the <code>SecurityGroupIds</code> property in the <a href="https://docs.aws.amazon.com/transfer/latest/userguide/API_UpdateServer.html">UpdateServer</a> API only if you are changing the <code>EndpointType</code> from
                *           <code>PUBLIC</code> or <code>VPC_ENDPOINT</code> to <code>VPC</code>. To change security
                *         groups associated with your server's VPC endpoint after creation, use the Amazon EC2
                *           <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyVpcEndpoint.html">ModifyVpcEndpoint</a> API.</p>
                *          </note>
                */
            SecurityGroupIds?: string[];
    }
    export namespace EndpointDetails {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EndpointDetails) => any;
    }
    export enum EndpointType {
            PUBLIC = "PUBLIC",
            VPC = "VPC",
            VPC_ENDPOINT = "VPC_ENDPOINT"
    }
    /**
        * <p>Returns information related to the type of user authentication that is in use for a file
        *       transfer protocol-enabled server's users. A server can have only one method of
        *       authentication.</p>
        */
    export interface IdentityProviderDetails {
            /**
                * <p>Provides the location of the service endpoint used to authenticate users.</p>
                */
            Url?: string;
            /**
                * <p>Provides the type of <code>InvocationRole</code> used to authenticate the user
                *       account.</p>
                */
            InvocationRole?: string;
            /**
                * <p>The identifier of the Amazon Web Services Directory Service directory that you want to stop sharing.</p>
                */
            DirectoryId?: string;
            /**
                * <p>The ARN for a lambda function to use for the Identity provider.</p>
                */
            Function?: string;
    }
    export namespace IdentityProviderDetails {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: IdentityProviderDetails) => any;
    }
    export enum IdentityProviderType {
            API_GATEWAY = "API_GATEWAY",
            AWS_DIRECTORY_SERVICE = "AWS_DIRECTORY_SERVICE",
            AWS_LAMBDA = "AWS_LAMBDA",
            SERVICE_MANAGED = "SERVICE_MANAGED"
    }
    export enum SetStatOption {
            DEFAULT = "DEFAULT",
            ENABLE_NO_OP = "ENABLE_NO_OP"
    }
    export enum TlsSessionResumptionMode {
            DISABLED = "DISABLED",
            ENABLED = "ENABLED",
            ENFORCED = "ENFORCED"
    }
    /**
        * <p>
        *       The protocol settings that are configured for your server.
        *     </p>
        */
    export interface ProtocolDetails {
            /**
                * <p>
                *       Indicates passive mode, for FTP and FTPS protocols.
                *       Enter a single IPv4 address, such as the public IP address of a firewall, router, or load balancer.
                *       For example:
                *     </p>
                *          <p>
                *             <code>
                *         aws transfer update-server --protocol-details PassiveIp=<i>0.0.0.0</i>
                *             </code>
                *          </p>
                *          <p>Replace <code>
                *                <i>0.0.0.0</i>
                *             </code> in the example above with the actual IP address you want to use.</p>
                *          <note>
                *             <p>
                *         If you change the <code>PassiveIp</code> value, you must stop and then restart your Transfer Family server for the change to take effect. For details on using passive mode (PASV) in a NAT environment, see <a href="http://aws.amazon.com/blogs/storage/configuring-your-ftps-server-behind-a-firewall-or-nat-with-aws-transfer-family/">Configuring your FTPS server behind a firewall or NAT with Transfer Family</a>.
                *       </p>
                *          </note>
                */
            PassiveIp?: string;
            /**
                * <p>A property used with Transfer Family servers that use the FTPS protocol. TLS Session Resumption provides a mechanism to resume or share a negotiated secret
                *       key between the control and data connection for an FTPS session. <code>TlsSessionResumptionMode</code> determines whether or not the server resumes recent,
                *       negotiated sessions through a unique session ID. This property is available during <code>CreateServer</code> and <code>UpdateServer</code> calls.
                *       If a <code>TlsSessionResumptionMode</code> value is not specified during <code>CreateServer</code>, it is set to <code>ENFORCED</code> by default.</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>DISABLED</code>: the server does not process TLS session resumption client requests and creates a new TLS session for each request. </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ENABLED</code>: the server processes and accepts clients that are performing TLS session resumption.
                *             The server doesn't reject client data connections that do not perform the TLS session resumption client processing.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ENFORCED</code>: the server processes and accepts clients that are performing TLS session resumption.
                *             The server rejects client data connections that do not perform the TLS session resumption client processing.
                *             Before you set the value to <code>ENFORCED</code>, test your clients.</p>
                *                <note>
                *                   <p>Not all FTPS clients perform TLS session resumption. So, if you choose to enforce
                *               TLS session resumption, you prevent any connections from FTPS clients that don't perform
                *               the protocol negotiation. To determine whether or not you can use the
                *               <code>ENFORCED</code> value, you need to test your clients.</p>
                *                </note>
                *             </li>
                *          </ul>
                */
            TlsSessionResumptionMode?: TlsSessionResumptionMode | string;
            /**
                * <p>Use the <code>SetStatOption</code> to ignore the error that is generated when the client attempts to use <code>SETSTAT</code> on a file you are uploading to an S3 bucket.</p>
                *          <p>Some SFTP file transfer clients can attempt to change the attributes of remote files, including timestamp and permissions, using commands, such as <code>SETSTAT</code> when uploading the file.
                *         However, these commands are not compatible with object storage systems, such as Amazon S3. Due to this incompatibility, file uploads from these clients can result in errors even when
                *         the file is otherwise successfully uploaded.</p>
                *          <p>Set the value to <code>ENABLE_NO_OP</code> to have the Transfer Family server ignore the <code>SETSTAT</code> command, and upload files without needing to make any changes to your SFTP client.
                *         While the <code>SetStatOption</code>
                *             <code>ENABLE_NO_OP</code> setting ignores the error, it does generate a log entry in Amazon CloudWatch Logs, so you can determine when the client is making a <code>SETSTAT</code> call.</p>
                *          <note>
                *             <p>If you want to preserve the original timestamp for your file, and modify other file attributes using <code>SETSTAT</code>, you can use Amazon EFS as backend storage with Transfer Family.</p>
                *          </note>
                */
            SetStatOption?: SetStatOption | string;
    }
    export namespace ProtocolDetails {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ProtocolDetails) => any;
    }
    export enum Protocol {
            FTP = "FTP",
            FTPS = "FTPS",
            SFTP = "SFTP"
    }
    /**
        * <p>Creates a key-value pair for a specific resource. Tags are metadata that you can use to
        *       search for and group a resource for various purposes. You can apply tags to servers, users,
        *       and roles. A tag key can take more than one value. For example, to group servers for
        *       accounting purposes, you might create a tag called <code>Group</code> and assign the values
        *         <code>Research</code> and <code>Accounting</code> to that group.</p>
        */
    export interface Tag {
            /**
                * <p>The name assigned to the tag that you create.</p>
                */
            Key: string | undefined;
            /**
                * <p>Contains one or more values that you assigned to the key name you create.</p>
                */
            Value: string | undefined;
    }
    export namespace Tag {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Tag) => any;
    }
    /**
        * <p>Specifies the workflow ID for the workflow to assign and the execution role used for executing the workflow.</p>
        */
    export interface WorkflowDetail {
            /**
                * <p>A unique identifier for the workflow.</p>
                */
            WorkflowId: string | undefined;
            /**
                * <p>Includes the necessary permissions for S3, EFS, and Lambda operations that Transfer can
                *       assume, so that all workflow steps can operate on the required resources</p>
                */
            ExecutionRole: string | undefined;
    }
    export namespace WorkflowDetail {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: WorkflowDetail) => any;
    }
    /**
        * <p>Container for the <code>WorkflowDetail</code> data type.
        *       It is used by actions that trigger a workflow to begin execution.</p>
        */
    export interface WorkflowDetails {
            /**
                * <p>A trigger that starts a workflow: the workflow begins to execute after a file is uploaded.</p>
                *          <p>To remove an associated workflow from a server, you can provide an empty <code>OnUpload</code> object, as in the following example.</p>
                *          <p>
                *             <code>aws transfer update-server --server-id s-01234567890abcdef --workflow-details '{"OnUpload":[]}'</code>
                *          </p>
                */
            OnUpload: WorkflowDetail[] | undefined;
    }
    export namespace WorkflowDetails {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: WorkflowDetails) => any;
    }
    export interface CreateServerRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the Amazon Web Services Certificate Manager (ACM) certificate. Required
                *       when <code>Protocols</code> is set to <code>FTPS</code>.</p>
                *
                *          <p>To request a new public certificate, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html">Request a public certificate</a>
                *       in the <i> Amazon Web Services Certificate Manager User Guide</i>.</p>
                *
                *          <p>To import an existing certificate into ACM, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html">Importing certificates into ACM</a>
                *       in the <i> Amazon Web Services Certificate Manager User Guide</i>.</p>
                *
                *          <p>To request a private certificate to use FTPS through private IP addresses, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html">Request a
                *         private certificate</a> in the <i> Amazon Web Services Certificate Manager User
                *       Guide</i>.</p>
                *
                *          <p>Certificates with the following cryptographic algorithms and key sizes are
                *       supported:</p>
                *
                *          <ul>
                *             <li>
                *                <p>2048-bit RSA (RSA_2048)</p>
                *             </li>
                *             <li>
                *                <p>4096-bit RSA (RSA_4096)</p>
                *             </li>
                *             <li>
                *                <p>Elliptic Prime Curve 256 bit (EC_prime256v1)</p>
                *             </li>
                *             <li>
                *                <p>Elliptic Prime Curve 384 bit (EC_secp384r1)</p>
                *             </li>
                *             <li>
                *                <p>Elliptic Prime Curve 521 bit (EC_secp521r1)</p>
                *             </li>
                *          </ul>
                *
                *          <note>
                *             <p>The certificate must be a valid SSL/TLS X.509 version 3 certificate with FQDN or IP
                *         address specified and information about the issuer.</p>
                *          </note>
                */
            Certificate?: string;
            /**
                * <p>The domain of the storage system that is used for file transfers. There are two domains
                *       available: Amazon Simple Storage Service (Amazon S3) and Amazon Elastic File System (Amazon EFS). The
                *       default value is S3.</p>
                *
                *          <note>
                *             <p>After the server is created, the domain cannot be changed.</p>
                *          </note>
                */
            Domain?: Domain | string;
            /**
                * <p>The virtual private cloud (VPC) endpoint settings that are configured for your server.
                *       When you host your endpoint within your VPC, you can make it accessible only to resources
                *       within your VPC, or you can attach Elastic IP addresses and make it accessible to clients over
                *       the internet. Your VPC's default security groups are automatically assigned to your
                *       endpoint.</p>
                */
            EndpointDetails?: EndpointDetails;
            /**
                * <p>The type of endpoint that you want your server to use. You can choose to make your server's endpoint publicly accessible (PUBLIC)
                *       or host it inside your VPC. With an endpoint that is hosted in a VPC, you can restrict access to your server and
                *       resources only within your VPC or choose to make it internet facing by attaching Elastic IP addresses directly to it.</p>
                *          <note>
                *             <p> After May 19, 2021, you won't be able to create a server using
                *           <code>EndpointType=VPC_ENDPOINT</code> in your Amazon Web Services account if your account hasn't already
                *       done so before May 19, 2021. If you have already created servers with
                *       <code>EndpointType=VPC_ENDPOINT</code> in your Amazon Web Services account on or before May 19, 2021,
                *         you will not be affected. After this date, use
                *         <code>EndpointType</code>=<code>VPC</code>.</p>
                *
                *             <p>For more information, see
                *         https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.</p>
                *             <p>It is recommended that you use <code>VPC</code> as the <code>EndpointType</code>. With
                *         this endpoint type, you have the option to directly associate up to three Elastic IPv4
                *         addresses (BYO IP included) with your server's endpoint and use VPC security groups to
                *         restrict traffic by the client's public IP address. This is not possible with
                *           <code>EndpointType</code> set to <code>VPC_ENDPOINT</code>.</p>
                *          </note>
                */
            EndpointType?: EndpointType | string;
            /**
                * <p>The RSA, ECDSA, or ED25519 private key to use for your server.</p>
                *
                *          <p>Use the following command to generate an RSA 2048 bit key with no passphrase:</p>
                *          <p>
                *             <code>ssh-keygen -t rsa -b 2048 -N "" -m PEM -f my-new-server-key</code>.</p>
                *          <p>Use a minimum value of 2048 for the <code>-b</code> option: you can create a stronger key using 3072 or 4096.</p>
                *
                *          <p>Use the following command to generate an ECDSA 256 bit key with no passphrase:</p>
                *          <p>
                *             <code>ssh-keygen -t ecdsa -b 256 -N "" -m PEM -f my-new-server-key</code>.</p>
                *          <p>Valid values for the <code>-b</code> option for ECDSA are 256, 384, and 521.</p>
                *
                *          <p>Use the following command to generate an ED25519 key with no passphrase:</p>
                *          <p>
                *             <code>ssh-keygen -t ed25519 -N "" -f my-new-server-key</code>.</p>
                *
                *          <p>For all of these commands, you can replace <i>my-new-server-key</i> with a string of your choice.</p>
                *
                *          <important>
                *             <p>If you aren't planning to migrate existing users from an existing SFTP-enabled
                *         server to a new server, don't update the host key. Accidentally changing a
                *         server's host key can be disruptive.</p>
                *          </important>
                *
                *
                *
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key">Change the host key for your SFTP-enabled server</a> in the <i>Amazon Web Services Transfer
                *         Family User Guide</i>.</p>
                */
            HostKey?: string;
            /**
                * <p>Required when <code>IdentityProviderType</code> is set to
                *         <code>AWS_DIRECTORY_SERVICE</code> or <code>API_GATEWAY</code>. Accepts an array containing
                *       all of the information required to use a directory in <code>AWS_DIRECTORY_SERVICE</code> or
                *       invoke a customer-supplied authentication API, including the API Gateway URL. Not required
                *       when <code>IdentityProviderType</code> is set to <code>SERVICE_MANAGED</code>.</p>
                */
            IdentityProviderDetails?: IdentityProviderDetails;
            /**
                * <p>Specifies the mode of authentication for a server. The default value is
                *         <code>SERVICE_MANAGED</code>, which allows you to store and access user credentials within
                *       the Amazon Web Services Transfer Family service.</p>
                *          <p>Use <code>AWS_DIRECTORY_SERVICE</code> to provide access to
                *       Active Directory groups in Amazon Web Services Managed Active Directory or Microsoft Active Directory in your
                *       on-premises environment or in Amazon Web Services using AD Connectors. This option also requires you to
                *       provide a Directory ID using the <code>IdentityProviderDetails</code> parameter.</p>
                *          <p>Use the <code>API_GATEWAY</code> value to integrate with an identity provider of your choosing. The
                *       <code>API_GATEWAY</code> setting requires you to provide an API Gateway endpoint URL to call
                *       for authentication using the <code>IdentityProviderDetails</code> parameter.</p>
                *          <p>Use the <code>AWS_LAMBDA</code> value to directly use a Lambda function as your identity provider. If you choose this value,
                *       you must specify the ARN for the lambda function in the <code>Function</code> parameter for the <code>IdentityProviderDetails</code> data type.</p>
                */
            IdentityProviderType?: IdentityProviderType | string;
            /**
                * <p>Specifies the Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that allows a server to turn
                *       on Amazon CloudWatch logging for Amazon S3 or Amazon EFS events. When set, user activity can be viewed in
                *       your CloudWatch logs.</p>
                */
            LoggingRole?: string;
            /**
                * <p>Specify a string to display when users connect to a server. This string is displayed after the user authenticates.</p>
                *          <note>
                *             <p>The SFTP protocol does not support post-authentication display banners.</p>
                *          </note>
                */
            PostAuthenticationLoginBanner?: string;
            /**
                * <p>Specify a string to display when users connect to a server. This string is displayed before the user authenticates.
                *     For example, the following banner displays details about using the system.</p>
                *          <p>
                *             <code>This system is for the use of authorized users only. Individuals using this computer system without authority,
                *     or in excess of their authority, are subject to having all of their activities on this system monitored and recorded by
                *     system personnel.</code>
                *          </p>
                */
            PreAuthenticationLoginBanner?: string;
            /**
                * <p>Specifies the file transfer protocol or protocols over which your file transfer protocol
                *       client can connect to your server's endpoint. The available protocols are:</p>
                *
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>SFTP</code> (Secure Shell (SSH) File Transfer Protocol): File transfer over
                *           SSH</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>FTPS</code> (File Transfer Protocol Secure): File transfer with TLS
                *           encryption</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>FTP</code> (File Transfer Protocol): Unencrypted file transfer</p>
                *             </li>
                *          </ul>
                *
                *          <note>
                *             <p>If you select <code>FTPS</code>, you must choose a certificate stored in Amazon Web Services Certificate
                *         Manager (ACM) which is used to identify your server when clients connect to it over
                *         FTPS.</p>
                *
                *             <p>If <code>Protocol</code> includes either <code>FTP</code> or <code>FTPS</code>, then the
                *           <code>EndpointType</code> must be <code>VPC</code> and the
                *           <code>IdentityProviderType</code> must be <code>AWS_DIRECTORY_SERVICE</code> or <code>API_GATEWAY</code>.</p>
                *
                *             <p>If <code>Protocol</code> includes <code>FTP</code>, then
                *           <code>AddressAllocationIds</code> cannot be associated.</p>
                *
                *             <p>If <code>Protocol</code> is set only to <code>SFTP</code>, the <code>EndpointType</code>
                *         can be set to <code>PUBLIC</code> and the <code>IdentityProviderType</code> can be set to
                *           <code>SERVICE_MANAGED</code>.</p>
                *          </note>
                */
            Protocols?: (Protocol | string)[];
            /**
                * <p>The protocol settings that are configured for your server.</p>
                *          <ul>
                *             <li>
                *                <p>
                *           Use the <code>PassiveIp</code> parameter to indicate passive mode (for FTP and FTPS protocols).
                *           Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer.
                *         </p>
                *             </li>
                *             <li>
                *                <p>Use the <code>SetStatOption</code> to ignore the error that is generated when the client attempts to use SETSTAT on a file you are uploading to an S3 bucket.
                *         Set the value to <code>ENABLE_NO_OP</code> to have the Transfer Family server ignore the SETSTAT command, and upload files without needing to make any changes to your SFTP client.
                *         Note that with <code>SetStatOption</code> set to <code>ENABLE_NO_OP</code>, Transfer generates a log entry to CloudWatch Logs, so you can determine when the client
                *         is making a SETSTAT call.</p>
                *             </li>
                *             <li>
                *                <p>Use the <code>TlsSessionResumptionMode</code> parameter to determine whether or not your Transfer server
                *           resumes recent, negotiated sessions through a unique session ID.</p>
                *             </li>
                *          </ul>
                */
            ProtocolDetails?: ProtocolDetails;
            /**
                * <p>Specifies the name of the security policy that is attached to the server.</p>
                */
            SecurityPolicyName?: string;
            /**
                * <p>Key-value pairs that can be used to group and search for servers.</p>
                */
            Tags?: Tag[];
            /**
                * <p>Specifies the workflow ID for the workflow to assign and the execution role used for executing the workflow.</p>
                */
            WorkflowDetails?: WorkflowDetails;
    }
    export namespace CreateServerRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateServerRequest) => any;
    }
    export interface CreateServerResponse {
            /**
                * <p>The service-assigned ID of the server that is created.</p>
                */
            ServerId: string | undefined;
    }
    export namespace CreateServerResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateServerResponse) => any;
    }
    /**
        * <p>The request was denied due to request throttling.</p>
        */
    export class ThrottlingException extends __BaseException {
            readonly name: "ThrottlingException";
            readonly $fault: "client";
            RetryAfterSeconds?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ThrottlingException, __BaseException>);
    }
    export interface CreateUserRequest {
            /**
                * <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
                *          <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
                */
            HomeDirectory?: string;
            /**
                * <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
                *     If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
                *     If you set it <code>LOGICAL</code>, you need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
                *     S3 or EFS paths visible to your users.</p>
                */
            HomeDirectoryType?: HomeDirectoryType | string;
            /**
                * <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
                *       be visible to your user and how you want to make them visible. You must specify the
                *         <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
                *       is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
                *       only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity
                *       and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
                *       can only be set when <code>HomeDirectoryType</code> is set to
                *       <i>LOGICAL</i>.</p>
                *
                *          <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
                *
                *          <p>
                *             <code>[ { "Entry": "/directory1", "Target":
                *         "/bucket_name/home/mydirectory" } ]</code>
                *          </p>
                *
                *          <p>In most cases, you can use this value instead of the session policy to lock your user
                *       down to the designated home directory ("<code>chroot</code>"). To do this, you can set
                *         <code>Entry</code> to <code>/</code> and set <code>Target</code> to the HomeDirectory
                *       parameter value.</p>
                *          <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p>
                *          <p>
                *             <code>[ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
                *          </p>
                */
            HomeDirectoryMappings?: HomeDirectoryMapEntry[];
            /**
                * <p>A session policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user
                *      access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include <code>${Transfer:UserName}</code>,
                *      <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
                *
                *          <note>
                *             <p>This only applies when the domain of <code>ServerId</code> is S3. EFS does not use session policies.</p>
                *             <p>For session policies, Amazon Web Services Transfer Family stores the policy as a JSON blob, instead
                *         of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass
                *         it in the <code>Policy</code> argument.</p>
                *
                *
                *
                *             <p>For an example of a session policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/session-policy.html">Example session
                *         policy</a>.</p>
                *
                *
                *
                *             <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>Amazon Web Services
                *           Security Token Service API Reference</i>.</p>
                *          </note>
                */
            Policy?: string;
            /**
                * <p>Specifies the full POSIX identity, including user ID (<code>Uid</code>), group ID
                *         (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
                *       your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
                *       files and directories in Amazon EFS determine the level of access your users get when
                *       transferring files into and out of your Amazon EFS file systems.</p>
                */
            PosixProfile?: PosixProfile;
            /**
                * <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
                *       file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
                *       files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
                *       server to access your resources when servicing your users' transfer requests.</p>
                */
            Role: string | undefined;
            /**
                * <p>A system-assigned unique identifier for a server instance. This is the specific server
                *       that you added your user to.</p>
                */
            ServerId: string | undefined;
            /**
                * <p>The public portion of the Secure Shell (SSH) key used to authenticate the user to the
                *       server.</p>
                *          <p>Transfer Family accepts RSA, ECDSA, and ED25519 keys.</p>
                */
            SshPublicKeyBody?: string;
            /**
                * <p>Key-value pairs that can be used to group and search for users. Tags are metadata attached
                *       to users for any purpose.</p>
                */
            Tags?: Tag[];
            /**
                * <p>A unique string that identifies a user and is associated with a <code>ServerId</code>. This user name must be a minimum of 3 and a maximum of 100 characters
                *       long. The following are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen
                *       '-', period '.', and at sign '@'. The user name can't start
                *       with a hyphen, period, or at sign.</p>
                */
            UserName: string | undefined;
    }
    export namespace CreateUserRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateUserRequest) => any;
    }
    export interface CreateUserResponse {
            /**
                * <p>The ID of the server that the user is attached to.</p>
                */
            ServerId: string | undefined;
            /**
                * <p>A unique string that identifies a user account associated with a server.</p>
                */
            UserName: string | undefined;
    }
    export namespace CreateUserResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateUserResponse) => any;
    }
    /**
        * <p>Each step type has its own <code>StepDetails</code> structure.</p>
        */
    export interface CustomStepDetails {
            /**
                * <p>The name of the step, used as an identifier.</p>
                */
            Name?: string;
            /**
                * <p>The ARN for the lambda function that is being called.</p>
                */
            Target?: string;
            /**
                * <p>Timeout, in seconds, for the step.</p>
                */
            TimeoutSeconds?: number;
            /**
                * <p>Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file
                *     for the workflow.</p>
                *          <ul>
                *             <li>
                *                <p>Enter <code>${previous.file}</code> to use the previous file as the input.
                *           In this case, this workflow step uses the output file from the previous workflow step as input.
                *           This is the default value.</p>
                *             </li>
                *             <li>
                *                <p>Enter <code>${original.file}</code> to use the originally-uploaded file location as input for this step.</p>
                *             </li>
                *          </ul>
                */
            SourceFileLocation?: string;
    }
    export namespace CustomStepDetails {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CustomStepDetails) => any;
    }
    /**
        * <p>The name of the step, used to identify the delete step.</p>
        */
    export interface DeleteStepDetails {
            /**
                * <p>The name of the step, used as an identifier.</p>
                */
            Name?: string;
            /**
                * <p>Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file
                *     for the workflow.</p>
                *          <ul>
                *             <li>
                *                <p>Enter <code>${previous.file}</code> to use the previous file as the input.
                *           In this case, this workflow step uses the output file from the previous workflow step as input.
                *           This is the default value.</p>
                *             </li>
                *             <li>
                *                <p>Enter <code>${original.file}</code> to use the originally-uploaded file location as input for this step.</p>
                *             </li>
                *          </ul>
                */
            SourceFileLocation?: string;
    }
    export namespace DeleteStepDetails {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteStepDetails) => any;
    }
    /**
        * <p>Specifies the key-value pair that are assigned to a file during the execution of a Tagging step.</p>
        */
    export interface S3Tag {
            /**
                * <p>The name assigned to the tag that you create.</p>
                */
            Key: string | undefined;
            /**
                * <p>The value that corresponds to the key.</p>
                */
            Value: string | undefined;
    }
    export namespace S3Tag {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: S3Tag) => any;
    }
    /**
        * <p>Each step type has its own <code>StepDetails</code> structure.</p>
        *          <p>The key/value pairs used to tag a file during the execution of a workflow step.</p>
        */
    export interface TagStepDetails {
            /**
                * <p>The name of the step, used as an identifier.</p>
                */
            Name?: string;
            /**
                * <p>Array that contains from 1 to 10 key/value pairs.</p>
                */
            Tags?: S3Tag[];
            /**
                * <p>Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file
                *     for the workflow.</p>
                *          <ul>
                *             <li>
                *                <p>Enter <code>${previous.file}</code> to use the previous file as the input.
                *           In this case, this workflow step uses the output file from the previous workflow step as input.
                *           This is the default value.</p>
                *             </li>
                *             <li>
                *                <p>Enter <code>${original.file}</code> to use the originally-uploaded file location as input for this step.</p>
                *             </li>
                *          </ul>
                */
            SourceFileLocation?: string;
    }
    export namespace TagStepDetails {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagStepDetails) => any;
    }
    export enum WorkflowStepType {
            COPY = "COPY",
            CUSTOM = "CUSTOM",
            DELETE = "DELETE",
            TAG = "TAG"
    }
    /**
        * <p>The basic building block of a workflow.</p>
        */
    export interface WorkflowStep {
            /**
                * <p>
                *         Currently, the following step types are supported.
                *       </p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <i>COPY</i>: copy the file to another location</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <i>CUSTOM</i>: custom step with a lambda target</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <i>DELETE</i>: delete the file</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <i>TAG</i>: add a tag to the file</p>
                *             </li>
                *          </ul>
                */
            Type?: WorkflowStepType | string;
            /**
                * <p>Details for a step that performs a file copy.</p>
                *          <p>
                *         Consists of the following values:
                *       </p>
                *          <ul>
                *             <li>
                *                <p>A description</p>
                *             </li>
                *             <li>
                *                <p>An S3 location for the destination of the file copy.</p>
                *             </li>
                *             <li>
                *                <p>A flag that indicates whether or not to overwrite an existing file of the same name.
                *         The default is <code>FALSE</code>.</p>
                *             </li>
                *          </ul>
                */
            CopyStepDetails?: CopyStepDetails;
            /**
                * <p>Details for a step that invokes a lambda function.</p>
                *          <p>
                *         Consists of the lambda function name, target, and timeout (in seconds).
                *       </p>
                */
            CustomStepDetails?: CustomStepDetails;
            /**
                * <p>Details for a step that deletes the file.</p>
                */
            DeleteStepDetails?: DeleteStepDetails;
            /**
                * <p>Details for a step that creates one or more tags.</p>
                *          <p>You specify one or more tags: each tag contains a key/value pair.</p>
                */
            TagStepDetails?: TagStepDetails;
    }
    export namespace WorkflowStep {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: WorkflowStep) => any;
    }
    export interface CreateWorkflowRequest {
            /**
                * <p>A textual description for the workflow.</p>
                */
            Description?: string;
            /**
                * <p>Specifies the details for the steps that are in the specified workflow.</p>
                *          <p>
                *       The <code>TYPE</code> specifies which of the following actions is being taken for this step.
                *     </p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <i>COPY</i>: copy the file to another location</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <i>CUSTOM</i>: custom step with a lambda target</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <i>DELETE</i>: delete the file</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <i>TAG</i>: add a tag to the file</p>
                *             </li>
                *          </ul>
                *          <note>
                *             <p>
                *         Currently, copying and tagging are supported only on S3.
                *       </p>
                *          </note>
                *          <p>
                *       For file location, you specify either the S3 bucket and key, or the EFS filesystem ID and path.
                *     </p>
                */
            Steps: WorkflowStep[] | undefined;
            /**
                * <p>Specifies the steps (actions) to take if errors are encountered during execution of the workflow.</p>
                *          <note>
                *             <p>For custom steps, the lambda function needs to send <code>FAILURE</code> to the call
                *         back API to kick off the exception steps. Additionally, if the lambda does not send
                *           <code>SUCCESS</code> before it times out, the exception steps are executed.</p>
                *          </note>
                */
            OnExceptionSteps?: WorkflowStep[];
            /**
                * <p>Key-value pairs that can be used to group and search for workflows. Tags are metadata attached
                *       to workflows for any purpose.</p>
                */
            Tags?: Tag[];
    }
    export namespace CreateWorkflowRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateWorkflowRequest) => any;
    }
    export interface CreateWorkflowResponse {
            /**
                * <p>A unique identifier for the workflow.</p>
                */
            WorkflowId: string | undefined;
    }
    export namespace CreateWorkflowResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateWorkflowResponse) => any;
    }
    export enum CustomStepStatus {
            FAILURE = "FAILURE",
            SUCCESS = "SUCCESS"
    }
    export interface DeleteAccessRequest {
            /**
                * <p>A system-assigned unique identifier for a server that has this user assigned.</p>
                */
            ServerId: string | undefined;
            /**
                * <p>A unique identifier that is required to identify specific groups within your directory.
                *     The users of the group that you associate have access to your Amazon S3 or Amazon EFS
                *     resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name,
                *     you can view the SID values by running the following command using Windows PowerShell.</p>
                *
                *          <p>
                *             <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamAccountName,ObjectSid</code>
                *          </p>
                *
                *          <p>In that command, replace <i>YourGroupName</i> with the name of your Active Directory group.</p>
                *
                *          <p>The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces.
                *     You can also include underscores or any of the following characters: =,.@:/-</p>
                */
            ExternalId: string | undefined;
    }
    export namespace DeleteAccessRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteAccessRequest) => any;
    }
    export interface DeleteServerRequest {
            /**
                * <p>A unique system-assigned identifier for a server instance.</p>
                */
            ServerId: string | undefined;
    }
    export namespace DeleteServerRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteServerRequest) => any;
    }
    export interface DeleteSshPublicKeyRequest {
            /**
                * <p>A system-assigned unique identifier for a file transfer protocol-enabled server instance
                *       that has the user assigned to it.</p>
                */
            ServerId: string | undefined;
            /**
                * <p>A unique identifier used to reference your user's specific SSH key.</p>
                */
            SshPublicKeyId: string | undefined;
            /**
                * <p>A unique string that identifies a user whose public key is being deleted.</p>
                */
            UserName: string | undefined;
    }
    export namespace DeleteSshPublicKeyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteSshPublicKeyRequest) => any;
    }
    export interface DeleteUserRequest {
            /**
                * <p>A system-assigned unique identifier for a server instance that has the user assigned to
                *       it.</p>
                */
            ServerId: string | undefined;
            /**
                * <p>A unique string that identifies a user that is being deleted from a server.</p>
                */
            UserName: string | undefined;
    }
    export namespace DeleteUserRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteUserRequest) => any;
    }
    export interface DeleteWorkflowRequest {
            /**
                * <p>A unique identifier for the workflow.</p>
                */
            WorkflowId: string | undefined;
    }
    export namespace DeleteWorkflowRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteWorkflowRequest) => any;
    }
    export interface DescribeAccessRequest {
            /**
                * <p>A system-assigned unique identifier for a server that has this access assigned.</p>
                */
            ServerId: string | undefined;
            /**
                * <p>A unique identifier that is required to identify specific groups within your directory.
                *     The users of the group that you associate have access to your Amazon S3 or Amazon EFS
                *     resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name,
                *     you can view the SID values by running the following command using Windows PowerShell.</p>
                *
                *          <p>
                *             <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamAccountName,ObjectSid</code>
                *          </p>
                *
                *          <p>In that command, replace <i>YourGroupName</i> with the name of your Active Directory group.</p>
                *
                *          <p>The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces.
                *     You can also include underscores or any of the following characters: =,.@:/-</p>
                */
            ExternalId: string | undefined;
    }
    export namespace DescribeAccessRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeAccessRequest) => any;
    }
    /**
        * <p>Describes the properties of the access that was specified.</p>
        */
    export interface DescribedAccess {
            /**
                * <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
                *          <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
                */
            HomeDirectory?: string;
            /**
                * <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
                *       be visible to your user and how you want to make them visible. You must specify the
                *         <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
                *       is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
                *       only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity
                *       and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
                *       can only be set when <code>HomeDirectoryType</code> is set to
                *       <i>LOGICAL</i>.</p>
                *
                *          <p>In most cases, you can use this value instead of the session policy to lock down the
                *       associated access to the designated home directory ("<code>chroot</code>"). To do this, you
                *       can set <code>Entry</code> to '/' and set <code>Target</code> to the
                *         <code>HomeDirectory</code> parameter value.</p>
                */
            HomeDirectoryMappings?: HomeDirectoryMapEntry[];
            /**
                * <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
                *     If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
                *     If you set it <code>LOGICAL</code>, you need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
                *     S3 or EFS paths visible to your users.</p>
                */
            HomeDirectoryType?: HomeDirectoryType | string;
            /**
                * <p>A session policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user
                *      access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include <code>${Transfer:UserName}</code>,
                *      <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
                */
            Policy?: string;
            /**
                * <p>The full POSIX identity, including user ID (<code>Uid</code>), group ID
                *       (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
                *       your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
                *       files and directories in your file system determine the level of access your users get when
                *       transferring files into and out of your Amazon EFS file systems.</p>
                */
            PosixProfile?: PosixProfile;
            /**
                * <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
                *       file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
                *       files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
                *       server to access your resources when servicing your users' transfer requests.</p>
                */
            Role?: string;
            /**
                * <p>A unique identifier that is required to identify specific groups within your directory.
                *     The users of the group that you associate have access to your Amazon S3 or Amazon EFS
                *     resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name,
                *     you can view the SID values by running the following command using Windows PowerShell.</p>
                *
                *          <p>
                *             <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamAccountName,ObjectSid</code>
                *          </p>
                *
                *          <p>In that command, replace <i>YourGroupName</i> with the name of your Active Directory group.</p>
                *
                *          <p>The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces.
                *     You can also include underscores or any of the following characters: =,.@:/-</p>
                */
            ExternalId?: string;
    }
    export namespace DescribedAccess {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribedAccess) => any;
    }
    export interface DescribeAccessResponse {
            /**
                * <p>A system-assigned unique identifier for a server that has this access assigned.</p>
                */
            ServerId: string | undefined;
            /**
                * <p>The external ID of the server that the access is attached to.</p>
                */
            Access: DescribedAccess | undefined;
    }
    export namespace DescribeAccessResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeAccessResponse) => any;
    }
    /**
        * <p>Specifies the details for the file location for the file being used in the workflow. Only applicable if you are using S3 storage.</p>
        */
    export interface S3FileLocation {
            /**
                * <p>Specifies the S3 bucket that contains the file being used.</p>
                */
            Bucket?: string;
            /**
                * <p>The name assigned to the file when it was created in S3. You use the object key to retrieve the object.</p>
                */
            Key?: string;
            /**
                * <p>Specifies the file version.</p>
                */
            VersionId?: string;
            /**
                * <p>The entity tag is a hash of the object. The ETag reflects changes only to the contents of an object, not its metadata.</p>
                */
            Etag?: string;
    }
    export namespace S3FileLocation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: S3FileLocation) => any;
    }
    /**
        * <p>Specifies the Amazon S3 or EFS file details to be used in the step.</p>
        */
    export interface FileLocation {
            /**
                * <p>Specifies the S3 details for the file being used, such as bucket, Etag, and so forth.</p>
                */
            S3FileLocation?: S3FileLocation;
            /**
                * <p>Specifies the Amazon EFS ID and the path for the file being used.</p>
                */
            EfsFileLocation?: EfsFileLocation;
    }
    export namespace FileLocation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FileLocation) => any;
    }
    /**
        * <p>Consists of the logging role and the log group name.</p>
        */
    export interface LoggingConfiguration {
            /**
                * <p>Specifies the Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that allows a server to turn
                *       on Amazon CloudWatch logging for Amazon S3 or Amazon EFS events. When set, user activity can be viewed in
                *       your CloudWatch logs.</p>
                */
            LoggingRole?: string;
            /**
                * <p>The name of the CloudWatch logging group for the Amazon Web Services Transfer server to which this workflow belongs.</p>
                */
            LogGroupName?: string;
    }
    export namespace LoggingConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LoggingConfiguration) => any;
    }
    export enum ExecutionErrorType {
            ALREADY_EXISTS = "ALREADY_EXISTS",
            BAD_REQUEST = "BAD_REQUEST",
            CUSTOM_STEP_FAILED = "CUSTOM_STEP_FAILED",
            INTERNAL_SERVER_ERROR = "INTERNAL_SERVER_ERROR",
            NOT_FOUND = "NOT_FOUND",
            PERMISSION_DENIED = "PERMISSION_DENIED",
            THROTTLED = "THROTTLED",
            TIMEOUT = "TIMEOUT"
    }
    /**
        * <p>Specifies the error message and type, for an error that occurs during the execution of the workflow.</p>
        */
    export interface ExecutionError {
            /**
                * <p>Specifies the error type.</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>ALREADY_EXISTS</code>: occurs for a copy step, if the overwrite option is not selected and a file with the same name already exists in the target location.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>BAD_REQUEST</code>: a general bad request: for example, a step that attempts to
                *           tag an EFS file returns <code>BAD_REQUEST</code>, as only S3 files can be tagged.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>CUSTOM_STEP_FAILED</code>: occurs when the custom step provided a callback that indicates failure.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>INTERNAL_SERVER_ERROR</code>: a catch-all error that can occur for a variety of
                *           reasons.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>NOT_FOUND</code>: occurs when a requested entity, for example a source file for
                *           a copy step, does not exist.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>PERMISSION_DENIED</code>: occurs if your policy does not contain the correct
                *           permissions to complete one or more of the steps in the workflow.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>TIMEOUT</code>: occurs when the execution times out.</p>
                *                <note>
                *                   <p> You can set the <code>TimeoutSeconds</code> for a custom step, anywhere from 1 second to 1800 seconds (30 minutes). </p>
                *                </note>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>THROTTLED</code>: occurs if you exceed the new execution refill rate of one
                *           workflow per second.</p>
                *             </li>
                *          </ul>
                */
            Type: ExecutionErrorType | string | undefined;
            /**
                * <p>Specifies the descriptive message that corresponds to the <code>ErrorType</code>.</p>
                */
            Message: string | undefined;
    }
    export namespace ExecutionError {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExecutionError) => any;
    }
    /**
        * <p>Specifies the following details for the step: error (if any), outputs (if any), and the step type.</p>
        */
    export interface ExecutionStepResult {
            /**
                * <p>One of the available step types.</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <i>COPY</i>: copy the file to another location</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <i>CUSTOM</i>: custom step with a lambda target</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <i>DELETE</i>: delete the file</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <i>TAG</i>: add a tag to the file</p>
                *             </li>
                *          </ul>
                */
            StepType?: WorkflowStepType | string;
            /**
                * <p>The values for the key/value pair applied as a tag to the file. Only applicable if the step type is <code>TAG</code>.</p>
                */
            Outputs?: string;
            /**
                * <p>Specifies the details for an error, if it occurred during execution of the specified workfow step.</p>
                */
            Error?: ExecutionError;
    }
    export namespace ExecutionStepResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExecutionStepResult) => any;
    }
    /**
        * <p>Specifies the steps in the workflow, as well as the steps to execute in case of any errors during workflow execution.</p>
        */
    export interface ExecutionResults {
            /**
                * <p>Specifies the details for the steps that are in the specified workflow.</p>
                */
            Steps?: ExecutionStepResult[];
            /**
                * <p>Specifies the steps (actions) to take if errors are encountered during execution of the workflow.</p>
                */
            OnExceptionSteps?: ExecutionStepResult[];
    }
    export namespace ExecutionResults {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExecutionResults) => any;
    }
    /**
        * <p>Specifies the user name, server ID, and session ID for a workflow.</p>
        */
    export interface UserDetails {
            /**
                * <p>A unique string that identifies a user account associated with a server.</p>
                */
            UserName: string | undefined;
            /**
                * <p>The system-assigned unique identifier for a Transfer server instance. </p>
                */
            ServerId: string | undefined;
            /**
                * <p>The system-assigned unique identifier for a session that corresponds to the workflow.</p>
                */
            SessionId?: string;
    }
    export namespace UserDetails {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UserDetails) => any;
    }
    /**
        * <p>A container object for the session details associated with a workflow.</p>
        */
    export interface ServiceMetadata {
            /**
                * <p>The Server ID (<code>ServerId</code>), Session ID (<code>SessionId</code>) and user (<code>UserName</code>) make up the <code>UserDetails</code>.</p>
                */
            UserDetails: UserDetails | undefined;
    }
    export namespace ServiceMetadata {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ServiceMetadata) => any;
    }
    export enum ExecutionStatus {
            COMPLETED = "COMPLETED",
            EXCEPTION = "EXCEPTION",
            HANDLING_EXCEPTION = "HANDLING_EXCEPTION",
            IN_PROGRESS = "IN_PROGRESS"
    }
    /**
        * <p>The details for an execution object.</p>
        */
    export interface DescribedExecution {
            /**
                * <p>A unique identifier for the execution of a workflow.</p>
                */
            ExecutionId?: string;
            /**
                * <p>A structure that describes the Amazon S3 or EFS file location.
                *       This is the file location when the execution begins: if the file is being copied,
                *     this is the initial (as opposed to destination) file location.</p>
                */
            InitialFileLocation?: FileLocation;
            /**
                * <p>A container object for the session details associated with a workflow.</p>
                */
            ServiceMetadata?: ServiceMetadata;
            /**
                * <p>The IAM role associated with the execution.</p>
                */
            ExecutionRole?: string;
            /**
                * <p>The IAM logging role associated with the execution.</p>
                */
            LoggingConfiguration?: LoggingConfiguration;
            /**
                * <p>The full POSIX identity, including user ID (<code>Uid</code>), group ID
                *       (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
                *       your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
                *       files and directories in your file system determine the level of access your users get when
                *       transferring files into and out of your Amazon EFS file systems.</p>
                */
            PosixProfile?: PosixProfile;
            /**
                * <p>The status is one of the execution. Can be in progress, completed, exception encountered, or handling the exception.
                *       </p>
                */
            Status?: ExecutionStatus | string;
            /**
                * <p>A structure that describes the execution results. This includes a list of the steps along with the details of each step,
                *     error type and message (if any), and the <code>OnExceptionSteps</code> structure.</p>
                */
            Results?: ExecutionResults;
    }
    export namespace DescribedExecution {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribedExecution) => any;
    }
    /**
        * <p>Describes the properties of a security policy that was specified. For more information
        *       about security policies, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/security-policies.html">Working with security
        *         policies</a>.</p>
        */
    export interface DescribedSecurityPolicy {
            /**
                * <p>Specifies whether this policy enables Federal Information Processing Standards
                *       (FIPS).</p>
                */
            Fips?: boolean;
            /**
                * <p>Specifies the name of the security policy that is attached to the server.</p>
                */
            SecurityPolicyName: string | undefined;
            /**
                * <p>Specifies the enabled Secure Shell (SSH) cipher encryption algorithms in the security
                *       policy that is attached to the server.</p>
                */
            SshCiphers?: string[];
            /**
                * <p>Specifies the enabled SSH key exchange (KEX) encryption algorithms in the security policy
                *       that is attached to the server.</p>
                */
            SshKexs?: string[];
            /**
                * <p>Specifies the enabled SSH message authentication code (MAC) encryption algorithms in the
                *       security policy that is attached to the server.</p>
                */
            SshMacs?: string[];
            /**
                * <p>Specifies the enabled Transport Layer Security (TLS) cipher encryption algorithms in the
                *       security policy that is attached to the server.</p>
                */
            TlsCiphers?: string[];
    }
    export namespace DescribedSecurityPolicy {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribedSecurityPolicy) => any;
    }
    export enum State {
            OFFLINE = "OFFLINE",
            ONLINE = "ONLINE",
            STARTING = "STARTING",
            START_FAILED = "START_FAILED",
            STOPPING = "STOPPING",
            STOP_FAILED = "STOP_FAILED"
    }
    /**
        * <p>Describes the properties of a file transfer protocol-enabled server that was
        *       specified.</p>
        */
    export interface DescribedServer {
            /**
                * <p>Specifies the unique Amazon Resource Name (ARN) of the server.</p>
                */
            Arn: string | undefined;
            /**
                * <p>Specifies the ARN of the Amazon Web ServicesCertificate Manager (ACM) certificate. Required when
                *         <code>Protocols</code> is set to <code>FTPS</code>.</p>
                */
            Certificate?: string;
            /**
                * <p>
                *       The protocol settings that are configured for your server.
                *     </p>
                *          <p>
                *       Use the <code>PassiveIp</code> parameter to indicate passive mode.
                *       Enter a single IPv4 address, such as the public IP address of a firewall, router, or load balancer.
                *     </p>
                */
            ProtocolDetails?: ProtocolDetails;
            /**
                * <p>Specifies the domain of the storage system that is used for file transfers.</p>
                */
            Domain?: Domain | string;
            /**
                * <p>The virtual private cloud (VPC) endpoint settings that are configured for your server.
                *       When you host your endpoint within your VPC, you can make it accessible only to resources
                *       within your VPC, or you can attach Elastic IP addresses and make it accessible to clients over
                *       the internet. Your VPC's default security groups are automatically assigned to your
                *       endpoint.</p>
                */
            EndpointDetails?: EndpointDetails;
            /**
                * <p>Defines the type of endpoint that your server is connected to. If your server is connected
                *       to a VPC endpoint, your server isn't accessible over the public internet.</p>
                */
            EndpointType?: EndpointType | string;
            /**
                * <p>Specifies the Base64-encoded SHA256 fingerprint of the server's host key. This value
                *       is equivalent to the output of the <code>ssh-keygen -l -f my-new-server-key</code>
                *       command.</p>
                */
            HostKeyFingerprint?: string;
            /**
                * <p>Specifies information to call a customer-supplied authentication API. This field is not
                *       populated when the <code>IdentityProviderType</code> of a server is
                *       <code>AWS_DIRECTORY_SERVICE</code> or <code>SERVICE_MANAGED</code>.</p>
                */
            IdentityProviderDetails?: IdentityProviderDetails;
            /**
                * <p>Specifies the mode of authentication for a server. The default value is
                *         <code>SERVICE_MANAGED</code>, which allows you to store and access user credentials within
                *       the Amazon Web Services Transfer Family service.</p>
                *          <p>Use <code>AWS_DIRECTORY_SERVICE</code> to provide access to
                *       Active Directory groups in Amazon Web Services Managed Active Directory or Microsoft Active Directory in your
                *       on-premises environment or in Amazon Web Services using AD Connectors. This option also requires you to
                *       provide a Directory ID using the <code>IdentityProviderDetails</code> parameter.</p>
                *          <p>Use the <code>API_GATEWAY</code> value to integrate with an identity provider of your choosing. The
                *       <code>API_GATEWAY</code> setting requires you to provide an API Gateway endpoint URL to call
                *       for authentication using the <code>IdentityProviderDetails</code> parameter.</p>
                *          <p>Use the <code>AWS_LAMBDA</code> value to directly use a Lambda function as your identity provider. If you choose this value,
                *       you must specify the ARN for the lambda function in the <code>Function</code> parameter for the <code>IdentityProviderDetails</code> data type.</p>
                */
            IdentityProviderType?: IdentityProviderType | string;
            /**
                * <p>Specifies the Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that allows a server to turn
                *       on Amazon CloudWatch logging for Amazon S3 or Amazon EFS events. When set, user activity can be viewed in
                *       your CloudWatch logs.</p>
                */
            LoggingRole?: string;
            /**
                * <p>Specify a string to display when users connect to a server. This string is displayed after the user authenticates.</p>
                *          <note>
                *             <p>The SFTP protocol does not support post-authentication display banners.</p>
                *          </note>
                */
            PostAuthenticationLoginBanner?: string;
            /**
                * <p>Specify a string to display when users connect to a server. This string is displayed before the user authenticates.
                *     For example, the following banner displays details about using the system.</p>
                *          <p>
                *             <code>This system is for the use of authorized users only. Individuals using this computer system without authority,
                *     or in excess of their authority, are subject to having all of their activities on this system monitored and recorded by
                *     system personnel.</code>
                *          </p>
                */
            PreAuthenticationLoginBanner?: string;
            /**
                * <p>Specifies the file transfer protocol or protocols over which your file transfer protocol
                *       client can connect to your server's endpoint. The available protocols are:</p>
                *
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>SFTP</code> (Secure Shell (SSH) File Transfer Protocol): File transfer over
                *           SSH</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>FTPS</code> (File Transfer Protocol Secure): File transfer with TLS
                *           encryption</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>FTP</code> (File Transfer Protocol): Unencrypted file transfer</p>
                *             </li>
                *          </ul>
                */
            Protocols?: (Protocol | string)[];
            /**
                * <p>Specifies the name of the security policy that is attached to the server.</p>
                */
            SecurityPolicyName?: string;
            /**
                * <p>Specifies the unique system-assigned identifier for a server that you instantiate.</p>
                */
            ServerId?: string;
            /**
                * <p>Specifies the condition of a server for the server that was described. A value of
                *         <code>ONLINE</code> indicates that the server can accept jobs and transfer files. A
                *         <code>State</code> value of <code>OFFLINE</code> means that the server cannot perform file
                *       transfer operations.</p>
                *
                *          <p>The states of <code>STARTING</code> and <code>STOPPING</code> indicate that the server is
                *       in an intermediate state, either not fully able to respond, or not fully offline. The values
                *       of <code>START_FAILED</code> or <code>STOP_FAILED</code> can indicate an error
                *       condition.</p>
                */
            State?: State | string;
            /**
                * <p>Specifies the key-value pairs that you can use to search for and group servers that were
                *       assigned to the server that was described.</p>
                */
            Tags?: Tag[];
            /**
                * <p>Specifies the number of users that are assigned to a server you specified with the
                *         <code>ServerId</code>.</p>
                */
            UserCount?: number;
            /**
                * <p>Specifies the workflow ID for the workflow to assign and the execution role used for executing the workflow.</p>
                */
            WorkflowDetails?: WorkflowDetails;
    }
    export namespace DescribedServer {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribedServer) => any;
    }
    /**
        * <p>Provides information about the public Secure Shell (SSH) key that is associated with a
        *       user account for the specific file transfer protocol-enabled server (as identified by
        *         <code>ServerId</code>). The information returned includes the date the key was imported, the
        *       public key contents, and the public key ID. A user can store more than one SSH public key
        *       associated with their user name on a specific server.</p>
        */
    export interface SshPublicKey {
            /**
                * <p>Specifies the date that the public key was added to the user account.</p>
                */
            DateImported: Date | undefined;
            /**
                * <p>Specifies the content of the SSH public key as specified by the
                *       <code>PublicKeyId</code>.</p>
                *          <p>Transfer Family accepts RSA, ECDSA, and ED25519 keys.</p>
                */
            SshPublicKeyBody: string | undefined;
            /**
                * <p>Specifies the <code>SshPublicKeyId</code> parameter contains the identifier of the public
                *       key.</p>
                */
            SshPublicKeyId: string | undefined;
    }
    export namespace SshPublicKey {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SshPublicKey) => any;
    }
    /**
        * <p>Describes the properties of a user that was specified.</p>
        */
    export interface DescribedUser {
            /**
                * <p>Specifies the unique Amazon Resource Name (ARN) for the user that was requested to be
                *       described.</p>
                */
            Arn: string | undefined;
            /**
                * <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
                *          <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
                */
            HomeDirectory?: string;
            /**
                * <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
                *       be visible to your user and how you want to make them visible. You must specify the
                *         <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
                *       is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
                *       only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity
                *       and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
                *       can only be set when <code>HomeDirectoryType</code> is set to
                *       <i>LOGICAL</i>.</p>
                *
                *          <p>In most cases, you can use this value instead of the session policy to lock your user
                *       down to the designated home directory ("<code>chroot</code>"). To do this, you can set
                *         <code>Entry</code> to '/' and set <code>Target</code> to the HomeDirectory
                *       parameter value.</p>
                */
            HomeDirectoryMappings?: HomeDirectoryMapEntry[];
            /**
                * <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
                *     If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
                *     If you set it <code>LOGICAL</code>, you need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
                *     S3 or EFS paths visible to your users.</p>
                */
            HomeDirectoryType?: HomeDirectoryType | string;
            /**
                * <p>A session policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user
                *      access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include <code>${Transfer:UserName}</code>,
                *      <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
                */
            Policy?: string;
            /**
                * <p>Specifies the full POSIX identity, including user ID (<code>Uid</code>), group ID
                *         (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
                *       your users' access to your Amazon Elastic File System (Amazon EFS) file systems. The POSIX
                *       permissions that are set on files and directories in your file system determine the level of
                *       access your users get when transferring files into and out of your Amazon EFS file
                *       systems.</p>
                */
            PosixProfile?: PosixProfile;
            /**
                * <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
                *       file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
                *       files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
                *       server to access your resources when servicing your users' transfer requests.</p>
                */
            Role?: string;
            /**
                * <p>Specifies the public key portion of the Secure Shell (SSH) keys stored for the described
                *       user.</p>
                */
            SshPublicKeys?: SshPublicKey[];
            /**
                * <p>Specifies the key-value pairs for the user requested. Tag can be used to search for and
                *       group users for a variety of purposes.</p>
                */
            Tags?: Tag[];
            /**
                * <p>Specifies the name of the user that was requested to be described. User names are used for
                *       authentication purposes. This is the string that will be used by your user when they log in to
                *       your server.</p>
                */
            UserName?: string;
    }
    export namespace DescribedUser {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribedUser) => any;
    }
    /**
        * <p>Describes the properties of the specified workflow</p>
        */
    export interface DescribedWorkflow {
            /**
                * <p>Specifies the unique Amazon Resource Name (ARN) for the workflow.</p>
                */
            Arn: string | undefined;
            /**
                * <p>Specifies the text description for the workflow.</p>
                */
            Description?: string;
            /**
                * <p>Specifies the details for the steps that are in the specified workflow.</p>
                */
            Steps?: WorkflowStep[];
            /**
                * <p>Specifies the steps (actions) to take if errors are encountered during execution of the workflow.</p>
                */
            OnExceptionSteps?: WorkflowStep[];
            /**
                * <p>A unique identifier for the workflow.</p>
                */
            WorkflowId?: string;
            /**
                * <p>Key-value pairs that can be used to group and search for workflows. Tags are metadata attached to workflows for any purpose.</p>
                */
            Tags?: Tag[];
    }
    export namespace DescribedWorkflow {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribedWorkflow) => any;
    }
    export interface DescribeExecutionRequest {
            /**
                * <p>A unique identifier for the execution of a workflow.</p>
                */
            ExecutionId: string | undefined;
            /**
                * <p>A unique identifier for the workflow.</p>
                */
            WorkflowId: string | undefined;
    }
    export namespace DescribeExecutionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeExecutionRequest) => any;
    }
    export interface DescribeExecutionResponse {
            /**
                * <p>A unique identifier for the workflow.</p>
                */
            WorkflowId: string | undefined;
            /**
                * <p>The structure that contains the details of the workflow' execution.</p>
                */
            Execution: DescribedExecution | undefined;
    }
    export namespace DescribeExecutionResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeExecutionResponse) => any;
    }
    export interface DescribeSecurityPolicyRequest {
            /**
                * <p>Specifies the name of the security policy that is attached to the server.</p>
                */
            SecurityPolicyName: string | undefined;
    }
    export namespace DescribeSecurityPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeSecurityPolicyRequest) => any;
    }
    export interface DescribeSecurityPolicyResponse {
            /**
                * <p>An array containing the properties of the security policy.</p>
                */
            SecurityPolicy: DescribedSecurityPolicy | undefined;
    }
    export namespace DescribeSecurityPolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeSecurityPolicyResponse) => any;
    }
    export interface DescribeServerRequest {
            /**
                * <p>A system-assigned unique identifier for a server.</p>
                */
            ServerId: string | undefined;
    }
    export namespace DescribeServerRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeServerRequest) => any;
    }
    export interface DescribeServerResponse {
            /**
                * <p>An array containing the properties of a server with the <code>ServerID</code> you
                *       specified.</p>
                */
            Server: DescribedServer | undefined;
    }
    export namespace DescribeServerResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeServerResponse) => any;
    }
    export interface DescribeUserRequest {
            /**
                * <p>A system-assigned unique identifier for a server that has this user assigned.</p>
                */
            ServerId: string | undefined;
            /**
                * <p>The name of the user assigned to one or more servers. User names are part of the sign-in
                *       credentials to use the Amazon Web Services Transfer Family service and perform file transfer tasks.</p>
                */
            UserName: string | undefined;
    }
    export namespace DescribeUserRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeUserRequest) => any;
    }
    export interface DescribeUserResponse {
            /**
                * <p>A system-assigned unique identifier for a server that has this user assigned.</p>
                */
            ServerId: string | undefined;
            /**
                * <p>An array containing the properties of the user account for the <code>ServerID</code> value
                *       that you specified.</p>
                */
            User: DescribedUser | undefined;
    }
    export namespace DescribeUserResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeUserResponse) => any;
    }
    export interface DescribeWorkflowRequest {
            /**
                * <p>A unique identifier for the workflow.</p>
                */
            WorkflowId: string | undefined;
    }
    export namespace DescribeWorkflowRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeWorkflowRequest) => any;
    }
    export interface DescribeWorkflowResponse {
            /**
                * <p>The structure that contains the details of the workflow.</p>
                */
            Workflow: DescribedWorkflow | undefined;
    }
    export namespace DescribeWorkflowResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeWorkflowResponse) => any;
    }
    export interface ImportSshPublicKeyRequest {
            /**
                * <p>A system-assigned unique identifier for a server.</p>
                */
            ServerId: string | undefined;
            /**
                * <p>The public key portion of an SSH key pair.</p>
                *          <p>Transfer Family accepts RSA, ECDSA, and ED25519 keys.</p>
                */
            SshPublicKeyBody: string | undefined;
            /**
                * <p>The name of the user account that is assigned to one or more servers.</p>
                */
            UserName: string | undefined;
    }
    export namespace ImportSshPublicKeyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImportSshPublicKeyRequest) => any;
    }
    /**
        * <p>Identifies the user, the server they belong to, and the identifier of the SSH public key
        *       associated with that user. A user can have more than one key on each server that they are
        *       associated with.</p>
        */
    export interface ImportSshPublicKeyResponse {
            /**
                * <p>A system-assigned unique identifier for a server.</p>
                */
            ServerId: string | undefined;
            /**
                * <p>The name given to a public key by the system that was imported.</p>
                */
            SshPublicKeyId: string | undefined;
            /**
                * <p>A user name assigned to the <code>ServerID</code> value that you specified.</p>
                */
            UserName: string | undefined;
    }
    export namespace ImportSshPublicKeyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImportSshPublicKeyResponse) => any;
    }
    /**
        * <p>The <code>NextToken</code> parameter that was passed is invalid.</p>
        */
    export class InvalidNextTokenException extends __BaseException {
            readonly name: "InvalidNextTokenException";
            readonly $fault: "client";
            Message: string | undefined;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidNextTokenException, __BaseException>);
    }
    export interface ListAccessesRequest {
            /**
                * <p>Specifies the maximum number of access SIDs to return.</p>
                */
            MaxResults?: number;
            /**
                * <p>When you can get additional results from the <code>ListAccesses</code> call, a
                *         <code>NextToken</code> parameter is returned in the output. You can then pass in a
                *       subsequent command to the <code>NextToken</code> parameter to continue listing additional
                *       accesses.</p>
                */
            NextToken?: string;
            /**
                * <p>A system-assigned unique identifier for a server that has users assigned to it.</p>
                */
            ServerId: string | undefined;
    }
    export namespace ListAccessesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListAccessesRequest) => any;
    }
    /**
        * <p>Lists the properties for one or more specified associated accesses.</p>
        */
    export interface ListedAccess {
            /**
                * <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
                *          <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
                */
            HomeDirectory?: string;
            /**
                * <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
                *     If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
                *     If you set it <code>LOGICAL</code>, you need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
                *     S3 or EFS paths visible to your users.</p>
                */
            HomeDirectoryType?: HomeDirectoryType | string;
            /**
                * <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
                *       file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
                *       files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
                *       server to access your resources when servicing your users' transfer requests.</p>
                */
            Role?: string;
            /**
                * <p>A unique identifier that is required to identify specific groups within your directory.
                *     The users of the group that you associate have access to your Amazon S3 or Amazon EFS
                *     resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name,
                *     you can view the SID values by running the following command using Windows PowerShell.</p>
                *
                *          <p>
                *             <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamAccountName,ObjectSid</code>
                *          </p>
                *
                *          <p>In that command, replace <i>YourGroupName</i> with the name of your Active Directory group.</p>
                *
                *          <p>The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces.
                *     You can also include underscores or any of the following characters: =,.@:/-</p>
                */
            ExternalId?: string;
    }
    export namespace ListedAccess {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListedAccess) => any;
    }
    export interface ListAccessesResponse {
            /**
                * <p>When you can get additional results from the <code>ListAccesses</code> call, a
                *         <code>NextToken</code> parameter is returned in the output. You can then pass in a
                *       subsequent command to the <code>NextToken</code> parameter to continue listing additional
                *       accesses.</p>
                */
            NextToken?: string;
            /**
                * <p>A system-assigned unique identifier for a server that has users assigned to it.</p>
                */
            ServerId: string | undefined;
            /**
                * <p>Returns the accesses and their properties for the <code>ServerId</code> value that you
                *       specify.</p>
                */
            Accesses: ListedAccess[] | undefined;
    }
    export namespace ListAccessesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListAccessesResponse) => any;
    }
    /**
        * <p>Returns properties of the execution that is specified.</p>
        */
    export interface ListedExecution {
            /**
                * <p>A unique identifier for the execution of a workflow.</p>
                */
            ExecutionId?: string;
            /**
                * <p>A structure that describes the Amazon S3 or EFS file location.
                *       This is the file location when the execution begins: if the file is being copied,
                *       this is the initial (as opposed to destination) file location.</p>
                */
            InitialFileLocation?: FileLocation;
            /**
                * <p>A container object for the session details associated with a workflow.</p>
                */
            ServiceMetadata?: ServiceMetadata;
            /**
                * <p>The status is one of the execution. Can be in progress, completed, exception encountered, or handling the exception.</p>
                */
            Status?: ExecutionStatus | string;
    }
    export namespace ListedExecution {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListedExecution) => any;
    }
    /**
        * <p>Returns properties of a file transfer protocol-enabled server that was specified.</p>
        */
    export interface ListedServer {
            /**
                * <p>Specifies the unique Amazon Resource Name (ARN) for a server to be listed.</p>
                */
            Arn: string | undefined;
            /**
                * <p>Specifies the domain of the storage system that is used for file transfers.</p>
                */
            Domain?: Domain | string;
            /**
                * <p>Specifies the mode of authentication for a server. The default value is
                *         <code>SERVICE_MANAGED</code>, which allows you to store and access user credentials within
                *       the Amazon Web Services Transfer Family service.</p>
                *          <p>Use <code>AWS_DIRECTORY_SERVICE</code> to provide access to
                *       Active Directory groups in Amazon Web Services Managed Active Directory or Microsoft Active Directory in your
                *       on-premises environment or in Amazon Web Services using AD Connectors. This option also requires you to
                *       provide a Directory ID using the <code>IdentityProviderDetails</code> parameter.</p>
                *          <p>Use the <code>API_GATEWAY</code> value to integrate with an identity provider of your choosing. The
                *       <code>API_GATEWAY</code> setting requires you to provide an API Gateway endpoint URL to call
                *       for authentication using the <code>IdentityProviderDetails</code> parameter.</p>
                *          <p>Use the <code>AWS_LAMBDA</code> value to directly use a Lambda function as your identity provider. If you choose this value,
                *       you must specify the ARN for the lambda function in the <code>Function</code> parameter for the <code>IdentityProviderDetails</code> data type.</p>
                */
            IdentityProviderType?: IdentityProviderType | string;
            /**
                * <p>Specifies the type of VPC endpoint that your server is connected to. If your server is
                *       connected to a VPC endpoint, your server isn't accessible over the public internet.</p>
                */
            EndpointType?: EndpointType | string;
            /**
                * <p>Specifies the Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that allows a server to turn
                *       on Amazon CloudWatch logging for Amazon S3 or Amazon EFS events. When set, user activity can be viewed in
                *       your CloudWatch logs.</p>
                */
            LoggingRole?: string;
            /**
                * <p>Specifies the unique system assigned identifier for the servers that were listed.</p>
                */
            ServerId?: string;
            /**
                * <p>Specifies the condition of a server for the server that was described. A value of
                *         <code>ONLINE</code> indicates that the server can accept jobs and transfer files. A
                *         <code>State</code> value of <code>OFFLINE</code> means that the server cannot perform file
                *       transfer operations.</p>
                *
                *          <p>The states of <code>STARTING</code> and <code>STOPPING</code> indicate that the server is
                *       in an intermediate state, either not fully able to respond, or not fully offline. The values
                *       of <code>START_FAILED</code> or <code>STOP_FAILED</code> can indicate an error
                *       condition.</p>
                */
            State?: State | string;
            /**
                * <p>Specifies the number of users that are assigned to a server you specified with the
                *         <code>ServerId</code>.</p>
                */
            UserCount?: number;
    }
    export namespace ListedServer {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListedServer) => any;
    }
    /**
        * <p>Returns properties of the user that you specify.</p>
        */
    export interface ListedUser {
            /**
                * <p>Provides the unique Amazon Resource Name (ARN) for the user that you want to learn
                *       about.</p>
                */
            Arn: string | undefined;
            /**
                * <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
                *          <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
                */
            HomeDirectory?: string;
            /**
                * <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
                *     If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
                *     If you set it <code>LOGICAL</code>, you need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
                *     S3 or EFS paths visible to your users.</p>
                */
            HomeDirectoryType?: HomeDirectoryType | string;
            /**
                * <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
                *       file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
                *       files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
                *       server to access your resources when servicing your users' transfer requests.</p>
                *          <note>
                *
                *             <p>The IAM role that controls your users' access to your Amazon S3 bucket for servers with <code>Domain=S3</code>, or your EFS file system for servers with <code>Domain=EFS</code>.
                *         </p>
                *             <p>The policies attached to this role determine the level of access you want to provide your users when
                *         transferring files into and out of your S3 buckets or EFS file systems.</p>
                *
                *          </note>
                */
            Role?: string;
            /**
                * <p>Specifies the number of SSH public keys stored for the user you specified.</p>
                */
            SshPublicKeyCount?: number;
            /**
                * <p>Specifies the name of the user whose ARN was specified. User names are used for
                *       authentication purposes.</p>
                */
            UserName?: string;
    }
    export namespace ListedUser {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListedUser) => any;
    }
    /**
        * <p>Contains the ID, text description, and Amazon Resource Name (ARN) for the workflow.</p>
        */
    export interface ListedWorkflow {
            /**
                * <p>A unique identifier for the workflow.</p>
                */
            WorkflowId?: string;
            /**
                * <p>Specifies the text description for the workflow.</p>
                */
            Description?: string;
            /**
                * <p>Specifies the unique Amazon Resource Name (ARN) for the workflow.</p>
                */
            Arn?: string;
    }
    export namespace ListedWorkflow {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListedWorkflow) => any;
    }
    export interface ListExecutionsRequest {
            /**
                * <p>Specifies the aximum number of executions to return.</p>
                */
            MaxResults?: number;
            /**
                * <p>
                *             <code>ListExecutions</code> returns the <code>NextToken</code> parameter in the output.
                *       You can then pass the <code>NextToken</code> parameter in a subsequent command to
                *       continue listing additional executions.</p>
                *          <p>
                *       This is useful for pagination, for instance.
                *       If you have 100 executions for a workflow, you might only want to list first 10. If so, callthe API by specifing the <code>max-results</code>:
                *     </p>
                *          <p>
                *             <code>aws transfer list-executions --max-results 10</code>
                *          </p>
                *          <p>
                *       This returns details for the first 10 executions, as well as the pointer (<code>NextToken</code>) to the eleventh execution.
                *       You can now call the API again, suppling the <code>NextToken</code> value you received:
                *     </p>
                *          <p>
                *             <code>aws transfer list-executions --max-results 10 --next-token $somePointerReturnedFromPreviousListResult</code>
                *          </p>
                *          <p>
                *       This call returns the next 10 executions, the 11th through the 20th. You can then repeat the call until the details
                *       for all 100 executions have been returned.
                *     </p>
                */
            NextToken?: string;
            /**
                * <p>A unique identifier for the workflow.</p>
                */
            WorkflowId: string | undefined;
    }
    export namespace ListExecutionsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListExecutionsRequest) => any;
    }
    export interface ListExecutionsResponse {
            /**
                * <p>
                *             <code>ListExecutions</code> returns the <code>NextToken</code> parameter in the output.
                *       You can then pass the <code>NextToken</code> parameter in a subsequent command to
                *       continue listing additional executions.</p>
                */
            NextToken?: string;
            /**
                * <p>A unique identifier for the workflow.</p>
                */
            WorkflowId: string | undefined;
            /**
                * <p>Returns the details for each execution.</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <b>NextToken</b>: returned from a call to several APIs,
                *       you can use pass it to a subsequent command to continue listing additional executions.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>StartTime</b>: timestamp indicating when the execution began.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>Executions</b>: details of the execution, including the execution ID, initial file location,
                *       and Service metadata.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>Status</b>: one of the following values:
                *         <code>IN_PROGRESS</code>, <code>COMPLETED</code>, <code>EXCEPTION</code>, <code>HANDLING_EXEPTION</code>.
                *       </p>
                *             </li>
                *          </ul>
                */
            Executions: ListedExecution[] | undefined;
    }
    export namespace ListExecutionsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListExecutionsResponse) => any;
    }
    export interface ListSecurityPoliciesRequest {
            /**
                * <p>Specifies the number of security policies to return as a response to the
                *         <code>ListSecurityPolicies</code> query.</p>
                */
            MaxResults?: number;
            /**
                * <p>When additional results are obtained from the <code>ListSecurityPolicies</code> command, a
                *         <code>NextToken</code> parameter is returned in the output. You can then pass the
                *         <code>NextToken</code> parameter in a subsequent command to continue listing additional
                *       security policies.</p>
                */
            NextToken?: string;
    }
    export namespace ListSecurityPoliciesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListSecurityPoliciesRequest) => any;
    }
    export interface ListSecurityPoliciesResponse {
            /**
                * <p>When you can get additional results from the <code>ListSecurityPolicies</code> operation,
                *       a <code>NextToken</code> parameter is returned in the output. In a following command, you can
                *       pass in the <code>NextToken</code> parameter to continue listing security policies.</p>
                */
            NextToken?: string;
            /**
                * <p>An array of security policies that were listed.</p>
                */
            SecurityPolicyNames: string[] | undefined;
    }
    export namespace ListSecurityPoliciesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListSecurityPoliciesResponse) => any;
    }
    export interface ListServersRequest {
            /**
                * <p>Specifies the number of servers to return as a response to the <code>ListServers</code>
                *       query.</p>
                */
            MaxResults?: number;
            /**
                * <p>When additional results are obtained from the <code>ListServers</code> command, a
                *         <code>NextToken</code> parameter is returned in the output. You can then pass the
                *         <code>NextToken</code> parameter in a subsequent command to continue listing additional
                *       servers.</p>
                */
            NextToken?: string;
    }
    export namespace ListServersRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListServersRequest) => any;
    }
    export interface ListServersResponse {
            /**
                * <p>When you can get additional results from the <code>ListServers</code> operation, a
                *         <code>NextToken</code> parameter is returned in the output. In a following command, you can
                *       pass in the <code>NextToken</code> parameter to continue listing additional servers.</p>
                */
            NextToken?: string;
            /**
                * <p>An array of servers that were listed.</p>
                */
            Servers: ListedServer[] | undefined;
    }
    export namespace ListServersResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListServersResponse) => any;
    }
    export interface ListTagsForResourceRequest {
            /**
                * <p>Requests the tags associated with a particular Amazon Resource Name (ARN). An ARN is an
                *       identifier for a specific Amazon Web Services resource, such as a server, user, or role.</p>
                */
            Arn: string | undefined;
            /**
                * <p>Specifies the number of tags to return as a response to the
                *         <code>ListTagsForResource</code> request.</p>
                */
            MaxResults?: number;
            /**
                * <p>When you request additional results from the <code>ListTagsForResource</code> operation, a
                *         <code>NextToken</code> parameter is returned in the input. You can then pass in a subsequent
                *       command to the <code>NextToken</code> parameter to continue listing additional tags.</p>
                */
            NextToken?: string;
    }
    export namespace ListTagsForResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceRequest) => any;
    }
    export interface ListTagsForResourceResponse {
            /**
                * <p>The ARN you specified to list the tags of.</p>
                */
            Arn?: string;
            /**
                * <p>When you can get additional results from the <code>ListTagsForResource</code> call, a
                *         <code>NextToken</code> parameter is returned in the output. You can then pass in a
                *       subsequent command to the <code>NextToken</code> parameter to continue listing additional
                *       tags.</p>
                */
            NextToken?: string;
            /**
                * <p>Key-value pairs that are assigned to a resource, usually for the purpose of grouping and
                *       searching for items. Tags are metadata that you define.</p>
                */
            Tags?: Tag[];
    }
    export namespace ListTagsForResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceResponse) => any;
    }
    export interface ListUsersRequest {
            /**
                * <p>Specifies the number of users to return as a response to the <code>ListUsers</code>
                *       request.</p>
                */
            MaxResults?: number;
            /**
                * <p>When you can get additional results from the <code>ListUsers</code> call, a
                *         <code>NextToken</code> parameter is returned in the output. You can then pass in a
                *       subsequent command to the <code>NextToken</code> parameter to continue listing additional
                *       users.</p>
                */
            NextToken?: string;
            /**
                * <p>A system-assigned unique identifier for a server that has users assigned to it.</p>
                */
            ServerId: string | undefined;
    }
    export namespace ListUsersRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListUsersRequest) => any;
    }
    export interface ListUsersResponse {
            /**
                * <p>When you can get additional results from the <code>ListUsers</code> call, a
                *         <code>NextToken</code> parameter is returned in the output. You can then pass in a
                *       subsequent command to the <code>NextToken</code> parameter to continue listing additional
                *       users.</p>
                */
            NextToken?: string;
            /**
                * <p>A system-assigned unique identifier for a server that the users are assigned to.</p>
                */
            ServerId: string | undefined;
            /**
                * <p>Returns the user accounts and their properties for the <code>ServerId</code> value that
                *       you specify.</p>
                */
            Users: ListedUser[] | undefined;
    }
    export namespace ListUsersResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListUsersResponse) => any;
    }
    export interface ListWorkflowsRequest {
            /**
                * <p>Specifies the maximum number of workflows to return.</p>
                */
            MaxResults?: number;
            /**
                * <p>
                *             <code>ListWorkflows</code> returns the <code>NextToken</code> parameter in the output.
                *       You can then pass the <code>NextToken</code> parameter in a subsequent command to
                *       continue listing additional workflows.</p>
                */
            NextToken?: string;
    }
    export namespace ListWorkflowsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListWorkflowsRequest) => any;
    }
    export interface ListWorkflowsResponse {
            /**
                * <p>
                *             <code>ListWorkflows</code> returns the <code>NextToken</code> parameter in the output.
                *       You can then pass the <code>NextToken</code> parameter in a subsequent command to
                *       continue listing additional workflows.</p>
                */
            NextToken?: string;
            /**
                * <p>Returns the <code>Arn</code>, <code>WorkflowId</code>, and <code>Description</code> for each workflow.</p>
                */
            Workflows: ListedWorkflow[] | undefined;
    }
    export namespace ListWorkflowsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListWorkflowsResponse) => any;
    }
    export interface SendWorkflowStepStateRequest {
            /**
                * <p>A unique identifier for the workflow.</p>
                */
            WorkflowId: string | undefined;
            /**
                * <p>A unique identifier for the execution of a workflow.</p>
                */
            ExecutionId: string | undefined;
            /**
                * <p>Used to distinguish between multiple callbacks for multiple Lambda steps within the same execution.</p>
                */
            Token: string | undefined;
            /**
                * <p>Indicates whether the specified step succeeded or failed.</p>
                */
            Status: CustomStepStatus | string | undefined;
    }
    export namespace SendWorkflowStepStateRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SendWorkflowStepStateRequest) => any;
    }
    export interface SendWorkflowStepStateResponse {
    }
    export namespace SendWorkflowStepStateResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SendWorkflowStepStateResponse) => any;
    }
    export interface StartServerRequest {
            /**
                * <p>A system-assigned unique identifier for a server that you start.</p>
                */
            ServerId: string | undefined;
    }
    export namespace StartServerRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartServerRequest) => any;
    }
    export interface StopServerRequest {
            /**
                * <p>A system-assigned unique identifier for a server that you stopped.</p>
                */
            ServerId: string | undefined;
    }
    export namespace StopServerRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StopServerRequest) => any;
    }
    export interface TagResourceRequest {
            /**
                * <p>An Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a server, user, or
                *       role.</p>
                */
            Arn: string | undefined;
            /**
                * <p>Key-value pairs assigned to ARNs that you can use to group and search for resources by
                *       type. You can attach this metadata to user accounts for any purpose.</p>
                */
            Tags: Tag[] | undefined;
    }
    export namespace TagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceRequest) => any;
    }
    export interface TestIdentityProviderRequest {
            /**
                * <p>A system-assigned identifier for a specific server. That server's user authentication
                *       method is tested with a user name and password.</p>
                */
            ServerId: string | undefined;
            /**
                * <p>The type of file transfer protocol to be tested.</p>
                *
                *          <p>The available protocols are:</p>
                *
                *          <ul>
                *             <li>
                *                <p>Secure Shell (SSH) File Transfer Protocol (SFTP)</p>
                *             </li>
                *             <li>
                *                <p>File Transfer Protocol Secure (FTPS)</p>
                *             </li>
                *             <li>
                *                <p>File Transfer Protocol (FTP)</p>
                *             </li>
                *          </ul>
                */
            ServerProtocol?: Protocol | string;
            /**
                * <p>The source IP address of the user account to be tested.</p>
                */
            SourceIp?: string;
            /**
                * <p>The name of the user account to be tested.</p>
                */
            UserName: string | undefined;
            /**
                * <p>The password of the user account to be tested.</p>
                */
            UserPassword?: string;
    }
    export namespace TestIdentityProviderRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TestIdentityProviderRequest) => any;
    }
    export interface TestIdentityProviderResponse {
            /**
                * <p>The response that is returned from your API Gateway.</p>
                */
            Response?: string;
            /**
                * <p>The HTTP status code that is the response from your API Gateway.</p>
                */
            StatusCode: number | undefined;
            /**
                * <p>A message that indicates whether the test was successful or not.</p>
                *          <note>
                *             <p>If an empty string is returned, the most likely cause is that the authentication failed due to an incorrect username or password.</p>
                *          </note>
                */
            Message?: string;
            /**
                * <p>The endpoint of the service used to authenticate a user.</p>
                */
            Url: string | undefined;
    }
    export namespace TestIdentityProviderResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TestIdentityProviderResponse) => any;
    }
    export interface UntagResourceRequest {
            /**
                * <p>The value of the resource that will have the tag removed. An Amazon Resource Name (ARN) is
                *       an identifier for a specific Amazon Web Services resource, such as a server, user, or role.</p>
                */
            Arn: string | undefined;
            /**
                * <p>TagKeys are key-value pairs assigned to ARNs that can be used to group and search for
                *       resources by type. This metadata can be attached to resources for any purpose.</p>
                */
            TagKeys: string[] | undefined;
    }
    export namespace UntagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceRequest) => any;
    }
    export interface UpdateAccessRequest {
            /**
                * <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
                *          <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
                */
            HomeDirectory?: string;
            /**
                * <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
                *     If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
                *     If you set it <code>LOGICAL</code>, you need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
                *     S3 or EFS paths visible to your users.</p>
                */
            HomeDirectoryType?: HomeDirectoryType | string;
            /**
                * <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
                *       be visible to your user and how you want to make them visible. You must specify the
                *         <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
                *       is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
                *       only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity
                *       and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
                *       can only be set when <code>HomeDirectoryType</code> is set to
                *       <i>LOGICAL</i>.</p>
                *          <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
                *          <p>
                *             <code>[ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ]</code>
                *          </p>
                *          <p>In most cases, you can use this value instead of the session policy to lock down your
                *         user to the designated home directory ("<code>chroot</code>"). To do this, you can set
                *         <code>Entry</code> to <code>/</code> and set <code>Target</code> to the
                *         <code>HomeDirectory</code> parameter value.</p>
                *          <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p>
                *          <p>
                *             <code>[ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
                *          </p>
                */
            HomeDirectoryMappings?: HomeDirectoryMapEntry[];
            /**
                * <p>A session policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user
                *      access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include <code>${Transfer:UserName}</code>,
                *      <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
                *
                *
                *          <note>
                *             <p>This only applies when the domain of <code>ServerId</code> is S3. EFS does not use session policies.</p>
                *             <p>For session policies, Amazon Web Services Transfer Family stores the policy as a JSON blob, instead
                *         of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass
                *         it in the <code>Policy</code> argument.</p>
                *             <p>For an example of a session policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/session-policy.html">Example
                *         session policy</a>.</p>
                *             <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>Amazon Web ServicesSecurity Token Service API
                *           Reference</i>.</p>
                *          </note>
                */
            Policy?: string;
            /**
                * <p>The full POSIX identity, including user ID (<code>Uid</code>), group ID
                *       (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
                *       your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
                *       files and directories in your file system determine the level of access your users get when
                *       transferring files into and out of your Amazon EFS file systems.</p>
                */
            PosixProfile?: PosixProfile;
            /**
                * <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
                *       file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
                *       files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
                *       server to access your resources when servicing your users' transfer requests.</p>
                */
            Role?: string;
            /**
                * <p>A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.</p>
                */
            ServerId: string | undefined;
            /**
                * <p>A unique identifier that is required to identify specific groups within your directory.
                *     The users of the group that you associate have access to your Amazon S3 or Amazon EFS
                *     resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name,
                *     you can view the SID values by running the following command using Windows PowerShell.</p>
                *
                *          <p>
                *             <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamAccountName,ObjectSid</code>
                *          </p>
                *
                *          <p>In that command, replace <i>YourGroupName</i> with the name of your Active Directory group.</p>
                *
                *          <p>The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces.
                *     You can also include underscores or any of the following characters: =,.@:/-</p>
                */
            ExternalId: string | undefined;
    }
    export namespace UpdateAccessRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateAccessRequest) => any;
    }
    export interface UpdateAccessResponse {
            /**
                * <p>The ID of the server that the user is attached to.</p>
                */
            ServerId: string | undefined;
            /**
                * <p>The external ID of the group whose users have access to your Amazon S3 or Amazon EFS
                *       resources over the enabled protocols using Amazon Web ServicesTransfer Family.</p>
                */
            ExternalId: string | undefined;
    }
    export namespace UpdateAccessResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateAccessResponse) => any;
    }
    export interface UpdateServerRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the Amazon Web ServicesCertificate Manager (ACM) certificate. Required
                *       when <code>Protocols</code> is set to <code>FTPS</code>.</p>
                *
                *          <p>To request a new public certificate, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html">Request a public certificate</a>
                *       in the <i> Amazon Web ServicesCertificate Manager User Guide</i>.</p>
                *
                *          <p>To import an existing certificate into ACM, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html">Importing certificates into ACM</a>
                *       in the <i> Amazon Web ServicesCertificate Manager User Guide</i>.</p>
                *
                *          <p>To request a private certificate to use FTPS through private IP addresses, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html">Request a
                *         private certificate</a> in the <i> Amazon Web ServicesCertificate Manager User
                *       Guide</i>.</p>
                *
                *          <p>Certificates with the following cryptographic algorithms and key sizes are
                *       supported:</p>
                *
                *          <ul>
                *             <li>
                *                <p>2048-bit RSA (RSA_2048)</p>
                *             </li>
                *             <li>
                *                <p>4096-bit RSA (RSA_4096)</p>
                *             </li>
                *             <li>
                *                <p>Elliptic Prime Curve 256 bit (EC_prime256v1)</p>
                *             </li>
                *             <li>
                *                <p>Elliptic Prime Curve 384 bit (EC_secp384r1)</p>
                *             </li>
                *             <li>
                *                <p>Elliptic Prime Curve 521 bit (EC_secp521r1)</p>
                *             </li>
                *          </ul>
                *
                *          <note>
                *             <p>The certificate must be a valid SSL/TLS X.509 version 3 certificate with FQDN or IP
                *         address specified and information about the issuer.</p>
                *          </note>
                */
            Certificate?: string;
            /**
                * <p>The protocol settings that are configured for your server.</p>
                *          <ul>
                *             <li>
                *                <p>
                *           Use the <code>PassiveIp</code> parameter to indicate passive mode (for FTP and FTPS protocols).
                *           Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer.
                *         </p>
                *             </li>
                *             <li>
                *                <p>Use the <code>SetStatOption</code> to ignore the error that is generated when the client attempts to use SETSTAT on a file you are uploading to an S3 bucket.
                *         Set the value to <code>ENABLE_NO_OP</code> to have the Transfer Family server ignore the SETSTAT command, and upload files without needing to make any changes to your SFTP client.
                *         Note that with <code>SetStatOption</code> set to <code>ENABLE_NO_OP</code>, Transfer generates a log entry to CloudWatch Logs, so you can determine when the client
                *         is making a SETSTAT call.</p>
                *             </li>
                *             <li>
                *                <p>Use the <code>TlsSessionResumptionMode</code> parameter to determine whether or not your Transfer server
                *           resumes recent, negotiated sessions through a unique session ID.</p>
                *             </li>
                *          </ul>
                */
            ProtocolDetails?: ProtocolDetails;
            /**
                * <p>The virtual private cloud (VPC) endpoint settings that are configured for your server.
                *       When you host your endpoint within your VPC, you can make it accessible only to resources
                *       within your VPC, or you can attach Elastic IP addresses and make it accessible to clients over
                *       the internet. Your VPC's default security groups are automatically assigned to your
                *       endpoint.</p>
                */
            EndpointDetails?: EndpointDetails;
            /**
                * <p>The type of endpoint that you want your server to use. You can choose to make your server's endpoint publicly accessible (PUBLIC)
                *       or host it inside your VPC. With an endpoint that is hosted in a VPC, you can restrict access to your server and
                *       resources only within your VPC or choose to make it internet facing by attaching Elastic IP addresses directly to it.</p>
                *          <note>
                *             <p> After May 19, 2021, you won't be able to create a server using
                *           <code>EndpointType=VPC_ENDPOINT</code> in your Amazon Web Servicesaccount if your account hasn't already
                *       done so before May 19, 2021. If you have already created servers with
                *       <code>EndpointType=VPC_ENDPOINT</code> in your Amazon Web Servicesaccount on or before May 19, 2021,
                *         you will not be affected. After this date, use
                *         <code>EndpointType</code>=<code>VPC</code>.</p>
                *
                *             <p>For more information, see
                *         https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.</p>
                *             <p>It is recommended that you use <code>VPC</code> as the <code>EndpointType</code>. With
                *         this endpoint type, you have the option to directly associate up to three Elastic IPv4
                *         addresses (BYO IP included) with your server's endpoint and use VPC security groups to
                *         restrict traffic by the client's public IP address. This is not possible with
                *           <code>EndpointType</code> set to <code>VPC_ENDPOINT</code>.</p>
                *          </note>
                */
            EndpointType?: EndpointType | string;
            /**
                * <p>The RSA, ECDSA, or ED25519 private key to use for your server.</p>
                *
                *          <p>Use the following command to generate an RSA 2048 bit key with no passphrase:</p>
                *          <p>
                *             <code>ssh-keygen -t rsa -b 2048 -N "" -m PEM -f my-new-server-key</code>.</p>
                *          <p>Use a minimum value of 2048 for the <code>-b</code> option: you can create a stronger key using 3072 or 4096.</p>
                *
                *          <p>Use the following command to generate an ECDSA 256 bit key with no passphrase:</p>
                *          <p>
                *             <code>ssh-keygen -t ecdsa -b 256 -N "" -m PEM -f my-new-server-key</code>.</p>
                *          <p>Valid values for the <code>-b</code> option for ECDSA are 256, 384, and 521.</p>
                *
                *          <p>Use the following command to generate an ED25519 key with no passphrase:</p>
                *          <p>
                *             <code>ssh-keygen -t ed25519 -N "" -f my-new-server-key</code>.</p>
                *
                *          <p>For all of these commands, you can replace <i>my-new-server-key</i> with a string of your choice.</p>
                *
                *          <important>
                *             <p>If you aren't planning to migrate existing users from an existing SFTP-enabled
                *         server to a new server, don't update the host key. Accidentally changing a
                *         server's host key can be disruptive.</p>
                *          </important>
                *
                *
                *
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key">Change the host key for your SFTP-enabled server</a> in the <i>Amazon Web Services Transfer
                *         Family User Guide</i>.</p>
                */
            HostKey?: string;
            /**
                * <p>An array containing all of the information required to call a customer's
                *       authentication API method.</p>
                */
            IdentityProviderDetails?: IdentityProviderDetails;
            /**
                * <p>Specifies the Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that allows a server to turn
                *       on Amazon CloudWatch logging for Amazon S3 or Amazon EFS events. When set, user activity can be viewed in
                *       your CloudWatch logs.</p>
                */
            LoggingRole?: string;
            /**
                * <p>Specify a string to display when users connect to a server. This string is displayed after the user authenticates.</p>
                *          <note>
                *             <p>The SFTP protocol does not support post-authentication display banners.</p>
                *          </note>
                */
            PostAuthenticationLoginBanner?: string;
            /**
                * <p>Specify a string to display when users connect to a server. This string is displayed before the user authenticates.
                *     For example, the following banner displays details about using the system.</p>
                *          <p>
                *             <code>This system is for the use of authorized users only. Individuals using this computer system without authority,
                *     or in excess of their authority, are subject to having all of their activities on this system monitored and recorded by
                *     system personnel.</code>
                *          </p>
                */
            PreAuthenticationLoginBanner?: string;
            /**
                * <p>Specifies the file transfer protocol or protocols over which your file transfer protocol
                *       client can connect to your server's endpoint. The available protocols are:</p>
                *
                *          <ul>
                *             <li>
                *                <p>Secure Shell (SSH) File Transfer Protocol (SFTP): File transfer over SSH</p>
                *             </li>
                *             <li>
                *                <p>File Transfer Protocol Secure (FTPS): File transfer with TLS encryption</p>
                *             </li>
                *             <li>
                *                <p>File Transfer Protocol (FTP): Unencrypted file transfer</p>
                *             </li>
                *          </ul>
                *
                *          <note>
                *             <p>If you select <code>FTPS</code>, you must choose a certificate stored in Amazon Web ServicesCertificate
                *         Manager (ACM) which will be used to identify your server when clients connect to it over
                *         FTPS.</p>
                *
                *
                *             <p>If <code>Protocol</code> includes either <code>FTP</code> or <code>FTPS</code>, then the
                *         <code>EndpointType</code> must be <code>VPC</code> and the
                *         <code>IdentityProviderType</code> must be <code>AWS_DIRECTORY_SERVICE</code> or <code>API_GATEWAY</code>.</p>
                *
                *             <p>If <code>Protocol</code> includes <code>FTP</code>, then
                *           <code>AddressAllocationIds</code> cannot be associated.</p>
                *
                *             <p>If <code>Protocol</code> is set only to <code>SFTP</code>, the <code>EndpointType</code>
                *         can be set to <code>PUBLIC</code> and the <code>IdentityProviderType</code> can be set to
                *           <code>SERVICE_MANAGED</code>.</p>
                *          </note>
                */
            Protocols?: (Protocol | string)[];
            /**
                * <p>Specifies the name of the security policy that is attached to the server.</p>
                */
            SecurityPolicyName?: string;
            /**
                * <p>A system-assigned unique identifier for a server instance that the user account is
                *       assigned to.</p>
                */
            ServerId: string | undefined;
            /**
                * <p>Specifies the workflow ID for the workflow to assign and the execution role used for executing the workflow.</p>
                *          <p>To remove an associated workflow from a server, you can provide an empty <code>OnUpload</code> object, as in the following example.</p>
                *          <p>
                *             <code>aws transfer update-server --server-id s-01234567890abcdef --workflow-details '{"OnUpload":[]}'</code>
                *          </p>
                */
            WorkflowDetails?: WorkflowDetails;
    }
    export namespace UpdateServerRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateServerRequest) => any;
    }
    export interface UpdateServerResponse {
            /**
                * <p>A system-assigned unique identifier for a server that the user account is assigned
                *       to.</p>
                */
            ServerId: string | undefined;
    }
    export namespace UpdateServerResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateServerResponse) => any;
    }
    export interface UpdateUserRequest {
            /**
                * <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
                *          <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
                */
            HomeDirectory?: string;
            /**
                * <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
                *     If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
                *     If you set it <code>LOGICAL</code>, you need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
                *     S3 or EFS paths visible to your users.</p>
                */
            HomeDirectoryType?: HomeDirectoryType | string;
            /**
                * <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
                *       be visible to your user and how you want to make them visible. You must specify the
                *         <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
                *       is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
                *       only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity
                *       and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
                *       can only be set when <code>HomeDirectoryType</code> is set to
                *       <i>LOGICAL</i>.</p>
                *
                *          <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
                *          <p>
                *             <code>[ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ]</code>
                *          </p>
                *
                *          <p>In most cases, you can use this value instead of the session policy to lock down your
                *       user to the designated home directory ("<code>chroot</code>"). To do this, you can set
                *         <code>Entry</code> to '/' and set <code>Target</code> to the HomeDirectory
                *       parameter value.</p>
                *
                *          <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p>
                *          <p>
                *             <code>[ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
                *          </p>
                */
            HomeDirectoryMappings?: HomeDirectoryMapEntry[];
            /**
                * <p>A session policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user
                *      access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include <code>${Transfer:UserName}</code>,
                *      <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
                *
                *          <note>
                *             <p>This only applies when the domain of <code>ServerId</code> is S3. EFS does not use session policies.</p>
                *             <p>For session policies, Amazon Web Services Transfer Family stores the policy as a JSON blob, instead
                *         of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass
                *         it in the <code>Policy</code> argument.</p>
                *
                *
                *
                *             <p>For an example of a session policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/session-policy">Creating a session
                *           policy</a>.</p>
                *
                *
                *
                *             <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>Amazon Web Services
                *           Security Token Service API Reference</i>.</p>
                *          </note>
                */
            Policy?: string;
            /**
                * <p>Specifies the full POSIX identity, including user ID (<code>Uid</code>), group ID
                *         (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
                *       your users' access to your Amazon Elastic File Systems (Amazon EFS). The POSIX permissions
                *       that are set on files and directories in your file system determines the level of access your
                *       users get when transferring files into and out of your Amazon EFS file systems.</p>
                */
            PosixProfile?: PosixProfile;
            /**
                * <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
                *       file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
                *       files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
                *       server to access your resources when servicing your users' transfer requests.</p>
                */
            Role?: string;
            /**
                * <p>A system-assigned unique identifier for a server instance that the user account is
                *       assigned to.</p>
                */
            ServerId: string | undefined;
            /**
                * <p>A unique string that identifies a user and is associated with a server as specified by the
                *         <code>ServerId</code>. This user name must be a minimum of 3 and a maximum of 100 characters
                *       long. The following are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen
                *       '-', period '.', and at sign '@'. The user name can't start
                *       with a hyphen, period, or at sign.</p>
                */
            UserName: string | undefined;
    }
    export namespace UpdateUserRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateUserRequest) => any;
    }
    /**
        * <p>
        *             <code>UpdateUserResponse</code> returns the user name and identifier for the request to
        *       update a user's properties.</p>
        */
    export interface UpdateUserResponse {
            /**
                * <p>A system-assigned unique identifier for a server instance that the user account is
                *       assigned to.</p>
                */
            ServerId: string | undefined;
            /**
                * <p>The unique identifier for a user that is assigned to a server instance that was specified
                *       in the request.</p>
                */
            UserName: string | undefined;
    }
    export namespace UpdateUserResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateUserResponse) => any;
    }
}

declare module '@aws-sdk/client-transfer/node_modules/@aws-sdk/client-transfer/dist-types/models/TransferServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from Transfer service.
        */
    export class TransferServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

