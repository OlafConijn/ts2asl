// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/smithy-client
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http

declare module '@aws-sdk/client-emr-containers' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { CancelJobRunCommandInput, CancelJobRunCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/CancelJobRunCommand";
    import { CreateManagedEndpointCommandInput, CreateManagedEndpointCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/CreateManagedEndpointCommand";
    import { CreateVirtualClusterCommandInput, CreateVirtualClusterCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/CreateVirtualClusterCommand";
    import { DeleteManagedEndpointCommandInput, DeleteManagedEndpointCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/DeleteManagedEndpointCommand";
    import { DeleteVirtualClusterCommandInput, DeleteVirtualClusterCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/DeleteVirtualClusterCommand";
    import { DescribeJobRunCommandInput, DescribeJobRunCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/DescribeJobRunCommand";
    import { DescribeManagedEndpointCommandInput, DescribeManagedEndpointCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/DescribeManagedEndpointCommand";
    import { DescribeVirtualClusterCommandInput, DescribeVirtualClusterCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/DescribeVirtualClusterCommand";
    import { ListJobRunsCommandInput, ListJobRunsCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/ListJobRunsCommand";
    import { ListManagedEndpointsCommandInput, ListManagedEndpointsCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/ListManagedEndpointsCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/ListTagsForResourceCommand";
    import { ListVirtualClustersCommandInput, ListVirtualClustersCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/ListVirtualClustersCommand";
    import { StartJobRunCommandInput, StartJobRunCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/StartJobRunCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/UntagResourceCommand";
    import { EMRContainersClient } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/EMRContainersClient";
    /**
        * <p>Amazon EMR on EKS provides a deployment option for Amazon EMR that allows you to run
        *          open-source big data frameworks on Amazon Elastic Kubernetes Service (Amazon EKS). With
        *          this deployment option, you can focus on running analytics workloads while Amazon EMR on
        *          EKS builds, configures, and manages containers for open-source applications. For more
        *          information about Amazon EMR on EKS concepts and tasks, see <a href="https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/emr-eks.html">What is Amazon EMR on EKS</a>.</p>
        *          <p>
        *             <i>Amazon EMR containers</i> is the API name for Amazon EMR on EKS. The
        *             <code>emr-containers</code> prefix is used in the following scenarios: </p>
        *          <ul>
        *             <li>
        *                <p>It is the prefix in the CLI commands for Amazon EMR on EKS. For example, <code>aws
        *                   emr-containers start-job-run</code>.</p>
        *             </li>
        *             <li>
        *                <p>It is the prefix before IAM policy actions for Amazon EMR on EKS. For example, <code>"Action": [
        *             "emr-containers:StartJobRun"]</code>. For more information, see <a href="https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/security_iam_service-with-iam.html#security_iam_service-with-iam-id-based-policies-actions">Policy actions for Amazon EMR on EKS</a>.</p>
        *             </li>
        *             <li>
        *                <p>It is the prefix used in Amazon EMR on EKS service endpoints. For example, <code>emr-containers.us-east-2.amazonaws.com</code>. For more
        *             information, see <a href="https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/service-quotas.html#service-endpoints">Amazon EMR on EKS Service Endpoints</a>.</p>
        *             </li>
        *          </ul>
        */
    export class EMRContainers extends EMRContainersClient {
            /**
                * <p>Cancels a job run. A job run is a unit of work, such as a Spark jar, PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.</p>
                */
            cancelJobRun(args: CancelJobRunCommandInput, options?: __HttpHandlerOptions): Promise<CancelJobRunCommandOutput>;
            cancelJobRun(args: CancelJobRunCommandInput, cb: (err: any, data?: CancelJobRunCommandOutput) => void): void;
            cancelJobRun(args: CancelJobRunCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CancelJobRunCommandOutput) => void): void;
            /**
                * <p>Creates a managed endpoint. A managed endpoint is a gateway that connects EMR Studio to Amazon EMR on EKS so that EMR Studio can communicate with your virtual cluster.</p>
                */
            createManagedEndpoint(args: CreateManagedEndpointCommandInput, options?: __HttpHandlerOptions): Promise<CreateManagedEndpointCommandOutput>;
            createManagedEndpoint(args: CreateManagedEndpointCommandInput, cb: (err: any, data?: CreateManagedEndpointCommandOutput) => void): void;
            createManagedEndpoint(args: CreateManagedEndpointCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateManagedEndpointCommandOutput) => void): void;
            /**
                * <p>Creates a virtual cluster. Virtual cluster is a managed entity on Amazon EMR on EKS. You can create, describe, list and delete virtual clusters. They do not consume any additional resource in your system. A single virtual cluster maps to a single Kubernetes namespace. Given this relationship, you can model virtual clusters the same way you model Kubernetes namespaces to meet your requirements.</p>
                */
            createVirtualCluster(args: CreateVirtualClusterCommandInput, options?: __HttpHandlerOptions): Promise<CreateVirtualClusterCommandOutput>;
            createVirtualCluster(args: CreateVirtualClusterCommandInput, cb: (err: any, data?: CreateVirtualClusterCommandOutput) => void): void;
            createVirtualCluster(args: CreateVirtualClusterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateVirtualClusterCommandOutput) => void): void;
            /**
                * <p>Deletes a managed endpoint. A managed endpoint is a gateway that connects EMR Studio to Amazon EMR on EKS so that EMR Studio can communicate with your virtual cluster.</p>
                */
            deleteManagedEndpoint(args: DeleteManagedEndpointCommandInput, options?: __HttpHandlerOptions): Promise<DeleteManagedEndpointCommandOutput>;
            deleteManagedEndpoint(args: DeleteManagedEndpointCommandInput, cb: (err: any, data?: DeleteManagedEndpointCommandOutput) => void): void;
            deleteManagedEndpoint(args: DeleteManagedEndpointCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteManagedEndpointCommandOutput) => void): void;
            /**
                * <p>Deletes a virtual cluster. Virtual cluster is a managed entity on Amazon EMR on EKS. You can create, describe, list and delete virtual clusters. They do not consume any additional resource in your system. A single virtual cluster maps to a single Kubernetes namespace. Given this relationship, you can model virtual clusters the same way you model Kubernetes namespaces to meet your requirements.</p>
                */
            deleteVirtualCluster(args: DeleteVirtualClusterCommandInput, options?: __HttpHandlerOptions): Promise<DeleteVirtualClusterCommandOutput>;
            deleteVirtualCluster(args: DeleteVirtualClusterCommandInput, cb: (err: any, data?: DeleteVirtualClusterCommandOutput) => void): void;
            deleteVirtualCluster(args: DeleteVirtualClusterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteVirtualClusterCommandOutput) => void): void;
            /**
                * <p>Displays detailed information about a job run. A job run is a unit of work, such as a Spark jar, PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.</p>
                */
            describeJobRun(args: DescribeJobRunCommandInput, options?: __HttpHandlerOptions): Promise<DescribeJobRunCommandOutput>;
            describeJobRun(args: DescribeJobRunCommandInput, cb: (err: any, data?: DescribeJobRunCommandOutput) => void): void;
            describeJobRun(args: DescribeJobRunCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeJobRunCommandOutput) => void): void;
            /**
                * <p>Displays detailed information about a managed endpoint. A managed endpoint is a gateway that connects EMR Studio to Amazon EMR on EKS so that EMR Studio can communicate with your virtual cluster.</p>
                */
            describeManagedEndpoint(args: DescribeManagedEndpointCommandInput, options?: __HttpHandlerOptions): Promise<DescribeManagedEndpointCommandOutput>;
            describeManagedEndpoint(args: DescribeManagedEndpointCommandInput, cb: (err: any, data?: DescribeManagedEndpointCommandOutput) => void): void;
            describeManagedEndpoint(args: DescribeManagedEndpointCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeManagedEndpointCommandOutput) => void): void;
            /**
                * <p>Displays detailed information about a specified virtual cluster. Virtual cluster is a managed entity on Amazon EMR on EKS. You can create, describe, list and delete virtual clusters. They do not consume any additional resource in your system. A single virtual cluster maps to a single Kubernetes namespace. Given this relationship, you can model virtual clusters the same way you model Kubernetes namespaces to meet your requirements.</p>
                */
            describeVirtualCluster(args: DescribeVirtualClusterCommandInput, options?: __HttpHandlerOptions): Promise<DescribeVirtualClusterCommandOutput>;
            describeVirtualCluster(args: DescribeVirtualClusterCommandInput, cb: (err: any, data?: DescribeVirtualClusterCommandOutput) => void): void;
            describeVirtualCluster(args: DescribeVirtualClusterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeVirtualClusterCommandOutput) => void): void;
            /**
                * <p>Lists job runs based on a set of parameters. A job run is a unit of work, such as a Spark jar, PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.</p>
                */
            listJobRuns(args: ListJobRunsCommandInput, options?: __HttpHandlerOptions): Promise<ListJobRunsCommandOutput>;
            listJobRuns(args: ListJobRunsCommandInput, cb: (err: any, data?: ListJobRunsCommandOutput) => void): void;
            listJobRuns(args: ListJobRunsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListJobRunsCommandOutput) => void): void;
            /**
                * <p>Lists managed endpoints based on a set of parameters. A managed endpoint is a gateway that connects EMR Studio to Amazon EMR on EKS so that EMR Studio can communicate with your virtual cluster.</p>
                */
            listManagedEndpoints(args: ListManagedEndpointsCommandInput, options?: __HttpHandlerOptions): Promise<ListManagedEndpointsCommandOutput>;
            listManagedEndpoints(args: ListManagedEndpointsCommandInput, cb: (err: any, data?: ListManagedEndpointsCommandOutput) => void): void;
            listManagedEndpoints(args: ListManagedEndpointsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListManagedEndpointsCommandOutput) => void): void;
            /**
                * <p>Lists the tags assigned to the resources.</p>
                */
            listTagsForResource(args: ListTagsForResourceCommandInput, options?: __HttpHandlerOptions): Promise<ListTagsForResourceCommandOutput>;
            listTagsForResource(args: ListTagsForResourceCommandInput, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            listTagsForResource(args: ListTagsForResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            /**
                * <p>Lists information about the specified virtual cluster. Virtual cluster is a managed entity on Amazon EMR on EKS. You can create, describe, list and delete virtual clusters. They do not consume any additional resource in your system. A single virtual cluster maps to a single Kubernetes namespace. Given this relationship, you can model virtual clusters the same way you model Kubernetes namespaces to meet your requirements.</p>
                */
            listVirtualClusters(args: ListVirtualClustersCommandInput, options?: __HttpHandlerOptions): Promise<ListVirtualClustersCommandOutput>;
            listVirtualClusters(args: ListVirtualClustersCommandInput, cb: (err: any, data?: ListVirtualClustersCommandOutput) => void): void;
            listVirtualClusters(args: ListVirtualClustersCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListVirtualClustersCommandOutput) => void): void;
            /**
                * <p>Starts a job run. A job run is a unit of work, such as a Spark jar, PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.</p>
                */
            startJobRun(args: StartJobRunCommandInput, options?: __HttpHandlerOptions): Promise<StartJobRunCommandOutput>;
            startJobRun(args: StartJobRunCommandInput, cb: (err: any, data?: StartJobRunCommandOutput) => void): void;
            startJobRun(args: StartJobRunCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: StartJobRunCommandOutput) => void): void;
            /**
                * <p>Assigns tags to resources. A tag is a label that you assign to an AWS resource. Each tag consists of a key and an optional value, both of which you define. Tags enable you to categorize your AWS resources by attributes such as purpose, owner, or environment. When you have many resources of the same type, you can quickly identify a specific resource based on the tags you've assigned to it. For example, you can define a set of tags for your Amazon EMR on EKS clusters to help you track each cluster's owner and stack level. We recommend that you devise a consistent set of tag keys for each resource type. You can then search and filter the resources based on the tags that you add.</p>
                */
            tagResource(args: TagResourceCommandInput, options?: __HttpHandlerOptions): Promise<TagResourceCommandOutput>;
            tagResource(args: TagResourceCommandInput, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            tagResource(args: TagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            /**
                * <p>Removes tags from resources.</p>
                */
            untagResource(args: UntagResourceCommandInput, options?: __HttpHandlerOptions): Promise<UntagResourceCommandOutput>;
            untagResource(args: UntagResourceCommandInput, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            untagResource(args: UntagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/CancelJobRunCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EMRContainersClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/EMRContainersClient";
    import { CancelJobRunRequest, CancelJobRunResponse } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/models/models_0";
    export interface CancelJobRunCommandInput extends CancelJobRunRequest {
    }
    export interface CancelJobRunCommandOutput extends CancelJobRunResponse, __MetadataBearer {
    }
    /**
        * <p>Cancels a job run. A job run is a unit of work, such as a Spark jar, PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EMRContainersClient, CancelJobRunCommand } from "@aws-sdk/client-emr-containers"; // ES Modules import
        * // const { EMRContainersClient, CancelJobRunCommand } = require("@aws-sdk/client-emr-containers"); // CommonJS import
        * const client = new EMRContainersClient(config);
        * const command = new CancelJobRunCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CancelJobRunCommandInput} for command's `input` shape.
        * @see {@link CancelJobRunCommandOutput} for command's `response` shape.
        * @see {@link EMRContainersClientResolvedConfig | config} for EMRContainersClient's `config` shape.
        *
        */
    export class CancelJobRunCommand extends $Command<CancelJobRunCommandInput, CancelJobRunCommandOutput, EMRContainersClientResolvedConfig> {
            readonly input: CancelJobRunCommandInput;
            constructor(input: CancelJobRunCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EMRContainersClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CancelJobRunCommandInput, CancelJobRunCommandOutput>;
    }
}

declare module '@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/CreateManagedEndpointCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EMRContainersClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/EMRContainersClient";
    import { CreateManagedEndpointRequest, CreateManagedEndpointResponse } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/models/models_0";
    export interface CreateManagedEndpointCommandInput extends CreateManagedEndpointRequest {
    }
    export interface CreateManagedEndpointCommandOutput extends CreateManagedEndpointResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a managed endpoint. A managed endpoint is a gateway that connects EMR Studio to Amazon EMR on EKS so that EMR Studio can communicate with your virtual cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EMRContainersClient, CreateManagedEndpointCommand } from "@aws-sdk/client-emr-containers"; // ES Modules import
        * // const { EMRContainersClient, CreateManagedEndpointCommand } = require("@aws-sdk/client-emr-containers"); // CommonJS import
        * const client = new EMRContainersClient(config);
        * const command = new CreateManagedEndpointCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateManagedEndpointCommandInput} for command's `input` shape.
        * @see {@link CreateManagedEndpointCommandOutput} for command's `response` shape.
        * @see {@link EMRContainersClientResolvedConfig | config} for EMRContainersClient's `config` shape.
        *
        */
    export class CreateManagedEndpointCommand extends $Command<CreateManagedEndpointCommandInput, CreateManagedEndpointCommandOutput, EMRContainersClientResolvedConfig> {
            readonly input: CreateManagedEndpointCommandInput;
            constructor(input: CreateManagedEndpointCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EMRContainersClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateManagedEndpointCommandInput, CreateManagedEndpointCommandOutput>;
    }
}

declare module '@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/CreateVirtualClusterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EMRContainersClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/EMRContainersClient";
    import { CreateVirtualClusterRequest, CreateVirtualClusterResponse } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/models/models_0";
    export interface CreateVirtualClusterCommandInput extends CreateVirtualClusterRequest {
    }
    export interface CreateVirtualClusterCommandOutput extends CreateVirtualClusterResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a virtual cluster. Virtual cluster is a managed entity on Amazon EMR on EKS. You can create, describe, list and delete virtual clusters. They do not consume any additional resource in your system. A single virtual cluster maps to a single Kubernetes namespace. Given this relationship, you can model virtual clusters the same way you model Kubernetes namespaces to meet your requirements.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EMRContainersClient, CreateVirtualClusterCommand } from "@aws-sdk/client-emr-containers"; // ES Modules import
        * // const { EMRContainersClient, CreateVirtualClusterCommand } = require("@aws-sdk/client-emr-containers"); // CommonJS import
        * const client = new EMRContainersClient(config);
        * const command = new CreateVirtualClusterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateVirtualClusterCommandInput} for command's `input` shape.
        * @see {@link CreateVirtualClusterCommandOutput} for command's `response` shape.
        * @see {@link EMRContainersClientResolvedConfig | config} for EMRContainersClient's `config` shape.
        *
        */
    export class CreateVirtualClusterCommand extends $Command<CreateVirtualClusterCommandInput, CreateVirtualClusterCommandOutput, EMRContainersClientResolvedConfig> {
            readonly input: CreateVirtualClusterCommandInput;
            constructor(input: CreateVirtualClusterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EMRContainersClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateVirtualClusterCommandInput, CreateVirtualClusterCommandOutput>;
    }
}

declare module '@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/DeleteManagedEndpointCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EMRContainersClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/EMRContainersClient";
    import { DeleteManagedEndpointRequest, DeleteManagedEndpointResponse } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/models/models_0";
    export interface DeleteManagedEndpointCommandInput extends DeleteManagedEndpointRequest {
    }
    export interface DeleteManagedEndpointCommandOutput extends DeleteManagedEndpointResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes a managed endpoint. A managed endpoint is a gateway that connects EMR Studio to Amazon EMR on EKS so that EMR Studio can communicate with your virtual cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EMRContainersClient, DeleteManagedEndpointCommand } from "@aws-sdk/client-emr-containers"; // ES Modules import
        * // const { EMRContainersClient, DeleteManagedEndpointCommand } = require("@aws-sdk/client-emr-containers"); // CommonJS import
        * const client = new EMRContainersClient(config);
        * const command = new DeleteManagedEndpointCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteManagedEndpointCommandInput} for command's `input` shape.
        * @see {@link DeleteManagedEndpointCommandOutput} for command's `response` shape.
        * @see {@link EMRContainersClientResolvedConfig | config} for EMRContainersClient's `config` shape.
        *
        */
    export class DeleteManagedEndpointCommand extends $Command<DeleteManagedEndpointCommandInput, DeleteManagedEndpointCommandOutput, EMRContainersClientResolvedConfig> {
            readonly input: DeleteManagedEndpointCommandInput;
            constructor(input: DeleteManagedEndpointCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EMRContainersClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteManagedEndpointCommandInput, DeleteManagedEndpointCommandOutput>;
    }
}

declare module '@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/DeleteVirtualClusterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EMRContainersClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/EMRContainersClient";
    import { DeleteVirtualClusterRequest, DeleteVirtualClusterResponse } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/models/models_0";
    export interface DeleteVirtualClusterCommandInput extends DeleteVirtualClusterRequest {
    }
    export interface DeleteVirtualClusterCommandOutput extends DeleteVirtualClusterResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes a virtual cluster. Virtual cluster is a managed entity on Amazon EMR on EKS. You can create, describe, list and delete virtual clusters. They do not consume any additional resource in your system. A single virtual cluster maps to a single Kubernetes namespace. Given this relationship, you can model virtual clusters the same way you model Kubernetes namespaces to meet your requirements.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EMRContainersClient, DeleteVirtualClusterCommand } from "@aws-sdk/client-emr-containers"; // ES Modules import
        * // const { EMRContainersClient, DeleteVirtualClusterCommand } = require("@aws-sdk/client-emr-containers"); // CommonJS import
        * const client = new EMRContainersClient(config);
        * const command = new DeleteVirtualClusterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteVirtualClusterCommandInput} for command's `input` shape.
        * @see {@link DeleteVirtualClusterCommandOutput} for command's `response` shape.
        * @see {@link EMRContainersClientResolvedConfig | config} for EMRContainersClient's `config` shape.
        *
        */
    export class DeleteVirtualClusterCommand extends $Command<DeleteVirtualClusterCommandInput, DeleteVirtualClusterCommandOutput, EMRContainersClientResolvedConfig> {
            readonly input: DeleteVirtualClusterCommandInput;
            constructor(input: DeleteVirtualClusterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EMRContainersClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteVirtualClusterCommandInput, DeleteVirtualClusterCommandOutput>;
    }
}

declare module '@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/DescribeJobRunCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EMRContainersClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/EMRContainersClient";
    import { DescribeJobRunRequest, DescribeJobRunResponse } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/models/models_0";
    export interface DescribeJobRunCommandInput extends DescribeJobRunRequest {
    }
    export interface DescribeJobRunCommandOutput extends DescribeJobRunResponse, __MetadataBearer {
    }
    /**
        * <p>Displays detailed information about a job run. A job run is a unit of work, such as a Spark jar, PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EMRContainersClient, DescribeJobRunCommand } from "@aws-sdk/client-emr-containers"; // ES Modules import
        * // const { EMRContainersClient, DescribeJobRunCommand } = require("@aws-sdk/client-emr-containers"); // CommonJS import
        * const client = new EMRContainersClient(config);
        * const command = new DescribeJobRunCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeJobRunCommandInput} for command's `input` shape.
        * @see {@link DescribeJobRunCommandOutput} for command's `response` shape.
        * @see {@link EMRContainersClientResolvedConfig | config} for EMRContainersClient's `config` shape.
        *
        */
    export class DescribeJobRunCommand extends $Command<DescribeJobRunCommandInput, DescribeJobRunCommandOutput, EMRContainersClientResolvedConfig> {
            readonly input: DescribeJobRunCommandInput;
            constructor(input: DescribeJobRunCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EMRContainersClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeJobRunCommandInput, DescribeJobRunCommandOutput>;
    }
}

declare module '@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/DescribeManagedEndpointCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EMRContainersClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/EMRContainersClient";
    import { DescribeManagedEndpointRequest, DescribeManagedEndpointResponse } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/models/models_0";
    export interface DescribeManagedEndpointCommandInput extends DescribeManagedEndpointRequest {
    }
    export interface DescribeManagedEndpointCommandOutput extends DescribeManagedEndpointResponse, __MetadataBearer {
    }
    /**
        * <p>Displays detailed information about a managed endpoint. A managed endpoint is a gateway that connects EMR Studio to Amazon EMR on EKS so that EMR Studio can communicate with your virtual cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EMRContainersClient, DescribeManagedEndpointCommand } from "@aws-sdk/client-emr-containers"; // ES Modules import
        * // const { EMRContainersClient, DescribeManagedEndpointCommand } = require("@aws-sdk/client-emr-containers"); // CommonJS import
        * const client = new EMRContainersClient(config);
        * const command = new DescribeManagedEndpointCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeManagedEndpointCommandInput} for command's `input` shape.
        * @see {@link DescribeManagedEndpointCommandOutput} for command's `response` shape.
        * @see {@link EMRContainersClientResolvedConfig | config} for EMRContainersClient's `config` shape.
        *
        */
    export class DescribeManagedEndpointCommand extends $Command<DescribeManagedEndpointCommandInput, DescribeManagedEndpointCommandOutput, EMRContainersClientResolvedConfig> {
            readonly input: DescribeManagedEndpointCommandInput;
            constructor(input: DescribeManagedEndpointCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EMRContainersClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeManagedEndpointCommandInput, DescribeManagedEndpointCommandOutput>;
    }
}

declare module '@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/DescribeVirtualClusterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EMRContainersClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/EMRContainersClient";
    import { DescribeVirtualClusterRequest, DescribeVirtualClusterResponse } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/models/models_0";
    export interface DescribeVirtualClusterCommandInput extends DescribeVirtualClusterRequest {
    }
    export interface DescribeVirtualClusterCommandOutput extends DescribeVirtualClusterResponse, __MetadataBearer {
    }
    /**
        * <p>Displays detailed information about a specified virtual cluster. Virtual cluster is a managed entity on Amazon EMR on EKS. You can create, describe, list and delete virtual clusters. They do not consume any additional resource in your system. A single virtual cluster maps to a single Kubernetes namespace. Given this relationship, you can model virtual clusters the same way you model Kubernetes namespaces to meet your requirements.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EMRContainersClient, DescribeVirtualClusterCommand } from "@aws-sdk/client-emr-containers"; // ES Modules import
        * // const { EMRContainersClient, DescribeVirtualClusterCommand } = require("@aws-sdk/client-emr-containers"); // CommonJS import
        * const client = new EMRContainersClient(config);
        * const command = new DescribeVirtualClusterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeVirtualClusterCommandInput} for command's `input` shape.
        * @see {@link DescribeVirtualClusterCommandOutput} for command's `response` shape.
        * @see {@link EMRContainersClientResolvedConfig | config} for EMRContainersClient's `config` shape.
        *
        */
    export class DescribeVirtualClusterCommand extends $Command<DescribeVirtualClusterCommandInput, DescribeVirtualClusterCommandOutput, EMRContainersClientResolvedConfig> {
            readonly input: DescribeVirtualClusterCommandInput;
            constructor(input: DescribeVirtualClusterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EMRContainersClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeVirtualClusterCommandInput, DescribeVirtualClusterCommandOutput>;
    }
}

declare module '@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/ListJobRunsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EMRContainersClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/EMRContainersClient";
    import { ListJobRunsRequest, ListJobRunsResponse } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/models/models_0";
    export interface ListJobRunsCommandInput extends ListJobRunsRequest {
    }
    export interface ListJobRunsCommandOutput extends ListJobRunsResponse, __MetadataBearer {
    }
    /**
        * <p>Lists job runs based on a set of parameters. A job run is a unit of work, such as a Spark jar, PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EMRContainersClient, ListJobRunsCommand } from "@aws-sdk/client-emr-containers"; // ES Modules import
        * // const { EMRContainersClient, ListJobRunsCommand } = require("@aws-sdk/client-emr-containers"); // CommonJS import
        * const client = new EMRContainersClient(config);
        * const command = new ListJobRunsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListJobRunsCommandInput} for command's `input` shape.
        * @see {@link ListJobRunsCommandOutput} for command's `response` shape.
        * @see {@link EMRContainersClientResolvedConfig | config} for EMRContainersClient's `config` shape.
        *
        */
    export class ListJobRunsCommand extends $Command<ListJobRunsCommandInput, ListJobRunsCommandOutput, EMRContainersClientResolvedConfig> {
            readonly input: ListJobRunsCommandInput;
            constructor(input: ListJobRunsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EMRContainersClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListJobRunsCommandInput, ListJobRunsCommandOutput>;
    }
}

declare module '@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/ListManagedEndpointsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EMRContainersClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/EMRContainersClient";
    import { ListManagedEndpointsRequest, ListManagedEndpointsResponse } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/models/models_0";
    export interface ListManagedEndpointsCommandInput extends ListManagedEndpointsRequest {
    }
    export interface ListManagedEndpointsCommandOutput extends ListManagedEndpointsResponse, __MetadataBearer {
    }
    /**
        * <p>Lists managed endpoints based on a set of parameters. A managed endpoint is a gateway that connects EMR Studio to Amazon EMR on EKS so that EMR Studio can communicate with your virtual cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EMRContainersClient, ListManagedEndpointsCommand } from "@aws-sdk/client-emr-containers"; // ES Modules import
        * // const { EMRContainersClient, ListManagedEndpointsCommand } = require("@aws-sdk/client-emr-containers"); // CommonJS import
        * const client = new EMRContainersClient(config);
        * const command = new ListManagedEndpointsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListManagedEndpointsCommandInput} for command's `input` shape.
        * @see {@link ListManagedEndpointsCommandOutput} for command's `response` shape.
        * @see {@link EMRContainersClientResolvedConfig | config} for EMRContainersClient's `config` shape.
        *
        */
    export class ListManagedEndpointsCommand extends $Command<ListManagedEndpointsCommandInput, ListManagedEndpointsCommandOutput, EMRContainersClientResolvedConfig> {
            readonly input: ListManagedEndpointsCommandInput;
            constructor(input: ListManagedEndpointsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EMRContainersClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListManagedEndpointsCommandInput, ListManagedEndpointsCommandOutput>;
    }
}

declare module '@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/ListTagsForResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EMRContainersClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/EMRContainersClient";
    import { ListTagsForResourceRequest, ListTagsForResourceResponse } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/models/models_0";
    export interface ListTagsForResourceCommandInput extends ListTagsForResourceRequest {
    }
    export interface ListTagsForResourceCommandOutput extends ListTagsForResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the tags assigned to the resources.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EMRContainersClient, ListTagsForResourceCommand } from "@aws-sdk/client-emr-containers"; // ES Modules import
        * // const { EMRContainersClient, ListTagsForResourceCommand } = require("@aws-sdk/client-emr-containers"); // CommonJS import
        * const client = new EMRContainersClient(config);
        * const command = new ListTagsForResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTagsForResourceCommandInput} for command's `input` shape.
        * @see {@link ListTagsForResourceCommandOutput} for command's `response` shape.
        * @see {@link EMRContainersClientResolvedConfig | config} for EMRContainersClient's `config` shape.
        *
        */
    export class ListTagsForResourceCommand extends $Command<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput, EMRContainersClientResolvedConfig> {
            readonly input: ListTagsForResourceCommandInput;
            constructor(input: ListTagsForResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EMRContainersClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/ListVirtualClustersCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EMRContainersClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/EMRContainersClient";
    import { ListVirtualClustersRequest, ListVirtualClustersResponse } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/models/models_0";
    export interface ListVirtualClustersCommandInput extends ListVirtualClustersRequest {
    }
    export interface ListVirtualClustersCommandOutput extends ListVirtualClustersResponse, __MetadataBearer {
    }
    /**
        * <p>Lists information about the specified virtual cluster. Virtual cluster is a managed entity on Amazon EMR on EKS. You can create, describe, list and delete virtual clusters. They do not consume any additional resource in your system. A single virtual cluster maps to a single Kubernetes namespace. Given this relationship, you can model virtual clusters the same way you model Kubernetes namespaces to meet your requirements.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EMRContainersClient, ListVirtualClustersCommand } from "@aws-sdk/client-emr-containers"; // ES Modules import
        * // const { EMRContainersClient, ListVirtualClustersCommand } = require("@aws-sdk/client-emr-containers"); // CommonJS import
        * const client = new EMRContainersClient(config);
        * const command = new ListVirtualClustersCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListVirtualClustersCommandInput} for command's `input` shape.
        * @see {@link ListVirtualClustersCommandOutput} for command's `response` shape.
        * @see {@link EMRContainersClientResolvedConfig | config} for EMRContainersClient's `config` shape.
        *
        */
    export class ListVirtualClustersCommand extends $Command<ListVirtualClustersCommandInput, ListVirtualClustersCommandOutput, EMRContainersClientResolvedConfig> {
            readonly input: ListVirtualClustersCommandInput;
            constructor(input: ListVirtualClustersCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EMRContainersClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListVirtualClustersCommandInput, ListVirtualClustersCommandOutput>;
    }
}

declare module '@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/StartJobRunCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EMRContainersClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/EMRContainersClient";
    import { StartJobRunRequest, StartJobRunResponse } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/models/models_0";
    export interface StartJobRunCommandInput extends StartJobRunRequest {
    }
    export interface StartJobRunCommandOutput extends StartJobRunResponse, __MetadataBearer {
    }
    /**
        * <p>Starts a job run. A job run is a unit of work, such as a Spark jar, PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EMRContainersClient, StartJobRunCommand } from "@aws-sdk/client-emr-containers"; // ES Modules import
        * // const { EMRContainersClient, StartJobRunCommand } = require("@aws-sdk/client-emr-containers"); // CommonJS import
        * const client = new EMRContainersClient(config);
        * const command = new StartJobRunCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link StartJobRunCommandInput} for command's `input` shape.
        * @see {@link StartJobRunCommandOutput} for command's `response` shape.
        * @see {@link EMRContainersClientResolvedConfig | config} for EMRContainersClient's `config` shape.
        *
        */
    export class StartJobRunCommand extends $Command<StartJobRunCommandInput, StartJobRunCommandOutput, EMRContainersClientResolvedConfig> {
            readonly input: StartJobRunCommandInput;
            constructor(input: StartJobRunCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EMRContainersClientResolvedConfig, options?: __HttpHandlerOptions): Handler<StartJobRunCommandInput, StartJobRunCommandOutput>;
    }
}

declare module '@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/TagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EMRContainersClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/EMRContainersClient";
    import { TagResourceRequest, TagResourceResponse } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/models/models_0";
    export interface TagResourceCommandInput extends TagResourceRequest {
    }
    export interface TagResourceCommandOutput extends TagResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Assigns tags to resources. A tag is a label that you assign to an AWS resource. Each tag consists of a key and an optional value, both of which you define. Tags enable you to categorize your AWS resources by attributes such as purpose, owner, or environment. When you have many resources of the same type, you can quickly identify a specific resource based on the tags you've assigned to it. For example, you can define a set of tags for your Amazon EMR on EKS clusters to help you track each cluster's owner and stack level. We recommend that you devise a consistent set of tag keys for each resource type. You can then search and filter the resources based on the tags that you add.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EMRContainersClient, TagResourceCommand } from "@aws-sdk/client-emr-containers"; // ES Modules import
        * // const { EMRContainersClient, TagResourceCommand } = require("@aws-sdk/client-emr-containers"); // CommonJS import
        * const client = new EMRContainersClient(config);
        * const command = new TagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TagResourceCommandInput} for command's `input` shape.
        * @see {@link TagResourceCommandOutput} for command's `response` shape.
        * @see {@link EMRContainersClientResolvedConfig | config} for EMRContainersClient's `config` shape.
        *
        */
    export class TagResourceCommand extends $Command<TagResourceCommandInput, TagResourceCommandOutput, EMRContainersClientResolvedConfig> {
            readonly input: TagResourceCommandInput;
            constructor(input: TagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EMRContainersClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TagResourceCommandInput, TagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/UntagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EMRContainersClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/EMRContainersClient";
    import { UntagResourceRequest, UntagResourceResponse } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/models/models_0";
    export interface UntagResourceCommandInput extends UntagResourceRequest {
    }
    export interface UntagResourceCommandOutput extends UntagResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Removes tags from resources.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EMRContainersClient, UntagResourceCommand } from "@aws-sdk/client-emr-containers"; // ES Modules import
        * // const { EMRContainersClient, UntagResourceCommand } = require("@aws-sdk/client-emr-containers"); // CommonJS import
        * const client = new EMRContainersClient(config);
        * const command = new UntagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UntagResourceCommandInput} for command's `input` shape.
        * @see {@link UntagResourceCommandOutput} for command's `response` shape.
        * @see {@link EMRContainersClientResolvedConfig | config} for EMRContainersClient's `config` shape.
        *
        */
    export class UntagResourceCommand extends $Command<UntagResourceCommandInput, UntagResourceCommandOutput, EMRContainersClientResolvedConfig> {
            readonly input: UntagResourceCommandInput;
            constructor(input: UntagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EMRContainersClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UntagResourceCommandInput, UntagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/EMRContainersClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { CancelJobRunCommandInput, CancelJobRunCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/CancelJobRunCommand";
    import { CreateManagedEndpointCommandInput, CreateManagedEndpointCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/CreateManagedEndpointCommand";
    import { CreateVirtualClusterCommandInput, CreateVirtualClusterCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/CreateVirtualClusterCommand";
    import { DeleteManagedEndpointCommandInput, DeleteManagedEndpointCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/DeleteManagedEndpointCommand";
    import { DeleteVirtualClusterCommandInput, DeleteVirtualClusterCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/DeleteVirtualClusterCommand";
    import { DescribeJobRunCommandInput, DescribeJobRunCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/DescribeJobRunCommand";
    import { DescribeManagedEndpointCommandInput, DescribeManagedEndpointCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/DescribeManagedEndpointCommand";
    import { DescribeVirtualClusterCommandInput, DescribeVirtualClusterCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/DescribeVirtualClusterCommand";
    import { ListJobRunsCommandInput, ListJobRunsCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/ListJobRunsCommand";
    import { ListManagedEndpointsCommandInput, ListManagedEndpointsCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/ListManagedEndpointsCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/ListTagsForResourceCommand";
    import { ListVirtualClustersCommandInput, ListVirtualClustersCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/ListVirtualClustersCommand";
    import { StartJobRunCommandInput, StartJobRunCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/StartJobRunCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/commands/UntagResourceCommand";
    export type ServiceInputTypes = CancelJobRunCommandInput | CreateManagedEndpointCommandInput | CreateVirtualClusterCommandInput | DeleteManagedEndpointCommandInput | DeleteVirtualClusterCommandInput | DescribeJobRunCommandInput | DescribeManagedEndpointCommandInput | DescribeVirtualClusterCommandInput | ListJobRunsCommandInput | ListManagedEndpointsCommandInput | ListTagsForResourceCommandInput | ListVirtualClustersCommandInput | StartJobRunCommandInput | TagResourceCommandInput | UntagResourceCommandInput;
    export type ServiceOutputTypes = CancelJobRunCommandOutput | CreateManagedEndpointCommandOutput | CreateVirtualClusterCommandOutput | DeleteManagedEndpointCommandOutput | DeleteVirtualClusterCommandOutput | DescribeJobRunCommandOutput | DescribeManagedEndpointCommandOutput | DescribeVirtualClusterCommandOutput | ListJobRunsCommandOutput | ListManagedEndpointsCommandOutput | ListTagsForResourceCommandOutput | ListVirtualClustersCommandOutput | StartJobRunCommandOutput | TagResourceCommandOutput | UntagResourceCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type EMRContainersClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of EMRContainersClient class constructor that set the region, credentials and other options.
        */
    export interface EMRContainersClientConfig extends EMRContainersClientConfigType {
    }
    type EMRContainersClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of EMRContainersClient class. This is resolved and normalized from the {@link EMRContainersClientConfig | constructor configuration interface}.
        */
    export interface EMRContainersClientResolvedConfig extends EMRContainersClientResolvedConfigType {
    }
    /**
        * <p>Amazon EMR on EKS provides a deployment option for Amazon EMR that allows you to run
        *          open-source big data frameworks on Amazon Elastic Kubernetes Service (Amazon EKS). With
        *          this deployment option, you can focus on running analytics workloads while Amazon EMR on
        *          EKS builds, configures, and manages containers for open-source applications. For more
        *          information about Amazon EMR on EKS concepts and tasks, see <a href="https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/emr-eks.html">What is Amazon EMR on EKS</a>.</p>
        *          <p>
        *             <i>Amazon EMR containers</i> is the API name for Amazon EMR on EKS. The
        *             <code>emr-containers</code> prefix is used in the following scenarios: </p>
        *          <ul>
        *             <li>
        *                <p>It is the prefix in the CLI commands for Amazon EMR on EKS. For example, <code>aws
        *                   emr-containers start-job-run</code>.</p>
        *             </li>
        *             <li>
        *                <p>It is the prefix before IAM policy actions for Amazon EMR on EKS. For example, <code>"Action": [
        *             "emr-containers:StartJobRun"]</code>. For more information, see <a href="https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/security_iam_service-with-iam.html#security_iam_service-with-iam-id-based-policies-actions">Policy actions for Amazon EMR on EKS</a>.</p>
        *             </li>
        *             <li>
        *                <p>It is the prefix used in Amazon EMR on EKS service endpoints. For example, <code>emr-containers.us-east-2.amazonaws.com</code>. For more
        *             information, see <a href="https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/service-quotas.html#service-endpoints">Amazon EMR on EKS Service Endpoints</a>.</p>
        *             </li>
        *          </ul>
        */
    export class EMRContainersClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, EMRContainersClientResolvedConfig> {
            /**
                * The resolved configuration of EMRContainersClient class. This is resolved and normalized from the {@link EMRContainersClientConfig | constructor configuration interface}.
                */
            readonly config: EMRContainersClientResolvedConfig;
            constructor(configuration: EMRContainersClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { EMRContainersServiceException as __BaseException } from "@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/models/EMRContainersServiceException";
    export interface CancelJobRunRequest {
            /**
                * <p>The ID of the job run to cancel.</p>
                */
            id: string | undefined;
            /**
                * <p>The ID of the virtual cluster for which the job run will be canceled.</p>
                */
            virtualClusterId: string | undefined;
    }
    export namespace CancelJobRunRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CancelJobRunRequest) => any;
    }
    export interface CancelJobRunResponse {
            /**
                * <p>The output contains the ID of the cancelled job run.</p>
                */
            id?: string;
            /**
                * <p>The output contains the virtual cluster ID for which the job run is cancelled.</p>
                */
            virtualClusterId?: string;
    }
    export namespace CancelJobRunResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CancelJobRunResponse) => any;
    }
    /**
        * <p>This is an internal server exception.</p>
        */
    export class InternalServerException extends __BaseException {
            readonly name: "InternalServerException";
            readonly $fault: "server";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InternalServerException, __BaseException>);
    }
    /**
        * <p>There are invalid parameters in the client request.</p>
        */
    export class ValidationException extends __BaseException {
            readonly name: "ValidationException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ValidationException, __BaseException>);
    }
    /**
        * <p>A configuration for CloudWatch monitoring. You can configure your jobs to send log information to CloudWatch Logs.</p>
        */
    export interface CloudWatchMonitoringConfiguration {
            /**
                * <p>The name of the log group for log publishing.</p>
                */
            logGroupName: string | undefined;
            /**
                * <p>The specified name prefix for log streams.</p>
                */
            logStreamNamePrefix?: string;
    }
    export namespace CloudWatchMonitoringConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CloudWatchMonitoringConfiguration) => any;
    }
    export enum PersistentAppUI {
            DISABLED = "DISABLED",
            ENABLED = "ENABLED"
    }
    /**
        * <p> Amazon S3 configuration for monitoring log publishing. You can configure your jobs to send log information to Amazon S3.</p>
        */
    export interface S3MonitoringConfiguration {
            /**
                * <p>Amazon S3 destination URI for log publishing.</p>
                */
            logUri: string | undefined;
    }
    export namespace S3MonitoringConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: S3MonitoringConfiguration) => any;
    }
    /**
        * <p>Configuration setting for monitoring.</p>
        */
    export interface MonitoringConfiguration {
            /**
                * <p>Monitoring configurations for the persistent application UI. </p>
                */
            persistentAppUI?: PersistentAppUI | string;
            /**
                * <p>Monitoring configurations for CloudWatch.</p>
                */
            cloudWatchMonitoringConfiguration?: CloudWatchMonitoringConfiguration;
            /**
                * <p>Amazon S3 configuration for monitoring log publishing.</p>
                */
            s3MonitoringConfiguration?: S3MonitoringConfiguration;
    }
    export namespace MonitoringConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: MonitoringConfiguration) => any;
    }
    export interface CreateManagedEndpointResponse {
            /**
                * <p>The output contains the ID of the managed endpoint.</p>
                */
            id?: string;
            /**
                * <p>The output contains the name of the managed endpoint.</p>
                */
            name?: string;
            /**
                * <p>The output contains the ARN of the managed endpoint.</p>
                */
            arn?: string;
            /**
                * <p>The output contains the ID of the virtual cluster.</p>
                */
            virtualClusterId?: string;
    }
    export namespace CreateManagedEndpointResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateManagedEndpointResponse) => any;
    }
    /**
        * <p>The specified resource was not found.</p>
        */
    export class ResourceNotFoundException extends __BaseException {
            readonly name: "ResourceNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>);
    }
    /**
        * <p>The information about the EKS cluster.</p>
        */
    export interface EksInfo {
            /**
                * <p>The namespaces of the EKS cluster.</p>
                */
            namespace?: string;
    }
    export namespace EksInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EksInfo) => any;
    }
    /**
        * <p>The information about the container used for a job run or a managed endpoint.</p>
        */
    export type ContainerInfo = ContainerInfo.EksInfoMember | ContainerInfo.$UnknownMember;
    export namespace ContainerInfo {
            /**
                * <p>The information about the EKS cluster.</p>
                */
            interface EksInfoMember {
                    eksInfo: EksInfo;
                    $unknown?: never;
            }
            interface $UnknownMember {
                    eksInfo?: never;
                    $unknown: [string, any];
            }
            interface Visitor<T> {
                    eksInfo: (value: EksInfo) => T;
                    _: (name: string, value: any) => T;
            }
            const visit: <T>(value: ContainerInfo, visitor: Visitor<T>) => T;
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ContainerInfo) => any;
    }
    export enum ContainerProviderType {
            EKS = "EKS"
    }
    /**
        * <p>The information about the container provider.</p>
        */
    export interface ContainerProvider {
            /**
                * <p>The type of the container provider. EKS is the only supported type as of now.</p>
                */
            type: ContainerProviderType | string | undefined;
            /**
                * <p>The ID of the container cluster.</p>
                */
            id: string | undefined;
            /**
                * <p>The information about the container cluster.</p>
                */
            info?: ContainerInfo;
    }
    export namespace ContainerProvider {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ContainerProvider) => any;
    }
    export interface CreateVirtualClusterRequest {
            /**
                * <p>The specified name of the virtual cluster.</p>
                */
            name: string | undefined;
            /**
                * <p>The container provider of the virtual cluster.</p>
                */
            containerProvider: ContainerProvider | undefined;
            /**
                * <p>The client token of the virtual cluster.</p>
                */
            clientToken?: string;
            /**
                * <p>The tags assigned to the virtual cluster.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace CreateVirtualClusterRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateVirtualClusterRequest) => any;
    }
    export interface CreateVirtualClusterResponse {
            /**
                * <p>This output contains the virtual cluster ID.</p>
                */
            id?: string;
            /**
                * <p>This output contains the name of the virtual cluster.</p>
                */
            name?: string;
            /**
                * <p>This output contains the ARN of virtual cluster.</p>
                */
            arn?: string;
    }
    export namespace CreateVirtualClusterResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateVirtualClusterResponse) => any;
    }
    export interface DeleteManagedEndpointRequest {
            /**
                * <p>The ID of the managed endpoint.</p>
                */
            id: string | undefined;
            /**
                * <p>The ID of the endpoint's virtual cluster.</p>
                */
            virtualClusterId: string | undefined;
    }
    export namespace DeleteManagedEndpointRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteManagedEndpointRequest) => any;
    }
    export interface DeleteManagedEndpointResponse {
            /**
                * <p>The output displays the ID of the managed endpoint.</p>
                */
            id?: string;
            /**
                * <p>The output displays the ID of the endpoint's virtual cluster.</p>
                */
            virtualClusterId?: string;
    }
    export namespace DeleteManagedEndpointResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteManagedEndpointResponse) => any;
    }
    export interface DeleteVirtualClusterRequest {
            /**
                * <p>The ID of the virtual cluster that will be deleted.</p>
                */
            id: string | undefined;
    }
    export namespace DeleteVirtualClusterRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteVirtualClusterRequest) => any;
    }
    export interface DeleteVirtualClusterResponse {
            /**
                * <p>This output contains the ID of the virtual cluster that will be deleted. </p>
                */
            id?: string;
    }
    export namespace DeleteVirtualClusterResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteVirtualClusterResponse) => any;
    }
    export interface DescribeJobRunRequest {
            /**
                * <p>The ID of the job run request. </p>
                */
            id: string | undefined;
            /**
                * <p>The ID of the virtual cluster for which the job run is submitted.</p>
                */
            virtualClusterId: string | undefined;
    }
    export namespace DescribeJobRunRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeJobRunRequest) => any;
    }
    export enum FailureReason {
            CLUSTER_UNAVAILABLE = "CLUSTER_UNAVAILABLE",
            INTERNAL_ERROR = "INTERNAL_ERROR",
            USER_ERROR = "USER_ERROR",
            VALIDATION_ERROR = "VALIDATION_ERROR"
    }
    /**
        * <p>The information about job driver for Spark submit.</p>
        */
    export interface SparkSubmitJobDriver {
            /**
                * <p>The entry point of job application.</p>
                */
            entryPoint: string | undefined;
            /**
                * <p>The arguments for job application.</p>
                */
            entryPointArguments?: string[];
            /**
                * <p>The Spark submit parameters that are used for job runs.</p>
                */
            sparkSubmitParameters?: string;
    }
    export namespace SparkSubmitJobDriver {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SparkSubmitJobDriver) => any;
    }
    /**
        * <p>Specify the driver that the job runs on.</p>
        */
    export interface JobDriver {
            /**
                * <p>The job driver parameters specified for spark submit.</p>
                */
            sparkSubmitJobDriver?: SparkSubmitJobDriver;
    }
    export namespace JobDriver {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: JobDriver) => any;
    }
    export enum JobRunState {
            CANCELLED = "CANCELLED",
            CANCEL_PENDING = "CANCEL_PENDING",
            COMPLETED = "COMPLETED",
            FAILED = "FAILED",
            PENDING = "PENDING",
            RUNNING = "RUNNING",
            SUBMITTED = "SUBMITTED"
    }
    export interface DescribeManagedEndpointRequest {
            /**
                * <p>This output displays ID of the managed endpoint.</p>
                */
            id: string | undefined;
            /**
                * <p>The ID of the endpoint's virtual cluster.</p>
                */
            virtualClusterId: string | undefined;
    }
    export namespace DescribeManagedEndpointRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeManagedEndpointRequest) => any;
    }
    /**
        * <p>The entity representing certificate data generated for managed endpoint.</p>
        */
    export interface Certificate {
            /**
                * <p>The ARN of the certificate generated for managed endpoint.</p>
                */
            certificateArn?: string;
            /**
                * <p>The base64 encoded PEM certificate data generated for managed endpoint.</p>
                */
            certificateData?: string;
    }
    export namespace Certificate {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Certificate) => any;
    }
    export enum EndpointState {
            ACTIVE = "ACTIVE",
            CREATING = "CREATING",
            TERMINATED = "TERMINATED",
            TERMINATED_WITH_ERRORS = "TERMINATED_WITH_ERRORS",
            TERMINATING = "TERMINATING"
    }
    export interface DescribeVirtualClusterRequest {
            /**
                * <p>The ID of the virtual cluster that will be described.</p>
                */
            id: string | undefined;
    }
    export namespace DescribeVirtualClusterRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeVirtualClusterRequest) => any;
    }
    export enum VirtualClusterState {
            ARRESTED = "ARRESTED",
            RUNNING = "RUNNING",
            TERMINATED = "TERMINATED",
            TERMINATING = "TERMINATING"
    }
    /**
        * <p>This entity describes a virtual cluster. A virtual cluster is a Kubernetes namespace that Amazon EMR is registered with. Amazon EMR uses virtual clusters to run jobs and host endpoints. Multiple virtual clusters can be backed by the same physical cluster. However, each virtual cluster maps to one namespace on an EKS cluster. Virtual clusters do not create any active resources that contribute to your bill or that require lifecycle management outside the service.</p>
        */
    export interface VirtualCluster {
            /**
                * <p>The ID of the virtual cluster.</p>
                */
            id?: string;
            /**
                * <p>The name of the virtual cluster.</p>
                */
            name?: string;
            /**
                * <p>The ARN of the virtual cluster.</p>
                */
            arn?: string;
            /**
                * <p>The state of the virtual cluster.</p>
                */
            state?: VirtualClusterState | string;
            /**
                * <p>The container provider of the virtual cluster.</p>
                */
            containerProvider?: ContainerProvider;
            /**
                * <p>The date and time when the virtual cluster is created.</p>
                */
            createdAt?: Date;
            /**
                * <p>The assigned tags of the virtual cluster.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace VirtualCluster {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: VirtualCluster) => any;
    }
    export interface DescribeVirtualClusterResponse {
            /**
                * <p>This output displays information about the specified virtual cluster.</p>
                */
            virtualCluster?: VirtualCluster;
    }
    export namespace DescribeVirtualClusterResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeVirtualClusterResponse) => any;
    }
    export interface ListJobRunsRequest {
            /**
                * <p>The ID of the virtual cluster for which to list the job run. </p>
                */
            virtualClusterId: string | undefined;
            /**
                * <p>The date and time before which the job runs were submitted.</p>
                */
            createdBefore?: Date;
            /**
                * <p>The date and time after which the job runs were submitted.</p>
                */
            createdAfter?: Date;
            /**
                * <p>The name of the job run.</p>
                */
            name?: string;
            /**
                * <p>The states of the job run.</p>
                */
            states?: (JobRunState | string)[];
            /**
                * <p>The maximum number of job runs that can be listed.</p>
                */
            maxResults?: number;
            /**
                * <p>The token for the next set of job runs to return.</p>
                */
            nextToken?: string;
    }
    export namespace ListJobRunsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListJobRunsRequest) => any;
    }
    export interface ListManagedEndpointsRequest {
            /**
                * <p>The ID of the virtual cluster.</p>
                */
            virtualClusterId: string | undefined;
            /**
                * <p>The date and time before which the endpoints are created.</p>
                */
            createdBefore?: Date;
            /**
                * <p> The date and time after which the endpoints are created.</p>
                */
            createdAfter?: Date;
            /**
                * <p>The types of the managed endpoints.</p>
                */
            types?: string[];
            /**
                * <p>The states of the managed endpoints.</p>
                */
            states?: (EndpointState | string)[];
            /**
                * <p>The maximum number of managed endpoints that can be listed.</p>
                */
            maxResults?: number;
            /**
                * <p> The token for the next set of managed endpoints to return. </p>
                */
            nextToken?: string;
    }
    export namespace ListManagedEndpointsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListManagedEndpointsRequest) => any;
    }
    export interface ListTagsForResourceRequest {
            /**
                * <p>The ARN of tagged resources.</p>
                */
            resourceArn: string | undefined;
    }
    export namespace ListTagsForResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceRequest) => any;
    }
    export interface ListTagsForResourceResponse {
            /**
                * <p>The tags assigned to resources.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace ListTagsForResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceResponse) => any;
    }
    export interface ListVirtualClustersRequest {
            /**
                * <p>The container provider ID of the virtual cluster.</p>
                */
            containerProviderId?: string;
            /**
                * <p>The container provider type of the virtual cluster. EKS is the only supported type as of now.</p>
                */
            containerProviderType?: ContainerProviderType | string;
            /**
                * <p>The date and time after which the virtual clusters are created.</p>
                */
            createdAfter?: Date;
            /**
                * <p>The date and time before which the virtual clusters are created.</p>
                */
            createdBefore?: Date;
            /**
                * <p>The states of the requested virtual clusters.</p>
                */
            states?: (VirtualClusterState | string)[];
            /**
                * <p>The maximum number of virtual clusters that can be listed.</p>
                */
            maxResults?: number;
            /**
                * <p>The token for the next set of virtual clusters to return. </p>
                */
            nextToken?: string;
    }
    export namespace ListVirtualClustersRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListVirtualClustersRequest) => any;
    }
    export interface ListVirtualClustersResponse {
            /**
                * <p>This output lists the specified virtual clusters.</p>
                */
            virtualClusters?: VirtualCluster[];
            /**
                * <p>This output displays the token for the next set of virtual clusters.</p>
                */
            nextToken?: string;
    }
    export namespace ListVirtualClustersResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListVirtualClustersResponse) => any;
    }
    export interface StartJobRunResponse {
            /**
                * <p>This output displays the started job run ID.</p>
                */
            id?: string;
            /**
                * <p>This output displays the name of the started job run.</p>
                */
            name?: string;
            /**
                * <p>This output lists the ARN of job run.</p>
                */
            arn?: string;
            /**
                * <p>This output displays the virtual cluster ID for which the job run was submitted.</p>
                */
            virtualClusterId?: string;
    }
    export namespace StartJobRunResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartJobRunResponse) => any;
    }
    export interface TagResourceRequest {
            /**
                * <p>The ARN of resources.</p>
                */
            resourceArn: string | undefined;
            /**
                * <p>The tags assigned to resources.</p>
                */
            tags: Record<string, string> | undefined;
    }
    export namespace TagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceRequest) => any;
    }
    export interface TagResourceResponse {
    }
    export namespace TagResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceResponse) => any;
    }
    export interface UntagResourceRequest {
            /**
                * <p>The ARN of resources.</p>
                */
            resourceArn: string | undefined;
            /**
                * <p>The tag keys of the resources.</p>
                */
            tagKeys: string[] | undefined;
    }
    export namespace UntagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceRequest) => any;
    }
    export interface UntagResourceResponse {
    }
    export namespace UntagResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceResponse) => any;
    }
    /**
        * <p>A configuration specification to be used when provisioning virtual clusters, which can include configurations for applications and software bundled with Amazon EMR on EKS. A configuration consists of a classification, properties, and optional nested configurations. A classification refers to an application-specific configuration file. Properties are the settings you want to change in that file.</p>
        */
    export interface Configuration {
            /**
                * <p>The classification within a configuration.</p>
                */
            classification: string | undefined;
            /**
                * <p>A set of properties specified within a configuration classification.</p>
                */
            properties?: Record<string, string>;
            /**
                * <p>A list of additional configurations to apply within a configuration object.</p>
                */
            configurations?: Configuration[];
    }
    export namespace Configuration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Configuration) => any;
    }
    /**
        * <p>A configuration specification to be used to override existing configurations.</p>
        */
    export interface ConfigurationOverrides {
            /**
                * <p>The configurations for the application running by the job run. </p>
                */
            applicationConfiguration?: Configuration[];
            /**
                * <p>The configurations for monitoring.</p>
                */
            monitoringConfiguration?: MonitoringConfiguration;
    }
    export namespace ConfigurationOverrides {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ConfigurationOverrides) => any;
    }
    export interface CreateManagedEndpointRequest {
            /**
                * <p>The name of the managed endpoint.</p>
                */
            name: string | undefined;
            /**
                * <p>The ID of the virtual cluster for which a managed endpoint is created.</p>
                */
            virtualClusterId: string | undefined;
            /**
                * <p>The type of the managed endpoint.</p>
                */
            type: string | undefined;
            /**
                * <p>The Amazon EMR release version.</p>
                */
            releaseLabel: string | undefined;
            /**
                * <p>The ARN of the execution role.</p>
                */
            executionRoleArn: string | undefined;
            /**
                * @deprecated
                *
                * <p>The certificate ARN provided by users for the managed endpoint. This fiedd is under deprecation and will be removed in future releases.</p>
                */
            certificateArn?: string;
            /**
                * <p>The configuration settings that will be used to override existing configurations.</p>
                */
            configurationOverrides?: ConfigurationOverrides;
            /**
                * <p>The client idempotency token for this create call.</p>
                */
            clientToken?: string;
            /**
                * <p>The tags of the managed endpoint.
                *       </p>
                */
            tags?: Record<string, string>;
    }
    export namespace CreateManagedEndpointRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateManagedEndpointRequest) => any;
    }
    /**
        * <p>This entity represents the endpoint that is managed by Amazon EMR on EKS.</p>
        */
    export interface Endpoint {
            /**
                * <p>The ID of the endpoint.</p>
                */
            id?: string;
            /**
                * <p>The name of the endpoint.</p>
                */
            name?: string;
            /**
                * <p>The ARN of the endpoint.</p>
                */
            arn?: string;
            /**
                * <p>The ID of the endpoint's virtual cluster.</p>
                */
            virtualClusterId?: string;
            /**
                * <p>The type of the endpoint.</p>
                */
            type?: string;
            /**
                * <p>The state of the endpoint.</p>
                */
            state?: EndpointState | string;
            /**
                * <p>The EMR release version to be used for the endpoint.</p>
                */
            releaseLabel?: string;
            /**
                * <p>The execution role ARN of the endpoint.</p>
                */
            executionRoleArn?: string;
            /**
                * @deprecated
                *
                * <p>The certificate ARN of the endpoint. This field is under deprecation and will be removed in future.</p>
                */
            certificateArn?: string;
            /**
                * <p>The certificate generated by emr control plane on customer behalf to secure the managed endpoint.</p>
                */
            certificateAuthority?: Certificate;
            /**
                * <p>The configuration settings that are used to override existing configurations for endpoints.</p>
                */
            configurationOverrides?: ConfigurationOverrides;
            /**
                * <p>The server URL of the endpoint.</p>
                */
            serverUrl?: string;
            /**
                * <p>The date and time when the endpoint was created.</p>
                */
            createdAt?: Date;
            /**
                * <p>The security group configuration of the endpoint.
                *       </p>
                */
            securityGroup?: string;
            /**
                * <p>The subnet IDs of the endpoint.
                *       </p>
                */
            subnetIds?: string[];
            /**
                * <p>
                *          Additional details of the endpoint state.
                *       </p>
                */
            stateDetails?: string;
            /**
                * <p>
                *          The reasons why the endpoint has failed.
                *       </p>
                */
            failureReason?: FailureReason | string;
            /**
                * <p>The tags of the endpoint.
                *       </p>
                */
            tags?: Record<string, string>;
    }
    export namespace Endpoint {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Endpoint) => any;
    }
    /**
        * <p>This entity describes a job run. A job run is a unit of work, such as a Spark jar, PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS. </p>
        */
    export interface JobRun {
            /**
                * <p>The ID of the job run.</p>
                */
            id?: string;
            /**
                * <p>The name of the job run.</p>
                */
            name?: string;
            /**
                * <p>The ID of the job run's virtual cluster.</p>
                */
            virtualClusterId?: string;
            /**
                * <p>The ARN of job run.</p>
                */
            arn?: string;
            /**
                * <p>The state of the job run. </p>
                */
            state?: JobRunState | string;
            /**
                * <p>The client token used to start a job run.</p>
                */
            clientToken?: string;
            /**
                * <p>The execution role ARN of the job run.</p>
                */
            executionRoleArn?: string;
            /**
                * <p>The release version of Amazon EMR.</p>
                */
            releaseLabel?: string;
            /**
                * <p>The configuration settings that are used to override default configuration.</p>
                */
            configurationOverrides?: ConfigurationOverrides;
            /**
                * <p>Parameters of job driver for the job run.</p>
                */
            jobDriver?: JobDriver;
            /**
                * <p>The date and time when the job run was created.</p>
                */
            createdAt?: Date;
            /**
                * <p>The user who created the job run.</p>
                */
            createdBy?: string;
            /**
                * <p>The date and time when the job run has finished.</p>
                */
            finishedAt?: Date;
            /**
                * <p>Additional details of the job run state.</p>
                */
            stateDetails?: string;
            /**
                * <p>The reasons why the job run has failed.</p>
                */
            failureReason?: FailureReason | string;
            /**
                * <p>The assigned tags of the job run.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace JobRun {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: JobRun) => any;
    }
    export interface StartJobRunRequest {
            /**
                * <p>The name of the job run.</p>
                */
            name?: string;
            /**
                * <p>The virtual cluster ID for which the job run request is submitted.</p>
                */
            virtualClusterId: string | undefined;
            /**
                * <p>The client idempotency token of the job run request. </p>
                */
            clientToken?: string;
            /**
                * <p>The execution role ARN for the job run.</p>
                */
            executionRoleArn: string | undefined;
            /**
                * <p>The Amazon EMR release version to use for the job run.</p>
                */
            releaseLabel: string | undefined;
            /**
                * <p>The job driver for the job run.</p>
                */
            jobDriver: JobDriver | undefined;
            /**
                * <p>The configuration overrides for the job run.</p>
                */
            configurationOverrides?: ConfigurationOverrides;
            /**
                * <p>The tags assigned to job runs.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace StartJobRunRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartJobRunRequest) => any;
    }
    export interface DescribeJobRunResponse {
            /**
                * <p>The output displays information about a job run.</p>
                */
            jobRun?: JobRun;
    }
    export namespace DescribeJobRunResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeJobRunResponse) => any;
    }
    export interface DescribeManagedEndpointResponse {
            /**
                * <p>This output displays information about a managed endpoint.</p>
                */
            endpoint?: Endpoint;
    }
    export namespace DescribeManagedEndpointResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeManagedEndpointResponse) => any;
    }
    export interface ListJobRunsResponse {
            /**
                * <p>This output lists information about the specified job runs.</p>
                */
            jobRuns?: JobRun[];
            /**
                * <p>This output displays the token for the next set of job runs.</p>
                */
            nextToken?: string;
    }
    export namespace ListJobRunsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListJobRunsResponse) => any;
    }
    export interface ListManagedEndpointsResponse {
            /**
                * <p>The managed endpoints to be listed.</p>
                */
            endpoints?: Endpoint[];
            /**
                * <p> The token for the next set of endpoints to return. </p>
                */
            nextToken?: string;
    }
    export namespace ListManagedEndpointsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListManagedEndpointsResponse) => any;
    }
}

declare module '@aws-sdk/client-emr-containers/node_modules/@aws-sdk/client-emr-containers/dist-types/models/EMRContainersServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from EMRContainers service.
        */
    export class EMRContainersServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

