// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/smithy-client
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http

declare module '@aws-sdk/client-redshift' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { AcceptReservedNodeExchangeCommandInput, AcceptReservedNodeExchangeCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/AcceptReservedNodeExchangeCommand";
    import { AddPartnerCommandInput, AddPartnerCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/AddPartnerCommand";
    import { AssociateDataShareConsumerCommandInput, AssociateDataShareConsumerCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/AssociateDataShareConsumerCommand";
    import { AuthorizeClusterSecurityGroupIngressCommandInput, AuthorizeClusterSecurityGroupIngressCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/AuthorizeClusterSecurityGroupIngressCommand";
    import { AuthorizeDataShareCommandInput, AuthorizeDataShareCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/AuthorizeDataShareCommand";
    import { AuthorizeEndpointAccessCommandInput, AuthorizeEndpointAccessCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/AuthorizeEndpointAccessCommand";
    import { AuthorizeSnapshotAccessCommandInput, AuthorizeSnapshotAccessCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/AuthorizeSnapshotAccessCommand";
    import { BatchDeleteClusterSnapshotsCommandInput, BatchDeleteClusterSnapshotsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/BatchDeleteClusterSnapshotsCommand";
    import { BatchModifyClusterSnapshotsCommandInput, BatchModifyClusterSnapshotsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/BatchModifyClusterSnapshotsCommand";
    import { CancelResizeCommandInput, CancelResizeCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CancelResizeCommand";
    import { CopyClusterSnapshotCommandInput, CopyClusterSnapshotCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CopyClusterSnapshotCommand";
    import { CreateAuthenticationProfileCommandInput, CreateAuthenticationProfileCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateAuthenticationProfileCommand";
    import { CreateClusterCommandInput, CreateClusterCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateClusterCommand";
    import { CreateClusterParameterGroupCommandInput, CreateClusterParameterGroupCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateClusterParameterGroupCommand";
    import { CreateClusterSecurityGroupCommandInput, CreateClusterSecurityGroupCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateClusterSecurityGroupCommand";
    import { CreateClusterSnapshotCommandInput, CreateClusterSnapshotCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateClusterSnapshotCommand";
    import { CreateClusterSubnetGroupCommandInput, CreateClusterSubnetGroupCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateClusterSubnetGroupCommand";
    import { CreateEndpointAccessCommandInput, CreateEndpointAccessCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateEndpointAccessCommand";
    import { CreateEventSubscriptionCommandInput, CreateEventSubscriptionCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateEventSubscriptionCommand";
    import { CreateHsmClientCertificateCommandInput, CreateHsmClientCertificateCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateHsmClientCertificateCommand";
    import { CreateHsmConfigurationCommandInput, CreateHsmConfigurationCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateHsmConfigurationCommand";
    import { CreateScheduledActionCommandInput, CreateScheduledActionCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateScheduledActionCommand";
    import { CreateSnapshotCopyGrantCommandInput, CreateSnapshotCopyGrantCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateSnapshotCopyGrantCommand";
    import { CreateSnapshotScheduleCommandInput, CreateSnapshotScheduleCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateSnapshotScheduleCommand";
    import { CreateTagsCommandInput, CreateTagsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateTagsCommand";
    import { CreateUsageLimitCommandInput, CreateUsageLimitCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateUsageLimitCommand";
    import { DeauthorizeDataShareCommandInput, DeauthorizeDataShareCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeauthorizeDataShareCommand";
    import { DeleteAuthenticationProfileCommandInput, DeleteAuthenticationProfileCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteAuthenticationProfileCommand";
    import { DeleteClusterCommandInput, DeleteClusterCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteClusterCommand";
    import { DeleteClusterParameterGroupCommandInput, DeleteClusterParameterGroupCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteClusterParameterGroupCommand";
    import { DeleteClusterSecurityGroupCommandInput, DeleteClusterSecurityGroupCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteClusterSecurityGroupCommand";
    import { DeleteClusterSnapshotCommandInput, DeleteClusterSnapshotCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteClusterSnapshotCommand";
    import { DeleteClusterSubnetGroupCommandInput, DeleteClusterSubnetGroupCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteClusterSubnetGroupCommand";
    import { DeleteEndpointAccessCommandInput, DeleteEndpointAccessCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteEndpointAccessCommand";
    import { DeleteEventSubscriptionCommandInput, DeleteEventSubscriptionCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteEventSubscriptionCommand";
    import { DeleteHsmClientCertificateCommandInput, DeleteHsmClientCertificateCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteHsmClientCertificateCommand";
    import { DeleteHsmConfigurationCommandInput, DeleteHsmConfigurationCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteHsmConfigurationCommand";
    import { DeletePartnerCommandInput, DeletePartnerCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeletePartnerCommand";
    import { DeleteScheduledActionCommandInput, DeleteScheduledActionCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteScheduledActionCommand";
    import { DeleteSnapshotCopyGrantCommandInput, DeleteSnapshotCopyGrantCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteSnapshotCopyGrantCommand";
    import { DeleteSnapshotScheduleCommandInput, DeleteSnapshotScheduleCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteSnapshotScheduleCommand";
    import { DeleteTagsCommandInput, DeleteTagsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteTagsCommand";
    import { DeleteUsageLimitCommandInput, DeleteUsageLimitCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteUsageLimitCommand";
    import { DescribeAccountAttributesCommandInput, DescribeAccountAttributesCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeAccountAttributesCommand";
    import { DescribeAuthenticationProfilesCommandInput, DescribeAuthenticationProfilesCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeAuthenticationProfilesCommand";
    import { DescribeClusterDbRevisionsCommandInput, DescribeClusterDbRevisionsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterDbRevisionsCommand";
    import { DescribeClusterParameterGroupsCommandInput, DescribeClusterParameterGroupsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterParameterGroupsCommand";
    import { DescribeClusterParametersCommandInput, DescribeClusterParametersCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterParametersCommand";
    import { DescribeClustersCommandInput, DescribeClustersCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClustersCommand";
    import { DescribeClusterSecurityGroupsCommandInput, DescribeClusterSecurityGroupsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterSecurityGroupsCommand";
    import { DescribeClusterSnapshotsCommandInput, DescribeClusterSnapshotsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterSnapshotsCommand";
    import { DescribeClusterSubnetGroupsCommandInput, DescribeClusterSubnetGroupsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterSubnetGroupsCommand";
    import { DescribeClusterTracksCommandInput, DescribeClusterTracksCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterTracksCommand";
    import { DescribeClusterVersionsCommandInput, DescribeClusterVersionsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterVersionsCommand";
    import { DescribeDataSharesCommandInput, DescribeDataSharesCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeDataSharesCommand";
    import { DescribeDataSharesForConsumerCommandInput, DescribeDataSharesForConsumerCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeDataSharesForConsumerCommand";
    import { DescribeDataSharesForProducerCommandInput, DescribeDataSharesForProducerCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeDataSharesForProducerCommand";
    import { DescribeDefaultClusterParametersCommandInput, DescribeDefaultClusterParametersCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeDefaultClusterParametersCommand";
    import { DescribeEndpointAccessCommandInput, DescribeEndpointAccessCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeEndpointAccessCommand";
    import { DescribeEndpointAuthorizationCommandInput, DescribeEndpointAuthorizationCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeEndpointAuthorizationCommand";
    import { DescribeEventCategoriesCommandInput, DescribeEventCategoriesCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeEventCategoriesCommand";
    import { DescribeEventsCommandInput, DescribeEventsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeEventsCommand";
    import { DescribeEventSubscriptionsCommandInput, DescribeEventSubscriptionsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeEventSubscriptionsCommand";
    import { DescribeHsmClientCertificatesCommandInput, DescribeHsmClientCertificatesCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeHsmClientCertificatesCommand";
    import { DescribeHsmConfigurationsCommandInput, DescribeHsmConfigurationsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeHsmConfigurationsCommand";
    import { DescribeLoggingStatusCommandInput, DescribeLoggingStatusCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeLoggingStatusCommand";
    import { DescribeNodeConfigurationOptionsCommandInput, DescribeNodeConfigurationOptionsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeNodeConfigurationOptionsCommand";
    import { DescribeOrderableClusterOptionsCommandInput, DescribeOrderableClusterOptionsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeOrderableClusterOptionsCommand";
    import { DescribePartnersCommandInput, DescribePartnersCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribePartnersCommand";
    import { DescribeReservedNodeExchangeStatusCommandInput, DescribeReservedNodeExchangeStatusCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeReservedNodeExchangeStatusCommand";
    import { DescribeReservedNodeOfferingsCommandInput, DescribeReservedNodeOfferingsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeReservedNodeOfferingsCommand";
    import { DescribeReservedNodesCommandInput, DescribeReservedNodesCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeReservedNodesCommand";
    import { DescribeResizeCommandInput, DescribeResizeCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeResizeCommand";
    import { DescribeScheduledActionsCommandInput, DescribeScheduledActionsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeScheduledActionsCommand";
    import { DescribeSnapshotCopyGrantsCommandInput, DescribeSnapshotCopyGrantsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeSnapshotCopyGrantsCommand";
    import { DescribeSnapshotSchedulesCommandInput, DescribeSnapshotSchedulesCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeSnapshotSchedulesCommand";
    import { DescribeStorageCommandInput, DescribeStorageCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeStorageCommand";
    import { DescribeTableRestoreStatusCommandInput, DescribeTableRestoreStatusCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeTableRestoreStatusCommand";
    import { DescribeTagsCommandInput, DescribeTagsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeTagsCommand";
    import { DescribeUsageLimitsCommandInput, DescribeUsageLimitsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeUsageLimitsCommand";
    import { DisableLoggingCommandInput, DisableLoggingCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DisableLoggingCommand";
    import { DisableSnapshotCopyCommandInput, DisableSnapshotCopyCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DisableSnapshotCopyCommand";
    import { DisassociateDataShareConsumerCommandInput, DisassociateDataShareConsumerCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DisassociateDataShareConsumerCommand";
    import { EnableLoggingCommandInput, EnableLoggingCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/EnableLoggingCommand";
    import { EnableSnapshotCopyCommandInput, EnableSnapshotCopyCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/EnableSnapshotCopyCommand";
    import { GetClusterCredentialsCommandInput, GetClusterCredentialsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/GetClusterCredentialsCommand";
    import { GetClusterCredentialsWithIAMCommandInput, GetClusterCredentialsWithIAMCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/GetClusterCredentialsWithIAMCommand";
    import { GetReservedNodeExchangeConfigurationOptionsCommandInput, GetReservedNodeExchangeConfigurationOptionsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/GetReservedNodeExchangeConfigurationOptionsCommand";
    import { GetReservedNodeExchangeOfferingsCommandInput, GetReservedNodeExchangeOfferingsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/GetReservedNodeExchangeOfferingsCommand";
    import { ModifyAquaConfigurationCommandInput, ModifyAquaConfigurationCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyAquaConfigurationCommand";
    import { ModifyAuthenticationProfileCommandInput, ModifyAuthenticationProfileCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyAuthenticationProfileCommand";
    import { ModifyClusterCommandInput, ModifyClusterCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterCommand";
    import { ModifyClusterDbRevisionCommandInput, ModifyClusterDbRevisionCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterDbRevisionCommand";
    import { ModifyClusterIamRolesCommandInput, ModifyClusterIamRolesCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterIamRolesCommand";
    import { ModifyClusterMaintenanceCommandInput, ModifyClusterMaintenanceCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterMaintenanceCommand";
    import { ModifyClusterParameterGroupCommandInput, ModifyClusterParameterGroupCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterParameterGroupCommand";
    import { ModifyClusterSnapshotCommandInput, ModifyClusterSnapshotCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterSnapshotCommand";
    import { ModifyClusterSnapshotScheduleCommandInput, ModifyClusterSnapshotScheduleCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterSnapshotScheduleCommand";
    import { ModifyClusterSubnetGroupCommandInput, ModifyClusterSubnetGroupCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterSubnetGroupCommand";
    import { ModifyEndpointAccessCommandInput, ModifyEndpointAccessCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyEndpointAccessCommand";
    import { ModifyEventSubscriptionCommandInput, ModifyEventSubscriptionCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyEventSubscriptionCommand";
    import { ModifyScheduledActionCommandInput, ModifyScheduledActionCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyScheduledActionCommand";
    import { ModifySnapshotCopyRetentionPeriodCommandInput, ModifySnapshotCopyRetentionPeriodCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifySnapshotCopyRetentionPeriodCommand";
    import { ModifySnapshotScheduleCommandInput, ModifySnapshotScheduleCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifySnapshotScheduleCommand";
    import { ModifyUsageLimitCommandInput, ModifyUsageLimitCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyUsageLimitCommand";
    import { PauseClusterCommandInput, PauseClusterCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/PauseClusterCommand";
    import { PurchaseReservedNodeOfferingCommandInput, PurchaseReservedNodeOfferingCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/PurchaseReservedNodeOfferingCommand";
    import { RebootClusterCommandInput, RebootClusterCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RebootClusterCommand";
    import { RejectDataShareCommandInput, RejectDataShareCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RejectDataShareCommand";
    import { ResetClusterParameterGroupCommandInput, ResetClusterParameterGroupCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ResetClusterParameterGroupCommand";
    import { ResizeClusterCommandInput, ResizeClusterCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ResizeClusterCommand";
    import { RestoreFromClusterSnapshotCommandInput, RestoreFromClusterSnapshotCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RestoreFromClusterSnapshotCommand";
    import { RestoreTableFromClusterSnapshotCommandInput, RestoreTableFromClusterSnapshotCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RestoreTableFromClusterSnapshotCommand";
    import { ResumeClusterCommandInput, ResumeClusterCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ResumeClusterCommand";
    import { RevokeClusterSecurityGroupIngressCommandInput, RevokeClusterSecurityGroupIngressCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RevokeClusterSecurityGroupIngressCommand";
    import { RevokeEndpointAccessCommandInput, RevokeEndpointAccessCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RevokeEndpointAccessCommand";
    import { RevokeSnapshotAccessCommandInput, RevokeSnapshotAccessCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RevokeSnapshotAccessCommand";
    import { RotateEncryptionKeyCommandInput, RotateEncryptionKeyCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RotateEncryptionKeyCommand";
    import { UpdatePartnerStatusCommandInput, UpdatePartnerStatusCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/UpdatePartnerStatusCommand";
    import { RedshiftClient } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    /**
        * <fullname>Amazon Redshift</fullname>
        *         <p>
        *             <b>Overview</b>
        *         </p>
        *         <p>This is an interface reference for Amazon Redshift. It contains documentation for one of
        *             the programming or command line interfaces you can use to manage Amazon Redshift clusters.
        *             Note that Amazon Redshift is asynchronous, which means that some interfaces may require
        *             techniques, such as polling or asynchronous callback handlers, to determine when a
        *             command has been applied. In this reference, the parameter descriptions indicate whether
        *             a change is applied immediately, on the next instance reboot, or during the next
        *             maintenance window. For a summary of the Amazon Redshift cluster management interfaces, go to
        *                 <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/using-aws-sdk.html">Using the
        *                 Amazon Redshift Management Interfaces</a>.</p>
        *         <p>Amazon Redshift manages all the work of setting up, operating, and scaling a data
        *             warehouse: provisioning capacity, monitoring and backing up the cluster, and applying
        *             patches and upgrades to the Amazon Redshift engine. You can focus on using your data to
        *             acquire new insights for your business and customers.</p>
        *         <p>If you are a first-time user of Amazon Redshift, we recommend that you begin by reading
        *             the <a href="https://docs.aws.amazon.com/redshift/latest/gsg/getting-started.html">Amazon Redshift Getting Started Guide</a>.</p>
        *
        *         <p>If you are a database developer, the <a href="https://docs.aws.amazon.com/redshift/latest/dg/welcome.html">Amazon Redshift Database Developer Guide</a> explains how to design,
        *             build, query, and maintain the databases that make up your data warehouse. </p>
        */
    export class Redshift extends RedshiftClient {
            /**
                * <p>Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the
                *             configuration (term, payment type, or number of nodes) and no additional costs.
                *         </p>
                */
            acceptReservedNodeExchange(args: AcceptReservedNodeExchangeCommandInput, options?: __HttpHandlerOptions): Promise<AcceptReservedNodeExchangeCommandOutput>;
            acceptReservedNodeExchange(args: AcceptReservedNodeExchangeCommandInput, cb: (err: any, data?: AcceptReservedNodeExchangeCommandOutput) => void): void;
            acceptReservedNodeExchange(args: AcceptReservedNodeExchangeCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AcceptReservedNodeExchangeCommandOutput) => void): void;
            /**
                * <p>Adds a partner integration to a cluster.
                *             This operation authorizes a partner to push status updates for the specified database.
                *             To complete the integration, you also set up the integration on the partner website.</p>
                */
            addPartner(args: AddPartnerCommandInput, options?: __HttpHandlerOptions): Promise<AddPartnerCommandOutput>;
            addPartner(args: AddPartnerCommandInput, cb: (err: any, data?: AddPartnerCommandOutput) => void): void;
            addPartner(args: AddPartnerCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AddPartnerCommandOutput) => void): void;
            /**
                * <p>From a datashare consumer account, associates a datashare with the
                *             account (AssociateEntireAccount) or the specified namespace (ConsumerArn). If you make this association, the consumer
                *             can consume the datashare.</p>
                */
            associateDataShareConsumer(args: AssociateDataShareConsumerCommandInput, options?: __HttpHandlerOptions): Promise<AssociateDataShareConsumerCommandOutput>;
            associateDataShareConsumer(args: AssociateDataShareConsumerCommandInput, cb: (err: any, data?: AssociateDataShareConsumerCommandOutput) => void): void;
            associateDataShareConsumer(args: AssociateDataShareConsumerCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AssociateDataShareConsumerCommandOutput) => void): void;
            /**
                * <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether
                *             the application accessing your cluster is running on the Internet or an Amazon EC2
                *             instance, you can authorize inbound access to either a Classless Interdomain Routing
                *             (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as
                *             many as 20 ingress rules to an Amazon Redshift security group.</p>
                *         <p>If you authorize access to an Amazon EC2 security group, specify
                *                 <i>EC2SecurityGroupName</i> and
                *                 <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and
                *             Amazon Redshift cluster must be in the same Amazon Web Services Region. </p>
                *         <p>If you authorize access to a CIDR/IP address range, specify
                *                 <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia
                *             article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p>
                *         <p>You must also associate the security group with a cluster so that clients running
                *             on these IP addresses or the EC2 instance are authorized to connect to the cluster. For
                *             information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security
                *                 Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            authorizeClusterSecurityGroupIngress(args: AuthorizeClusterSecurityGroupIngressCommandInput, options?: __HttpHandlerOptions): Promise<AuthorizeClusterSecurityGroupIngressCommandOutput>;
            authorizeClusterSecurityGroupIngress(args: AuthorizeClusterSecurityGroupIngressCommandInput, cb: (err: any, data?: AuthorizeClusterSecurityGroupIngressCommandOutput) => void): void;
            authorizeClusterSecurityGroupIngress(args: AuthorizeClusterSecurityGroupIngressCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AuthorizeClusterSecurityGroupIngressCommandOutput) => void): void;
            /**
                * <p>From a data producer account, authorizes the sharing of a datashare with one or more
                *             consumer accounts or managing entities. To authorize a datashare for a data consumer,
                *             the producer account must have the correct access permissions.</p>
                */
            authorizeDataShare(args: AuthorizeDataShareCommandInput, options?: __HttpHandlerOptions): Promise<AuthorizeDataShareCommandOutput>;
            authorizeDataShare(args: AuthorizeDataShareCommandInput, cb: (err: any, data?: AuthorizeDataShareCommandOutput) => void): void;
            authorizeDataShare(args: AuthorizeDataShareCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AuthorizeDataShareCommandOutput) => void): void;
            /**
                * <p>Grants access to a cluster.</p>
                */
            authorizeEndpointAccess(args: AuthorizeEndpointAccessCommandInput, options?: __HttpHandlerOptions): Promise<AuthorizeEndpointAccessCommandOutput>;
            authorizeEndpointAccess(args: AuthorizeEndpointAccessCommandInput, cb: (err: any, data?: AuthorizeEndpointAccessCommandOutput) => void): void;
            authorizeEndpointAccess(args: AuthorizeEndpointAccessCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AuthorizeEndpointAccessCommandOutput) => void): void;
            /**
                * <p>Authorizes the specified Amazon Web Services account to restore the specified
                *             snapshot.</p>
                *         <p>
                * For more information about working with snapshots, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            authorizeSnapshotAccess(args: AuthorizeSnapshotAccessCommandInput, options?: __HttpHandlerOptions): Promise<AuthorizeSnapshotAccessCommandOutput>;
            authorizeSnapshotAccess(args: AuthorizeSnapshotAccessCommandInput, cb: (err: any, data?: AuthorizeSnapshotAccessCommandOutput) => void): void;
            authorizeSnapshotAccess(args: AuthorizeSnapshotAccessCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AuthorizeSnapshotAccessCommandOutput) => void): void;
            /**
                * <p>Deletes a set of cluster snapshots.</p>
                */
            batchDeleteClusterSnapshots(args: BatchDeleteClusterSnapshotsCommandInput, options?: __HttpHandlerOptions): Promise<BatchDeleteClusterSnapshotsCommandOutput>;
            batchDeleteClusterSnapshots(args: BatchDeleteClusterSnapshotsCommandInput, cb: (err: any, data?: BatchDeleteClusterSnapshotsCommandOutput) => void): void;
            batchDeleteClusterSnapshots(args: BatchDeleteClusterSnapshotsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchDeleteClusterSnapshotsCommandOutput) => void): void;
            /**
                * <p>Modifies the settings for a set of cluster snapshots.</p>
                */
            batchModifyClusterSnapshots(args: BatchModifyClusterSnapshotsCommandInput, options?: __HttpHandlerOptions): Promise<BatchModifyClusterSnapshotsCommandOutput>;
            batchModifyClusterSnapshots(args: BatchModifyClusterSnapshotsCommandInput, cb: (err: any, data?: BatchModifyClusterSnapshotsCommandOutput) => void): void;
            batchModifyClusterSnapshots(args: BatchModifyClusterSnapshotsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchModifyClusterSnapshotsCommandOutput) => void): void;
            /**
                * <p>Cancels a resize operation for a cluster.</p>
                */
            cancelResize(args: CancelResizeCommandInput, options?: __HttpHandlerOptions): Promise<CancelResizeCommandOutput>;
            cancelResize(args: CancelResizeCommandInput, cb: (err: any, data?: CancelResizeCommandOutput) => void): void;
            cancelResize(args: CancelResizeCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CancelResizeCommandOutput) => void): void;
            /**
                * <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot.
                *             The source must be an automated snapshot and it must be in the available
                *             state.</p>
                *         <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the
                *             cluster. Also, when the retention period of the snapshot expires, Amazon Redshift
                *             automatically deletes it. If you want to keep an automated snapshot for a longer period,
                *             you can make a manual copy of the snapshot. Manual snapshots are retained until you
                *             delete them.</p>
                *         <p>
                * For more information about working with snapshots, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            copyClusterSnapshot(args: CopyClusterSnapshotCommandInput, options?: __HttpHandlerOptions): Promise<CopyClusterSnapshotCommandOutput>;
            copyClusterSnapshot(args: CopyClusterSnapshotCommandInput, cb: (err: any, data?: CopyClusterSnapshotCommandOutput) => void): void;
            copyClusterSnapshot(args: CopyClusterSnapshotCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CopyClusterSnapshotCommandOutput) => void): void;
            /**
                * <p>Creates an authentication profile with the specified parameters.</p>
                */
            createAuthenticationProfile(args: CreateAuthenticationProfileCommandInput, options?: __HttpHandlerOptions): Promise<CreateAuthenticationProfileCommandOutput>;
            createAuthenticationProfile(args: CreateAuthenticationProfileCommandInput, cb: (err: any, data?: CreateAuthenticationProfileCommandOutput) => void): void;
            createAuthenticationProfile(args: CreateAuthenticationProfileCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateAuthenticationProfileCommandOutput) => void): void;
            /**
                * <p>Creates a new cluster with the specified parameters.</p>
                *         <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster
                *             subnet group name. The cluster subnet group identifies the subnets of your VPC that
                *             Amazon Redshift uses when creating the cluster.
                * For more information about managing clusters, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            createCluster(args: CreateClusterCommandInput, options?: __HttpHandlerOptions): Promise<CreateClusterCommandOutput>;
            createCluster(args: CreateClusterCommandInput, cb: (err: any, data?: CreateClusterCommandOutput) => void): void;
            createCluster(args: CreateClusterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateClusterCommandOutput) => void): void;
            /**
                * <p>Creates an Amazon Redshift parameter group.</p>
                *         <p>Creating parameter groups is independent of creating clusters. You can associate a
                *             cluster with a parameter group when you create the cluster. You can also associate an
                *             existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p>
                *         <p>Parameters in the parameter group define specific behavior that applies to the
                *             databases you create on the cluster.
                * For more information about parameters and parameter groups, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            createClusterParameterGroup(args: CreateClusterParameterGroupCommandInput, options?: __HttpHandlerOptions): Promise<CreateClusterParameterGroupCommandOutput>;
            createClusterParameterGroup(args: CreateClusterParameterGroupCommandInput, cb: (err: any, data?: CreateClusterParameterGroupCommandOutput) => void): void;
            createClusterParameterGroup(args: CreateClusterParameterGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateClusterParameterGroupCommandOutput) => void): void;
            /**
                * <p>Creates a new Amazon Redshift security group. You use security groups to control access
                *             to non-VPC clusters.</p>
                *         <p>
                * For information about managing security groups, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the
                * <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            createClusterSecurityGroup(args: CreateClusterSecurityGroupCommandInput, options?: __HttpHandlerOptions): Promise<CreateClusterSecurityGroupCommandOutput>;
            createClusterSecurityGroup(args: CreateClusterSecurityGroupCommandInput, cb: (err: any, data?: CreateClusterSecurityGroupCommandOutput) => void): void;
            createClusterSecurityGroup(args: CreateClusterSecurityGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateClusterSecurityGroupCommandOutput) => void): void;
            /**
                * <p>Creates a manual snapshot of the specified cluster. The cluster must be in the
                *                 <code>available</code> state. </p>
                *         <p>
                * For more information about working with snapshots, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            createClusterSnapshot(args: CreateClusterSnapshotCommandInput, options?: __HttpHandlerOptions): Promise<CreateClusterSnapshotCommandOutput>;
            createClusterSnapshot(args: CreateClusterSnapshotCommandInput, cb: (err: any, data?: CreateClusterSnapshotCommandOutput) => void): void;
            createClusterSnapshot(args: CreateClusterSnapshotCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateClusterSnapshotCommandOutput) => void): void;
            /**
                * <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more
                *             subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating
                *             Amazon Redshift subnet group.</p>
                *         <p>
                * For information about subnet groups, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the
                * <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            createClusterSubnetGroup(args: CreateClusterSubnetGroupCommandInput, options?: __HttpHandlerOptions): Promise<CreateClusterSubnetGroupCommandOutput>;
            createClusterSubnetGroup(args: CreateClusterSubnetGroupCommandInput, cb: (err: any, data?: CreateClusterSubnetGroupCommandOutput) => void): void;
            createClusterSubnetGroup(args: CreateClusterSubnetGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateClusterSubnetGroupCommandOutput) => void): void;
            /**
                * <p>Creates a Redshift-managed VPC endpoint.</p>
                */
            createEndpointAccess(args: CreateEndpointAccessCommandInput, options?: __HttpHandlerOptions): Promise<CreateEndpointAccessCommandOutput>;
            createEndpointAccess(args: CreateEndpointAccessCommandInput, cb: (err: any, data?: CreateEndpointAccessCommandOutput) => void): void;
            createEndpointAccess(args: CreateEndpointAccessCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateEndpointAccessCommandOutput) => void): void;
            /**
                * <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN
                *             (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console,
                *             the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you
                *             must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in
                *             the SNS console.</p>
                *         <p>You can specify the source type, and lists of Amazon Redshift source IDs, event
                *             categories, and event severities. Notifications will be sent for all events you want
                *             that match those criteria. For example, you can specify source type = cluster, source ID
                *             = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity =
                *             ERROR. The subscription will only send notifications for those ERROR events in the
                *             Availability and Backup categories for the specified clusters.</p>
                *         <p>If you specify both the source type and source IDs, such as source type = cluster
                *             and source identifier = my-cluster-1, notifications will be sent for all the cluster
                *             events for my-cluster-1. If you specify a source type but do not specify a source
                *             identifier, you will receive notice of the events for the objects of that type in your
                *             Amazon Web Services account. If you do not specify either the SourceType nor the SourceIdentifier, you
                *             will be notified of events generated from all Amazon Redshift sources belonging to your Amazon Web Services account. You must specify a source type if you specify a source ID.</p>
                */
            createEventSubscription(args: CreateEventSubscriptionCommandInput, options?: __HttpHandlerOptions): Promise<CreateEventSubscriptionCommandOutput>;
            createEventSubscription(args: CreateEventSubscriptionCommandInput, cb: (err: any, data?: CreateEventSubscriptionCommandOutput) => void): void;
            createEventSubscription(args: CreateEventSubscriptionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateEventSubscriptionCommandOutput) => void): void;
            /**
                * <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to
                *             the client's HSM in order to store and retrieve the keys used to encrypt the cluster
                *             databases.</p>
                *         <p>The command returns a public key, which you must store in the HSM. In addition to
                *             creating the HSM certificate, you must create an Amazon Redshift HSM configuration that
                *             provides a cluster the information needed to store and use encryption keys in the HSM.
                *             For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html#working-with-HSM">Hardware Security Modules</a>
                *             in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            createHsmClientCertificate(args: CreateHsmClientCertificateCommandInput, options?: __HttpHandlerOptions): Promise<CreateHsmClientCertificateCommandOutput>;
            createHsmClientCertificate(args: CreateHsmClientCertificateCommandInput, cb: (err: any, data?: CreateHsmClientCertificateCommandOutput) => void): void;
            createHsmClientCertificate(args: CreateHsmClientCertificateCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateHsmClientCertificateCommandOutput) => void): void;
            /**
                * <p>Creates an HSM configuration that contains the information required by an Amazon Redshift
                *             cluster to store and use database encryption keys in a Hardware Security Module (HSM).
                *             After creating the HSM configuration, you can specify it as a parameter when creating a
                *             cluster. The cluster will then store its encryption keys in the HSM.</p>
                *         <p>In addition to creating an HSM configuration, you must also create an HSM client
                *             certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a>
                *             in the Amazon Redshift Cluster Management Guide.</p>
                */
            createHsmConfiguration(args: CreateHsmConfigurationCommandInput, options?: __HttpHandlerOptions): Promise<CreateHsmConfigurationCommandOutput>;
            createHsmConfiguration(args: CreateHsmConfigurationCommandInput, cb: (err: any, data?: CreateHsmConfigurationCommandOutput) => void): void;
            createHsmConfiguration(args: CreateHsmConfigurationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateHsmConfigurationCommandOutput) => void): void;
            /**
                * <p>Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action.
                *             For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation.
                *         </p>
                */
            createScheduledAction(args: CreateScheduledActionCommandInput, options?: __HttpHandlerOptions): Promise<CreateScheduledActionCommandOutput>;
            createScheduledAction(args: CreateScheduledActionCommandInput, cb: (err: any, data?: CreateScheduledActionCommandOutput) => void): void;
            createScheduledAction(args: CreateScheduledActionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateScheduledActionCommandOutput) => void): void;
            /**
                * <p>Creates a snapshot copy grant that permits Amazon Redshift to use an encrypted symmetric key
                *             from Key Management Service (KMS) to encrypt copied snapshots in a
                *             destination region.</p>
                *         <p>
                * For more information about managing snapshot copy grants, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.
                * </p>
                */
            createSnapshotCopyGrant(args: CreateSnapshotCopyGrantCommandInput, options?: __HttpHandlerOptions): Promise<CreateSnapshotCopyGrantCommandOutput>;
            createSnapshotCopyGrant(args: CreateSnapshotCopyGrantCommandInput, cb: (err: any, data?: CreateSnapshotCopyGrantCommandOutput) => void): void;
            createSnapshotCopyGrant(args: CreateSnapshotCopyGrantCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateSnapshotCopyGrantCommandOutput) => void): void;
            /**
                * <p>Create a snapshot schedule that can be associated to a cluster and which overrides the default system backup schedule. </p>
                */
            createSnapshotSchedule(args: CreateSnapshotScheduleCommandInput, options?: __HttpHandlerOptions): Promise<CreateSnapshotScheduleCommandOutput>;
            createSnapshotSchedule(args: CreateSnapshotScheduleCommandInput, cb: (err: any, data?: CreateSnapshotScheduleCommandOutput) => void): void;
            createSnapshotSchedule(args: CreateSnapshotScheduleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateSnapshotScheduleCommandOutput) => void): void;
            /**
                * <p>Adds tags to a cluster.</p>
                *         <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a
                *             resource, you will receive an error and the attempt will fail.</p>
                *         <p>If you specify a key that already exists for the resource, the value for that key
                *             will be updated with the new value.</p>
                */
            createTags(args: CreateTagsCommandInput, options?: __HttpHandlerOptions): Promise<CreateTagsCommandOutput>;
            createTags(args: CreateTagsCommandInput, cb: (err: any, data?: CreateTagsCommandOutput) => void): void;
            createTags(args: CreateTagsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateTagsCommandOutput) => void): void;
            /**
                * <p>Creates a usage limit for a specified Amazon Redshift feature on a cluster.
                *             The usage limit is identified by the returned usage limit identifier.</p>
                */
            createUsageLimit(args: CreateUsageLimitCommandInput, options?: __HttpHandlerOptions): Promise<CreateUsageLimitCommandOutput>;
            createUsageLimit(args: CreateUsageLimitCommandInput, cb: (err: any, data?: CreateUsageLimitCommandOutput) => void): void;
            createUsageLimit(args: CreateUsageLimitCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateUsageLimitCommandOutput) => void): void;
            /**
                * <p>From a datashare producer account, removes authorization from the specified datashare. </p>
                */
            deauthorizeDataShare(args: DeauthorizeDataShareCommandInput, options?: __HttpHandlerOptions): Promise<DeauthorizeDataShareCommandOutput>;
            deauthorizeDataShare(args: DeauthorizeDataShareCommandInput, cb: (err: any, data?: DeauthorizeDataShareCommandOutput) => void): void;
            deauthorizeDataShare(args: DeauthorizeDataShareCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeauthorizeDataShareCommandOutput) => void): void;
            /**
                * <p>Deletes an authentication profile.</p>
                */
            deleteAuthenticationProfile(args: DeleteAuthenticationProfileCommandInput, options?: __HttpHandlerOptions): Promise<DeleteAuthenticationProfileCommandOutput>;
            deleteAuthenticationProfile(args: DeleteAuthenticationProfileCommandInput, cb: (err: any, data?: DeleteAuthenticationProfileCommandOutput) => void): void;
            deleteAuthenticationProfile(args: DeleteAuthenticationProfileCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteAuthenticationProfileCommandOutput) => void): void;
            /**
                * <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web
                *             service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete
                *             operation cannot be canceled or reverted once submitted.
                * For more information about managing clusters, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                *         <p>If you want to shut down the cluster and retain it for future use, set
                *                 <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a
                *             name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this
                *             snapshot to resume using the cluster. If a final cluster snapshot is requested, the
                *             status of the cluster will be "final-snapshot" while the snapshot is being taken, then
                *             it's "deleting" once Amazon Redshift begins deleting the cluster. </p>
                *         <p>
                * For more information about managing clusters, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            deleteCluster(args: DeleteClusterCommandInput, options?: __HttpHandlerOptions): Promise<DeleteClusterCommandOutput>;
            deleteCluster(args: DeleteClusterCommandInput, cb: (err: any, data?: DeleteClusterCommandOutput) => void): void;
            deleteCluster(args: DeleteClusterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteClusterCommandOutput) => void): void;
            /**
                * <p>Deletes a specified Amazon Redshift parameter group.</p>
                *         <note>
                *             <p>You cannot delete a parameter group if it is associated with a
                *                 cluster.</p>
                *         </note>
                */
            deleteClusterParameterGroup(args: DeleteClusterParameterGroupCommandInput, options?: __HttpHandlerOptions): Promise<DeleteClusterParameterGroupCommandOutput>;
            deleteClusterParameterGroup(args: DeleteClusterParameterGroupCommandInput, cb: (err: any, data?: DeleteClusterParameterGroupCommandOutput) => void): void;
            deleteClusterParameterGroup(args: DeleteClusterParameterGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteClusterParameterGroupCommandOutput) => void): void;
            /**
                * <p>Deletes an Amazon Redshift security group.</p>
                *         <note>
                *             <p>You cannot delete a security group that is associated with any clusters. You
                *                 cannot delete the default security group.</p>
                *         </note>
                *         <p>
                * For information about managing security groups, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the
                * <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            deleteClusterSecurityGroup(args: DeleteClusterSecurityGroupCommandInput, options?: __HttpHandlerOptions): Promise<DeleteClusterSecurityGroupCommandOutput>;
            deleteClusterSecurityGroup(args: DeleteClusterSecurityGroupCommandInput, cb: (err: any, data?: DeleteClusterSecurityGroupCommandOutput) => void): void;
            deleteClusterSecurityGroup(args: DeleteClusterSecurityGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteClusterSecurityGroupCommandOutput) => void): void;
            /**
                * <p>Deletes the specified manual snapshot. The snapshot must be in the
                *                 <code>available</code> state, with no other users authorized to access the snapshot. </p>
                *         <p>Unlike automated snapshots, manual snapshots are retained even after you delete
                *             your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual
                *             snapshot explicitly to avoid getting charged. If other accounts are authorized to access
                *             the snapshot, you must revoke all of the authorizations before you can delete the
                *             snapshot.</p>
                */
            deleteClusterSnapshot(args: DeleteClusterSnapshotCommandInput, options?: __HttpHandlerOptions): Promise<DeleteClusterSnapshotCommandOutput>;
            deleteClusterSnapshot(args: DeleteClusterSnapshotCommandInput, cb: (err: any, data?: DeleteClusterSnapshotCommandOutput) => void): void;
            deleteClusterSnapshot(args: DeleteClusterSnapshotCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteClusterSnapshotCommandOutput) => void): void;
            /**
                * <p>Deletes the specified cluster subnet group.</p>
                */
            deleteClusterSubnetGroup(args: DeleteClusterSubnetGroupCommandInput, options?: __HttpHandlerOptions): Promise<DeleteClusterSubnetGroupCommandOutput>;
            deleteClusterSubnetGroup(args: DeleteClusterSubnetGroupCommandInput, cb: (err: any, data?: DeleteClusterSubnetGroupCommandOutput) => void): void;
            deleteClusterSubnetGroup(args: DeleteClusterSubnetGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteClusterSubnetGroupCommandOutput) => void): void;
            /**
                * <p>Deletes a Redshift-managed VPC endpoint.</p>
                */
            deleteEndpointAccess(args: DeleteEndpointAccessCommandInput, options?: __HttpHandlerOptions): Promise<DeleteEndpointAccessCommandOutput>;
            deleteEndpointAccess(args: DeleteEndpointAccessCommandInput, cb: (err: any, data?: DeleteEndpointAccessCommandOutput) => void): void;
            deleteEndpointAccess(args: DeleteEndpointAccessCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteEndpointAccessCommandOutput) => void): void;
            /**
                * <p>Deletes an Amazon Redshift event notification subscription.</p>
                */
            deleteEventSubscription(args: DeleteEventSubscriptionCommandInput, options?: __HttpHandlerOptions): Promise<DeleteEventSubscriptionCommandOutput>;
            deleteEventSubscription(args: DeleteEventSubscriptionCommandInput, cb: (err: any, data?: DeleteEventSubscriptionCommandOutput) => void): void;
            deleteEventSubscription(args: DeleteEventSubscriptionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteEventSubscriptionCommandOutput) => void): void;
            /**
                * <p>Deletes the specified HSM client certificate.</p>
                */
            deleteHsmClientCertificate(args: DeleteHsmClientCertificateCommandInput, options?: __HttpHandlerOptions): Promise<DeleteHsmClientCertificateCommandOutput>;
            deleteHsmClientCertificate(args: DeleteHsmClientCertificateCommandInput, cb: (err: any, data?: DeleteHsmClientCertificateCommandOutput) => void): void;
            deleteHsmClientCertificate(args: DeleteHsmClientCertificateCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteHsmClientCertificateCommandOutput) => void): void;
            /**
                * <p>Deletes the specified Amazon Redshift HSM configuration.</p>
                */
            deleteHsmConfiguration(args: DeleteHsmConfigurationCommandInput, options?: __HttpHandlerOptions): Promise<DeleteHsmConfigurationCommandOutput>;
            deleteHsmConfiguration(args: DeleteHsmConfigurationCommandInput, cb: (err: any, data?: DeleteHsmConfigurationCommandOutput) => void): void;
            deleteHsmConfiguration(args: DeleteHsmConfigurationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteHsmConfigurationCommandOutput) => void): void;
            /**
                * <p>Deletes a partner integration from a cluster. Data can still flow to the cluster until the integration is deleted at the partner's website.</p>
                */
            deletePartner(args: DeletePartnerCommandInput, options?: __HttpHandlerOptions): Promise<DeletePartnerCommandOutput>;
            deletePartner(args: DeletePartnerCommandInput, cb: (err: any, data?: DeletePartnerCommandOutput) => void): void;
            deletePartner(args: DeletePartnerCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeletePartnerCommandOutput) => void): void;
            /**
                * <p>Deletes a scheduled action.
                *              </p>
                */
            deleteScheduledAction(args: DeleteScheduledActionCommandInput, options?: __HttpHandlerOptions): Promise<DeleteScheduledActionCommandOutput>;
            deleteScheduledAction(args: DeleteScheduledActionCommandInput, cb: (err: any, data?: DeleteScheduledActionCommandOutput) => void): void;
            deleteScheduledAction(args: DeleteScheduledActionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteScheduledActionCommandOutput) => void): void;
            /**
                * <p>Deletes the specified snapshot copy grant.</p>
                */
            deleteSnapshotCopyGrant(args: DeleteSnapshotCopyGrantCommandInput, options?: __HttpHandlerOptions): Promise<DeleteSnapshotCopyGrantCommandOutput>;
            deleteSnapshotCopyGrant(args: DeleteSnapshotCopyGrantCommandInput, cb: (err: any, data?: DeleteSnapshotCopyGrantCommandOutput) => void): void;
            deleteSnapshotCopyGrant(args: DeleteSnapshotCopyGrantCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteSnapshotCopyGrantCommandOutput) => void): void;
            /**
                * <p>Deletes a snapshot schedule.</p>
                */
            deleteSnapshotSchedule(args: DeleteSnapshotScheduleCommandInput, options?: __HttpHandlerOptions): Promise<DeleteSnapshotScheduleCommandOutput>;
            deleteSnapshotSchedule(args: DeleteSnapshotScheduleCommandInput, cb: (err: any, data?: DeleteSnapshotScheduleCommandOutput) => void): void;
            deleteSnapshotSchedule(args: DeleteSnapshotScheduleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteSnapshotScheduleCommandOutput) => void): void;
            /**
                * <p>Deletes tags from a resource. You must provide the ARN of the resource
                *             from which you want to delete the tag or tags.</p>
                */
            deleteTags(args: DeleteTagsCommandInput, options?: __HttpHandlerOptions): Promise<DeleteTagsCommandOutput>;
            deleteTags(args: DeleteTagsCommandInput, cb: (err: any, data?: DeleteTagsCommandOutput) => void): void;
            deleteTags(args: DeleteTagsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteTagsCommandOutput) => void): void;
            /**
                * <p>Deletes a usage limit from a cluster.</p>
                */
            deleteUsageLimit(args: DeleteUsageLimitCommandInput, options?: __HttpHandlerOptions): Promise<DeleteUsageLimitCommandOutput>;
            deleteUsageLimit(args: DeleteUsageLimitCommandInput, cb: (err: any, data?: DeleteUsageLimitCommandOutput) => void): void;
            deleteUsageLimit(args: DeleteUsageLimitCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteUsageLimitCommandOutput) => void): void;
            /**
                * <p>Returns a list of attributes attached to an account</p>
                */
            describeAccountAttributes(args: DescribeAccountAttributesCommandInput, options?: __HttpHandlerOptions): Promise<DescribeAccountAttributesCommandOutput>;
            describeAccountAttributes(args: DescribeAccountAttributesCommandInput, cb: (err: any, data?: DescribeAccountAttributesCommandOutput) => void): void;
            describeAccountAttributes(args: DescribeAccountAttributesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeAccountAttributesCommandOutput) => void): void;
            /**
                * <p>Describes an authentication profile.</p>
                */
            describeAuthenticationProfiles(args: DescribeAuthenticationProfilesCommandInput, options?: __HttpHandlerOptions): Promise<DescribeAuthenticationProfilesCommandOutput>;
            describeAuthenticationProfiles(args: DescribeAuthenticationProfilesCommandInput, cb: (err: any, data?: DescribeAuthenticationProfilesCommandOutput) => void): void;
            describeAuthenticationProfiles(args: DescribeAuthenticationProfilesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeAuthenticationProfilesCommandOutput) => void): void;
            /**
                * <p>Returns an array of <code>ClusterDbRevision</code> objects.</p>
                */
            describeClusterDbRevisions(args: DescribeClusterDbRevisionsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeClusterDbRevisionsCommandOutput>;
            describeClusterDbRevisions(args: DescribeClusterDbRevisionsCommandInput, cb: (err: any, data?: DescribeClusterDbRevisionsCommandOutput) => void): void;
            describeClusterDbRevisions(args: DescribeClusterDbRevisionsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeClusterDbRevisionsCommandOutput) => void): void;
            /**
                * <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you
                *             created and the default parameter group. For each parameter group, the response includes
                *             the parameter group name, description, and parameter group family name. You can
                *             optionally specify a name to retrieve the description of a specific parameter
                *             group.</p>
                *         <p>
                * For more information about parameters and parameter groups, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                *         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
                *             all parameter groups that match any combination of the specified keys and values. For
                *             example, if you have <code>owner</code> and <code>environment</code> for tag keys, and
                *                 <code>admin</code> and <code>test</code> for tag values, all parameter groups that
                *             have any combination of those values are returned.</p>
                *         <p>If both tag keys and values are omitted from the request, parameter groups are
                *             returned regardless of whether they have tag keys or values associated with
                *             them.</p>
                */
            describeClusterParameterGroups(args: DescribeClusterParameterGroupsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeClusterParameterGroupsCommandOutput>;
            describeClusterParameterGroups(args: DescribeClusterParameterGroupsCommandInput, cb: (err: any, data?: DescribeClusterParameterGroupsCommandOutput) => void): void;
            describeClusterParameterGroups(args: DescribeClusterParameterGroupsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeClusterParameterGroupsCommandOutput) => void): void;
            /**
                * <p>Returns a detailed list of parameters contained within the specified Amazon Redshift
                *             parameter group. For each parameter the response includes information such as parameter
                *             name, description, data type, value, whether the parameter value is modifiable, and so
                *             on.</p>
                *         <p>You can specify <i>source</i> filter to retrieve parameters of only
                *             specific type. For example, to retrieve parameters that were modified by a user action
                *             such as from <a>ModifyClusterParameterGroup</a>, you can specify
                *                 <i>source</i> equal to <i>user</i>.</p>
                *         <p>
                * For more information about parameters and parameter groups, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            describeClusterParameters(args: DescribeClusterParametersCommandInput, options?: __HttpHandlerOptions): Promise<DescribeClusterParametersCommandOutput>;
            describeClusterParameters(args: DescribeClusterParametersCommandInput, cb: (err: any, data?: DescribeClusterParametersCommandOutput) => void): void;
            describeClusterParameters(args: DescribeClusterParametersCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeClusterParametersCommandOutput) => void): void;
            /**
                * <p>Returns properties of provisioned clusters including general cluster properties,
                *             cluster database properties, maintenance and backup properties, and security and access
                *             properties. This operation supports pagination.
                * For more information about managing clusters, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                *         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
                *             all clusters that match any combination of the specified keys and values. For example,
                *             if you have <code>owner</code> and <code>environment</code> for tag keys, and
                *                 <code>admin</code> and <code>test</code> for tag values, all clusters that have any
                *             combination of those values are returned.</p>
                *         <p>If both tag keys and values are omitted from the request, clusters are returned
                *             regardless of whether they have tag keys or values associated with them.</p>
                */
            describeClusters(args: DescribeClustersCommandInput, options?: __HttpHandlerOptions): Promise<DescribeClustersCommandOutput>;
            describeClusters(args: DescribeClustersCommandInput, cb: (err: any, data?: DescribeClustersCommandOutput) => void): void;
            describeClusters(args: DescribeClustersCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeClustersCommandOutput) => void): void;
            /**
                * <p>Returns information about Amazon Redshift security groups. If the name of a security
                *             group is specified, the response will contain only information about only that security
                *             group.</p>
                *         <p>
                * For information about managing security groups, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the
                * <i>Amazon Redshift Cluster Management Guide</i>.</p>
                *         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
                *             all security groups that match any combination of the specified keys and values. For
                *             example, if you have <code>owner</code> and <code>environment</code> for tag keys, and
                *                 <code>admin</code> and <code>test</code> for tag values, all security groups that
                *             have any combination of those values are returned.</p>
                *         <p>If both tag keys and values are omitted from the request, security groups are
                *             returned regardless of whether they have tag keys or values associated with
                *             them.</p>
                */
            describeClusterSecurityGroups(args: DescribeClusterSecurityGroupsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeClusterSecurityGroupsCommandOutput>;
            describeClusterSecurityGroups(args: DescribeClusterSecurityGroupsCommandInput, cb: (err: any, data?: DescribeClusterSecurityGroupsCommandOutput) => void): void;
            describeClusterSecurityGroups(args: DescribeClusterSecurityGroupsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeClusterSecurityGroupsCommandOutput) => void): void;
            /**
                * <p>Returns one or more snapshot objects, which contain metadata about your cluster
                *             snapshots. By default, this operation returns information about all snapshots of all
                *             clusters that are owned by your Amazon Web Services account. No information is returned for
                *             snapshots owned by inactive Amazon Web Services accounts.</p>
                *         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
                *             all snapshots that match any combination of the specified keys and values. For example,
                *             if you have <code>owner</code> and <code>environment</code> for tag keys, and
                *                 <code>admin</code> and <code>test</code> for tag values, all snapshots that have any
                *             combination of those values are returned. Only snapshots that you own are returned in
                *             the response; shared snapshots are not returned with the tag key and tag value request
                *             parameters.</p>
                *         <p>If both tag keys and values are omitted from the request, snapshots are returned
                *             regardless of whether they have tag keys or values associated with them.</p>
                */
            describeClusterSnapshots(args: DescribeClusterSnapshotsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeClusterSnapshotsCommandOutput>;
            describeClusterSnapshots(args: DescribeClusterSnapshotsCommandInput, cb: (err: any, data?: DescribeClusterSnapshotsCommandOutput) => void): void;
            describeClusterSnapshots(args: DescribeClusterSnapshotsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeClusterSnapshotsCommandOutput) => void): void;
            /**
                * <p>Returns one or more cluster subnet group objects, which contain metadata about your
                *             cluster subnet groups. By default, this operation returns information about all cluster
                *             subnet groups that are defined in your Amazon Web Services account.</p>
                *         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
                *             all subnet groups that match any combination of the specified keys and values. For
                *             example, if you have <code>owner</code> and <code>environment</code> for tag keys, and
                *                 <code>admin</code> and <code>test</code> for tag values, all subnet groups that have
                *             any combination of those values are returned.</p>
                *         <p>If both tag keys and values are omitted from the request, subnet groups are
                *             returned regardless of whether they have tag keys or values associated with
                *             them.</p>
                */
            describeClusterSubnetGroups(args: DescribeClusterSubnetGroupsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeClusterSubnetGroupsCommandOutput>;
            describeClusterSubnetGroups(args: DescribeClusterSubnetGroupsCommandInput, cb: (err: any, data?: DescribeClusterSubnetGroupsCommandOutput) => void): void;
            describeClusterSubnetGroups(args: DescribeClusterSubnetGroupsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeClusterSubnetGroupsCommandOutput) => void): void;
            /**
                * <p>Returns a list of all the available maintenance tracks.</p>
                */
            describeClusterTracks(args: DescribeClusterTracksCommandInput, options?: __HttpHandlerOptions): Promise<DescribeClusterTracksCommandOutput>;
            describeClusterTracks(args: DescribeClusterTracksCommandInput, cb: (err: any, data?: DescribeClusterTracksCommandOutput) => void): void;
            describeClusterTracks(args: DescribeClusterTracksCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeClusterTracksCommandOutput) => void): void;
            /**
                * <p>Returns descriptions of the available Amazon Redshift cluster versions. You can call this
                *             operation even before creating any clusters to learn more about the Amazon Redshift versions.
                *
                * For more information about managing clusters, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            describeClusterVersions(args: DescribeClusterVersionsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeClusterVersionsCommandOutput>;
            describeClusterVersions(args: DescribeClusterVersionsCommandInput, cb: (err: any, data?: DescribeClusterVersionsCommandOutput) => void): void;
            describeClusterVersions(args: DescribeClusterVersionsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeClusterVersionsCommandOutput) => void): void;
            /**
                * <p>Shows the status of any inbound or outbound datashares available in the specified
                *             account.</p>
                */
            describeDataShares(args: DescribeDataSharesCommandInput, options?: __HttpHandlerOptions): Promise<DescribeDataSharesCommandOutput>;
            describeDataShares(args: DescribeDataSharesCommandInput, cb: (err: any, data?: DescribeDataSharesCommandOutput) => void): void;
            describeDataShares(args: DescribeDataSharesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeDataSharesCommandOutput) => void): void;
            /**
                * <p>Returns a list of datashares where the account identifier being called is a consumer account identifier.</p>
                */
            describeDataSharesForConsumer(args: DescribeDataSharesForConsumerCommandInput, options?: __HttpHandlerOptions): Promise<DescribeDataSharesForConsumerCommandOutput>;
            describeDataSharesForConsumer(args: DescribeDataSharesForConsumerCommandInput, cb: (err: any, data?: DescribeDataSharesForConsumerCommandOutput) => void): void;
            describeDataSharesForConsumer(args: DescribeDataSharesForConsumerCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeDataSharesForConsumerCommandOutput) => void): void;
            /**
                * <p>Returns a list of datashares when the account identifier being called is a producer account identifier.</p>
                */
            describeDataSharesForProducer(args: DescribeDataSharesForProducerCommandInput, options?: __HttpHandlerOptions): Promise<DescribeDataSharesForProducerCommandOutput>;
            describeDataSharesForProducer(args: DescribeDataSharesForProducerCommandInput, cb: (err: any, data?: DescribeDataSharesForProducerCommandOutput) => void): void;
            describeDataSharesForProducer(args: DescribeDataSharesForProducerCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeDataSharesForProducerCommandOutput) => void): void;
            /**
                * <p>Returns a list of parameter settings for the specified parameter group
                *             family.</p>
                *         <p>
                * For more information about parameters and parameter groups, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            describeDefaultClusterParameters(args: DescribeDefaultClusterParametersCommandInput, options?: __HttpHandlerOptions): Promise<DescribeDefaultClusterParametersCommandOutput>;
            describeDefaultClusterParameters(args: DescribeDefaultClusterParametersCommandInput, cb: (err: any, data?: DescribeDefaultClusterParametersCommandOutput) => void): void;
            describeDefaultClusterParameters(args: DescribeDefaultClusterParametersCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeDefaultClusterParametersCommandOutput) => void): void;
            /**
                * <p>Describes a Redshift-managed VPC endpoint.</p>
                */
            describeEndpointAccess(args: DescribeEndpointAccessCommandInput, options?: __HttpHandlerOptions): Promise<DescribeEndpointAccessCommandOutput>;
            describeEndpointAccess(args: DescribeEndpointAccessCommandInput, cb: (err: any, data?: DescribeEndpointAccessCommandOutput) => void): void;
            describeEndpointAccess(args: DescribeEndpointAccessCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeEndpointAccessCommandOutput) => void): void;
            /**
                * <p>Describes an endpoint authorization.</p>
                */
            describeEndpointAuthorization(args: DescribeEndpointAuthorizationCommandInput, options?: __HttpHandlerOptions): Promise<DescribeEndpointAuthorizationCommandOutput>;
            describeEndpointAuthorization(args: DescribeEndpointAuthorizationCommandInput, cb: (err: any, data?: DescribeEndpointAuthorizationCommandOutput) => void): void;
            describeEndpointAuthorization(args: DescribeEndpointAuthorizationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeEndpointAuthorizationCommandOutput) => void): void;
            /**
                * <p>Displays a list of event categories for all event source types, or for a specified
                *             source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event
                *                 Notifications</a>.</p>
                */
            describeEventCategories(args: DescribeEventCategoriesCommandInput, options?: __HttpHandlerOptions): Promise<DescribeEventCategoriesCommandOutput>;
            describeEventCategories(args: DescribeEventCategoriesCommandInput, cb: (err: any, data?: DescribeEventCategoriesCommandOutput) => void): void;
            describeEventCategories(args: DescribeEventCategoriesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeEventCategoriesCommandOutput) => void): void;
            /**
                * <p>Returns events related to clusters, security groups, snapshots, and parameter
                *             groups for the past 14 days. Events specific to a particular cluster, security group,
                *             snapshot or parameter group can be obtained by providing the name as a parameter. By
                *             default, the past hour of events are returned.</p>
                */
            describeEvents(args: DescribeEventsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeEventsCommandOutput>;
            describeEvents(args: DescribeEventsCommandInput, cb: (err: any, data?: DescribeEventsCommandOutput) => void): void;
            describeEvents(args: DescribeEventsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeEventsCommandOutput) => void): void;
            /**
                * <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a
                *             customer account. If you specify a subscription name, lists the description for that
                *             subscription.</p>
                *         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
                *             all event notification subscriptions that match any combination of the specified keys
                *             and values. For example, if you have <code>owner</code> and <code>environment</code> for
                *             tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions
                *             that have any combination of those values are returned.</p>
                *         <p>If both tag keys and values are omitted from the request, subscriptions are
                *             returned regardless of whether they have tag keys or values associated with
                *             them.</p>
                */
            describeEventSubscriptions(args: DescribeEventSubscriptionsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeEventSubscriptionsCommandOutput>;
            describeEventSubscriptions(args: DescribeEventSubscriptionsCommandInput, cb: (err: any, data?: DescribeEventSubscriptionsCommandOutput) => void): void;
            describeEventSubscriptions(args: DescribeEventSubscriptionsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeEventSubscriptionsCommandOutput) => void): void;
            /**
                * <p>Returns information about the specified HSM client certificate. If no certificate
                *             ID is specified, returns information about all the HSM certificates owned by your Amazon Web Services account.</p>
                *         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
                *             all HSM client certificates that match any combination of the specified keys and values.
                *             For example, if you have <code>owner</code> and <code>environment</code> for tag keys,
                *             and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates
                *             that have any combination of those values are returned.</p>
                *         <p>If both tag keys and values are omitted from the request, HSM client certificates
                *             are returned regardless of whether they have tag keys or values associated with
                *             them.</p>
                */
            describeHsmClientCertificates(args: DescribeHsmClientCertificatesCommandInput, options?: __HttpHandlerOptions): Promise<DescribeHsmClientCertificatesCommandOutput>;
            describeHsmClientCertificates(args: DescribeHsmClientCertificatesCommandInput, cb: (err: any, data?: DescribeHsmClientCertificatesCommandOutput) => void): void;
            describeHsmClientCertificates(args: DescribeHsmClientCertificatesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeHsmClientCertificatesCommandOutput) => void): void;
            /**
                * <p>Returns information about the specified Amazon Redshift HSM configuration. If no
                *             configuration ID is specified, returns information about all the HSM configurations
                *             owned by your Amazon Web Services account.</p>
                *         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
                *             all HSM connections that match any combination of the specified keys and values. For
                *             example, if you have <code>owner</code> and <code>environment</code> for tag keys, and
                *                 <code>admin</code> and <code>test</code> for tag values, all HSM connections that
                *             have any combination of those values are returned.</p>
                *         <p>If both tag keys and values are omitted from the request, HSM connections are
                *             returned regardless of whether they have tag keys or values associated with
                *             them.</p>
                */
            describeHsmConfigurations(args: DescribeHsmConfigurationsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeHsmConfigurationsCommandOutput>;
            describeHsmConfigurations(args: DescribeHsmConfigurationsCommandInput, cb: (err: any, data?: DescribeHsmConfigurationsCommandOutput) => void): void;
            describeHsmConfigurations(args: DescribeHsmConfigurationsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeHsmConfigurationsCommandOutput) => void): void;
            /**
                * <p>Describes whether information, such as queries and connection attempts, is being
                *             logged for the specified Amazon Redshift cluster.</p>
                */
            describeLoggingStatus(args: DescribeLoggingStatusCommandInput, options?: __HttpHandlerOptions): Promise<DescribeLoggingStatusCommandOutput>;
            describeLoggingStatus(args: DescribeLoggingStatusCommandInput, cb: (err: any, data?: DescribeLoggingStatusCommandOutput) => void): void;
            describeLoggingStatus(args: DescribeLoggingStatusCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeLoggingStatusCommandOutput) => void): void;
            /**
                * <p>Returns properties of possible node configurations such as node type, number of nodes, and
                *             disk usage for the specified action type.</p>
                */
            describeNodeConfigurationOptions(args: DescribeNodeConfigurationOptionsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeNodeConfigurationOptionsCommandOutput>;
            describeNodeConfigurationOptions(args: DescribeNodeConfigurationOptionsCommandInput, cb: (err: any, data?: DescribeNodeConfigurationOptionsCommandOutput) => void): void;
            describeNodeConfigurationOptions(args: DescribeNodeConfigurationOptionsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeNodeConfigurationOptionsCommandOutput) => void): void;
            /**
                * <p>Returns a list of orderable cluster options. Before you create a new cluster you
                *             can use this operation to find what options are available, such as the EC2 Availability
                *             Zones (AZ) in the specific Amazon Web Services Region that you can specify, and the node types you can
                *             request. The node types differ by available storage, memory, CPU and price. With the
                *             cost involved you might want to obtain a list of cluster options in the specific region
                *             and specify values when creating a cluster.
                * For more information about managing clusters, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            describeOrderableClusterOptions(args: DescribeOrderableClusterOptionsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeOrderableClusterOptionsCommandOutput>;
            describeOrderableClusterOptions(args: DescribeOrderableClusterOptionsCommandInput, cb: (err: any, data?: DescribeOrderableClusterOptionsCommandOutput) => void): void;
            describeOrderableClusterOptions(args: DescribeOrderableClusterOptionsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeOrderableClusterOptionsCommandOutput) => void): void;
            /**
                * <p>Returns information about the partner integrations defined for a cluster.</p>
                */
            describePartners(args: DescribePartnersCommandInput, options?: __HttpHandlerOptions): Promise<DescribePartnersCommandOutput>;
            describePartners(args: DescribePartnersCommandInput, cb: (err: any, data?: DescribePartnersCommandOutput) => void): void;
            describePartners(args: DescribePartnersCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribePartnersCommandOutput) => void): void;
            /**
                * <p>Returns exchange status details and associated metadata for a reserved-node
                *             exchange. Statuses include such values as in progress and requested.</p>
                */
            describeReservedNodeExchangeStatus(args: DescribeReservedNodeExchangeStatusCommandInput, options?: __HttpHandlerOptions): Promise<DescribeReservedNodeExchangeStatusCommandOutput>;
            describeReservedNodeExchangeStatus(args: DescribeReservedNodeExchangeStatusCommandInput, cb: (err: any, data?: DescribeReservedNodeExchangeStatusCommandOutput) => void): void;
            describeReservedNodeExchangeStatus(args: DescribeReservedNodeExchangeStatusCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeReservedNodeExchangeStatusCommandOutput) => void): void;
            /**
                * <p>Returns a list of the available reserved node offerings by Amazon Redshift with their
                *             descriptions including the node type, the fixed and recurring costs of reserving the
                *             node and duration the node will be reserved for you. These descriptions help you
                *             determine which reserve node offering you want to purchase. You then use the unique
                *             offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one
                *             or more nodes for your Amazon Redshift cluster. </p>
                *         <p>
                * For more information about reserved node offerings, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            describeReservedNodeOfferings(args: DescribeReservedNodeOfferingsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeReservedNodeOfferingsCommandOutput>;
            describeReservedNodeOfferings(args: DescribeReservedNodeOfferingsCommandInput, cb: (err: any, data?: DescribeReservedNodeOfferingsCommandOutput) => void): void;
            describeReservedNodeOfferings(args: DescribeReservedNodeOfferingsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeReservedNodeOfferingsCommandOutput) => void): void;
            /**
                * <p>Returns the descriptions of the reserved nodes.</p>
                */
            describeReservedNodes(args: DescribeReservedNodesCommandInput, options?: __HttpHandlerOptions): Promise<DescribeReservedNodesCommandOutput>;
            describeReservedNodes(args: DescribeReservedNodesCommandInput, cb: (err: any, data?: DescribeReservedNodesCommandOutput) => void): void;
            describeReservedNodes(args: DescribeReservedNodesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeReservedNodesCommandOutput) => void): void;
            /**
                * <p>Returns information about the last resize operation for the specified cluster. If
                *             no resize operation has ever been initiated for the specified cluster, a <code>HTTP
                *                 404</code> error is returned. If a resize operation was initiated and completed, the
                *             status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p>
                *         <p>A resize operation can be requested using <a>ModifyCluster</a> and
                *             specifying a different number or type of nodes for the cluster. </p>
                */
            describeResize(args: DescribeResizeCommandInput, options?: __HttpHandlerOptions): Promise<DescribeResizeCommandOutput>;
            describeResize(args: DescribeResizeCommandInput, cb: (err: any, data?: DescribeResizeCommandOutput) => void): void;
            describeResize(args: DescribeResizeCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeResizeCommandOutput) => void): void;
            /**
                * <p>Describes properties of scheduled actions.
                *              </p>
                */
            describeScheduledActions(args: DescribeScheduledActionsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeScheduledActionsCommandOutput>;
            describeScheduledActions(args: DescribeScheduledActionsCommandInput, cb: (err: any, data?: DescribeScheduledActionsCommandOutput) => void): void;
            describeScheduledActions(args: DescribeScheduledActionsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeScheduledActionsCommandOutput) => void): void;
            /**
                * <p>Returns a list of snapshot copy grants owned by the Amazon Web Services account in the destination
                *             region.</p>
                *         <p>
                * For more information about managing snapshot copy grants, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.
                * </p>
                */
            describeSnapshotCopyGrants(args: DescribeSnapshotCopyGrantsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeSnapshotCopyGrantsCommandOutput>;
            describeSnapshotCopyGrants(args: DescribeSnapshotCopyGrantsCommandInput, cb: (err: any, data?: DescribeSnapshotCopyGrantsCommandOutput) => void): void;
            describeSnapshotCopyGrants(args: DescribeSnapshotCopyGrantsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeSnapshotCopyGrantsCommandOutput) => void): void;
            /**
                * <p>Returns a list of snapshot schedules. </p>
                */
            describeSnapshotSchedules(args: DescribeSnapshotSchedulesCommandInput, options?: __HttpHandlerOptions): Promise<DescribeSnapshotSchedulesCommandOutput>;
            describeSnapshotSchedules(args: DescribeSnapshotSchedulesCommandInput, cb: (err: any, data?: DescribeSnapshotSchedulesCommandOutput) => void): void;
            describeSnapshotSchedules(args: DescribeSnapshotSchedulesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeSnapshotSchedulesCommandOutput) => void): void;
            /**
                * <p>Returns account level backups storage size and provisional storage.</p>
                */
            describeStorage(args: DescribeStorageCommandInput, options?: __HttpHandlerOptions): Promise<DescribeStorageCommandOutput>;
            describeStorage(args: DescribeStorageCommandInput, cb: (err: any, data?: DescribeStorageCommandOutput) => void): void;
            describeStorage(args: DescribeStorageCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeStorageCommandOutput) => void): void;
            /**
                * <p>Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value
                *             for the <code>TableRestoreRequestId</code> parameter, then
                *                 <code>DescribeTableRestoreStatus</code> returns the status of all table restore
                *             requests ordered by the date and time of the request in ascending order. Otherwise
                *                 <code>DescribeTableRestoreStatus</code> returns the status of the table specified by
                *                 <code>TableRestoreRequestId</code>.</p>
                */
            describeTableRestoreStatus(args: DescribeTableRestoreStatusCommandInput, options?: __HttpHandlerOptions): Promise<DescribeTableRestoreStatusCommandOutput>;
            describeTableRestoreStatus(args: DescribeTableRestoreStatusCommandInput, cb: (err: any, data?: DescribeTableRestoreStatusCommandOutput) => void): void;
            describeTableRestoreStatus(args: DescribeTableRestoreStatusCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeTableRestoreStatusCommandOutput) => void): void;
            /**
                * <p>Returns a list of tags. You can return tags from a specific resource by specifying
                *             an ARN, or you can return all tags for a given type of resource, such as clusters,
                *             snapshots, and so on.</p>
                *         <p>The following are limitations for <code>DescribeTags</code>: </p>
                *         <ul>
                *             <li>
                *                 <p>You cannot specify an ARN and a resource-type value together in the same
                *                     request.</p>
                *             </li>
                *             <li>
                *                 <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code>
                *                     parameters together with the ARN parameter.</p>
                *             </li>
                *             <li>
                *                 <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results
                *                     to return in a request.</p>
                *             </li>
                *          </ul>
                *         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
                *             all resources that match any combination of the specified keys and values. For example,
                *             if you have <code>owner</code> and <code>environment</code> for tag keys, and
                *                 <code>admin</code> and <code>test</code> for tag values, all resources that have any
                *             combination of those values are returned.</p>
                *         <p>If both tag keys and values are omitted from the request, resources are returned
                *             regardless of whether they have tag keys or values associated with them.</p>
                */
            describeTags(args: DescribeTagsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeTagsCommandOutput>;
            describeTags(args: DescribeTagsCommandInput, cb: (err: any, data?: DescribeTagsCommandOutput) => void): void;
            describeTags(args: DescribeTagsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeTagsCommandOutput) => void): void;
            /**
                * <p>Shows usage limits on a cluster.
                *             Results are filtered based on the combination of input usage limit identifier, cluster identifier, and feature type parameters:</p>
                *         <ul>
                *             <li>
                *                <p>If usage limit identifier, cluster identifier, and feature type are not provided,
                *                 then all usage limit objects for the current account in the current region are returned.</p>
                *             </li>
                *             <li>
                *                <p>If usage limit identifier is provided,
                *                 then the corresponding usage limit object is returned.</p>
                *             </li>
                *             <li>
                *                <p>If cluster identifier is provided,
                *                 then all usage limit objects for the specified cluster are returned.</p>
                *             </li>
                *             <li>
                *                <p>If cluster identifier and feature type are provided,
                *                 then all usage limit objects for the combination of cluster and feature are returned.</p>
                *             </li>
                *          </ul>
                */
            describeUsageLimits(args: DescribeUsageLimitsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeUsageLimitsCommandOutput>;
            describeUsageLimits(args: DescribeUsageLimitsCommandInput, cb: (err: any, data?: DescribeUsageLimitsCommandOutput) => void): void;
            describeUsageLimits(args: DescribeUsageLimitsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeUsageLimitsCommandOutput) => void): void;
            /**
                * <p>Stops logging information, such as queries and connection attempts, for the
                *             specified Amazon Redshift cluster.</p>
                */
            disableLogging(args: DisableLoggingCommandInput, options?: __HttpHandlerOptions): Promise<DisableLoggingCommandOutput>;
            disableLogging(args: DisableLoggingCommandInput, cb: (err: any, data?: DisableLoggingCommandOutput) => void): void;
            disableLogging(args: DisableLoggingCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DisableLoggingCommandOutput) => void): void;
            /**
                * <p>Disables the automatic copying of snapshots from one region to another region for a
                *             specified cluster.</p>
                *         <p>If your cluster and its snapshots are encrypted using an encrypted symmetric key
                *             from Key Management Service, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that
                *             grants Amazon Redshift permission to the key in the destination region. </p>
                */
            disableSnapshotCopy(args: DisableSnapshotCopyCommandInput, options?: __HttpHandlerOptions): Promise<DisableSnapshotCopyCommandOutput>;
            disableSnapshotCopy(args: DisableSnapshotCopyCommandInput, cb: (err: any, data?: DisableSnapshotCopyCommandOutput) => void): void;
            disableSnapshotCopy(args: DisableSnapshotCopyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DisableSnapshotCopyCommandOutput) => void): void;
            /**
                * <p>From a datashare consumer account, remove association for the specified datashare.
                *             </p>
                */
            disassociateDataShareConsumer(args: DisassociateDataShareConsumerCommandInput, options?: __HttpHandlerOptions): Promise<DisassociateDataShareConsumerCommandOutput>;
            disassociateDataShareConsumer(args: DisassociateDataShareConsumerCommandInput, cb: (err: any, data?: DisassociateDataShareConsumerCommandOutput) => void): void;
            disassociateDataShareConsumer(args: DisassociateDataShareConsumerCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DisassociateDataShareConsumerCommandOutput) => void): void;
            /**
                * <p>Starts logging information, such as queries and connection attempts, for the
                *             specified Amazon Redshift cluster.</p>
                */
            enableLogging(args: EnableLoggingCommandInput, options?: __HttpHandlerOptions): Promise<EnableLoggingCommandOutput>;
            enableLogging(args: EnableLoggingCommandInput, cb: (err: any, data?: EnableLoggingCommandOutput) => void): void;
            enableLogging(args: EnableLoggingCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: EnableLoggingCommandOutput) => void): void;
            /**
                * <p>Enables the automatic copy of snapshots from one region to another region for a
                *             specified cluster.</p>
                */
            enableSnapshotCopy(args: EnableSnapshotCopyCommandInput, options?: __HttpHandlerOptions): Promise<EnableSnapshotCopyCommandOutput>;
            enableSnapshotCopy(args: EnableSnapshotCopyCommandInput, cb: (err: any, data?: EnableSnapshotCopyCommandOutput) => void): void;
            enableSnapshotCopy(args: EnableSnapshotCopyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: EnableSnapshotCopyCommandOutput) => void): void;
            /**
                * <p>Returns a database user name and temporary password with temporary authorization to
                *             log on to an Amazon Redshift database. The action returns the database user name
                *             prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or
                *                 <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can
                *             optionally specify one or more database user groups that the user will join at log on.
                *             By default, the temporary credentials expire in 900 seconds. You can optionally specify
                *             a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more
                *             information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication
                *                 to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p>
                *         <p>The Identity and Access Management (IAM) user or role that runs
                *             GetClusterCredentials must have an IAM policy attached that allows access to all
                *             necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the
                *             Amazon Redshift Cluster Management Guide.</p>
                *         <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the
                *                 <code>redshift:JoinGroup</code> action with access to the listed
                *                 <code>dbgroups</code>. </p>
                *         <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>,
                *             then the policy must include the <code>redshift:CreateClusterUser</code>
                *             permission.</p>
                *         <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access
                *             to the resource <code>dbname</code> for the specified database name. </p>
                */
            getClusterCredentials(args: GetClusterCredentialsCommandInput, options?: __HttpHandlerOptions): Promise<GetClusterCredentialsCommandOutput>;
            getClusterCredentials(args: GetClusterCredentialsCommandInput, cb: (err: any, data?: GetClusterCredentialsCommandOutput) => void): void;
            getClusterCredentials(args: GetClusterCredentialsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetClusterCredentialsCommandOutput) => void): void;
            /**
                * <p>Returns a database user name and temporary password with temporary authorization to
                *             log in to an Amazon Redshift database.
                *             The database user is mapped 1:1 to the source Identity and Access Management (IAM) identity.
                *             For more information about IAM identities, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id.html">IAM Identities (users, user groups, and roles)</a> in the
                *             Amazon Web Services Identity and Access Management User Guide.</p>
                *         <p>The Identity and Access Management (IAM) identity that runs
                *             this operation must have an IAM policy attached that allows access to all
                *             necessary actions and resources.
                *                 For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html">Using identity-based policies (IAM policies)</a> in the
                *             Amazon Redshift Cluster Management Guide. </p>
                */
            getClusterCredentialsWithIAM(args: GetClusterCredentialsWithIAMCommandInput, options?: __HttpHandlerOptions): Promise<GetClusterCredentialsWithIAMCommandOutput>;
            getClusterCredentialsWithIAM(args: GetClusterCredentialsWithIAMCommandInput, cb: (err: any, data?: GetClusterCredentialsWithIAMCommandOutput) => void): void;
            getClusterCredentialsWithIAM(args: GetClusterCredentialsWithIAMCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetClusterCredentialsWithIAMCommandOutput) => void): void;
            /**
                * <p>Gets the configuration options for the reserved-node exchange. These options
                *             include information about the source reserved node and target reserved node offering.
                *             Details include the node type, the price, the node count, and the offering type.</p>
                */
            getReservedNodeExchangeConfigurationOptions(args: GetReservedNodeExchangeConfigurationOptionsCommandInput, options?: __HttpHandlerOptions): Promise<GetReservedNodeExchangeConfigurationOptionsCommandOutput>;
            getReservedNodeExchangeConfigurationOptions(args: GetReservedNodeExchangeConfigurationOptionsCommandInput, cb: (err: any, data?: GetReservedNodeExchangeConfigurationOptionsCommandOutput) => void): void;
            getReservedNodeExchangeConfigurationOptions(args: GetReservedNodeExchangeConfigurationOptionsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetReservedNodeExchangeConfigurationOptionsCommandOutput) => void): void;
            /**
                * <p>Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term,
                *             and usage price of the given DC1 reserved node.</p>
                */
            getReservedNodeExchangeOfferings(args: GetReservedNodeExchangeOfferingsCommandInput, options?: __HttpHandlerOptions): Promise<GetReservedNodeExchangeOfferingsCommandOutput>;
            getReservedNodeExchangeOfferings(args: GetReservedNodeExchangeOfferingsCommandInput, cb: (err: any, data?: GetReservedNodeExchangeOfferingsCommandOutput) => void): void;
            getReservedNodeExchangeOfferings(args: GetReservedNodeExchangeOfferingsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetReservedNodeExchangeOfferingsCommandOutput) => void): void;
            /**
                * <p>Modifies whether a cluster can use AQUA (Advanced Query Accelerator). </p>
                */
            modifyAquaConfiguration(args: ModifyAquaConfigurationCommandInput, options?: __HttpHandlerOptions): Promise<ModifyAquaConfigurationCommandOutput>;
            modifyAquaConfiguration(args: ModifyAquaConfigurationCommandInput, cb: (err: any, data?: ModifyAquaConfigurationCommandOutput) => void): void;
            modifyAquaConfiguration(args: ModifyAquaConfigurationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ModifyAquaConfigurationCommandOutput) => void): void;
            /**
                * <p>Modifies an authentication profile.</p>
                */
            modifyAuthenticationProfile(args: ModifyAuthenticationProfileCommandInput, options?: __HttpHandlerOptions): Promise<ModifyAuthenticationProfileCommandOutput>;
            modifyAuthenticationProfile(args: ModifyAuthenticationProfileCommandInput, cb: (err: any, data?: ModifyAuthenticationProfileCommandOutput) => void): void;
            modifyAuthenticationProfile(args: ModifyAuthenticationProfileCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ModifyAuthenticationProfileCommandOutput) => void): void;
            /**
                * <p>Modifies the settings for a cluster.</p>
                *         <p>You can also change node type and the number of nodes to scale up or down the
                *             cluster. When resizing a cluster, you must specify both the number of nodes and the node
                *             type even if one of the parameters does not change.</p>
                * 		       <p>You can add another security or
                *             parameter group, or change the admin user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect.
                * For more information about managing clusters, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            modifyCluster(args: ModifyClusterCommandInput, options?: __HttpHandlerOptions): Promise<ModifyClusterCommandOutput>;
            modifyCluster(args: ModifyClusterCommandInput, cb: (err: any, data?: ModifyClusterCommandOutput) => void): void;
            modifyCluster(args: ModifyClusterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ModifyClusterCommandOutput) => void): void;
            /**
                * <p>Modifies the database revision of a cluster. The database revision is a unique
                *             revision of the database running in a cluster.</p>
                */
            modifyClusterDbRevision(args: ModifyClusterDbRevisionCommandInput, options?: __HttpHandlerOptions): Promise<ModifyClusterDbRevisionCommandOutput>;
            modifyClusterDbRevision(args: ModifyClusterDbRevisionCommandInput, cb: (err: any, data?: ModifyClusterDbRevisionCommandOutput) => void): void;
            modifyClusterDbRevision(args: ModifyClusterDbRevisionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ModifyClusterDbRevisionCommandOutput) => void): void;
            /**
                * <p>Modifies the list of Identity and Access Management (IAM) roles that can be
                *             used by the cluster to access other Amazon Web Services services.</p>
                *         <p>The maximum number of IAM roles that you can associate is subject to a quota.
                *             For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Quotas and limits</a>
                *             in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            modifyClusterIamRoles(args: ModifyClusterIamRolesCommandInput, options?: __HttpHandlerOptions): Promise<ModifyClusterIamRolesCommandOutput>;
            modifyClusterIamRoles(args: ModifyClusterIamRolesCommandInput, cb: (err: any, data?: ModifyClusterIamRolesCommandOutput) => void): void;
            modifyClusterIamRoles(args: ModifyClusterIamRolesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ModifyClusterIamRolesCommandOutput) => void): void;
            /**
                * <p>Modifies the maintenance settings of a cluster.</p>
                */
            modifyClusterMaintenance(args: ModifyClusterMaintenanceCommandInput, options?: __HttpHandlerOptions): Promise<ModifyClusterMaintenanceCommandOutput>;
            modifyClusterMaintenance(args: ModifyClusterMaintenanceCommandInput, cb: (err: any, data?: ModifyClusterMaintenanceCommandOutput) => void): void;
            modifyClusterMaintenance(args: ModifyClusterMaintenanceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ModifyClusterMaintenanceCommandOutput) => void): void;
            /**
                * <p>Modifies the parameters of a parameter group. For the parameters parameter, it can't contain ASCII characters.</p>
                *         <p>
                * For more information about parameters and parameter groups, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            modifyClusterParameterGroup(args: ModifyClusterParameterGroupCommandInput, options?: __HttpHandlerOptions): Promise<ModifyClusterParameterGroupCommandOutput>;
            modifyClusterParameterGroup(args: ModifyClusterParameterGroupCommandInput, cb: (err: any, data?: ModifyClusterParameterGroupCommandOutput) => void): void;
            modifyClusterParameterGroup(args: ModifyClusterParameterGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ModifyClusterParameterGroupCommandOutput) => void): void;
            /**
                * <p>Modifies the settings for a snapshot.</p>
                * 		       <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
                */
            modifyClusterSnapshot(args: ModifyClusterSnapshotCommandInput, options?: __HttpHandlerOptions): Promise<ModifyClusterSnapshotCommandOutput>;
            modifyClusterSnapshot(args: ModifyClusterSnapshotCommandInput, cb: (err: any, data?: ModifyClusterSnapshotCommandOutput) => void): void;
            modifyClusterSnapshot(args: ModifyClusterSnapshotCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ModifyClusterSnapshotCommandOutput) => void): void;
            /**
                * <p>Modifies a snapshot schedule for a cluster.</p>
                */
            modifyClusterSnapshotSchedule(args: ModifyClusterSnapshotScheduleCommandInput, options?: __HttpHandlerOptions): Promise<ModifyClusterSnapshotScheduleCommandOutput>;
            modifyClusterSnapshotSchedule(args: ModifyClusterSnapshotScheduleCommandInput, cb: (err: any, data?: ModifyClusterSnapshotScheduleCommandOutput) => void): void;
            modifyClusterSnapshotSchedule(args: ModifyClusterSnapshotScheduleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ModifyClusterSnapshotScheduleCommandOutput) => void): void;
            /**
                * <p>Modifies a cluster subnet group to include the specified list of VPC subnets. The
                *             operation replaces the existing list of subnets with the new list of subnets.</p>
                */
            modifyClusterSubnetGroup(args: ModifyClusterSubnetGroupCommandInput, options?: __HttpHandlerOptions): Promise<ModifyClusterSubnetGroupCommandOutput>;
            modifyClusterSubnetGroup(args: ModifyClusterSubnetGroupCommandInput, cb: (err: any, data?: ModifyClusterSubnetGroupCommandOutput) => void): void;
            modifyClusterSubnetGroup(args: ModifyClusterSubnetGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ModifyClusterSubnetGroupCommandOutput) => void): void;
            /**
                * <p>Modifies a Redshift-managed VPC endpoint.</p>
                */
            modifyEndpointAccess(args: ModifyEndpointAccessCommandInput, options?: __HttpHandlerOptions): Promise<ModifyEndpointAccessCommandOutput>;
            modifyEndpointAccess(args: ModifyEndpointAccessCommandInput, cb: (err: any, data?: ModifyEndpointAccessCommandOutput) => void): void;
            modifyEndpointAccess(args: ModifyEndpointAccessCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ModifyEndpointAccessCommandOutput) => void): void;
            /**
                * <p>Modifies an existing Amazon Redshift event notification subscription.</p>
                */
            modifyEventSubscription(args: ModifyEventSubscriptionCommandInput, options?: __HttpHandlerOptions): Promise<ModifyEventSubscriptionCommandOutput>;
            modifyEventSubscription(args: ModifyEventSubscriptionCommandInput, cb: (err: any, data?: ModifyEventSubscriptionCommandOutput) => void): void;
            modifyEventSubscription(args: ModifyEventSubscriptionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ModifyEventSubscriptionCommandOutput) => void): void;
            /**
                * <p>Modifies a scheduled action.
                *             </p>
                */
            modifyScheduledAction(args: ModifyScheduledActionCommandInput, options?: __HttpHandlerOptions): Promise<ModifyScheduledActionCommandOutput>;
            modifyScheduledAction(args: ModifyScheduledActionCommandInput, cb: (err: any, data?: ModifyScheduledActionCommandOutput) => void): void;
            modifyScheduledAction(args: ModifyScheduledActionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ModifyScheduledActionCommandOutput) => void): void;
            /**
                * <p>Modifies the number of days to retain snapshots in the destination Amazon Web Services Region after
                *             they are copied from the source Amazon Web Services Region. By default, this operation only changes the
                *             retention period of copied automated snapshots. The retention periods for both new and
                *             existing copied automated snapshots are updated with the new retention period. You can
                *             set the manual option to change only the retention periods of copied manual snapshots.
                *             If you set this option, only newly copied manual snapshots have the new retention
                *             period. </p>
                */
            modifySnapshotCopyRetentionPeriod(args: ModifySnapshotCopyRetentionPeriodCommandInput, options?: __HttpHandlerOptions): Promise<ModifySnapshotCopyRetentionPeriodCommandOutput>;
            modifySnapshotCopyRetentionPeriod(args: ModifySnapshotCopyRetentionPeriodCommandInput, cb: (err: any, data?: ModifySnapshotCopyRetentionPeriodCommandOutput) => void): void;
            modifySnapshotCopyRetentionPeriod(args: ModifySnapshotCopyRetentionPeriodCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ModifySnapshotCopyRetentionPeriodCommandOutput) => void): void;
            /**
                * <p>Modifies a snapshot schedule. Any schedule associated with a cluster is modified
                *             asynchronously.</p>
                */
            modifySnapshotSchedule(args: ModifySnapshotScheduleCommandInput, options?: __HttpHandlerOptions): Promise<ModifySnapshotScheduleCommandOutput>;
            modifySnapshotSchedule(args: ModifySnapshotScheduleCommandInput, cb: (err: any, data?: ModifySnapshotScheduleCommandOutput) => void): void;
            modifySnapshotSchedule(args: ModifySnapshotScheduleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ModifySnapshotScheduleCommandOutput) => void): void;
            /**
                * <p>Modifies a usage limit in a cluster.
                *             You can't modify the feature type or period of a usage limit.</p>
                */
            modifyUsageLimit(args: ModifyUsageLimitCommandInput, options?: __HttpHandlerOptions): Promise<ModifyUsageLimitCommandOutput>;
            modifyUsageLimit(args: ModifyUsageLimitCommandInput, cb: (err: any, data?: ModifyUsageLimitCommandOutput) => void): void;
            modifyUsageLimit(args: ModifyUsageLimitCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ModifyUsageLimitCommandOutput) => void): void;
            /**
                * <p>Pauses a cluster.</p>
                */
            pauseCluster(args: PauseClusterCommandInput, options?: __HttpHandlerOptions): Promise<PauseClusterCommandOutput>;
            pauseCluster(args: PauseClusterCommandInput, cb: (err: any, data?: PauseClusterCommandOutput) => void): void;
            pauseCluster(args: PauseClusterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PauseClusterCommandOutput) => void): void;
            /**
                * <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of
                *             reserved node offerings. You can purchase one or more of the offerings. You can call the
                *                 <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved
                *             node offerings. You can call this API by providing a specific reserved node offering and
                *             the number of nodes you want to reserve. </p>
                *         <p>
                * For more information about reserved node offerings, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            purchaseReservedNodeOffering(args: PurchaseReservedNodeOfferingCommandInput, options?: __HttpHandlerOptions): Promise<PurchaseReservedNodeOfferingCommandOutput>;
            purchaseReservedNodeOffering(args: PurchaseReservedNodeOfferingCommandInput, cb: (err: any, data?: PurchaseReservedNodeOfferingCommandOutput) => void): void;
            purchaseReservedNodeOffering(args: PurchaseReservedNodeOfferingCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PurchaseReservedNodeOfferingCommandOutput) => void): void;
            /**
                * <p>Reboots a cluster. This action is taken as soon as possible. It results in a
                *             momentary outage to the cluster, during which the cluster status is set to
                *                 <code>rebooting</code>. A cluster event is created when the reboot is completed. Any
                *             pending cluster modifications (see <a>ModifyCluster</a>) are applied at this
                *             reboot.
                * For more information about managing clusters, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
                */
            rebootCluster(args: RebootClusterCommandInput, options?: __HttpHandlerOptions): Promise<RebootClusterCommandOutput>;
            rebootCluster(args: RebootClusterCommandInput, cb: (err: any, data?: RebootClusterCommandOutput) => void): void;
            rebootCluster(args: RebootClusterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RebootClusterCommandOutput) => void): void;
            /**
                * <p>From a datashare consumer account, rejects the specified datashare.</p>
                */
            rejectDataShare(args: RejectDataShareCommandInput, options?: __HttpHandlerOptions): Promise<RejectDataShareCommandOutput>;
            rejectDataShare(args: RejectDataShareCommandInput, cb: (err: any, data?: RejectDataShareCommandOutput) => void): void;
            rejectDataShare(args: RejectDataShareCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RejectDataShareCommandOutput) => void): void;
            /**
                * <p>Sets one or more parameters of the specified parameter group to their default
                *             values and sets the source values of the parameters to "engine-default". To reset the
                *             entire parameter group specify the <i>ResetAllParameters</i> parameter.
                *             For parameter changes to take effect you must reboot any associated clusters. </p>
                */
            resetClusterParameterGroup(args: ResetClusterParameterGroupCommandInput, options?: __HttpHandlerOptions): Promise<ResetClusterParameterGroupCommandOutput>;
            resetClusterParameterGroup(args: ResetClusterParameterGroupCommandInput, cb: (err: any, data?: ResetClusterParameterGroupCommandOutput) => void): void;
            resetClusterParameterGroup(args: ResetClusterParameterGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ResetClusterParameterGroupCommandOutput) => void): void;
            /**
                * <p>Changes the size of the cluster. You can change the cluster's type, or change the
                *             number or type of nodes. The default behavior is to use the elastic resize method. With
                *             an elastic resize, your cluster is available for read and write operations more quickly
                *             than with the classic resize method. </p>
                *         <p>Elastic resize operations have the following restrictions:</p>
                *         <ul>
                *             <li>
                *                 <p>You can only resize clusters of the following types:</p>
                *                 <ul>
                *                   <li>
                *                         <p>dc1.large (if your cluster is in a VPC)</p>
                *                     </li>
                *                   <li>
                *                         <p>dc1.8xlarge (if your cluster is in a VPC)</p>
                *                     </li>
                *                   <li>
                *                         <p>dc2.large</p>
                *                     </li>
                *                   <li>
                *                         <p>dc2.8xlarge</p>
                *                     </li>
                *                   <li>
                *                         <p>ds2.xlarge</p>
                *                     </li>
                *                   <li>
                *                         <p>ds2.8xlarge</p>
                *                     </li>
                *                   <li>
                *                         <p>ra3.xlplus</p>
                *                     </li>
                *                   <li>
                *                         <p>ra3.4xlarge</p>
                *                     </li>
                *                   <li>
                *                         <p>ra3.16xlarge</p>
                *                     </li>
                *                </ul>
                *             </li>
                *             <li>
                *                 <p>The type of nodes that you add must match the node type for the
                *                     cluster.</p>
                *             </li>
                *          </ul>
                */
            resizeCluster(args: ResizeClusterCommandInput, options?: __HttpHandlerOptions): Promise<ResizeClusterCommandOutput>;
            resizeCluster(args: ResizeClusterCommandInput, cb: (err: any, data?: ResizeClusterCommandOutput) => void): void;
            resizeCluster(args: ResizeClusterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ResizeClusterCommandOutput) => void): void;
            /**
                * <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting
                *             cluster with the same configuration as the original cluster from which the snapshot was
                *             created, except that the new cluster is created with the default cluster security and
                *             parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different
                *             parameter group with the restored cluster. If you are using a DS node type, you can also
                *             choose to change to another DS node type of the same size during restore.</p>
                *         <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where
                *             you want the cluster restored.</p>
                *         <p>
                * For more information about working with snapshots, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            restoreFromClusterSnapshot(args: RestoreFromClusterSnapshotCommandInput, options?: __HttpHandlerOptions): Promise<RestoreFromClusterSnapshotCommandOutput>;
            restoreFromClusterSnapshot(args: RestoreFromClusterSnapshotCommandInput, cb: (err: any, data?: RestoreFromClusterSnapshotCommandOutput) => void): void;
            restoreFromClusterSnapshot(args: RestoreFromClusterSnapshotCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RestoreFromClusterSnapshotCommandOutput) => void): void;
            /**
                * <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must
                *             create the new table within the Amazon Redshift cluster that the snapshot was taken
                *             from.</p>
                *         <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with
                *             the same name as an existing table in an Amazon Redshift cluster. That is, you cannot
                *             overwrite an existing table in a cluster with a restored table. If you want to replace
                *             your original table with a new, restored table, then rename or drop your original table
                *             before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your
                *             original table, then you can pass the original name of the table as the
                *                 <code>NewTableName</code> parameter value in the call to
                *                 <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original
                *             table with the table created from the snapshot.</p>
                */
            restoreTableFromClusterSnapshot(args: RestoreTableFromClusterSnapshotCommandInput, options?: __HttpHandlerOptions): Promise<RestoreTableFromClusterSnapshotCommandOutput>;
            restoreTableFromClusterSnapshot(args: RestoreTableFromClusterSnapshotCommandInput, cb: (err: any, data?: RestoreTableFromClusterSnapshotCommandOutput) => void): void;
            restoreTableFromClusterSnapshot(args: RestoreTableFromClusterSnapshotCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RestoreTableFromClusterSnapshotCommandOutput) => void): void;
            /**
                * <p>Resumes a paused cluster.</p>
                */
            resumeCluster(args: ResumeClusterCommandInput, options?: __HttpHandlerOptions): Promise<ResumeClusterCommandOutput>;
            resumeCluster(args: ResumeClusterCommandInput, cb: (err: any, data?: ResumeClusterCommandOutput) => void): void;
            resumeCluster(args: ResumeClusterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ResumeClusterCommandOutput) => void): void;
            /**
                * <p>Revokes an ingress rule in an Amazon Redshift security group for a previously authorized
                *             IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>.
                * For information about managing security groups, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the
                * <i>Amazon Redshift Cluster Management Guide</i>. </p>
                */
            revokeClusterSecurityGroupIngress(args: RevokeClusterSecurityGroupIngressCommandInput, options?: __HttpHandlerOptions): Promise<RevokeClusterSecurityGroupIngressCommandOutput>;
            revokeClusterSecurityGroupIngress(args: RevokeClusterSecurityGroupIngressCommandInput, cb: (err: any, data?: RevokeClusterSecurityGroupIngressCommandOutput) => void): void;
            revokeClusterSecurityGroupIngress(args: RevokeClusterSecurityGroupIngressCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RevokeClusterSecurityGroupIngressCommandOutput) => void): void;
            /**
                * <p>Revokes access to a cluster.</p>
                */
            revokeEndpointAccess(args: RevokeEndpointAccessCommandInput, options?: __HttpHandlerOptions): Promise<RevokeEndpointAccessCommandOutput>;
            revokeEndpointAccess(args: RevokeEndpointAccessCommandInput, cb: (err: any, data?: RevokeEndpointAccessCommandOutput) => void): void;
            revokeEndpointAccess(args: RevokeEndpointAccessCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RevokeEndpointAccessCommandOutput) => void): void;
            /**
                * <p>Removes the ability of the specified  Amazon Web Services account to restore the specified
                *             snapshot. If the account is currently restoring the snapshot, the restore will run to
                *             completion.</p>
                *         <p>
                * For more information about working with snapshots, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            revokeSnapshotAccess(args: RevokeSnapshotAccessCommandInput, options?: __HttpHandlerOptions): Promise<RevokeSnapshotAccessCommandOutput>;
            revokeSnapshotAccess(args: RevokeSnapshotAccessCommandInput, cb: (err: any, data?: RevokeSnapshotAccessCommandOutput) => void): void;
            revokeSnapshotAccess(args: RevokeSnapshotAccessCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RevokeSnapshotAccessCommandOutput) => void): void;
            /**
                * <p>Rotates the encryption keys for a cluster.</p>
                */
            rotateEncryptionKey(args: RotateEncryptionKeyCommandInput, options?: __HttpHandlerOptions): Promise<RotateEncryptionKeyCommandOutput>;
            rotateEncryptionKey(args: RotateEncryptionKeyCommandInput, cb: (err: any, data?: RotateEncryptionKeyCommandOutput) => void): void;
            rotateEncryptionKey(args: RotateEncryptionKeyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RotateEncryptionKeyCommandOutput) => void): void;
            /**
                * <p>Updates the status of a partner integration.</p>
                */
            updatePartnerStatus(args: UpdatePartnerStatusCommandInput, options?: __HttpHandlerOptions): Promise<UpdatePartnerStatusCommandOutput>;
            updatePartnerStatus(args: UpdatePartnerStatusCommandInput, cb: (err: any, data?: UpdatePartnerStatusCommandOutput) => void): void;
            updatePartnerStatus(args: UpdatePartnerStatusCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdatePartnerStatusCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/AcceptReservedNodeExchangeCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { AcceptReservedNodeExchangeInputMessage, AcceptReservedNodeExchangeOutputMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface AcceptReservedNodeExchangeCommandInput extends AcceptReservedNodeExchangeInputMessage {
    }
    export interface AcceptReservedNodeExchangeCommandOutput extends AcceptReservedNodeExchangeOutputMessage, __MetadataBearer {
    }
    /**
        * <p>Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the
        *             configuration (term, payment type, or number of nodes) and no additional costs.
        *         </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, AcceptReservedNodeExchangeCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, AcceptReservedNodeExchangeCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new AcceptReservedNodeExchangeCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link AcceptReservedNodeExchangeCommandInput} for command's `input` shape.
        * @see {@link AcceptReservedNodeExchangeCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class AcceptReservedNodeExchangeCommand extends $Command<AcceptReservedNodeExchangeCommandInput, AcceptReservedNodeExchangeCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: AcceptReservedNodeExchangeCommandInput;
            constructor(input: AcceptReservedNodeExchangeCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<AcceptReservedNodeExchangeCommandInput, AcceptReservedNodeExchangeCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/AddPartnerCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { PartnerIntegrationInputMessage, PartnerIntegrationOutputMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface AddPartnerCommandInput extends PartnerIntegrationInputMessage {
    }
    export interface AddPartnerCommandOutput extends PartnerIntegrationOutputMessage, __MetadataBearer {
    }
    /**
        * <p>Adds a partner integration to a cluster.
        *             This operation authorizes a partner to push status updates for the specified database.
        *             To complete the integration, you also set up the integration on the partner website.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, AddPartnerCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, AddPartnerCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new AddPartnerCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link AddPartnerCommandInput} for command's `input` shape.
        * @see {@link AddPartnerCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class AddPartnerCommand extends $Command<AddPartnerCommandInput, AddPartnerCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: AddPartnerCommandInput;
            constructor(input: AddPartnerCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<AddPartnerCommandInput, AddPartnerCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/AssociateDataShareConsumerCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { AssociateDataShareConsumerMessage, DataShare } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface AssociateDataShareConsumerCommandInput extends AssociateDataShareConsumerMessage {
    }
    export interface AssociateDataShareConsumerCommandOutput extends DataShare, __MetadataBearer {
    }
    /**
        * <p>From a datashare consumer account, associates a datashare with the
        *             account (AssociateEntireAccount) or the specified namespace (ConsumerArn). If you make this association, the consumer
        *             can consume the datashare.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, AssociateDataShareConsumerCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, AssociateDataShareConsumerCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new AssociateDataShareConsumerCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link AssociateDataShareConsumerCommandInput} for command's `input` shape.
        * @see {@link AssociateDataShareConsumerCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class AssociateDataShareConsumerCommand extends $Command<AssociateDataShareConsumerCommandInput, AssociateDataShareConsumerCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: AssociateDataShareConsumerCommandInput;
            constructor(input: AssociateDataShareConsumerCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<AssociateDataShareConsumerCommandInput, AssociateDataShareConsumerCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/AuthorizeClusterSecurityGroupIngressCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { AuthorizeClusterSecurityGroupIngressMessage, AuthorizeClusterSecurityGroupIngressResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface AuthorizeClusterSecurityGroupIngressCommandInput extends AuthorizeClusterSecurityGroupIngressMessage {
    }
    export interface AuthorizeClusterSecurityGroupIngressCommandOutput extends AuthorizeClusterSecurityGroupIngressResult, __MetadataBearer {
    }
    /**
        * <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether
        *             the application accessing your cluster is running on the Internet or an Amazon EC2
        *             instance, you can authorize inbound access to either a Classless Interdomain Routing
        *             (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as
        *             many as 20 ingress rules to an Amazon Redshift security group.</p>
        *         <p>If you authorize access to an Amazon EC2 security group, specify
        *                 <i>EC2SecurityGroupName</i> and
        *                 <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and
        *             Amazon Redshift cluster must be in the same Amazon Web Services Region. </p>
        *         <p>If you authorize access to a CIDR/IP address range, specify
        *                 <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia
        *             article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p>
        *         <p>You must also associate the security group with a cluster so that clients running
        *             on these IP addresses or the EC2 instance are authorized to connect to the cluster. For
        *             information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security
        *                 Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, AuthorizeClusterSecurityGroupIngressCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, AuthorizeClusterSecurityGroupIngressCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new AuthorizeClusterSecurityGroupIngressCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link AuthorizeClusterSecurityGroupIngressCommandInput} for command's `input` shape.
        * @see {@link AuthorizeClusterSecurityGroupIngressCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class AuthorizeClusterSecurityGroupIngressCommand extends $Command<AuthorizeClusterSecurityGroupIngressCommandInput, AuthorizeClusterSecurityGroupIngressCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: AuthorizeClusterSecurityGroupIngressCommandInput;
            constructor(input: AuthorizeClusterSecurityGroupIngressCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<AuthorizeClusterSecurityGroupIngressCommandInput, AuthorizeClusterSecurityGroupIngressCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/AuthorizeDataShareCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { AuthorizeDataShareMessage, DataShare } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface AuthorizeDataShareCommandInput extends AuthorizeDataShareMessage {
    }
    export interface AuthorizeDataShareCommandOutput extends DataShare, __MetadataBearer {
    }
    /**
        * <p>From a data producer account, authorizes the sharing of a datashare with one or more
        *             consumer accounts or managing entities. To authorize a datashare for a data consumer,
        *             the producer account must have the correct access permissions.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, AuthorizeDataShareCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, AuthorizeDataShareCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new AuthorizeDataShareCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link AuthorizeDataShareCommandInput} for command's `input` shape.
        * @see {@link AuthorizeDataShareCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class AuthorizeDataShareCommand extends $Command<AuthorizeDataShareCommandInput, AuthorizeDataShareCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: AuthorizeDataShareCommandInput;
            constructor(input: AuthorizeDataShareCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<AuthorizeDataShareCommandInput, AuthorizeDataShareCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/AuthorizeEndpointAccessCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { AuthorizeEndpointAccessMessage, EndpointAuthorization } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface AuthorizeEndpointAccessCommandInput extends AuthorizeEndpointAccessMessage {
    }
    export interface AuthorizeEndpointAccessCommandOutput extends EndpointAuthorization, __MetadataBearer {
    }
    /**
        * <p>Grants access to a cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, AuthorizeEndpointAccessCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, AuthorizeEndpointAccessCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new AuthorizeEndpointAccessCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link AuthorizeEndpointAccessCommandInput} for command's `input` shape.
        * @see {@link AuthorizeEndpointAccessCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class AuthorizeEndpointAccessCommand extends $Command<AuthorizeEndpointAccessCommandInput, AuthorizeEndpointAccessCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: AuthorizeEndpointAccessCommandInput;
            constructor(input: AuthorizeEndpointAccessCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<AuthorizeEndpointAccessCommandInput, AuthorizeEndpointAccessCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/AuthorizeSnapshotAccessCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { AuthorizeSnapshotAccessMessage, AuthorizeSnapshotAccessResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface AuthorizeSnapshotAccessCommandInput extends AuthorizeSnapshotAccessMessage {
    }
    export interface AuthorizeSnapshotAccessCommandOutput extends AuthorizeSnapshotAccessResult, __MetadataBearer {
    }
    /**
        * <p>Authorizes the specified Amazon Web Services account to restore the specified
        *             snapshot.</p>
        *         <p>
        * For more information about working with snapshots, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, AuthorizeSnapshotAccessCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, AuthorizeSnapshotAccessCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new AuthorizeSnapshotAccessCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link AuthorizeSnapshotAccessCommandInput} for command's `input` shape.
        * @see {@link AuthorizeSnapshotAccessCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class AuthorizeSnapshotAccessCommand extends $Command<AuthorizeSnapshotAccessCommandInput, AuthorizeSnapshotAccessCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: AuthorizeSnapshotAccessCommandInput;
            constructor(input: AuthorizeSnapshotAccessCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<AuthorizeSnapshotAccessCommandInput, AuthorizeSnapshotAccessCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/BatchDeleteClusterSnapshotsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { BatchDeleteClusterSnapshotsRequest, BatchDeleteClusterSnapshotsResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface BatchDeleteClusterSnapshotsCommandInput extends BatchDeleteClusterSnapshotsRequest {
    }
    export interface BatchDeleteClusterSnapshotsCommandOutput extends BatchDeleteClusterSnapshotsResult, __MetadataBearer {
    }
    /**
        * <p>Deletes a set of cluster snapshots.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, BatchDeleteClusterSnapshotsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, BatchDeleteClusterSnapshotsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new BatchDeleteClusterSnapshotsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchDeleteClusterSnapshotsCommandInput} for command's `input` shape.
        * @see {@link BatchDeleteClusterSnapshotsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class BatchDeleteClusterSnapshotsCommand extends $Command<BatchDeleteClusterSnapshotsCommandInput, BatchDeleteClusterSnapshotsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: BatchDeleteClusterSnapshotsCommandInput;
            constructor(input: BatchDeleteClusterSnapshotsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchDeleteClusterSnapshotsCommandInput, BatchDeleteClusterSnapshotsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/BatchModifyClusterSnapshotsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { BatchModifyClusterSnapshotsMessage, BatchModifyClusterSnapshotsOutputMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface BatchModifyClusterSnapshotsCommandInput extends BatchModifyClusterSnapshotsMessage {
    }
    export interface BatchModifyClusterSnapshotsCommandOutput extends BatchModifyClusterSnapshotsOutputMessage, __MetadataBearer {
    }
    /**
        * <p>Modifies the settings for a set of cluster snapshots.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, BatchModifyClusterSnapshotsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, BatchModifyClusterSnapshotsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new BatchModifyClusterSnapshotsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchModifyClusterSnapshotsCommandInput} for command's `input` shape.
        * @see {@link BatchModifyClusterSnapshotsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class BatchModifyClusterSnapshotsCommand extends $Command<BatchModifyClusterSnapshotsCommandInput, BatchModifyClusterSnapshotsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: BatchModifyClusterSnapshotsCommandInput;
            constructor(input: BatchModifyClusterSnapshotsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchModifyClusterSnapshotsCommandInput, BatchModifyClusterSnapshotsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CancelResizeCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CancelResizeMessage, ResizeProgressMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface CancelResizeCommandInput extends CancelResizeMessage {
    }
    export interface CancelResizeCommandOutput extends ResizeProgressMessage, __MetadataBearer {
    }
    /**
        * <p>Cancels a resize operation for a cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, CancelResizeCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, CancelResizeCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new CancelResizeCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CancelResizeCommandInput} for command's `input` shape.
        * @see {@link CancelResizeCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class CancelResizeCommand extends $Command<CancelResizeCommandInput, CancelResizeCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: CancelResizeCommandInput;
            constructor(input: CancelResizeCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CancelResizeCommandInput, CancelResizeCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CopyClusterSnapshotCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CopyClusterSnapshotMessage, CopyClusterSnapshotResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface CopyClusterSnapshotCommandInput extends CopyClusterSnapshotMessage {
    }
    export interface CopyClusterSnapshotCommandOutput extends CopyClusterSnapshotResult, __MetadataBearer {
    }
    /**
        * <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot.
        *             The source must be an automated snapshot and it must be in the available
        *             state.</p>
        *         <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the
        *             cluster. Also, when the retention period of the snapshot expires, Amazon Redshift
        *             automatically deletes it. If you want to keep an automated snapshot for a longer period,
        *             you can make a manual copy of the snapshot. Manual snapshots are retained until you
        *             delete them.</p>
        *         <p>
        * For more information about working with snapshots, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, CopyClusterSnapshotCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, CopyClusterSnapshotCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new CopyClusterSnapshotCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CopyClusterSnapshotCommandInput} for command's `input` shape.
        * @see {@link CopyClusterSnapshotCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class CopyClusterSnapshotCommand extends $Command<CopyClusterSnapshotCommandInput, CopyClusterSnapshotCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: CopyClusterSnapshotCommandInput;
            constructor(input: CopyClusterSnapshotCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CopyClusterSnapshotCommandInput, CopyClusterSnapshotCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateAuthenticationProfileCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateAuthenticationProfileMessage, CreateAuthenticationProfileResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface CreateAuthenticationProfileCommandInput extends CreateAuthenticationProfileMessage {
    }
    export interface CreateAuthenticationProfileCommandOutput extends CreateAuthenticationProfileResult, __MetadataBearer {
    }
    /**
        * <p>Creates an authentication profile with the specified parameters.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, CreateAuthenticationProfileCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, CreateAuthenticationProfileCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new CreateAuthenticationProfileCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateAuthenticationProfileCommandInput} for command's `input` shape.
        * @see {@link CreateAuthenticationProfileCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class CreateAuthenticationProfileCommand extends $Command<CreateAuthenticationProfileCommandInput, CreateAuthenticationProfileCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: CreateAuthenticationProfileCommandInput;
            constructor(input: CreateAuthenticationProfileCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateAuthenticationProfileCommandInput, CreateAuthenticationProfileCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateClusterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateClusterMessage, CreateClusterResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface CreateClusterCommandInput extends CreateClusterMessage {
    }
    export interface CreateClusterCommandOutput extends CreateClusterResult, __MetadataBearer {
    }
    /**
        * <p>Creates a new cluster with the specified parameters.</p>
        *         <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster
        *             subnet group name. The cluster subnet group identifies the subnets of your VPC that
        *             Amazon Redshift uses when creating the cluster.
        * For more information about managing clusters, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, CreateClusterCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, CreateClusterCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new CreateClusterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateClusterCommandInput} for command's `input` shape.
        * @see {@link CreateClusterCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class CreateClusterCommand extends $Command<CreateClusterCommandInput, CreateClusterCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: CreateClusterCommandInput;
            constructor(input: CreateClusterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateClusterCommandInput, CreateClusterCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateClusterParameterGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateClusterParameterGroupMessage, CreateClusterParameterGroupResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface CreateClusterParameterGroupCommandInput extends CreateClusterParameterGroupMessage {
    }
    export interface CreateClusterParameterGroupCommandOutput extends CreateClusterParameterGroupResult, __MetadataBearer {
    }
    /**
        * <p>Creates an Amazon Redshift parameter group.</p>
        *         <p>Creating parameter groups is independent of creating clusters. You can associate a
        *             cluster with a parameter group when you create the cluster. You can also associate an
        *             existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p>
        *         <p>Parameters in the parameter group define specific behavior that applies to the
        *             databases you create on the cluster.
        * For more information about parameters and parameter groups, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, CreateClusterParameterGroupCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, CreateClusterParameterGroupCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new CreateClusterParameterGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateClusterParameterGroupCommandInput} for command's `input` shape.
        * @see {@link CreateClusterParameterGroupCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class CreateClusterParameterGroupCommand extends $Command<CreateClusterParameterGroupCommandInput, CreateClusterParameterGroupCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: CreateClusterParameterGroupCommandInput;
            constructor(input: CreateClusterParameterGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateClusterParameterGroupCommandInput, CreateClusterParameterGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateClusterSecurityGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateClusterSecurityGroupMessage, CreateClusterSecurityGroupResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface CreateClusterSecurityGroupCommandInput extends CreateClusterSecurityGroupMessage {
    }
    export interface CreateClusterSecurityGroupCommandOutput extends CreateClusterSecurityGroupResult, __MetadataBearer {
    }
    /**
        * <p>Creates a new Amazon Redshift security group. You use security groups to control access
        *             to non-VPC clusters.</p>
        *         <p>
        * For information about managing security groups, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the
        * <i>Amazon Redshift Cluster Management Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, CreateClusterSecurityGroupCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, CreateClusterSecurityGroupCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new CreateClusterSecurityGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateClusterSecurityGroupCommandInput} for command's `input` shape.
        * @see {@link CreateClusterSecurityGroupCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class CreateClusterSecurityGroupCommand extends $Command<CreateClusterSecurityGroupCommandInput, CreateClusterSecurityGroupCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: CreateClusterSecurityGroupCommandInput;
            constructor(input: CreateClusterSecurityGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateClusterSecurityGroupCommandInput, CreateClusterSecurityGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateClusterSnapshotCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateClusterSnapshotMessage, CreateClusterSnapshotResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface CreateClusterSnapshotCommandInput extends CreateClusterSnapshotMessage {
    }
    export interface CreateClusterSnapshotCommandOutput extends CreateClusterSnapshotResult, __MetadataBearer {
    }
    /**
        * <p>Creates a manual snapshot of the specified cluster. The cluster must be in the
        *                 <code>available</code> state. </p>
        *         <p>
        * For more information about working with snapshots, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, CreateClusterSnapshotCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, CreateClusterSnapshotCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new CreateClusterSnapshotCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateClusterSnapshotCommandInput} for command's `input` shape.
        * @see {@link CreateClusterSnapshotCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class CreateClusterSnapshotCommand extends $Command<CreateClusterSnapshotCommandInput, CreateClusterSnapshotCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: CreateClusterSnapshotCommandInput;
            constructor(input: CreateClusterSnapshotCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateClusterSnapshotCommandInput, CreateClusterSnapshotCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateClusterSubnetGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateClusterSubnetGroupMessage, CreateClusterSubnetGroupResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface CreateClusterSubnetGroupCommandInput extends CreateClusterSubnetGroupMessage {
    }
    export interface CreateClusterSubnetGroupCommandOutput extends CreateClusterSubnetGroupResult, __MetadataBearer {
    }
    /**
        * <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more
        *             subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating
        *             Amazon Redshift subnet group.</p>
        *         <p>
        * For information about subnet groups, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the
        * <i>Amazon Redshift Cluster Management Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, CreateClusterSubnetGroupCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, CreateClusterSubnetGroupCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new CreateClusterSubnetGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateClusterSubnetGroupCommandInput} for command's `input` shape.
        * @see {@link CreateClusterSubnetGroupCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class CreateClusterSubnetGroupCommand extends $Command<CreateClusterSubnetGroupCommandInput, CreateClusterSubnetGroupCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: CreateClusterSubnetGroupCommandInput;
            constructor(input: CreateClusterSubnetGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateClusterSubnetGroupCommandInput, CreateClusterSubnetGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateEndpointAccessCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateEndpointAccessMessage, EndpointAccess } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface CreateEndpointAccessCommandInput extends CreateEndpointAccessMessage {
    }
    export interface CreateEndpointAccessCommandOutput extends EndpointAccess, __MetadataBearer {
    }
    /**
        * <p>Creates a Redshift-managed VPC endpoint.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, CreateEndpointAccessCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, CreateEndpointAccessCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new CreateEndpointAccessCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateEndpointAccessCommandInput} for command's `input` shape.
        * @see {@link CreateEndpointAccessCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class CreateEndpointAccessCommand extends $Command<CreateEndpointAccessCommandInput, CreateEndpointAccessCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: CreateEndpointAccessCommandInput;
            constructor(input: CreateEndpointAccessCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateEndpointAccessCommandInput, CreateEndpointAccessCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateEventSubscriptionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateEventSubscriptionMessage, CreateEventSubscriptionResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface CreateEventSubscriptionCommandInput extends CreateEventSubscriptionMessage {
    }
    export interface CreateEventSubscriptionCommandOutput extends CreateEventSubscriptionResult, __MetadataBearer {
    }
    /**
        * <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN
        *             (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console,
        *             the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you
        *             must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in
        *             the SNS console.</p>
        *         <p>You can specify the source type, and lists of Amazon Redshift source IDs, event
        *             categories, and event severities. Notifications will be sent for all events you want
        *             that match those criteria. For example, you can specify source type = cluster, source ID
        *             = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity =
        *             ERROR. The subscription will only send notifications for those ERROR events in the
        *             Availability and Backup categories for the specified clusters.</p>
        *         <p>If you specify both the source type and source IDs, such as source type = cluster
        *             and source identifier = my-cluster-1, notifications will be sent for all the cluster
        *             events for my-cluster-1. If you specify a source type but do not specify a source
        *             identifier, you will receive notice of the events for the objects of that type in your
        *             Amazon Web Services account. If you do not specify either the SourceType nor the SourceIdentifier, you
        *             will be notified of events generated from all Amazon Redshift sources belonging to your Amazon Web Services account. You must specify a source type if you specify a source ID.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, CreateEventSubscriptionCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, CreateEventSubscriptionCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new CreateEventSubscriptionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateEventSubscriptionCommandInput} for command's `input` shape.
        * @see {@link CreateEventSubscriptionCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class CreateEventSubscriptionCommand extends $Command<CreateEventSubscriptionCommandInput, CreateEventSubscriptionCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: CreateEventSubscriptionCommandInput;
            constructor(input: CreateEventSubscriptionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateEventSubscriptionCommandInput, CreateEventSubscriptionCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateHsmClientCertificateCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateHsmClientCertificateMessage, CreateHsmClientCertificateResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface CreateHsmClientCertificateCommandInput extends CreateHsmClientCertificateMessage {
    }
    export interface CreateHsmClientCertificateCommandOutput extends CreateHsmClientCertificateResult, __MetadataBearer {
    }
    /**
        * <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to
        *             the client's HSM in order to store and retrieve the keys used to encrypt the cluster
        *             databases.</p>
        *         <p>The command returns a public key, which you must store in the HSM. In addition to
        *             creating the HSM certificate, you must create an Amazon Redshift HSM configuration that
        *             provides a cluster the information needed to store and use encryption keys in the HSM.
        *             For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html#working-with-HSM">Hardware Security Modules</a>
        *             in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, CreateHsmClientCertificateCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, CreateHsmClientCertificateCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new CreateHsmClientCertificateCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateHsmClientCertificateCommandInput} for command's `input` shape.
        * @see {@link CreateHsmClientCertificateCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class CreateHsmClientCertificateCommand extends $Command<CreateHsmClientCertificateCommandInput, CreateHsmClientCertificateCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: CreateHsmClientCertificateCommandInput;
            constructor(input: CreateHsmClientCertificateCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateHsmClientCertificateCommandInput, CreateHsmClientCertificateCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateHsmConfigurationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateHsmConfigurationMessage, CreateHsmConfigurationResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface CreateHsmConfigurationCommandInput extends CreateHsmConfigurationMessage {
    }
    export interface CreateHsmConfigurationCommandOutput extends CreateHsmConfigurationResult, __MetadataBearer {
    }
    /**
        * <p>Creates an HSM configuration that contains the information required by an Amazon Redshift
        *             cluster to store and use database encryption keys in a Hardware Security Module (HSM).
        *             After creating the HSM configuration, you can specify it as a parameter when creating a
        *             cluster. The cluster will then store its encryption keys in the HSM.</p>
        *         <p>In addition to creating an HSM configuration, you must also create an HSM client
        *             certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a>
        *             in the Amazon Redshift Cluster Management Guide.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, CreateHsmConfigurationCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, CreateHsmConfigurationCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new CreateHsmConfigurationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateHsmConfigurationCommandInput} for command's `input` shape.
        * @see {@link CreateHsmConfigurationCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class CreateHsmConfigurationCommand extends $Command<CreateHsmConfigurationCommandInput, CreateHsmConfigurationCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: CreateHsmConfigurationCommandInput;
            constructor(input: CreateHsmConfigurationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateHsmConfigurationCommandInput, CreateHsmConfigurationCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateScheduledActionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateScheduledActionMessage, ScheduledAction } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface CreateScheduledActionCommandInput extends CreateScheduledActionMessage {
    }
    export interface CreateScheduledActionCommandOutput extends ScheduledAction, __MetadataBearer {
    }
    /**
        * <p>Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action.
        *             For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation.
        *         </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, CreateScheduledActionCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, CreateScheduledActionCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new CreateScheduledActionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateScheduledActionCommandInput} for command's `input` shape.
        * @see {@link CreateScheduledActionCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class CreateScheduledActionCommand extends $Command<CreateScheduledActionCommandInput, CreateScheduledActionCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: CreateScheduledActionCommandInput;
            constructor(input: CreateScheduledActionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateScheduledActionCommandInput, CreateScheduledActionCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateSnapshotCopyGrantCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateSnapshotCopyGrantMessage, CreateSnapshotCopyGrantResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface CreateSnapshotCopyGrantCommandInput extends CreateSnapshotCopyGrantMessage {
    }
    export interface CreateSnapshotCopyGrantCommandOutput extends CreateSnapshotCopyGrantResult, __MetadataBearer {
    }
    /**
        * <p>Creates a snapshot copy grant that permits Amazon Redshift to use an encrypted symmetric key
        *             from Key Management Service (KMS) to encrypt copied snapshots in a
        *             destination region.</p>
        *         <p>
        * For more information about managing snapshot copy grants, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.
        * </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, CreateSnapshotCopyGrantCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, CreateSnapshotCopyGrantCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new CreateSnapshotCopyGrantCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateSnapshotCopyGrantCommandInput} for command's `input` shape.
        * @see {@link CreateSnapshotCopyGrantCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class CreateSnapshotCopyGrantCommand extends $Command<CreateSnapshotCopyGrantCommandInput, CreateSnapshotCopyGrantCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: CreateSnapshotCopyGrantCommandInput;
            constructor(input: CreateSnapshotCopyGrantCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateSnapshotCopyGrantCommandInput, CreateSnapshotCopyGrantCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateSnapshotScheduleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateSnapshotScheduleMessage, SnapshotSchedule } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface CreateSnapshotScheduleCommandInput extends CreateSnapshotScheduleMessage {
    }
    export interface CreateSnapshotScheduleCommandOutput extends SnapshotSchedule, __MetadataBearer {
    }
    /**
        * <p>Create a snapshot schedule that can be associated to a cluster and which overrides the default system backup schedule. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, CreateSnapshotScheduleCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, CreateSnapshotScheduleCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new CreateSnapshotScheduleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateSnapshotScheduleCommandInput} for command's `input` shape.
        * @see {@link CreateSnapshotScheduleCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class CreateSnapshotScheduleCommand extends $Command<CreateSnapshotScheduleCommandInput, CreateSnapshotScheduleCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: CreateSnapshotScheduleCommandInput;
            constructor(input: CreateSnapshotScheduleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateSnapshotScheduleCommandInput, CreateSnapshotScheduleCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateTagsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateTagsMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface CreateTagsCommandInput extends CreateTagsMessage {
    }
    export interface CreateTagsCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Adds tags to a cluster.</p>
        *         <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a
        *             resource, you will receive an error and the attempt will fail.</p>
        *         <p>If you specify a key that already exists for the resource, the value for that key
        *             will be updated with the new value.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, CreateTagsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, CreateTagsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new CreateTagsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateTagsCommandInput} for command's `input` shape.
        * @see {@link CreateTagsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class CreateTagsCommand extends $Command<CreateTagsCommandInput, CreateTagsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: CreateTagsCommandInput;
            constructor(input: CreateTagsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateTagsCommandInput, CreateTagsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateUsageLimitCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateUsageLimitMessage, UsageLimit } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface CreateUsageLimitCommandInput extends CreateUsageLimitMessage {
    }
    export interface CreateUsageLimitCommandOutput extends UsageLimit, __MetadataBearer {
    }
    /**
        * <p>Creates a usage limit for a specified Amazon Redshift feature on a cluster.
        *             The usage limit is identified by the returned usage limit identifier.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, CreateUsageLimitCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, CreateUsageLimitCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new CreateUsageLimitCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateUsageLimitCommandInput} for command's `input` shape.
        * @see {@link CreateUsageLimitCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class CreateUsageLimitCommand extends $Command<CreateUsageLimitCommandInput, CreateUsageLimitCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: CreateUsageLimitCommandInput;
            constructor(input: CreateUsageLimitCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateUsageLimitCommandInput, CreateUsageLimitCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeauthorizeDataShareCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DataShare, DeauthorizeDataShareMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DeauthorizeDataShareCommandInput extends DeauthorizeDataShareMessage {
    }
    export interface DeauthorizeDataShareCommandOutput extends DataShare, __MetadataBearer {
    }
    /**
        * <p>From a datashare producer account, removes authorization from the specified datashare. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DeauthorizeDataShareCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DeauthorizeDataShareCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DeauthorizeDataShareCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeauthorizeDataShareCommandInput} for command's `input` shape.
        * @see {@link DeauthorizeDataShareCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DeauthorizeDataShareCommand extends $Command<DeauthorizeDataShareCommandInput, DeauthorizeDataShareCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DeauthorizeDataShareCommandInput;
            constructor(input: DeauthorizeDataShareCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeauthorizeDataShareCommandInput, DeauthorizeDataShareCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteAuthenticationProfileCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteAuthenticationProfileMessage, DeleteAuthenticationProfileResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DeleteAuthenticationProfileCommandInput extends DeleteAuthenticationProfileMessage {
    }
    export interface DeleteAuthenticationProfileCommandOutput extends DeleteAuthenticationProfileResult, __MetadataBearer {
    }
    /**
        * <p>Deletes an authentication profile.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DeleteAuthenticationProfileCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DeleteAuthenticationProfileCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DeleteAuthenticationProfileCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteAuthenticationProfileCommandInput} for command's `input` shape.
        * @see {@link DeleteAuthenticationProfileCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DeleteAuthenticationProfileCommand extends $Command<DeleteAuthenticationProfileCommandInput, DeleteAuthenticationProfileCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DeleteAuthenticationProfileCommandInput;
            constructor(input: DeleteAuthenticationProfileCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteAuthenticationProfileCommandInput, DeleteAuthenticationProfileCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteClusterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteClusterMessage, DeleteClusterResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DeleteClusterCommandInput extends DeleteClusterMessage {
    }
    export interface DeleteClusterCommandOutput extends DeleteClusterResult, __MetadataBearer {
    }
    /**
        * <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web
        *             service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete
        *             operation cannot be canceled or reverted once submitted.
        * For more information about managing clusters, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        *         <p>If you want to shut down the cluster and retain it for future use, set
        *                 <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a
        *             name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this
        *             snapshot to resume using the cluster. If a final cluster snapshot is requested, the
        *             status of the cluster will be "final-snapshot" while the snapshot is being taken, then
        *             it's "deleting" once Amazon Redshift begins deleting the cluster. </p>
        *         <p>
        * For more information about managing clusters, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DeleteClusterCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DeleteClusterCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DeleteClusterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteClusterCommandInput} for command's `input` shape.
        * @see {@link DeleteClusterCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DeleteClusterCommand extends $Command<DeleteClusterCommandInput, DeleteClusterCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DeleteClusterCommandInput;
            constructor(input: DeleteClusterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteClusterCommandInput, DeleteClusterCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteClusterParameterGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteClusterParameterGroupMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DeleteClusterParameterGroupCommandInput extends DeleteClusterParameterGroupMessage {
    }
    export interface DeleteClusterParameterGroupCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes a specified Amazon Redshift parameter group.</p>
        *         <note>
        *             <p>You cannot delete a parameter group if it is associated with a
        *                 cluster.</p>
        *         </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DeleteClusterParameterGroupCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DeleteClusterParameterGroupCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DeleteClusterParameterGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteClusterParameterGroupCommandInput} for command's `input` shape.
        * @see {@link DeleteClusterParameterGroupCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DeleteClusterParameterGroupCommand extends $Command<DeleteClusterParameterGroupCommandInput, DeleteClusterParameterGroupCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DeleteClusterParameterGroupCommandInput;
            constructor(input: DeleteClusterParameterGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteClusterParameterGroupCommandInput, DeleteClusterParameterGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteClusterSecurityGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteClusterSecurityGroupMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DeleteClusterSecurityGroupCommandInput extends DeleteClusterSecurityGroupMessage {
    }
    export interface DeleteClusterSecurityGroupCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes an Amazon Redshift security group.</p>
        *         <note>
        *             <p>You cannot delete a security group that is associated with any clusters. You
        *                 cannot delete the default security group.</p>
        *         </note>
        *         <p>
        * For information about managing security groups, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the
        * <i>Amazon Redshift Cluster Management Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DeleteClusterSecurityGroupCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DeleteClusterSecurityGroupCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DeleteClusterSecurityGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteClusterSecurityGroupCommandInput} for command's `input` shape.
        * @see {@link DeleteClusterSecurityGroupCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DeleteClusterSecurityGroupCommand extends $Command<DeleteClusterSecurityGroupCommandInput, DeleteClusterSecurityGroupCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DeleteClusterSecurityGroupCommandInput;
            constructor(input: DeleteClusterSecurityGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteClusterSecurityGroupCommandInput, DeleteClusterSecurityGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteClusterSnapshotCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteClusterSnapshotMessage, DeleteClusterSnapshotResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DeleteClusterSnapshotCommandInput extends DeleteClusterSnapshotMessage {
    }
    export interface DeleteClusterSnapshotCommandOutput extends DeleteClusterSnapshotResult, __MetadataBearer {
    }
    /**
        * <p>Deletes the specified manual snapshot. The snapshot must be in the
        *                 <code>available</code> state, with no other users authorized to access the snapshot. </p>
        *         <p>Unlike automated snapshots, manual snapshots are retained even after you delete
        *             your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual
        *             snapshot explicitly to avoid getting charged. If other accounts are authorized to access
        *             the snapshot, you must revoke all of the authorizations before you can delete the
        *             snapshot.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DeleteClusterSnapshotCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DeleteClusterSnapshotCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DeleteClusterSnapshotCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteClusterSnapshotCommandInput} for command's `input` shape.
        * @see {@link DeleteClusterSnapshotCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DeleteClusterSnapshotCommand extends $Command<DeleteClusterSnapshotCommandInput, DeleteClusterSnapshotCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DeleteClusterSnapshotCommandInput;
            constructor(input: DeleteClusterSnapshotCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteClusterSnapshotCommandInput, DeleteClusterSnapshotCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteClusterSubnetGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteClusterSubnetGroupMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DeleteClusterSubnetGroupCommandInput extends DeleteClusterSubnetGroupMessage {
    }
    export interface DeleteClusterSubnetGroupCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes the specified cluster subnet group.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DeleteClusterSubnetGroupCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DeleteClusterSubnetGroupCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DeleteClusterSubnetGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteClusterSubnetGroupCommandInput} for command's `input` shape.
        * @see {@link DeleteClusterSubnetGroupCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DeleteClusterSubnetGroupCommand extends $Command<DeleteClusterSubnetGroupCommandInput, DeleteClusterSubnetGroupCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DeleteClusterSubnetGroupCommandInput;
            constructor(input: DeleteClusterSubnetGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteClusterSubnetGroupCommandInput, DeleteClusterSubnetGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteEndpointAccessCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteEndpointAccessMessage, EndpointAccess } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DeleteEndpointAccessCommandInput extends DeleteEndpointAccessMessage {
    }
    export interface DeleteEndpointAccessCommandOutput extends EndpointAccess, __MetadataBearer {
    }
    /**
        * <p>Deletes a Redshift-managed VPC endpoint.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DeleteEndpointAccessCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DeleteEndpointAccessCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DeleteEndpointAccessCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteEndpointAccessCommandInput} for command's `input` shape.
        * @see {@link DeleteEndpointAccessCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DeleteEndpointAccessCommand extends $Command<DeleteEndpointAccessCommandInput, DeleteEndpointAccessCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DeleteEndpointAccessCommandInput;
            constructor(input: DeleteEndpointAccessCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteEndpointAccessCommandInput, DeleteEndpointAccessCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteEventSubscriptionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteEventSubscriptionMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DeleteEventSubscriptionCommandInput extends DeleteEventSubscriptionMessage {
    }
    export interface DeleteEventSubscriptionCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes an Amazon Redshift event notification subscription.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DeleteEventSubscriptionCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DeleteEventSubscriptionCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DeleteEventSubscriptionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteEventSubscriptionCommandInput} for command's `input` shape.
        * @see {@link DeleteEventSubscriptionCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DeleteEventSubscriptionCommand extends $Command<DeleteEventSubscriptionCommandInput, DeleteEventSubscriptionCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DeleteEventSubscriptionCommandInput;
            constructor(input: DeleteEventSubscriptionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteEventSubscriptionCommandInput, DeleteEventSubscriptionCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteHsmClientCertificateCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteHsmClientCertificateMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DeleteHsmClientCertificateCommandInput extends DeleteHsmClientCertificateMessage {
    }
    export interface DeleteHsmClientCertificateCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes the specified HSM client certificate.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DeleteHsmClientCertificateCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DeleteHsmClientCertificateCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DeleteHsmClientCertificateCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteHsmClientCertificateCommandInput} for command's `input` shape.
        * @see {@link DeleteHsmClientCertificateCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DeleteHsmClientCertificateCommand extends $Command<DeleteHsmClientCertificateCommandInput, DeleteHsmClientCertificateCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DeleteHsmClientCertificateCommandInput;
            constructor(input: DeleteHsmClientCertificateCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteHsmClientCertificateCommandInput, DeleteHsmClientCertificateCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteHsmConfigurationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteHsmConfigurationMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DeleteHsmConfigurationCommandInput extends DeleteHsmConfigurationMessage {
    }
    export interface DeleteHsmConfigurationCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes the specified Amazon Redshift HSM configuration.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DeleteHsmConfigurationCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DeleteHsmConfigurationCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DeleteHsmConfigurationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteHsmConfigurationCommandInput} for command's `input` shape.
        * @see {@link DeleteHsmConfigurationCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DeleteHsmConfigurationCommand extends $Command<DeleteHsmConfigurationCommandInput, DeleteHsmConfigurationCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DeleteHsmConfigurationCommandInput;
            constructor(input: DeleteHsmConfigurationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteHsmConfigurationCommandInput, DeleteHsmConfigurationCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeletePartnerCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { PartnerIntegrationInputMessage, PartnerIntegrationOutputMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DeletePartnerCommandInput extends PartnerIntegrationInputMessage {
    }
    export interface DeletePartnerCommandOutput extends PartnerIntegrationOutputMessage, __MetadataBearer {
    }
    /**
        * <p>Deletes a partner integration from a cluster. Data can still flow to the cluster until the integration is deleted at the partner's website.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DeletePartnerCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DeletePartnerCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DeletePartnerCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeletePartnerCommandInput} for command's `input` shape.
        * @see {@link DeletePartnerCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DeletePartnerCommand extends $Command<DeletePartnerCommandInput, DeletePartnerCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DeletePartnerCommandInput;
            constructor(input: DeletePartnerCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeletePartnerCommandInput, DeletePartnerCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteScheduledActionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteScheduledActionMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DeleteScheduledActionCommandInput extends DeleteScheduledActionMessage {
    }
    export interface DeleteScheduledActionCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes a scheduled action.
        *              </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DeleteScheduledActionCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DeleteScheduledActionCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DeleteScheduledActionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteScheduledActionCommandInput} for command's `input` shape.
        * @see {@link DeleteScheduledActionCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DeleteScheduledActionCommand extends $Command<DeleteScheduledActionCommandInput, DeleteScheduledActionCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DeleteScheduledActionCommandInput;
            constructor(input: DeleteScheduledActionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteScheduledActionCommandInput, DeleteScheduledActionCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteSnapshotCopyGrantCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteSnapshotCopyGrantMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DeleteSnapshotCopyGrantCommandInput extends DeleteSnapshotCopyGrantMessage {
    }
    export interface DeleteSnapshotCopyGrantCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes the specified snapshot copy grant.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DeleteSnapshotCopyGrantCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DeleteSnapshotCopyGrantCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DeleteSnapshotCopyGrantCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteSnapshotCopyGrantCommandInput} for command's `input` shape.
        * @see {@link DeleteSnapshotCopyGrantCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DeleteSnapshotCopyGrantCommand extends $Command<DeleteSnapshotCopyGrantCommandInput, DeleteSnapshotCopyGrantCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DeleteSnapshotCopyGrantCommandInput;
            constructor(input: DeleteSnapshotCopyGrantCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteSnapshotCopyGrantCommandInput, DeleteSnapshotCopyGrantCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteSnapshotScheduleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteSnapshotScheduleMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DeleteSnapshotScheduleCommandInput extends DeleteSnapshotScheduleMessage {
    }
    export interface DeleteSnapshotScheduleCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes a snapshot schedule.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DeleteSnapshotScheduleCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DeleteSnapshotScheduleCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DeleteSnapshotScheduleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteSnapshotScheduleCommandInput} for command's `input` shape.
        * @see {@link DeleteSnapshotScheduleCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DeleteSnapshotScheduleCommand extends $Command<DeleteSnapshotScheduleCommandInput, DeleteSnapshotScheduleCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DeleteSnapshotScheduleCommandInput;
            constructor(input: DeleteSnapshotScheduleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteSnapshotScheduleCommandInput, DeleteSnapshotScheduleCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteTagsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteTagsMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DeleteTagsCommandInput extends DeleteTagsMessage {
    }
    export interface DeleteTagsCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes tags from a resource. You must provide the ARN of the resource
        *             from which you want to delete the tag or tags.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DeleteTagsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DeleteTagsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DeleteTagsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteTagsCommandInput} for command's `input` shape.
        * @see {@link DeleteTagsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DeleteTagsCommand extends $Command<DeleteTagsCommandInput, DeleteTagsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DeleteTagsCommandInput;
            constructor(input: DeleteTagsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteTagsCommandInput, DeleteTagsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteUsageLimitCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteUsageLimitMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DeleteUsageLimitCommandInput extends DeleteUsageLimitMessage {
    }
    export interface DeleteUsageLimitCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes a usage limit from a cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DeleteUsageLimitCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DeleteUsageLimitCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DeleteUsageLimitCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteUsageLimitCommandInput} for command's `input` shape.
        * @see {@link DeleteUsageLimitCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DeleteUsageLimitCommand extends $Command<DeleteUsageLimitCommandInput, DeleteUsageLimitCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DeleteUsageLimitCommandInput;
            constructor(input: DeleteUsageLimitCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteUsageLimitCommandInput, DeleteUsageLimitCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeAccountAttributesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { AccountAttributeList, DescribeAccountAttributesMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeAccountAttributesCommandInput extends DescribeAccountAttributesMessage {
    }
    export interface DescribeAccountAttributesCommandOutput extends AccountAttributeList, __MetadataBearer {
    }
    /**
        * <p>Returns a list of attributes attached to an account</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeAccountAttributesCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeAccountAttributesCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeAccountAttributesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeAccountAttributesCommandInput} for command's `input` shape.
        * @see {@link DescribeAccountAttributesCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeAccountAttributesCommand extends $Command<DescribeAccountAttributesCommandInput, DescribeAccountAttributesCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeAccountAttributesCommandInput;
            constructor(input: DescribeAccountAttributesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeAccountAttributesCommandInput, DescribeAccountAttributesCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeAuthenticationProfilesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeAuthenticationProfilesMessage, DescribeAuthenticationProfilesResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeAuthenticationProfilesCommandInput extends DescribeAuthenticationProfilesMessage {
    }
    export interface DescribeAuthenticationProfilesCommandOutput extends DescribeAuthenticationProfilesResult, __MetadataBearer {
    }
    /**
        * <p>Describes an authentication profile.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeAuthenticationProfilesCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeAuthenticationProfilesCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeAuthenticationProfilesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeAuthenticationProfilesCommandInput} for command's `input` shape.
        * @see {@link DescribeAuthenticationProfilesCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeAuthenticationProfilesCommand extends $Command<DescribeAuthenticationProfilesCommandInput, DescribeAuthenticationProfilesCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeAuthenticationProfilesCommandInput;
            constructor(input: DescribeAuthenticationProfilesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeAuthenticationProfilesCommandInput, DescribeAuthenticationProfilesCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterDbRevisionsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ClusterDbRevisionsMessage, DescribeClusterDbRevisionsMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeClusterDbRevisionsCommandInput extends DescribeClusterDbRevisionsMessage {
    }
    export interface DescribeClusterDbRevisionsCommandOutput extends ClusterDbRevisionsMessage, __MetadataBearer {
    }
    /**
        * <p>Returns an array of <code>ClusterDbRevision</code> objects.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeClusterDbRevisionsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeClusterDbRevisionsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeClusterDbRevisionsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeClusterDbRevisionsCommandInput} for command's `input` shape.
        * @see {@link DescribeClusterDbRevisionsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeClusterDbRevisionsCommand extends $Command<DescribeClusterDbRevisionsCommandInput, DescribeClusterDbRevisionsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeClusterDbRevisionsCommandInput;
            constructor(input: DescribeClusterDbRevisionsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeClusterDbRevisionsCommandInput, DescribeClusterDbRevisionsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterParameterGroupsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ClusterParameterGroupsMessage, DescribeClusterParameterGroupsMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeClusterParameterGroupsCommandInput extends DescribeClusterParameterGroupsMessage {
    }
    export interface DescribeClusterParameterGroupsCommandOutput extends ClusterParameterGroupsMessage, __MetadataBearer {
    }
    /**
        * <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you
        *             created and the default parameter group. For each parameter group, the response includes
        *             the parameter group name, description, and parameter group family name. You can
        *             optionally specify a name to retrieve the description of a specific parameter
        *             group.</p>
        *         <p>
        * For more information about parameters and parameter groups, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        *         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
        *             all parameter groups that match any combination of the specified keys and values. For
        *             example, if you have <code>owner</code> and <code>environment</code> for tag keys, and
        *                 <code>admin</code> and <code>test</code> for tag values, all parameter groups that
        *             have any combination of those values are returned.</p>
        *         <p>If both tag keys and values are omitted from the request, parameter groups are
        *             returned regardless of whether they have tag keys or values associated with
        *             them.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeClusterParameterGroupsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeClusterParameterGroupsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeClusterParameterGroupsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeClusterParameterGroupsCommandInput} for command's `input` shape.
        * @see {@link DescribeClusterParameterGroupsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeClusterParameterGroupsCommand extends $Command<DescribeClusterParameterGroupsCommandInput, DescribeClusterParameterGroupsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeClusterParameterGroupsCommandInput;
            constructor(input: DescribeClusterParameterGroupsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeClusterParameterGroupsCommandInput, DescribeClusterParameterGroupsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterParametersCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ClusterParameterGroupDetails, DescribeClusterParametersMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeClusterParametersCommandInput extends DescribeClusterParametersMessage {
    }
    export interface DescribeClusterParametersCommandOutput extends ClusterParameterGroupDetails, __MetadataBearer {
    }
    /**
        * <p>Returns a detailed list of parameters contained within the specified Amazon Redshift
        *             parameter group. For each parameter the response includes information such as parameter
        *             name, description, data type, value, whether the parameter value is modifiable, and so
        *             on.</p>
        *         <p>You can specify <i>source</i> filter to retrieve parameters of only
        *             specific type. For example, to retrieve parameters that were modified by a user action
        *             such as from <a>ModifyClusterParameterGroup</a>, you can specify
        *                 <i>source</i> equal to <i>user</i>.</p>
        *         <p>
        * For more information about parameters and parameter groups, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeClusterParametersCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeClusterParametersCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeClusterParametersCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeClusterParametersCommandInput} for command's `input` shape.
        * @see {@link DescribeClusterParametersCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeClusterParametersCommand extends $Command<DescribeClusterParametersCommandInput, DescribeClusterParametersCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeClusterParametersCommandInput;
            constructor(input: DescribeClusterParametersCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeClusterParametersCommandInput, DescribeClusterParametersCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClustersCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ClustersMessage, DescribeClustersMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeClustersCommandInput extends DescribeClustersMessage {
    }
    export interface DescribeClustersCommandOutput extends ClustersMessage, __MetadataBearer {
    }
    /**
        * <p>Returns properties of provisioned clusters including general cluster properties,
        *             cluster database properties, maintenance and backup properties, and security and access
        *             properties. This operation supports pagination.
        * For more information about managing clusters, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        *         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
        *             all clusters that match any combination of the specified keys and values. For example,
        *             if you have <code>owner</code> and <code>environment</code> for tag keys, and
        *                 <code>admin</code> and <code>test</code> for tag values, all clusters that have any
        *             combination of those values are returned.</p>
        *         <p>If both tag keys and values are omitted from the request, clusters are returned
        *             regardless of whether they have tag keys or values associated with them.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeClustersCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeClustersCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeClustersCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeClustersCommandInput} for command's `input` shape.
        * @see {@link DescribeClustersCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeClustersCommand extends $Command<DescribeClustersCommandInput, DescribeClustersCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeClustersCommandInput;
            constructor(input: DescribeClustersCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeClustersCommandInput, DescribeClustersCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterSecurityGroupsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ClusterSecurityGroupMessage, DescribeClusterSecurityGroupsMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeClusterSecurityGroupsCommandInput extends DescribeClusterSecurityGroupsMessage {
    }
    export interface DescribeClusterSecurityGroupsCommandOutput extends ClusterSecurityGroupMessage, __MetadataBearer {
    }
    /**
        * <p>Returns information about Amazon Redshift security groups. If the name of a security
        *             group is specified, the response will contain only information about only that security
        *             group.</p>
        *         <p>
        * For information about managing security groups, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the
        * <i>Amazon Redshift Cluster Management Guide</i>.</p>
        *         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
        *             all security groups that match any combination of the specified keys and values. For
        *             example, if you have <code>owner</code> and <code>environment</code> for tag keys, and
        *                 <code>admin</code> and <code>test</code> for tag values, all security groups that
        *             have any combination of those values are returned.</p>
        *         <p>If both tag keys and values are omitted from the request, security groups are
        *             returned regardless of whether they have tag keys or values associated with
        *             them.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeClusterSecurityGroupsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeClusterSecurityGroupsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeClusterSecurityGroupsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeClusterSecurityGroupsCommandInput} for command's `input` shape.
        * @see {@link DescribeClusterSecurityGroupsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeClusterSecurityGroupsCommand extends $Command<DescribeClusterSecurityGroupsCommandInput, DescribeClusterSecurityGroupsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeClusterSecurityGroupsCommandInput;
            constructor(input: DescribeClusterSecurityGroupsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeClusterSecurityGroupsCommandInput, DescribeClusterSecurityGroupsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterSnapshotsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeClusterSnapshotsMessage, SnapshotMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeClusterSnapshotsCommandInput extends DescribeClusterSnapshotsMessage {
    }
    export interface DescribeClusterSnapshotsCommandOutput extends SnapshotMessage, __MetadataBearer {
    }
    /**
        * <p>Returns one or more snapshot objects, which contain metadata about your cluster
        *             snapshots. By default, this operation returns information about all snapshots of all
        *             clusters that are owned by your Amazon Web Services account. No information is returned for
        *             snapshots owned by inactive Amazon Web Services accounts.</p>
        *         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
        *             all snapshots that match any combination of the specified keys and values. For example,
        *             if you have <code>owner</code> and <code>environment</code> for tag keys, and
        *                 <code>admin</code> and <code>test</code> for tag values, all snapshots that have any
        *             combination of those values are returned. Only snapshots that you own are returned in
        *             the response; shared snapshots are not returned with the tag key and tag value request
        *             parameters.</p>
        *         <p>If both tag keys and values are omitted from the request, snapshots are returned
        *             regardless of whether they have tag keys or values associated with them.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeClusterSnapshotsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeClusterSnapshotsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeClusterSnapshotsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeClusterSnapshotsCommandInput} for command's `input` shape.
        * @see {@link DescribeClusterSnapshotsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeClusterSnapshotsCommand extends $Command<DescribeClusterSnapshotsCommandInput, DescribeClusterSnapshotsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeClusterSnapshotsCommandInput;
            constructor(input: DescribeClusterSnapshotsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeClusterSnapshotsCommandInput, DescribeClusterSnapshotsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterSubnetGroupsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ClusterSubnetGroupMessage, DescribeClusterSubnetGroupsMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeClusterSubnetGroupsCommandInput extends DescribeClusterSubnetGroupsMessage {
    }
    export interface DescribeClusterSubnetGroupsCommandOutput extends ClusterSubnetGroupMessage, __MetadataBearer {
    }
    /**
        * <p>Returns one or more cluster subnet group objects, which contain metadata about your
        *             cluster subnet groups. By default, this operation returns information about all cluster
        *             subnet groups that are defined in your Amazon Web Services account.</p>
        *         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
        *             all subnet groups that match any combination of the specified keys and values. For
        *             example, if you have <code>owner</code> and <code>environment</code> for tag keys, and
        *                 <code>admin</code> and <code>test</code> for tag values, all subnet groups that have
        *             any combination of those values are returned.</p>
        *         <p>If both tag keys and values are omitted from the request, subnet groups are
        *             returned regardless of whether they have tag keys or values associated with
        *             them.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeClusterSubnetGroupsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeClusterSubnetGroupsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeClusterSubnetGroupsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeClusterSubnetGroupsCommandInput} for command's `input` shape.
        * @see {@link DescribeClusterSubnetGroupsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeClusterSubnetGroupsCommand extends $Command<DescribeClusterSubnetGroupsCommandInput, DescribeClusterSubnetGroupsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeClusterSubnetGroupsCommandInput;
            constructor(input: DescribeClusterSubnetGroupsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeClusterSubnetGroupsCommandInput, DescribeClusterSubnetGroupsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterTracksCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeClusterTracksMessage, TrackListMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeClusterTracksCommandInput extends DescribeClusterTracksMessage {
    }
    export interface DescribeClusterTracksCommandOutput extends TrackListMessage, __MetadataBearer {
    }
    /**
        * <p>Returns a list of all the available maintenance tracks.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeClusterTracksCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeClusterTracksCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeClusterTracksCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeClusterTracksCommandInput} for command's `input` shape.
        * @see {@link DescribeClusterTracksCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeClusterTracksCommand extends $Command<DescribeClusterTracksCommandInput, DescribeClusterTracksCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeClusterTracksCommandInput;
            constructor(input: DescribeClusterTracksCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeClusterTracksCommandInput, DescribeClusterTracksCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterVersionsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ClusterVersionsMessage, DescribeClusterVersionsMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeClusterVersionsCommandInput extends DescribeClusterVersionsMessage {
    }
    export interface DescribeClusterVersionsCommandOutput extends ClusterVersionsMessage, __MetadataBearer {
    }
    /**
        * <p>Returns descriptions of the available Amazon Redshift cluster versions. You can call this
        *             operation even before creating any clusters to learn more about the Amazon Redshift versions.
        *
        * For more information about managing clusters, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeClusterVersionsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeClusterVersionsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeClusterVersionsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeClusterVersionsCommandInput} for command's `input` shape.
        * @see {@link DescribeClusterVersionsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeClusterVersionsCommand extends $Command<DescribeClusterVersionsCommandInput, DescribeClusterVersionsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeClusterVersionsCommandInput;
            constructor(input: DescribeClusterVersionsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeClusterVersionsCommandInput, DescribeClusterVersionsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeDataSharesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeDataSharesMessage, DescribeDataSharesResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeDataSharesCommandInput extends DescribeDataSharesMessage {
    }
    export interface DescribeDataSharesCommandOutput extends DescribeDataSharesResult, __MetadataBearer {
    }
    /**
        * <p>Shows the status of any inbound or outbound datashares available in the specified
        *             account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeDataSharesCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeDataSharesCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeDataSharesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeDataSharesCommandInput} for command's `input` shape.
        * @see {@link DescribeDataSharesCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeDataSharesCommand extends $Command<DescribeDataSharesCommandInput, DescribeDataSharesCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeDataSharesCommandInput;
            constructor(input: DescribeDataSharesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeDataSharesCommandInput, DescribeDataSharesCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeDataSharesForConsumerCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeDataSharesForConsumerMessage, DescribeDataSharesForConsumerResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeDataSharesForConsumerCommandInput extends DescribeDataSharesForConsumerMessage {
    }
    export interface DescribeDataSharesForConsumerCommandOutput extends DescribeDataSharesForConsumerResult, __MetadataBearer {
    }
    /**
        * <p>Returns a list of datashares where the account identifier being called is a consumer account identifier.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeDataSharesForConsumerCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeDataSharesForConsumerCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeDataSharesForConsumerCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeDataSharesForConsumerCommandInput} for command's `input` shape.
        * @see {@link DescribeDataSharesForConsumerCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeDataSharesForConsumerCommand extends $Command<DescribeDataSharesForConsumerCommandInput, DescribeDataSharesForConsumerCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeDataSharesForConsumerCommandInput;
            constructor(input: DescribeDataSharesForConsumerCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeDataSharesForConsumerCommandInput, DescribeDataSharesForConsumerCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeDataSharesForProducerCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeDataSharesForProducerMessage, DescribeDataSharesForProducerResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeDataSharesForProducerCommandInput extends DescribeDataSharesForProducerMessage {
    }
    export interface DescribeDataSharesForProducerCommandOutput extends DescribeDataSharesForProducerResult, __MetadataBearer {
    }
    /**
        * <p>Returns a list of datashares when the account identifier being called is a producer account identifier.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeDataSharesForProducerCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeDataSharesForProducerCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeDataSharesForProducerCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeDataSharesForProducerCommandInput} for command's `input` shape.
        * @see {@link DescribeDataSharesForProducerCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeDataSharesForProducerCommand extends $Command<DescribeDataSharesForProducerCommandInput, DescribeDataSharesForProducerCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeDataSharesForProducerCommandInput;
            constructor(input: DescribeDataSharesForProducerCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeDataSharesForProducerCommandInput, DescribeDataSharesForProducerCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeDefaultClusterParametersCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeDefaultClusterParametersMessage, DescribeDefaultClusterParametersResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeDefaultClusterParametersCommandInput extends DescribeDefaultClusterParametersMessage {
    }
    export interface DescribeDefaultClusterParametersCommandOutput extends DescribeDefaultClusterParametersResult, __MetadataBearer {
    }
    /**
        * <p>Returns a list of parameter settings for the specified parameter group
        *             family.</p>
        *         <p>
        * For more information about parameters and parameter groups, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeDefaultClusterParametersCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeDefaultClusterParametersCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeDefaultClusterParametersCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeDefaultClusterParametersCommandInput} for command's `input` shape.
        * @see {@link DescribeDefaultClusterParametersCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeDefaultClusterParametersCommand extends $Command<DescribeDefaultClusterParametersCommandInput, DescribeDefaultClusterParametersCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeDefaultClusterParametersCommandInput;
            constructor(input: DescribeDefaultClusterParametersCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeDefaultClusterParametersCommandInput, DescribeDefaultClusterParametersCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeEndpointAccessCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeEndpointAccessMessage, EndpointAccessList } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeEndpointAccessCommandInput extends DescribeEndpointAccessMessage {
    }
    export interface DescribeEndpointAccessCommandOutput extends EndpointAccessList, __MetadataBearer {
    }
    /**
        * <p>Describes a Redshift-managed VPC endpoint.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeEndpointAccessCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeEndpointAccessCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeEndpointAccessCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeEndpointAccessCommandInput} for command's `input` shape.
        * @see {@link DescribeEndpointAccessCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeEndpointAccessCommand extends $Command<DescribeEndpointAccessCommandInput, DescribeEndpointAccessCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeEndpointAccessCommandInput;
            constructor(input: DescribeEndpointAccessCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeEndpointAccessCommandInput, DescribeEndpointAccessCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeEndpointAuthorizationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeEndpointAuthorizationMessage, EndpointAuthorizationList } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeEndpointAuthorizationCommandInput extends DescribeEndpointAuthorizationMessage {
    }
    export interface DescribeEndpointAuthorizationCommandOutput extends EndpointAuthorizationList, __MetadataBearer {
    }
    /**
        * <p>Describes an endpoint authorization.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeEndpointAuthorizationCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeEndpointAuthorizationCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeEndpointAuthorizationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeEndpointAuthorizationCommandInput} for command's `input` shape.
        * @see {@link DescribeEndpointAuthorizationCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeEndpointAuthorizationCommand extends $Command<DescribeEndpointAuthorizationCommandInput, DescribeEndpointAuthorizationCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeEndpointAuthorizationCommandInput;
            constructor(input: DescribeEndpointAuthorizationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeEndpointAuthorizationCommandInput, DescribeEndpointAuthorizationCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeEventCategoriesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeEventCategoriesMessage, EventCategoriesMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeEventCategoriesCommandInput extends DescribeEventCategoriesMessage {
    }
    export interface DescribeEventCategoriesCommandOutput extends EventCategoriesMessage, __MetadataBearer {
    }
    /**
        * <p>Displays a list of event categories for all event source types, or for a specified
        *             source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event
        *                 Notifications</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeEventCategoriesCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeEventCategoriesCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeEventCategoriesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeEventCategoriesCommandInput} for command's `input` shape.
        * @see {@link DescribeEventCategoriesCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeEventCategoriesCommand extends $Command<DescribeEventCategoriesCommandInput, DescribeEventCategoriesCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeEventCategoriesCommandInput;
            constructor(input: DescribeEventCategoriesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeEventCategoriesCommandInput, DescribeEventCategoriesCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeEventsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeEventsMessage, EventsMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeEventsCommandInput extends DescribeEventsMessage {
    }
    export interface DescribeEventsCommandOutput extends EventsMessage, __MetadataBearer {
    }
    /**
        * <p>Returns events related to clusters, security groups, snapshots, and parameter
        *             groups for the past 14 days. Events specific to a particular cluster, security group,
        *             snapshot or parameter group can be obtained by providing the name as a parameter. By
        *             default, the past hour of events are returned.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeEventsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeEventsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeEventsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeEventsCommandInput} for command's `input` shape.
        * @see {@link DescribeEventsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeEventsCommand extends $Command<DescribeEventsCommandInput, DescribeEventsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeEventsCommandInput;
            constructor(input: DescribeEventsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeEventsCommandInput, DescribeEventsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeEventSubscriptionsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeEventSubscriptionsMessage, EventSubscriptionsMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeEventSubscriptionsCommandInput extends DescribeEventSubscriptionsMessage {
    }
    export interface DescribeEventSubscriptionsCommandOutput extends EventSubscriptionsMessage, __MetadataBearer {
    }
    /**
        * <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a
        *             customer account. If you specify a subscription name, lists the description for that
        *             subscription.</p>
        *         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
        *             all event notification subscriptions that match any combination of the specified keys
        *             and values. For example, if you have <code>owner</code> and <code>environment</code> for
        *             tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions
        *             that have any combination of those values are returned.</p>
        *         <p>If both tag keys and values are omitted from the request, subscriptions are
        *             returned regardless of whether they have tag keys or values associated with
        *             them.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeEventSubscriptionsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeEventSubscriptionsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeEventSubscriptionsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeEventSubscriptionsCommandInput} for command's `input` shape.
        * @see {@link DescribeEventSubscriptionsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeEventSubscriptionsCommand extends $Command<DescribeEventSubscriptionsCommandInput, DescribeEventSubscriptionsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeEventSubscriptionsCommandInput;
            constructor(input: DescribeEventSubscriptionsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeEventSubscriptionsCommandInput, DescribeEventSubscriptionsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeHsmClientCertificatesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeHsmClientCertificatesMessage, HsmClientCertificateMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeHsmClientCertificatesCommandInput extends DescribeHsmClientCertificatesMessage {
    }
    export interface DescribeHsmClientCertificatesCommandOutput extends HsmClientCertificateMessage, __MetadataBearer {
    }
    /**
        * <p>Returns information about the specified HSM client certificate. If no certificate
        *             ID is specified, returns information about all the HSM certificates owned by your Amazon Web Services account.</p>
        *         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
        *             all HSM client certificates that match any combination of the specified keys and values.
        *             For example, if you have <code>owner</code> and <code>environment</code> for tag keys,
        *             and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates
        *             that have any combination of those values are returned.</p>
        *         <p>If both tag keys and values are omitted from the request, HSM client certificates
        *             are returned regardless of whether they have tag keys or values associated with
        *             them.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeHsmClientCertificatesCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeHsmClientCertificatesCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeHsmClientCertificatesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeHsmClientCertificatesCommandInput} for command's `input` shape.
        * @see {@link DescribeHsmClientCertificatesCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeHsmClientCertificatesCommand extends $Command<DescribeHsmClientCertificatesCommandInput, DescribeHsmClientCertificatesCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeHsmClientCertificatesCommandInput;
            constructor(input: DescribeHsmClientCertificatesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeHsmClientCertificatesCommandInput, DescribeHsmClientCertificatesCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeHsmConfigurationsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeHsmConfigurationsMessage, HsmConfigurationMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeHsmConfigurationsCommandInput extends DescribeHsmConfigurationsMessage {
    }
    export interface DescribeHsmConfigurationsCommandOutput extends HsmConfigurationMessage, __MetadataBearer {
    }
    /**
        * <p>Returns information about the specified Amazon Redshift HSM configuration. If no
        *             configuration ID is specified, returns information about all the HSM configurations
        *             owned by your Amazon Web Services account.</p>
        *         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
        *             all HSM connections that match any combination of the specified keys and values. For
        *             example, if you have <code>owner</code> and <code>environment</code> for tag keys, and
        *                 <code>admin</code> and <code>test</code> for tag values, all HSM connections that
        *             have any combination of those values are returned.</p>
        *         <p>If both tag keys and values are omitted from the request, HSM connections are
        *             returned regardless of whether they have tag keys or values associated with
        *             them.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeHsmConfigurationsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeHsmConfigurationsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeHsmConfigurationsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeHsmConfigurationsCommandInput} for command's `input` shape.
        * @see {@link DescribeHsmConfigurationsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeHsmConfigurationsCommand extends $Command<DescribeHsmConfigurationsCommandInput, DescribeHsmConfigurationsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeHsmConfigurationsCommandInput;
            constructor(input: DescribeHsmConfigurationsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeHsmConfigurationsCommandInput, DescribeHsmConfigurationsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeLoggingStatusCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeLoggingStatusMessage, LoggingStatus } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeLoggingStatusCommandInput extends DescribeLoggingStatusMessage {
    }
    export interface DescribeLoggingStatusCommandOutput extends LoggingStatus, __MetadataBearer {
    }
    /**
        * <p>Describes whether information, such as queries and connection attempts, is being
        *             logged for the specified Amazon Redshift cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeLoggingStatusCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeLoggingStatusCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeLoggingStatusCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeLoggingStatusCommandInput} for command's `input` shape.
        * @see {@link DescribeLoggingStatusCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeLoggingStatusCommand extends $Command<DescribeLoggingStatusCommandInput, DescribeLoggingStatusCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeLoggingStatusCommandInput;
            constructor(input: DescribeLoggingStatusCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeLoggingStatusCommandInput, DescribeLoggingStatusCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeNodeConfigurationOptionsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeNodeConfigurationOptionsMessage, NodeConfigurationOptionsMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeNodeConfigurationOptionsCommandInput extends DescribeNodeConfigurationOptionsMessage {
    }
    export interface DescribeNodeConfigurationOptionsCommandOutput extends NodeConfigurationOptionsMessage, __MetadataBearer {
    }
    /**
        * <p>Returns properties of possible node configurations such as node type, number of nodes, and
        *             disk usage for the specified action type.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeNodeConfigurationOptionsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeNodeConfigurationOptionsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeNodeConfigurationOptionsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeNodeConfigurationOptionsCommandInput} for command's `input` shape.
        * @see {@link DescribeNodeConfigurationOptionsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeNodeConfigurationOptionsCommand extends $Command<DescribeNodeConfigurationOptionsCommandInput, DescribeNodeConfigurationOptionsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeNodeConfigurationOptionsCommandInput;
            constructor(input: DescribeNodeConfigurationOptionsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeNodeConfigurationOptionsCommandInput, DescribeNodeConfigurationOptionsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeOrderableClusterOptionsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeOrderableClusterOptionsMessage, OrderableClusterOptionsMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeOrderableClusterOptionsCommandInput extends DescribeOrderableClusterOptionsMessage {
    }
    export interface DescribeOrderableClusterOptionsCommandOutput extends OrderableClusterOptionsMessage, __MetadataBearer {
    }
    /**
        * <p>Returns a list of orderable cluster options. Before you create a new cluster you
        *             can use this operation to find what options are available, such as the EC2 Availability
        *             Zones (AZ) in the specific Amazon Web Services Region that you can specify, and the node types you can
        *             request. The node types differ by available storage, memory, CPU and price. With the
        *             cost involved you might want to obtain a list of cluster options in the specific region
        *             and specify values when creating a cluster.
        * For more information about managing clusters, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeOrderableClusterOptionsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeOrderableClusterOptionsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeOrderableClusterOptionsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeOrderableClusterOptionsCommandInput} for command's `input` shape.
        * @see {@link DescribeOrderableClusterOptionsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeOrderableClusterOptionsCommand extends $Command<DescribeOrderableClusterOptionsCommandInput, DescribeOrderableClusterOptionsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeOrderableClusterOptionsCommandInput;
            constructor(input: DescribeOrderableClusterOptionsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeOrderableClusterOptionsCommandInput, DescribeOrderableClusterOptionsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribePartnersCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribePartnersInputMessage, DescribePartnersOutputMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribePartnersCommandInput extends DescribePartnersInputMessage {
    }
    export interface DescribePartnersCommandOutput extends DescribePartnersOutputMessage, __MetadataBearer {
    }
    /**
        * <p>Returns information about the partner integrations defined for a cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribePartnersCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribePartnersCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribePartnersCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribePartnersCommandInput} for command's `input` shape.
        * @see {@link DescribePartnersCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribePartnersCommand extends $Command<DescribePartnersCommandInput, DescribePartnersCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribePartnersCommandInput;
            constructor(input: DescribePartnersCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribePartnersCommandInput, DescribePartnersCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeReservedNodeExchangeStatusCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeReservedNodeExchangeStatusInputMessage, DescribeReservedNodeExchangeStatusOutputMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeReservedNodeExchangeStatusCommandInput extends DescribeReservedNodeExchangeStatusInputMessage {
    }
    export interface DescribeReservedNodeExchangeStatusCommandOutput extends DescribeReservedNodeExchangeStatusOutputMessage, __MetadataBearer {
    }
    /**
        * <p>Returns exchange status details and associated metadata for a reserved-node
        *             exchange. Statuses include such values as in progress and requested.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeReservedNodeExchangeStatusCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeReservedNodeExchangeStatusCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeReservedNodeExchangeStatusCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeReservedNodeExchangeStatusCommandInput} for command's `input` shape.
        * @see {@link DescribeReservedNodeExchangeStatusCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeReservedNodeExchangeStatusCommand extends $Command<DescribeReservedNodeExchangeStatusCommandInput, DescribeReservedNodeExchangeStatusCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeReservedNodeExchangeStatusCommandInput;
            constructor(input: DescribeReservedNodeExchangeStatusCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeReservedNodeExchangeStatusCommandInput, DescribeReservedNodeExchangeStatusCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeReservedNodeOfferingsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeReservedNodeOfferingsMessage, ReservedNodeOfferingsMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeReservedNodeOfferingsCommandInput extends DescribeReservedNodeOfferingsMessage {
    }
    export interface DescribeReservedNodeOfferingsCommandOutput extends ReservedNodeOfferingsMessage, __MetadataBearer {
    }
    /**
        * <p>Returns a list of the available reserved node offerings by Amazon Redshift with their
        *             descriptions including the node type, the fixed and recurring costs of reserving the
        *             node and duration the node will be reserved for you. These descriptions help you
        *             determine which reserve node offering you want to purchase. You then use the unique
        *             offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one
        *             or more nodes for your Amazon Redshift cluster. </p>
        *         <p>
        * For more information about reserved node offerings, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeReservedNodeOfferingsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeReservedNodeOfferingsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeReservedNodeOfferingsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeReservedNodeOfferingsCommandInput} for command's `input` shape.
        * @see {@link DescribeReservedNodeOfferingsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeReservedNodeOfferingsCommand extends $Command<DescribeReservedNodeOfferingsCommandInput, DescribeReservedNodeOfferingsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeReservedNodeOfferingsCommandInput;
            constructor(input: DescribeReservedNodeOfferingsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeReservedNodeOfferingsCommandInput, DescribeReservedNodeOfferingsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeReservedNodesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeReservedNodesMessage, ReservedNodesMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeReservedNodesCommandInput extends DescribeReservedNodesMessage {
    }
    export interface DescribeReservedNodesCommandOutput extends ReservedNodesMessage, __MetadataBearer {
    }
    /**
        * <p>Returns the descriptions of the reserved nodes.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeReservedNodesCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeReservedNodesCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeReservedNodesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeReservedNodesCommandInput} for command's `input` shape.
        * @see {@link DescribeReservedNodesCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeReservedNodesCommand extends $Command<DescribeReservedNodesCommandInput, DescribeReservedNodesCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeReservedNodesCommandInput;
            constructor(input: DescribeReservedNodesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeReservedNodesCommandInput, DescribeReservedNodesCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeResizeCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ResizeProgressMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { DescribeResizeMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeResizeCommandInput extends DescribeResizeMessage {
    }
    export interface DescribeResizeCommandOutput extends ResizeProgressMessage, __MetadataBearer {
    }
    /**
        * <p>Returns information about the last resize operation for the specified cluster. If
        *             no resize operation has ever been initiated for the specified cluster, a <code>HTTP
        *                 404</code> error is returned. If a resize operation was initiated and completed, the
        *             status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p>
        *         <p>A resize operation can be requested using <a>ModifyCluster</a> and
        *             specifying a different number or type of nodes for the cluster. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeResizeCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeResizeCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeResizeCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeResizeCommandInput} for command's `input` shape.
        * @see {@link DescribeResizeCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeResizeCommand extends $Command<DescribeResizeCommandInput, DescribeResizeCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeResizeCommandInput;
            constructor(input: DescribeResizeCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeResizeCommandInput, DescribeResizeCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeScheduledActionsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeScheduledActionsMessage, ScheduledActionsMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeScheduledActionsCommandInput extends DescribeScheduledActionsMessage {
    }
    export interface DescribeScheduledActionsCommandOutput extends ScheduledActionsMessage, __MetadataBearer {
    }
    /**
        * <p>Describes properties of scheduled actions.
        *              </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeScheduledActionsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeScheduledActionsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeScheduledActionsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeScheduledActionsCommandInput} for command's `input` shape.
        * @see {@link DescribeScheduledActionsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeScheduledActionsCommand extends $Command<DescribeScheduledActionsCommandInput, DescribeScheduledActionsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeScheduledActionsCommandInput;
            constructor(input: DescribeScheduledActionsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeScheduledActionsCommandInput, DescribeScheduledActionsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeSnapshotCopyGrantsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeSnapshotCopyGrantsMessage, SnapshotCopyGrantMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeSnapshotCopyGrantsCommandInput extends DescribeSnapshotCopyGrantsMessage {
    }
    export interface DescribeSnapshotCopyGrantsCommandOutput extends SnapshotCopyGrantMessage, __MetadataBearer {
    }
    /**
        * <p>Returns a list of snapshot copy grants owned by the Amazon Web Services account in the destination
        *             region.</p>
        *         <p>
        * For more information about managing snapshot copy grants, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.
        * </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeSnapshotCopyGrantsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeSnapshotCopyGrantsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeSnapshotCopyGrantsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeSnapshotCopyGrantsCommandInput} for command's `input` shape.
        * @see {@link DescribeSnapshotCopyGrantsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeSnapshotCopyGrantsCommand extends $Command<DescribeSnapshotCopyGrantsCommandInput, DescribeSnapshotCopyGrantsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeSnapshotCopyGrantsCommandInput;
            constructor(input: DescribeSnapshotCopyGrantsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeSnapshotCopyGrantsCommandInput, DescribeSnapshotCopyGrantsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeSnapshotSchedulesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeSnapshotSchedulesMessage, DescribeSnapshotSchedulesOutputMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeSnapshotSchedulesCommandInput extends DescribeSnapshotSchedulesMessage {
    }
    export interface DescribeSnapshotSchedulesCommandOutput extends DescribeSnapshotSchedulesOutputMessage, __MetadataBearer {
    }
    /**
        * <p>Returns a list of snapshot schedules. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeSnapshotSchedulesCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeSnapshotSchedulesCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeSnapshotSchedulesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeSnapshotSchedulesCommandInput} for command's `input` shape.
        * @see {@link DescribeSnapshotSchedulesCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeSnapshotSchedulesCommand extends $Command<DescribeSnapshotSchedulesCommandInput, DescribeSnapshotSchedulesCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeSnapshotSchedulesCommandInput;
            constructor(input: DescribeSnapshotSchedulesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeSnapshotSchedulesCommandInput, DescribeSnapshotSchedulesCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeStorageCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CustomerStorageMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeStorageCommandInput {
    }
    export interface DescribeStorageCommandOutput extends CustomerStorageMessage, __MetadataBearer {
    }
    /**
        * <p>Returns account level backups storage size and provisional storage.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeStorageCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeStorageCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeStorageCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeStorageCommandInput} for command's `input` shape.
        * @see {@link DescribeStorageCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeStorageCommand extends $Command<DescribeStorageCommandInput, DescribeStorageCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeStorageCommandInput;
            constructor(input: DescribeStorageCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeStorageCommandInput, DescribeStorageCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeTableRestoreStatusCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeTableRestoreStatusMessage, TableRestoreStatusMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeTableRestoreStatusCommandInput extends DescribeTableRestoreStatusMessage {
    }
    export interface DescribeTableRestoreStatusCommandOutput extends TableRestoreStatusMessage, __MetadataBearer {
    }
    /**
        * <p>Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value
        *             for the <code>TableRestoreRequestId</code> parameter, then
        *                 <code>DescribeTableRestoreStatus</code> returns the status of all table restore
        *             requests ordered by the date and time of the request in ascending order. Otherwise
        *                 <code>DescribeTableRestoreStatus</code> returns the status of the table specified by
        *                 <code>TableRestoreRequestId</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeTableRestoreStatusCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeTableRestoreStatusCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeTableRestoreStatusCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeTableRestoreStatusCommandInput} for command's `input` shape.
        * @see {@link DescribeTableRestoreStatusCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeTableRestoreStatusCommand extends $Command<DescribeTableRestoreStatusCommandInput, DescribeTableRestoreStatusCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeTableRestoreStatusCommandInput;
            constructor(input: DescribeTableRestoreStatusCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeTableRestoreStatusCommandInput, DescribeTableRestoreStatusCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeTagsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeTagsMessage, TaggedResourceListMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeTagsCommandInput extends DescribeTagsMessage {
    }
    export interface DescribeTagsCommandOutput extends TaggedResourceListMessage, __MetadataBearer {
    }
    /**
        * <p>Returns a list of tags. You can return tags from a specific resource by specifying
        *             an ARN, or you can return all tags for a given type of resource, such as clusters,
        *             snapshots, and so on.</p>
        *         <p>The following are limitations for <code>DescribeTags</code>: </p>
        *         <ul>
        *             <li>
        *                 <p>You cannot specify an ARN and a resource-type value together in the same
        *                     request.</p>
        *             </li>
        *             <li>
        *                 <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code>
        *                     parameters together with the ARN parameter.</p>
        *             </li>
        *             <li>
        *                 <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results
        *                     to return in a request.</p>
        *             </li>
        *          </ul>
        *         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
        *             all resources that match any combination of the specified keys and values. For example,
        *             if you have <code>owner</code> and <code>environment</code> for tag keys, and
        *                 <code>admin</code> and <code>test</code> for tag values, all resources that have any
        *             combination of those values are returned.</p>
        *         <p>If both tag keys and values are omitted from the request, resources are returned
        *             regardless of whether they have tag keys or values associated with them.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeTagsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeTagsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeTagsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeTagsCommandInput} for command's `input` shape.
        * @see {@link DescribeTagsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeTagsCommand extends $Command<DescribeTagsCommandInput, DescribeTagsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeTagsCommandInput;
            constructor(input: DescribeTagsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeTagsCommandInput, DescribeTagsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeUsageLimitsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeUsageLimitsMessage, UsageLimitList } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DescribeUsageLimitsCommandInput extends DescribeUsageLimitsMessage {
    }
    export interface DescribeUsageLimitsCommandOutput extends UsageLimitList, __MetadataBearer {
    }
    /**
        * <p>Shows usage limits on a cluster.
        *             Results are filtered based on the combination of input usage limit identifier, cluster identifier, and feature type parameters:</p>
        *         <ul>
        *             <li>
        *                <p>If usage limit identifier, cluster identifier, and feature type are not provided,
        *                 then all usage limit objects for the current account in the current region are returned.</p>
        *             </li>
        *             <li>
        *                <p>If usage limit identifier is provided,
        *                 then the corresponding usage limit object is returned.</p>
        *             </li>
        *             <li>
        *                <p>If cluster identifier is provided,
        *                 then all usage limit objects for the specified cluster are returned.</p>
        *             </li>
        *             <li>
        *                <p>If cluster identifier and feature type are provided,
        *                 then all usage limit objects for the combination of cluster and feature are returned.</p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DescribeUsageLimitsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DescribeUsageLimitsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DescribeUsageLimitsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeUsageLimitsCommandInput} for command's `input` shape.
        * @see {@link DescribeUsageLimitsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DescribeUsageLimitsCommand extends $Command<DescribeUsageLimitsCommandInput, DescribeUsageLimitsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DescribeUsageLimitsCommandInput;
            constructor(input: DescribeUsageLimitsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeUsageLimitsCommandInput, DescribeUsageLimitsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DisableLoggingCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DisableLoggingMessage, LoggingStatus } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DisableLoggingCommandInput extends DisableLoggingMessage {
    }
    export interface DisableLoggingCommandOutput extends LoggingStatus, __MetadataBearer {
    }
    /**
        * <p>Stops logging information, such as queries and connection attempts, for the
        *             specified Amazon Redshift cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DisableLoggingCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DisableLoggingCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DisableLoggingCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DisableLoggingCommandInput} for command's `input` shape.
        * @see {@link DisableLoggingCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DisableLoggingCommand extends $Command<DisableLoggingCommandInput, DisableLoggingCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DisableLoggingCommandInput;
            constructor(input: DisableLoggingCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DisableLoggingCommandInput, DisableLoggingCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DisableSnapshotCopyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DisableSnapshotCopyMessage, DisableSnapshotCopyResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DisableSnapshotCopyCommandInput extends DisableSnapshotCopyMessage {
    }
    export interface DisableSnapshotCopyCommandOutput extends DisableSnapshotCopyResult, __MetadataBearer {
    }
    /**
        * <p>Disables the automatic copying of snapshots from one region to another region for a
        *             specified cluster.</p>
        *         <p>If your cluster and its snapshots are encrypted using an encrypted symmetric key
        *             from Key Management Service, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that
        *             grants Amazon Redshift permission to the key in the destination region. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DisableSnapshotCopyCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DisableSnapshotCopyCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DisableSnapshotCopyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DisableSnapshotCopyCommandInput} for command's `input` shape.
        * @see {@link DisableSnapshotCopyCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DisableSnapshotCopyCommand extends $Command<DisableSnapshotCopyCommandInput, DisableSnapshotCopyCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DisableSnapshotCopyCommandInput;
            constructor(input: DisableSnapshotCopyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DisableSnapshotCopyCommandInput, DisableSnapshotCopyCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DisassociateDataShareConsumerCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DataShare } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { DisassociateDataShareConsumerMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface DisassociateDataShareConsumerCommandInput extends DisassociateDataShareConsumerMessage {
    }
    export interface DisassociateDataShareConsumerCommandOutput extends DataShare, __MetadataBearer {
    }
    /**
        * <p>From a datashare consumer account, remove association for the specified datashare.
        *             </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, DisassociateDataShareConsumerCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, DisassociateDataShareConsumerCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new DisassociateDataShareConsumerCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DisassociateDataShareConsumerCommandInput} for command's `input` shape.
        * @see {@link DisassociateDataShareConsumerCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class DisassociateDataShareConsumerCommand extends $Command<DisassociateDataShareConsumerCommandInput, DisassociateDataShareConsumerCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: DisassociateDataShareConsumerCommandInput;
            constructor(input: DisassociateDataShareConsumerCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DisassociateDataShareConsumerCommandInput, DisassociateDataShareConsumerCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/EnableLoggingCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EnableLoggingMessage, LoggingStatus } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface EnableLoggingCommandInput extends EnableLoggingMessage {
    }
    export interface EnableLoggingCommandOutput extends LoggingStatus, __MetadataBearer {
    }
    /**
        * <p>Starts logging information, such as queries and connection attempts, for the
        *             specified Amazon Redshift cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, EnableLoggingCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, EnableLoggingCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new EnableLoggingCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link EnableLoggingCommandInput} for command's `input` shape.
        * @see {@link EnableLoggingCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class EnableLoggingCommand extends $Command<EnableLoggingCommandInput, EnableLoggingCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: EnableLoggingCommandInput;
            constructor(input: EnableLoggingCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<EnableLoggingCommandInput, EnableLoggingCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/EnableSnapshotCopyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EnableSnapshotCopyMessage, EnableSnapshotCopyResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface EnableSnapshotCopyCommandInput extends EnableSnapshotCopyMessage {
    }
    export interface EnableSnapshotCopyCommandOutput extends EnableSnapshotCopyResult, __MetadataBearer {
    }
    /**
        * <p>Enables the automatic copy of snapshots from one region to another region for a
        *             specified cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, EnableSnapshotCopyCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, EnableSnapshotCopyCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new EnableSnapshotCopyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link EnableSnapshotCopyCommandInput} for command's `input` shape.
        * @see {@link EnableSnapshotCopyCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class EnableSnapshotCopyCommand extends $Command<EnableSnapshotCopyCommandInput, EnableSnapshotCopyCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: EnableSnapshotCopyCommandInput;
            constructor(input: EnableSnapshotCopyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<EnableSnapshotCopyCommandInput, EnableSnapshotCopyCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/GetClusterCredentialsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ClusterCredentials } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { GetClusterCredentialsMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface GetClusterCredentialsCommandInput extends GetClusterCredentialsMessage {
    }
    export interface GetClusterCredentialsCommandOutput extends ClusterCredentials, __MetadataBearer {
    }
    /**
        * <p>Returns a database user name and temporary password with temporary authorization to
        *             log on to an Amazon Redshift database. The action returns the database user name
        *             prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or
        *                 <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can
        *             optionally specify one or more database user groups that the user will join at log on.
        *             By default, the temporary credentials expire in 900 seconds. You can optionally specify
        *             a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more
        *             information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication
        *                 to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p>
        *         <p>The Identity and Access Management (IAM) user or role that runs
        *             GetClusterCredentials must have an IAM policy attached that allows access to all
        *             necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the
        *             Amazon Redshift Cluster Management Guide.</p>
        *         <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the
        *                 <code>redshift:JoinGroup</code> action with access to the listed
        *                 <code>dbgroups</code>. </p>
        *         <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>,
        *             then the policy must include the <code>redshift:CreateClusterUser</code>
        *             permission.</p>
        *         <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access
        *             to the resource <code>dbname</code> for the specified database name. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, GetClusterCredentialsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, GetClusterCredentialsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new GetClusterCredentialsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetClusterCredentialsCommandInput} for command's `input` shape.
        * @see {@link GetClusterCredentialsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class GetClusterCredentialsCommand extends $Command<GetClusterCredentialsCommandInput, GetClusterCredentialsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: GetClusterCredentialsCommandInput;
            constructor(input: GetClusterCredentialsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetClusterCredentialsCommandInput, GetClusterCredentialsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/GetClusterCredentialsWithIAMCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ClusterExtendedCredentials } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { GetClusterCredentialsWithIAMMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface GetClusterCredentialsWithIAMCommandInput extends GetClusterCredentialsWithIAMMessage {
    }
    export interface GetClusterCredentialsWithIAMCommandOutput extends ClusterExtendedCredentials, __MetadataBearer {
    }
    /**
        * <p>Returns a database user name and temporary password with temporary authorization to
        *             log in to an Amazon Redshift database.
        *             The database user is mapped 1:1 to the source Identity and Access Management (IAM) identity.
        *             For more information about IAM identities, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id.html">IAM Identities (users, user groups, and roles)</a> in the
        *             Amazon Web Services Identity and Access Management User Guide.</p>
        *         <p>The Identity and Access Management (IAM) identity that runs
        *             this operation must have an IAM policy attached that allows access to all
        *             necessary actions and resources.
        *                 For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html">Using identity-based policies (IAM policies)</a> in the
        *             Amazon Redshift Cluster Management Guide. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, GetClusterCredentialsWithIAMCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, GetClusterCredentialsWithIAMCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new GetClusterCredentialsWithIAMCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetClusterCredentialsWithIAMCommandInput} for command's `input` shape.
        * @see {@link GetClusterCredentialsWithIAMCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class GetClusterCredentialsWithIAMCommand extends $Command<GetClusterCredentialsWithIAMCommandInput, GetClusterCredentialsWithIAMCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: GetClusterCredentialsWithIAMCommandInput;
            constructor(input: GetClusterCredentialsWithIAMCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetClusterCredentialsWithIAMCommandInput, GetClusterCredentialsWithIAMCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/GetReservedNodeExchangeConfigurationOptionsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetReservedNodeExchangeConfigurationOptionsInputMessage, GetReservedNodeExchangeConfigurationOptionsOutputMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface GetReservedNodeExchangeConfigurationOptionsCommandInput extends GetReservedNodeExchangeConfigurationOptionsInputMessage {
    }
    export interface GetReservedNodeExchangeConfigurationOptionsCommandOutput extends GetReservedNodeExchangeConfigurationOptionsOutputMessage, __MetadataBearer {
    }
    /**
        * <p>Gets the configuration options for the reserved-node exchange. These options
        *             include information about the source reserved node and target reserved node offering.
        *             Details include the node type, the price, the node count, and the offering type.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, GetReservedNodeExchangeConfigurationOptionsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, GetReservedNodeExchangeConfigurationOptionsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new GetReservedNodeExchangeConfigurationOptionsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetReservedNodeExchangeConfigurationOptionsCommandInput} for command's `input` shape.
        * @see {@link GetReservedNodeExchangeConfigurationOptionsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class GetReservedNodeExchangeConfigurationOptionsCommand extends $Command<GetReservedNodeExchangeConfigurationOptionsCommandInput, GetReservedNodeExchangeConfigurationOptionsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: GetReservedNodeExchangeConfigurationOptionsCommandInput;
            constructor(input: GetReservedNodeExchangeConfigurationOptionsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetReservedNodeExchangeConfigurationOptionsCommandInput, GetReservedNodeExchangeConfigurationOptionsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/GetReservedNodeExchangeOfferingsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetReservedNodeExchangeOfferingsInputMessage, GetReservedNodeExchangeOfferingsOutputMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface GetReservedNodeExchangeOfferingsCommandInput extends GetReservedNodeExchangeOfferingsInputMessage {
    }
    export interface GetReservedNodeExchangeOfferingsCommandOutput extends GetReservedNodeExchangeOfferingsOutputMessage, __MetadataBearer {
    }
    /**
        * <p>Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term,
        *             and usage price of the given DC1 reserved node.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, GetReservedNodeExchangeOfferingsCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, GetReservedNodeExchangeOfferingsCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new GetReservedNodeExchangeOfferingsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetReservedNodeExchangeOfferingsCommandInput} for command's `input` shape.
        * @see {@link GetReservedNodeExchangeOfferingsCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class GetReservedNodeExchangeOfferingsCommand extends $Command<GetReservedNodeExchangeOfferingsCommandInput, GetReservedNodeExchangeOfferingsCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: GetReservedNodeExchangeOfferingsCommandInput;
            constructor(input: GetReservedNodeExchangeOfferingsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetReservedNodeExchangeOfferingsCommandInput, GetReservedNodeExchangeOfferingsCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyAquaConfigurationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ModifyAquaInputMessage, ModifyAquaOutputMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface ModifyAquaConfigurationCommandInput extends ModifyAquaInputMessage {
    }
    export interface ModifyAquaConfigurationCommandOutput extends ModifyAquaOutputMessage, __MetadataBearer {
    }
    /**
        * <p>Modifies whether a cluster can use AQUA (Advanced Query Accelerator). </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, ModifyAquaConfigurationCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, ModifyAquaConfigurationCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new ModifyAquaConfigurationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ModifyAquaConfigurationCommandInput} for command's `input` shape.
        * @see {@link ModifyAquaConfigurationCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class ModifyAquaConfigurationCommand extends $Command<ModifyAquaConfigurationCommandInput, ModifyAquaConfigurationCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: ModifyAquaConfigurationCommandInput;
            constructor(input: ModifyAquaConfigurationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ModifyAquaConfigurationCommandInput, ModifyAquaConfigurationCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyAuthenticationProfileCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ModifyAuthenticationProfileMessage, ModifyAuthenticationProfileResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface ModifyAuthenticationProfileCommandInput extends ModifyAuthenticationProfileMessage {
    }
    export interface ModifyAuthenticationProfileCommandOutput extends ModifyAuthenticationProfileResult, __MetadataBearer {
    }
    /**
        * <p>Modifies an authentication profile.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, ModifyAuthenticationProfileCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, ModifyAuthenticationProfileCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new ModifyAuthenticationProfileCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ModifyAuthenticationProfileCommandInput} for command's `input` shape.
        * @see {@link ModifyAuthenticationProfileCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class ModifyAuthenticationProfileCommand extends $Command<ModifyAuthenticationProfileCommandInput, ModifyAuthenticationProfileCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: ModifyAuthenticationProfileCommandInput;
            constructor(input: ModifyAuthenticationProfileCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ModifyAuthenticationProfileCommandInput, ModifyAuthenticationProfileCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ModifyClusterMessage, ModifyClusterResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface ModifyClusterCommandInput extends ModifyClusterMessage {
    }
    export interface ModifyClusterCommandOutput extends ModifyClusterResult, __MetadataBearer {
    }
    /**
        * <p>Modifies the settings for a cluster.</p>
        *         <p>You can also change node type and the number of nodes to scale up or down the
        *             cluster. When resizing a cluster, you must specify both the number of nodes and the node
        *             type even if one of the parameters does not change.</p>
        * 		       <p>You can add another security or
        *             parameter group, or change the admin user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect.
        * For more information about managing clusters, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, ModifyClusterCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, ModifyClusterCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new ModifyClusterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ModifyClusterCommandInput} for command's `input` shape.
        * @see {@link ModifyClusterCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class ModifyClusterCommand extends $Command<ModifyClusterCommandInput, ModifyClusterCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: ModifyClusterCommandInput;
            constructor(input: ModifyClusterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ModifyClusterCommandInput, ModifyClusterCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterDbRevisionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ModifyClusterDbRevisionMessage, ModifyClusterDbRevisionResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface ModifyClusterDbRevisionCommandInput extends ModifyClusterDbRevisionMessage {
    }
    export interface ModifyClusterDbRevisionCommandOutput extends ModifyClusterDbRevisionResult, __MetadataBearer {
    }
    /**
        * <p>Modifies the database revision of a cluster. The database revision is a unique
        *             revision of the database running in a cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, ModifyClusterDbRevisionCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, ModifyClusterDbRevisionCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new ModifyClusterDbRevisionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ModifyClusterDbRevisionCommandInput} for command's `input` shape.
        * @see {@link ModifyClusterDbRevisionCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class ModifyClusterDbRevisionCommand extends $Command<ModifyClusterDbRevisionCommandInput, ModifyClusterDbRevisionCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: ModifyClusterDbRevisionCommandInput;
            constructor(input: ModifyClusterDbRevisionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ModifyClusterDbRevisionCommandInput, ModifyClusterDbRevisionCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterIamRolesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ModifyClusterIamRolesMessage, ModifyClusterIamRolesResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface ModifyClusterIamRolesCommandInput extends ModifyClusterIamRolesMessage {
    }
    export interface ModifyClusterIamRolesCommandOutput extends ModifyClusterIamRolesResult, __MetadataBearer {
    }
    /**
        * <p>Modifies the list of Identity and Access Management (IAM) roles that can be
        *             used by the cluster to access other Amazon Web Services services.</p>
        *         <p>The maximum number of IAM roles that you can associate is subject to a quota.
        *             For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Quotas and limits</a>
        *             in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, ModifyClusterIamRolesCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, ModifyClusterIamRolesCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new ModifyClusterIamRolesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ModifyClusterIamRolesCommandInput} for command's `input` shape.
        * @see {@link ModifyClusterIamRolesCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class ModifyClusterIamRolesCommand extends $Command<ModifyClusterIamRolesCommandInput, ModifyClusterIamRolesCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: ModifyClusterIamRolesCommandInput;
            constructor(input: ModifyClusterIamRolesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ModifyClusterIamRolesCommandInput, ModifyClusterIamRolesCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterMaintenanceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ModifyClusterMaintenanceMessage, ModifyClusterMaintenanceResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface ModifyClusterMaintenanceCommandInput extends ModifyClusterMaintenanceMessage {
    }
    export interface ModifyClusterMaintenanceCommandOutput extends ModifyClusterMaintenanceResult, __MetadataBearer {
    }
    /**
        * <p>Modifies the maintenance settings of a cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, ModifyClusterMaintenanceCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, ModifyClusterMaintenanceCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new ModifyClusterMaintenanceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ModifyClusterMaintenanceCommandInput} for command's `input` shape.
        * @see {@link ModifyClusterMaintenanceCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class ModifyClusterMaintenanceCommand extends $Command<ModifyClusterMaintenanceCommandInput, ModifyClusterMaintenanceCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: ModifyClusterMaintenanceCommandInput;
            constructor(input: ModifyClusterMaintenanceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ModifyClusterMaintenanceCommandInput, ModifyClusterMaintenanceCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterParameterGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ClusterParameterGroupNameMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { ModifyClusterParameterGroupMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface ModifyClusterParameterGroupCommandInput extends ModifyClusterParameterGroupMessage {
    }
    export interface ModifyClusterParameterGroupCommandOutput extends ClusterParameterGroupNameMessage, __MetadataBearer {
    }
    /**
        * <p>Modifies the parameters of a parameter group. For the parameters parameter, it can't contain ASCII characters.</p>
        *         <p>
        * For more information about parameters and parameter groups, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, ModifyClusterParameterGroupCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, ModifyClusterParameterGroupCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new ModifyClusterParameterGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ModifyClusterParameterGroupCommandInput} for command's `input` shape.
        * @see {@link ModifyClusterParameterGroupCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class ModifyClusterParameterGroupCommand extends $Command<ModifyClusterParameterGroupCommandInput, ModifyClusterParameterGroupCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: ModifyClusterParameterGroupCommandInput;
            constructor(input: ModifyClusterParameterGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ModifyClusterParameterGroupCommandInput, ModifyClusterParameterGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterSnapshotCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ModifyClusterSnapshotMessage, ModifyClusterSnapshotResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface ModifyClusterSnapshotCommandInput extends ModifyClusterSnapshotMessage {
    }
    export interface ModifyClusterSnapshotCommandOutput extends ModifyClusterSnapshotResult, __MetadataBearer {
    }
    /**
        * <p>Modifies the settings for a snapshot.</p>
        * 		       <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, ModifyClusterSnapshotCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, ModifyClusterSnapshotCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new ModifyClusterSnapshotCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ModifyClusterSnapshotCommandInput} for command's `input` shape.
        * @see {@link ModifyClusterSnapshotCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class ModifyClusterSnapshotCommand extends $Command<ModifyClusterSnapshotCommandInput, ModifyClusterSnapshotCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: ModifyClusterSnapshotCommandInput;
            constructor(input: ModifyClusterSnapshotCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ModifyClusterSnapshotCommandInput, ModifyClusterSnapshotCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterSnapshotScheduleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ModifyClusterSnapshotScheduleMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface ModifyClusterSnapshotScheduleCommandInput extends ModifyClusterSnapshotScheduleMessage {
    }
    export interface ModifyClusterSnapshotScheduleCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Modifies a snapshot schedule for a cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, ModifyClusterSnapshotScheduleCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, ModifyClusterSnapshotScheduleCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new ModifyClusterSnapshotScheduleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ModifyClusterSnapshotScheduleCommandInput} for command's `input` shape.
        * @see {@link ModifyClusterSnapshotScheduleCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class ModifyClusterSnapshotScheduleCommand extends $Command<ModifyClusterSnapshotScheduleCommandInput, ModifyClusterSnapshotScheduleCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: ModifyClusterSnapshotScheduleCommandInput;
            constructor(input: ModifyClusterSnapshotScheduleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ModifyClusterSnapshotScheduleCommandInput, ModifyClusterSnapshotScheduleCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterSubnetGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ModifyClusterSubnetGroupMessage, ModifyClusterSubnetGroupResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface ModifyClusterSubnetGroupCommandInput extends ModifyClusterSubnetGroupMessage {
    }
    export interface ModifyClusterSubnetGroupCommandOutput extends ModifyClusterSubnetGroupResult, __MetadataBearer {
    }
    /**
        * <p>Modifies a cluster subnet group to include the specified list of VPC subnets. The
        *             operation replaces the existing list of subnets with the new list of subnets.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, ModifyClusterSubnetGroupCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, ModifyClusterSubnetGroupCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new ModifyClusterSubnetGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ModifyClusterSubnetGroupCommandInput} for command's `input` shape.
        * @see {@link ModifyClusterSubnetGroupCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class ModifyClusterSubnetGroupCommand extends $Command<ModifyClusterSubnetGroupCommandInput, ModifyClusterSubnetGroupCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: ModifyClusterSubnetGroupCommandInput;
            constructor(input: ModifyClusterSubnetGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ModifyClusterSubnetGroupCommandInput, ModifyClusterSubnetGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyEndpointAccessCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EndpointAccess } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { ModifyEndpointAccessMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface ModifyEndpointAccessCommandInput extends ModifyEndpointAccessMessage {
    }
    export interface ModifyEndpointAccessCommandOutput extends EndpointAccess, __MetadataBearer {
    }
    /**
        * <p>Modifies a Redshift-managed VPC endpoint.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, ModifyEndpointAccessCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, ModifyEndpointAccessCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new ModifyEndpointAccessCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ModifyEndpointAccessCommandInput} for command's `input` shape.
        * @see {@link ModifyEndpointAccessCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class ModifyEndpointAccessCommand extends $Command<ModifyEndpointAccessCommandInput, ModifyEndpointAccessCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: ModifyEndpointAccessCommandInput;
            constructor(input: ModifyEndpointAccessCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ModifyEndpointAccessCommandInput, ModifyEndpointAccessCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyEventSubscriptionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ModifyEventSubscriptionMessage, ModifyEventSubscriptionResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface ModifyEventSubscriptionCommandInput extends ModifyEventSubscriptionMessage {
    }
    export interface ModifyEventSubscriptionCommandOutput extends ModifyEventSubscriptionResult, __MetadataBearer {
    }
    /**
        * <p>Modifies an existing Amazon Redshift event notification subscription.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, ModifyEventSubscriptionCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, ModifyEventSubscriptionCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new ModifyEventSubscriptionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ModifyEventSubscriptionCommandInput} for command's `input` shape.
        * @see {@link ModifyEventSubscriptionCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class ModifyEventSubscriptionCommand extends $Command<ModifyEventSubscriptionCommandInput, ModifyEventSubscriptionCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: ModifyEventSubscriptionCommandInput;
            constructor(input: ModifyEventSubscriptionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ModifyEventSubscriptionCommandInput, ModifyEventSubscriptionCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyScheduledActionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ScheduledAction } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { ModifyScheduledActionMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface ModifyScheduledActionCommandInput extends ModifyScheduledActionMessage {
    }
    export interface ModifyScheduledActionCommandOutput extends ScheduledAction, __MetadataBearer {
    }
    /**
        * <p>Modifies a scheduled action.
        *             </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, ModifyScheduledActionCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, ModifyScheduledActionCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new ModifyScheduledActionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ModifyScheduledActionCommandInput} for command's `input` shape.
        * @see {@link ModifyScheduledActionCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class ModifyScheduledActionCommand extends $Command<ModifyScheduledActionCommandInput, ModifyScheduledActionCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: ModifyScheduledActionCommandInput;
            constructor(input: ModifyScheduledActionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ModifyScheduledActionCommandInput, ModifyScheduledActionCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifySnapshotCopyRetentionPeriodCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ModifySnapshotCopyRetentionPeriodMessage, ModifySnapshotCopyRetentionPeriodResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface ModifySnapshotCopyRetentionPeriodCommandInput extends ModifySnapshotCopyRetentionPeriodMessage {
    }
    export interface ModifySnapshotCopyRetentionPeriodCommandOutput extends ModifySnapshotCopyRetentionPeriodResult, __MetadataBearer {
    }
    /**
        * <p>Modifies the number of days to retain snapshots in the destination Amazon Web Services Region after
        *             they are copied from the source Amazon Web Services Region. By default, this operation only changes the
        *             retention period of copied automated snapshots. The retention periods for both new and
        *             existing copied automated snapshots are updated with the new retention period. You can
        *             set the manual option to change only the retention periods of copied manual snapshots.
        *             If you set this option, only newly copied manual snapshots have the new retention
        *             period. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, ModifySnapshotCopyRetentionPeriodCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, ModifySnapshotCopyRetentionPeriodCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new ModifySnapshotCopyRetentionPeriodCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ModifySnapshotCopyRetentionPeriodCommandInput} for command's `input` shape.
        * @see {@link ModifySnapshotCopyRetentionPeriodCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class ModifySnapshotCopyRetentionPeriodCommand extends $Command<ModifySnapshotCopyRetentionPeriodCommandInput, ModifySnapshotCopyRetentionPeriodCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: ModifySnapshotCopyRetentionPeriodCommandInput;
            constructor(input: ModifySnapshotCopyRetentionPeriodCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ModifySnapshotCopyRetentionPeriodCommandInput, ModifySnapshotCopyRetentionPeriodCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifySnapshotScheduleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { SnapshotSchedule } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { ModifySnapshotScheduleMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface ModifySnapshotScheduleCommandInput extends ModifySnapshotScheduleMessage {
    }
    export interface ModifySnapshotScheduleCommandOutput extends SnapshotSchedule, __MetadataBearer {
    }
    /**
        * <p>Modifies a snapshot schedule. Any schedule associated with a cluster is modified
        *             asynchronously.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, ModifySnapshotScheduleCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, ModifySnapshotScheduleCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new ModifySnapshotScheduleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ModifySnapshotScheduleCommandInput} for command's `input` shape.
        * @see {@link ModifySnapshotScheduleCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class ModifySnapshotScheduleCommand extends $Command<ModifySnapshotScheduleCommandInput, ModifySnapshotScheduleCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: ModifySnapshotScheduleCommandInput;
            constructor(input: ModifySnapshotScheduleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ModifySnapshotScheduleCommandInput, ModifySnapshotScheduleCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyUsageLimitCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UsageLimit } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { ModifyUsageLimitMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface ModifyUsageLimitCommandInput extends ModifyUsageLimitMessage {
    }
    export interface ModifyUsageLimitCommandOutput extends UsageLimit, __MetadataBearer {
    }
    /**
        * <p>Modifies a usage limit in a cluster.
        *             You can't modify the feature type or period of a usage limit.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, ModifyUsageLimitCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, ModifyUsageLimitCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new ModifyUsageLimitCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ModifyUsageLimitCommandInput} for command's `input` shape.
        * @see {@link ModifyUsageLimitCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class ModifyUsageLimitCommand extends $Command<ModifyUsageLimitCommandInput, ModifyUsageLimitCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: ModifyUsageLimitCommandInput;
            constructor(input: ModifyUsageLimitCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ModifyUsageLimitCommandInput, ModifyUsageLimitCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/PauseClusterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { PauseClusterMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { PauseClusterResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface PauseClusterCommandInput extends PauseClusterMessage {
    }
    export interface PauseClusterCommandOutput extends PauseClusterResult, __MetadataBearer {
    }
    /**
        * <p>Pauses a cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, PauseClusterCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, PauseClusterCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new PauseClusterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PauseClusterCommandInput} for command's `input` shape.
        * @see {@link PauseClusterCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class PauseClusterCommand extends $Command<PauseClusterCommandInput, PauseClusterCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: PauseClusterCommandInput;
            constructor(input: PauseClusterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PauseClusterCommandInput, PauseClusterCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/PurchaseReservedNodeOfferingCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { PurchaseReservedNodeOfferingMessage, PurchaseReservedNodeOfferingResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface PurchaseReservedNodeOfferingCommandInput extends PurchaseReservedNodeOfferingMessage {
    }
    export interface PurchaseReservedNodeOfferingCommandOutput extends PurchaseReservedNodeOfferingResult, __MetadataBearer {
    }
    /**
        * <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of
        *             reserved node offerings. You can purchase one or more of the offerings. You can call the
        *                 <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved
        *             node offerings. You can call this API by providing a specific reserved node offering and
        *             the number of nodes you want to reserve. </p>
        *         <p>
        * For more information about reserved node offerings, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, PurchaseReservedNodeOfferingCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, PurchaseReservedNodeOfferingCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new PurchaseReservedNodeOfferingCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PurchaseReservedNodeOfferingCommandInput} for command's `input` shape.
        * @see {@link PurchaseReservedNodeOfferingCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class PurchaseReservedNodeOfferingCommand extends $Command<PurchaseReservedNodeOfferingCommandInput, PurchaseReservedNodeOfferingCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: PurchaseReservedNodeOfferingCommandInput;
            constructor(input: PurchaseReservedNodeOfferingCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PurchaseReservedNodeOfferingCommandInput, PurchaseReservedNodeOfferingCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RebootClusterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { RebootClusterMessage, RebootClusterResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface RebootClusterCommandInput extends RebootClusterMessage {
    }
    export interface RebootClusterCommandOutput extends RebootClusterResult, __MetadataBearer {
    }
    /**
        * <p>Reboots a cluster. This action is taken as soon as possible. It results in a
        *             momentary outage to the cluster, during which the cluster status is set to
        *                 <code>rebooting</code>. A cluster event is created when the reboot is completed. Any
        *             pending cluster modifications (see <a>ModifyCluster</a>) are applied at this
        *             reboot.
        * For more information about managing clusters, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, RebootClusterCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, RebootClusterCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new RebootClusterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RebootClusterCommandInput} for command's `input` shape.
        * @see {@link RebootClusterCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class RebootClusterCommand extends $Command<RebootClusterCommandInput, RebootClusterCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: RebootClusterCommandInput;
            constructor(input: RebootClusterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RebootClusterCommandInput, RebootClusterCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RejectDataShareCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DataShare } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RejectDataShareMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface RejectDataShareCommandInput extends RejectDataShareMessage {
    }
    export interface RejectDataShareCommandOutput extends DataShare, __MetadataBearer {
    }
    /**
        * <p>From a datashare consumer account, rejects the specified datashare.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, RejectDataShareCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, RejectDataShareCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new RejectDataShareCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RejectDataShareCommandInput} for command's `input` shape.
        * @see {@link RejectDataShareCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class RejectDataShareCommand extends $Command<RejectDataShareCommandInput, RejectDataShareCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: RejectDataShareCommandInput;
            constructor(input: RejectDataShareCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RejectDataShareCommandInput, RejectDataShareCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ResetClusterParameterGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ClusterParameterGroupNameMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { ResetClusterParameterGroupMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface ResetClusterParameterGroupCommandInput extends ResetClusterParameterGroupMessage {
    }
    export interface ResetClusterParameterGroupCommandOutput extends ClusterParameterGroupNameMessage, __MetadataBearer {
    }
    /**
        * <p>Sets one or more parameters of the specified parameter group to their default
        *             values and sets the source values of the parameters to "engine-default". To reset the
        *             entire parameter group specify the <i>ResetAllParameters</i> parameter.
        *             For parameter changes to take effect you must reboot any associated clusters. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, ResetClusterParameterGroupCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, ResetClusterParameterGroupCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new ResetClusterParameterGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ResetClusterParameterGroupCommandInput} for command's `input` shape.
        * @see {@link ResetClusterParameterGroupCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class ResetClusterParameterGroupCommand extends $Command<ResetClusterParameterGroupCommandInput, ResetClusterParameterGroupCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: ResetClusterParameterGroupCommandInput;
            constructor(input: ResetClusterParameterGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ResetClusterParameterGroupCommandInput, ResetClusterParameterGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ResizeClusterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ResizeClusterMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { ResizeClusterResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface ResizeClusterCommandInput extends ResizeClusterMessage {
    }
    export interface ResizeClusterCommandOutput extends ResizeClusterResult, __MetadataBearer {
    }
    /**
        * <p>Changes the size of the cluster. You can change the cluster's type, or change the
        *             number or type of nodes. The default behavior is to use the elastic resize method. With
        *             an elastic resize, your cluster is available for read and write operations more quickly
        *             than with the classic resize method. </p>
        *         <p>Elastic resize operations have the following restrictions:</p>
        *         <ul>
        *             <li>
        *                 <p>You can only resize clusters of the following types:</p>
        *                 <ul>
        *                   <li>
        *                         <p>dc1.large (if your cluster is in a VPC)</p>
        *                     </li>
        *                   <li>
        *                         <p>dc1.8xlarge (if your cluster is in a VPC)</p>
        *                     </li>
        *                   <li>
        *                         <p>dc2.large</p>
        *                     </li>
        *                   <li>
        *                         <p>dc2.8xlarge</p>
        *                     </li>
        *                   <li>
        *                         <p>ds2.xlarge</p>
        *                     </li>
        *                   <li>
        *                         <p>ds2.8xlarge</p>
        *                     </li>
        *                   <li>
        *                         <p>ra3.xlplus</p>
        *                     </li>
        *                   <li>
        *                         <p>ra3.4xlarge</p>
        *                     </li>
        *                   <li>
        *                         <p>ra3.16xlarge</p>
        *                     </li>
        *                </ul>
        *             </li>
        *             <li>
        *                 <p>The type of nodes that you add must match the node type for the
        *                     cluster.</p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, ResizeClusterCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, ResizeClusterCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new ResizeClusterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ResizeClusterCommandInput} for command's `input` shape.
        * @see {@link ResizeClusterCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class ResizeClusterCommand extends $Command<ResizeClusterCommandInput, ResizeClusterCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: ResizeClusterCommandInput;
            constructor(input: ResizeClusterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ResizeClusterCommandInput, ResizeClusterCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RestoreFromClusterSnapshotCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { RestoreFromClusterSnapshotMessage, RestoreFromClusterSnapshotResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface RestoreFromClusterSnapshotCommandInput extends RestoreFromClusterSnapshotMessage {
    }
    export interface RestoreFromClusterSnapshotCommandOutput extends RestoreFromClusterSnapshotResult, __MetadataBearer {
    }
    /**
        * <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting
        *             cluster with the same configuration as the original cluster from which the snapshot was
        *             created, except that the new cluster is created with the default cluster security and
        *             parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different
        *             parameter group with the restored cluster. If you are using a DS node type, you can also
        *             choose to change to another DS node type of the same size during restore.</p>
        *         <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where
        *             you want the cluster restored.</p>
        *         <p>
        * For more information about working with snapshots, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, RestoreFromClusterSnapshotCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, RestoreFromClusterSnapshotCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new RestoreFromClusterSnapshotCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RestoreFromClusterSnapshotCommandInput} for command's `input` shape.
        * @see {@link RestoreFromClusterSnapshotCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class RestoreFromClusterSnapshotCommand extends $Command<RestoreFromClusterSnapshotCommandInput, RestoreFromClusterSnapshotCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: RestoreFromClusterSnapshotCommandInput;
            constructor(input: RestoreFromClusterSnapshotCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RestoreFromClusterSnapshotCommandInput, RestoreFromClusterSnapshotCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RestoreTableFromClusterSnapshotCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { RestoreTableFromClusterSnapshotMessage, RestoreTableFromClusterSnapshotResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface RestoreTableFromClusterSnapshotCommandInput extends RestoreTableFromClusterSnapshotMessage {
    }
    export interface RestoreTableFromClusterSnapshotCommandOutput extends RestoreTableFromClusterSnapshotResult, __MetadataBearer {
    }
    /**
        * <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must
        *             create the new table within the Amazon Redshift cluster that the snapshot was taken
        *             from.</p>
        *         <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with
        *             the same name as an existing table in an Amazon Redshift cluster. That is, you cannot
        *             overwrite an existing table in a cluster with a restored table. If you want to replace
        *             your original table with a new, restored table, then rename or drop your original table
        *             before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your
        *             original table, then you can pass the original name of the table as the
        *                 <code>NewTableName</code> parameter value in the call to
        *                 <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original
        *             table with the table created from the snapshot.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, RestoreTableFromClusterSnapshotCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, RestoreTableFromClusterSnapshotCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new RestoreTableFromClusterSnapshotCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RestoreTableFromClusterSnapshotCommandInput} for command's `input` shape.
        * @see {@link RestoreTableFromClusterSnapshotCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class RestoreTableFromClusterSnapshotCommand extends $Command<RestoreTableFromClusterSnapshotCommandInput, RestoreTableFromClusterSnapshotCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: RestoreTableFromClusterSnapshotCommandInput;
            constructor(input: RestoreTableFromClusterSnapshotCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RestoreTableFromClusterSnapshotCommandInput, RestoreTableFromClusterSnapshotCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ResumeClusterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ResumeClusterMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { ResumeClusterResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface ResumeClusterCommandInput extends ResumeClusterMessage {
    }
    export interface ResumeClusterCommandOutput extends ResumeClusterResult, __MetadataBearer {
    }
    /**
        * <p>Resumes a paused cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, ResumeClusterCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, ResumeClusterCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new ResumeClusterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ResumeClusterCommandInput} for command's `input` shape.
        * @see {@link ResumeClusterCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class ResumeClusterCommand extends $Command<ResumeClusterCommandInput, ResumeClusterCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: ResumeClusterCommandInput;
            constructor(input: ResumeClusterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ResumeClusterCommandInput, ResumeClusterCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RevokeClusterSecurityGroupIngressCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { RevokeClusterSecurityGroupIngressMessage, RevokeClusterSecurityGroupIngressResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface RevokeClusterSecurityGroupIngressCommandInput extends RevokeClusterSecurityGroupIngressMessage {
    }
    export interface RevokeClusterSecurityGroupIngressCommandOutput extends RevokeClusterSecurityGroupIngressResult, __MetadataBearer {
    }
    /**
        * <p>Revokes an ingress rule in an Amazon Redshift security group for a previously authorized
        *             IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>.
        * For information about managing security groups, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the
        * <i>Amazon Redshift Cluster Management Guide</i>. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, RevokeClusterSecurityGroupIngressCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, RevokeClusterSecurityGroupIngressCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new RevokeClusterSecurityGroupIngressCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RevokeClusterSecurityGroupIngressCommandInput} for command's `input` shape.
        * @see {@link RevokeClusterSecurityGroupIngressCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class RevokeClusterSecurityGroupIngressCommand extends $Command<RevokeClusterSecurityGroupIngressCommandInput, RevokeClusterSecurityGroupIngressCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: RevokeClusterSecurityGroupIngressCommandInput;
            constructor(input: RevokeClusterSecurityGroupIngressCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RevokeClusterSecurityGroupIngressCommandInput, RevokeClusterSecurityGroupIngressCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RevokeEndpointAccessCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EndpointAuthorization } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RevokeEndpointAccessMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface RevokeEndpointAccessCommandInput extends RevokeEndpointAccessMessage {
    }
    export interface RevokeEndpointAccessCommandOutput extends EndpointAuthorization, __MetadataBearer {
    }
    /**
        * <p>Revokes access to a cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, RevokeEndpointAccessCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, RevokeEndpointAccessCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new RevokeEndpointAccessCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RevokeEndpointAccessCommandInput} for command's `input` shape.
        * @see {@link RevokeEndpointAccessCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class RevokeEndpointAccessCommand extends $Command<RevokeEndpointAccessCommandInput, RevokeEndpointAccessCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: RevokeEndpointAccessCommandInput;
            constructor(input: RevokeEndpointAccessCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RevokeEndpointAccessCommandInput, RevokeEndpointAccessCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RevokeSnapshotAccessCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { RevokeSnapshotAccessMessage, RevokeSnapshotAccessResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface RevokeSnapshotAccessCommandInput extends RevokeSnapshotAccessMessage {
    }
    export interface RevokeSnapshotAccessCommandOutput extends RevokeSnapshotAccessResult, __MetadataBearer {
    }
    /**
        * <p>Removes the ability of the specified  Amazon Web Services account to restore the specified
        *             snapshot. If the account is currently restoring the snapshot, the restore will run to
        *             completion.</p>
        *         <p>
        * For more information about working with snapshots, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, RevokeSnapshotAccessCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, RevokeSnapshotAccessCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new RevokeSnapshotAccessCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RevokeSnapshotAccessCommandInput} for command's `input` shape.
        * @see {@link RevokeSnapshotAccessCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class RevokeSnapshotAccessCommand extends $Command<RevokeSnapshotAccessCommandInput, RevokeSnapshotAccessCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: RevokeSnapshotAccessCommandInput;
            constructor(input: RevokeSnapshotAccessCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RevokeSnapshotAccessCommandInput, RevokeSnapshotAccessCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RotateEncryptionKeyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { RotateEncryptionKeyMessage, RotateEncryptionKeyResult } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface RotateEncryptionKeyCommandInput extends RotateEncryptionKeyMessage {
    }
    export interface RotateEncryptionKeyCommandOutput extends RotateEncryptionKeyResult, __MetadataBearer {
    }
    /**
        * <p>Rotates the encryption keys for a cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, RotateEncryptionKeyCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, RotateEncryptionKeyCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new RotateEncryptionKeyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RotateEncryptionKeyCommandInput} for command's `input` shape.
        * @see {@link RotateEncryptionKeyCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class RotateEncryptionKeyCommand extends $Command<RotateEncryptionKeyCommandInput, RotateEncryptionKeyCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: RotateEncryptionKeyCommandInput;
            constructor(input: RotateEncryptionKeyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RotateEncryptionKeyCommandInput, RotateEncryptionKeyCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/UpdatePartnerStatusCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { PartnerIntegrationOutputMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { UpdatePartnerStatusInputMessage } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1";
    import { RedshiftClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient";
    export interface UpdatePartnerStatusCommandInput extends UpdatePartnerStatusInputMessage {
    }
    export interface UpdatePartnerStatusCommandOutput extends PartnerIntegrationOutputMessage, __MetadataBearer {
    }
    /**
        * <p>Updates the status of a partner integration.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RedshiftClient, UpdatePartnerStatusCommand } from "@aws-sdk/client-redshift"; // ES Modules import
        * // const { RedshiftClient, UpdatePartnerStatusCommand } = require("@aws-sdk/client-redshift"); // CommonJS import
        * const client = new RedshiftClient(config);
        * const command = new UpdatePartnerStatusCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdatePartnerStatusCommandInput} for command's `input` shape.
        * @see {@link UpdatePartnerStatusCommandOutput} for command's `response` shape.
        * @see {@link RedshiftClientResolvedConfig | config} for RedshiftClient's `config` shape.
        *
        */
    export class UpdatePartnerStatusCommand extends $Command<UpdatePartnerStatusCommandInput, UpdatePartnerStatusCommandOutput, RedshiftClientResolvedConfig> {
            readonly input: UpdatePartnerStatusCommandInput;
            constructor(input: UpdatePartnerStatusCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RedshiftClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdatePartnerStatusCommandInput, UpdatePartnerStatusCommandOutput>;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/RedshiftClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { AcceptReservedNodeExchangeCommandInput, AcceptReservedNodeExchangeCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/AcceptReservedNodeExchangeCommand";
    import { AddPartnerCommandInput, AddPartnerCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/AddPartnerCommand";
    import { AssociateDataShareConsumerCommandInput, AssociateDataShareConsumerCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/AssociateDataShareConsumerCommand";
    import { AuthorizeClusterSecurityGroupIngressCommandInput, AuthorizeClusterSecurityGroupIngressCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/AuthorizeClusterSecurityGroupIngressCommand";
    import { AuthorizeDataShareCommandInput, AuthorizeDataShareCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/AuthorizeDataShareCommand";
    import { AuthorizeEndpointAccessCommandInput, AuthorizeEndpointAccessCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/AuthorizeEndpointAccessCommand";
    import { AuthorizeSnapshotAccessCommandInput, AuthorizeSnapshotAccessCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/AuthorizeSnapshotAccessCommand";
    import { BatchDeleteClusterSnapshotsCommandInput, BatchDeleteClusterSnapshotsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/BatchDeleteClusterSnapshotsCommand";
    import { BatchModifyClusterSnapshotsCommandInput, BatchModifyClusterSnapshotsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/BatchModifyClusterSnapshotsCommand";
    import { CancelResizeCommandInput, CancelResizeCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CancelResizeCommand";
    import { CopyClusterSnapshotCommandInput, CopyClusterSnapshotCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CopyClusterSnapshotCommand";
    import { CreateAuthenticationProfileCommandInput, CreateAuthenticationProfileCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateAuthenticationProfileCommand";
    import { CreateClusterCommandInput, CreateClusterCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateClusterCommand";
    import { CreateClusterParameterGroupCommandInput, CreateClusterParameterGroupCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateClusterParameterGroupCommand";
    import { CreateClusterSecurityGroupCommandInput, CreateClusterSecurityGroupCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateClusterSecurityGroupCommand";
    import { CreateClusterSnapshotCommandInput, CreateClusterSnapshotCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateClusterSnapshotCommand";
    import { CreateClusterSubnetGroupCommandInput, CreateClusterSubnetGroupCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateClusterSubnetGroupCommand";
    import { CreateEndpointAccessCommandInput, CreateEndpointAccessCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateEndpointAccessCommand";
    import { CreateEventSubscriptionCommandInput, CreateEventSubscriptionCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateEventSubscriptionCommand";
    import { CreateHsmClientCertificateCommandInput, CreateHsmClientCertificateCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateHsmClientCertificateCommand";
    import { CreateHsmConfigurationCommandInput, CreateHsmConfigurationCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateHsmConfigurationCommand";
    import { CreateScheduledActionCommandInput, CreateScheduledActionCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateScheduledActionCommand";
    import { CreateSnapshotCopyGrantCommandInput, CreateSnapshotCopyGrantCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateSnapshotCopyGrantCommand";
    import { CreateSnapshotScheduleCommandInput, CreateSnapshotScheduleCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateSnapshotScheduleCommand";
    import { CreateTagsCommandInput, CreateTagsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateTagsCommand";
    import { CreateUsageLimitCommandInput, CreateUsageLimitCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/CreateUsageLimitCommand";
    import { DeauthorizeDataShareCommandInput, DeauthorizeDataShareCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeauthorizeDataShareCommand";
    import { DeleteAuthenticationProfileCommandInput, DeleteAuthenticationProfileCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteAuthenticationProfileCommand";
    import { DeleteClusterCommandInput, DeleteClusterCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteClusterCommand";
    import { DeleteClusterParameterGroupCommandInput, DeleteClusterParameterGroupCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteClusterParameterGroupCommand";
    import { DeleteClusterSecurityGroupCommandInput, DeleteClusterSecurityGroupCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteClusterSecurityGroupCommand";
    import { DeleteClusterSnapshotCommandInput, DeleteClusterSnapshotCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteClusterSnapshotCommand";
    import { DeleteClusterSubnetGroupCommandInput, DeleteClusterSubnetGroupCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteClusterSubnetGroupCommand";
    import { DeleteEndpointAccessCommandInput, DeleteEndpointAccessCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteEndpointAccessCommand";
    import { DeleteEventSubscriptionCommandInput, DeleteEventSubscriptionCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteEventSubscriptionCommand";
    import { DeleteHsmClientCertificateCommandInput, DeleteHsmClientCertificateCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteHsmClientCertificateCommand";
    import { DeleteHsmConfigurationCommandInput, DeleteHsmConfigurationCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteHsmConfigurationCommand";
    import { DeletePartnerCommandInput, DeletePartnerCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeletePartnerCommand";
    import { DeleteScheduledActionCommandInput, DeleteScheduledActionCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteScheduledActionCommand";
    import { DeleteSnapshotCopyGrantCommandInput, DeleteSnapshotCopyGrantCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteSnapshotCopyGrantCommand";
    import { DeleteSnapshotScheduleCommandInput, DeleteSnapshotScheduleCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteSnapshotScheduleCommand";
    import { DeleteTagsCommandInput, DeleteTagsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteTagsCommand";
    import { DeleteUsageLimitCommandInput, DeleteUsageLimitCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DeleteUsageLimitCommand";
    import { DescribeAccountAttributesCommandInput, DescribeAccountAttributesCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeAccountAttributesCommand";
    import { DescribeAuthenticationProfilesCommandInput, DescribeAuthenticationProfilesCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeAuthenticationProfilesCommand";
    import { DescribeClusterDbRevisionsCommandInput, DescribeClusterDbRevisionsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterDbRevisionsCommand";
    import { DescribeClusterParameterGroupsCommandInput, DescribeClusterParameterGroupsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterParameterGroupsCommand";
    import { DescribeClusterParametersCommandInput, DescribeClusterParametersCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterParametersCommand";
    import { DescribeClustersCommandInput, DescribeClustersCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClustersCommand";
    import { DescribeClusterSecurityGroupsCommandInput, DescribeClusterSecurityGroupsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterSecurityGroupsCommand";
    import { DescribeClusterSnapshotsCommandInput, DescribeClusterSnapshotsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterSnapshotsCommand";
    import { DescribeClusterSubnetGroupsCommandInput, DescribeClusterSubnetGroupsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterSubnetGroupsCommand";
    import { DescribeClusterTracksCommandInput, DescribeClusterTracksCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterTracksCommand";
    import { DescribeClusterVersionsCommandInput, DescribeClusterVersionsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeClusterVersionsCommand";
    import { DescribeDataSharesCommandInput, DescribeDataSharesCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeDataSharesCommand";
    import { DescribeDataSharesForConsumerCommandInput, DescribeDataSharesForConsumerCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeDataSharesForConsumerCommand";
    import { DescribeDataSharesForProducerCommandInput, DescribeDataSharesForProducerCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeDataSharesForProducerCommand";
    import { DescribeDefaultClusterParametersCommandInput, DescribeDefaultClusterParametersCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeDefaultClusterParametersCommand";
    import { DescribeEndpointAccessCommandInput, DescribeEndpointAccessCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeEndpointAccessCommand";
    import { DescribeEndpointAuthorizationCommandInput, DescribeEndpointAuthorizationCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeEndpointAuthorizationCommand";
    import { DescribeEventCategoriesCommandInput, DescribeEventCategoriesCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeEventCategoriesCommand";
    import { DescribeEventsCommandInput, DescribeEventsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeEventsCommand";
    import { DescribeEventSubscriptionsCommandInput, DescribeEventSubscriptionsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeEventSubscriptionsCommand";
    import { DescribeHsmClientCertificatesCommandInput, DescribeHsmClientCertificatesCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeHsmClientCertificatesCommand";
    import { DescribeHsmConfigurationsCommandInput, DescribeHsmConfigurationsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeHsmConfigurationsCommand";
    import { DescribeLoggingStatusCommandInput, DescribeLoggingStatusCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeLoggingStatusCommand";
    import { DescribeNodeConfigurationOptionsCommandInput, DescribeNodeConfigurationOptionsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeNodeConfigurationOptionsCommand";
    import { DescribeOrderableClusterOptionsCommandInput, DescribeOrderableClusterOptionsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeOrderableClusterOptionsCommand";
    import { DescribePartnersCommandInput, DescribePartnersCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribePartnersCommand";
    import { DescribeReservedNodeExchangeStatusCommandInput, DescribeReservedNodeExchangeStatusCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeReservedNodeExchangeStatusCommand";
    import { DescribeReservedNodeOfferingsCommandInput, DescribeReservedNodeOfferingsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeReservedNodeOfferingsCommand";
    import { DescribeReservedNodesCommandInput, DescribeReservedNodesCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeReservedNodesCommand";
    import { DescribeResizeCommandInput, DescribeResizeCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeResizeCommand";
    import { DescribeScheduledActionsCommandInput, DescribeScheduledActionsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeScheduledActionsCommand";
    import { DescribeSnapshotCopyGrantsCommandInput, DescribeSnapshotCopyGrantsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeSnapshotCopyGrantsCommand";
    import { DescribeSnapshotSchedulesCommandInput, DescribeSnapshotSchedulesCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeSnapshotSchedulesCommand";
    import { DescribeStorageCommandInput, DescribeStorageCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeStorageCommand";
    import { DescribeTableRestoreStatusCommandInput, DescribeTableRestoreStatusCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeTableRestoreStatusCommand";
    import { DescribeTagsCommandInput, DescribeTagsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeTagsCommand";
    import { DescribeUsageLimitsCommandInput, DescribeUsageLimitsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DescribeUsageLimitsCommand";
    import { DisableLoggingCommandInput, DisableLoggingCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DisableLoggingCommand";
    import { DisableSnapshotCopyCommandInput, DisableSnapshotCopyCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DisableSnapshotCopyCommand";
    import { DisassociateDataShareConsumerCommandInput, DisassociateDataShareConsumerCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/DisassociateDataShareConsumerCommand";
    import { EnableLoggingCommandInput, EnableLoggingCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/EnableLoggingCommand";
    import { EnableSnapshotCopyCommandInput, EnableSnapshotCopyCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/EnableSnapshotCopyCommand";
    import { GetClusterCredentialsCommandInput, GetClusterCredentialsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/GetClusterCredentialsCommand";
    import { GetClusterCredentialsWithIAMCommandInput, GetClusterCredentialsWithIAMCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/GetClusterCredentialsWithIAMCommand";
    import { GetReservedNodeExchangeConfigurationOptionsCommandInput, GetReservedNodeExchangeConfigurationOptionsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/GetReservedNodeExchangeConfigurationOptionsCommand";
    import { GetReservedNodeExchangeOfferingsCommandInput, GetReservedNodeExchangeOfferingsCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/GetReservedNodeExchangeOfferingsCommand";
    import { ModifyAquaConfigurationCommandInput, ModifyAquaConfigurationCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyAquaConfigurationCommand";
    import { ModifyAuthenticationProfileCommandInput, ModifyAuthenticationProfileCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyAuthenticationProfileCommand";
    import { ModifyClusterCommandInput, ModifyClusterCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterCommand";
    import { ModifyClusterDbRevisionCommandInput, ModifyClusterDbRevisionCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterDbRevisionCommand";
    import { ModifyClusterIamRolesCommandInput, ModifyClusterIamRolesCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterIamRolesCommand";
    import { ModifyClusterMaintenanceCommandInput, ModifyClusterMaintenanceCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterMaintenanceCommand";
    import { ModifyClusterParameterGroupCommandInput, ModifyClusterParameterGroupCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterParameterGroupCommand";
    import { ModifyClusterSnapshotCommandInput, ModifyClusterSnapshotCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterSnapshotCommand";
    import { ModifyClusterSnapshotScheduleCommandInput, ModifyClusterSnapshotScheduleCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterSnapshotScheduleCommand";
    import { ModifyClusterSubnetGroupCommandInput, ModifyClusterSubnetGroupCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyClusterSubnetGroupCommand";
    import { ModifyEndpointAccessCommandInput, ModifyEndpointAccessCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyEndpointAccessCommand";
    import { ModifyEventSubscriptionCommandInput, ModifyEventSubscriptionCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyEventSubscriptionCommand";
    import { ModifyScheduledActionCommandInput, ModifyScheduledActionCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyScheduledActionCommand";
    import { ModifySnapshotCopyRetentionPeriodCommandInput, ModifySnapshotCopyRetentionPeriodCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifySnapshotCopyRetentionPeriodCommand";
    import { ModifySnapshotScheduleCommandInput, ModifySnapshotScheduleCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifySnapshotScheduleCommand";
    import { ModifyUsageLimitCommandInput, ModifyUsageLimitCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ModifyUsageLimitCommand";
    import { PauseClusterCommandInput, PauseClusterCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/PauseClusterCommand";
    import { PurchaseReservedNodeOfferingCommandInput, PurchaseReservedNodeOfferingCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/PurchaseReservedNodeOfferingCommand";
    import { RebootClusterCommandInput, RebootClusterCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RebootClusterCommand";
    import { RejectDataShareCommandInput, RejectDataShareCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RejectDataShareCommand";
    import { ResetClusterParameterGroupCommandInput, ResetClusterParameterGroupCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ResetClusterParameterGroupCommand";
    import { ResizeClusterCommandInput, ResizeClusterCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ResizeClusterCommand";
    import { RestoreFromClusterSnapshotCommandInput, RestoreFromClusterSnapshotCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RestoreFromClusterSnapshotCommand";
    import { RestoreTableFromClusterSnapshotCommandInput, RestoreTableFromClusterSnapshotCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RestoreTableFromClusterSnapshotCommand";
    import { ResumeClusterCommandInput, ResumeClusterCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/ResumeClusterCommand";
    import { RevokeClusterSecurityGroupIngressCommandInput, RevokeClusterSecurityGroupIngressCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RevokeClusterSecurityGroupIngressCommand";
    import { RevokeEndpointAccessCommandInput, RevokeEndpointAccessCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RevokeEndpointAccessCommand";
    import { RevokeSnapshotAccessCommandInput, RevokeSnapshotAccessCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RevokeSnapshotAccessCommand";
    import { RotateEncryptionKeyCommandInput, RotateEncryptionKeyCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/RotateEncryptionKeyCommand";
    import { UpdatePartnerStatusCommandInput, UpdatePartnerStatusCommandOutput } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/commands/UpdatePartnerStatusCommand";
    export type ServiceInputTypes = AcceptReservedNodeExchangeCommandInput | AddPartnerCommandInput | AssociateDataShareConsumerCommandInput | AuthorizeClusterSecurityGroupIngressCommandInput | AuthorizeDataShareCommandInput | AuthorizeEndpointAccessCommandInput | AuthorizeSnapshotAccessCommandInput | BatchDeleteClusterSnapshotsCommandInput | BatchModifyClusterSnapshotsCommandInput | CancelResizeCommandInput | CopyClusterSnapshotCommandInput | CreateAuthenticationProfileCommandInput | CreateClusterCommandInput | CreateClusterParameterGroupCommandInput | CreateClusterSecurityGroupCommandInput | CreateClusterSnapshotCommandInput | CreateClusterSubnetGroupCommandInput | CreateEndpointAccessCommandInput | CreateEventSubscriptionCommandInput | CreateHsmClientCertificateCommandInput | CreateHsmConfigurationCommandInput | CreateScheduledActionCommandInput | CreateSnapshotCopyGrantCommandInput | CreateSnapshotScheduleCommandInput | CreateTagsCommandInput | CreateUsageLimitCommandInput | DeauthorizeDataShareCommandInput | DeleteAuthenticationProfileCommandInput | DeleteClusterCommandInput | DeleteClusterParameterGroupCommandInput | DeleteClusterSecurityGroupCommandInput | DeleteClusterSnapshotCommandInput | DeleteClusterSubnetGroupCommandInput | DeleteEndpointAccessCommandInput | DeleteEventSubscriptionCommandInput | DeleteHsmClientCertificateCommandInput | DeleteHsmConfigurationCommandInput | DeletePartnerCommandInput | DeleteScheduledActionCommandInput | DeleteSnapshotCopyGrantCommandInput | DeleteSnapshotScheduleCommandInput | DeleteTagsCommandInput | DeleteUsageLimitCommandInput | DescribeAccountAttributesCommandInput | DescribeAuthenticationProfilesCommandInput | DescribeClusterDbRevisionsCommandInput | DescribeClusterParameterGroupsCommandInput | DescribeClusterParametersCommandInput | DescribeClusterSecurityGroupsCommandInput | DescribeClusterSnapshotsCommandInput | DescribeClusterSubnetGroupsCommandInput | DescribeClusterTracksCommandInput | DescribeClusterVersionsCommandInput | DescribeClustersCommandInput | DescribeDataSharesCommandInput | DescribeDataSharesForConsumerCommandInput | DescribeDataSharesForProducerCommandInput | DescribeDefaultClusterParametersCommandInput | DescribeEndpointAccessCommandInput | DescribeEndpointAuthorizationCommandInput | DescribeEventCategoriesCommandInput | DescribeEventSubscriptionsCommandInput | DescribeEventsCommandInput | DescribeHsmClientCertificatesCommandInput | DescribeHsmConfigurationsCommandInput | DescribeLoggingStatusCommandInput | DescribeNodeConfigurationOptionsCommandInput | DescribeOrderableClusterOptionsCommandInput | DescribePartnersCommandInput | DescribeReservedNodeExchangeStatusCommandInput | DescribeReservedNodeOfferingsCommandInput | DescribeReservedNodesCommandInput | DescribeResizeCommandInput | DescribeScheduledActionsCommandInput | DescribeSnapshotCopyGrantsCommandInput | DescribeSnapshotSchedulesCommandInput | DescribeStorageCommandInput | DescribeTableRestoreStatusCommandInput | DescribeTagsCommandInput | DescribeUsageLimitsCommandInput | DisableLoggingCommandInput | DisableSnapshotCopyCommandInput | DisassociateDataShareConsumerCommandInput | EnableLoggingCommandInput | EnableSnapshotCopyCommandInput | GetClusterCredentialsCommandInput | GetClusterCredentialsWithIAMCommandInput | GetReservedNodeExchangeConfigurationOptionsCommandInput | GetReservedNodeExchangeOfferingsCommandInput | ModifyAquaConfigurationCommandInput | ModifyAuthenticationProfileCommandInput | ModifyClusterCommandInput | ModifyClusterDbRevisionCommandInput | ModifyClusterIamRolesCommandInput | ModifyClusterMaintenanceCommandInput | ModifyClusterParameterGroupCommandInput | ModifyClusterSnapshotCommandInput | ModifyClusterSnapshotScheduleCommandInput | ModifyClusterSubnetGroupCommandInput | ModifyEndpointAccessCommandInput | ModifyEventSubscriptionCommandInput | ModifyScheduledActionCommandInput | ModifySnapshotCopyRetentionPeriodCommandInput | ModifySnapshotScheduleCommandInput | ModifyUsageLimitCommandInput | PauseClusterCommandInput | PurchaseReservedNodeOfferingCommandInput | RebootClusterCommandInput | RejectDataShareCommandInput | ResetClusterParameterGroupCommandInput | ResizeClusterCommandInput | RestoreFromClusterSnapshotCommandInput | RestoreTableFromClusterSnapshotCommandInput | ResumeClusterCommandInput | RevokeClusterSecurityGroupIngressCommandInput | RevokeEndpointAccessCommandInput | RevokeSnapshotAccessCommandInput | RotateEncryptionKeyCommandInput | UpdatePartnerStatusCommandInput;
    export type ServiceOutputTypes = AcceptReservedNodeExchangeCommandOutput | AddPartnerCommandOutput | AssociateDataShareConsumerCommandOutput | AuthorizeClusterSecurityGroupIngressCommandOutput | AuthorizeDataShareCommandOutput | AuthorizeEndpointAccessCommandOutput | AuthorizeSnapshotAccessCommandOutput | BatchDeleteClusterSnapshotsCommandOutput | BatchModifyClusterSnapshotsCommandOutput | CancelResizeCommandOutput | CopyClusterSnapshotCommandOutput | CreateAuthenticationProfileCommandOutput | CreateClusterCommandOutput | CreateClusterParameterGroupCommandOutput | CreateClusterSecurityGroupCommandOutput | CreateClusterSnapshotCommandOutput | CreateClusterSubnetGroupCommandOutput | CreateEndpointAccessCommandOutput | CreateEventSubscriptionCommandOutput | CreateHsmClientCertificateCommandOutput | CreateHsmConfigurationCommandOutput | CreateScheduledActionCommandOutput | CreateSnapshotCopyGrantCommandOutput | CreateSnapshotScheduleCommandOutput | CreateTagsCommandOutput | CreateUsageLimitCommandOutput | DeauthorizeDataShareCommandOutput | DeleteAuthenticationProfileCommandOutput | DeleteClusterCommandOutput | DeleteClusterParameterGroupCommandOutput | DeleteClusterSecurityGroupCommandOutput | DeleteClusterSnapshotCommandOutput | DeleteClusterSubnetGroupCommandOutput | DeleteEndpointAccessCommandOutput | DeleteEventSubscriptionCommandOutput | DeleteHsmClientCertificateCommandOutput | DeleteHsmConfigurationCommandOutput | DeletePartnerCommandOutput | DeleteScheduledActionCommandOutput | DeleteSnapshotCopyGrantCommandOutput | DeleteSnapshotScheduleCommandOutput | DeleteTagsCommandOutput | DeleteUsageLimitCommandOutput | DescribeAccountAttributesCommandOutput | DescribeAuthenticationProfilesCommandOutput | DescribeClusterDbRevisionsCommandOutput | DescribeClusterParameterGroupsCommandOutput | DescribeClusterParametersCommandOutput | DescribeClusterSecurityGroupsCommandOutput | DescribeClusterSnapshotsCommandOutput | DescribeClusterSubnetGroupsCommandOutput | DescribeClusterTracksCommandOutput | DescribeClusterVersionsCommandOutput | DescribeClustersCommandOutput | DescribeDataSharesCommandOutput | DescribeDataSharesForConsumerCommandOutput | DescribeDataSharesForProducerCommandOutput | DescribeDefaultClusterParametersCommandOutput | DescribeEndpointAccessCommandOutput | DescribeEndpointAuthorizationCommandOutput | DescribeEventCategoriesCommandOutput | DescribeEventSubscriptionsCommandOutput | DescribeEventsCommandOutput | DescribeHsmClientCertificatesCommandOutput | DescribeHsmConfigurationsCommandOutput | DescribeLoggingStatusCommandOutput | DescribeNodeConfigurationOptionsCommandOutput | DescribeOrderableClusterOptionsCommandOutput | DescribePartnersCommandOutput | DescribeReservedNodeExchangeStatusCommandOutput | DescribeReservedNodeOfferingsCommandOutput | DescribeReservedNodesCommandOutput | DescribeResizeCommandOutput | DescribeScheduledActionsCommandOutput | DescribeSnapshotCopyGrantsCommandOutput | DescribeSnapshotSchedulesCommandOutput | DescribeStorageCommandOutput | DescribeTableRestoreStatusCommandOutput | DescribeTagsCommandOutput | DescribeUsageLimitsCommandOutput | DisableLoggingCommandOutput | DisableSnapshotCopyCommandOutput | DisassociateDataShareConsumerCommandOutput | EnableLoggingCommandOutput | EnableSnapshotCopyCommandOutput | GetClusterCredentialsCommandOutput | GetClusterCredentialsWithIAMCommandOutput | GetReservedNodeExchangeConfigurationOptionsCommandOutput | GetReservedNodeExchangeOfferingsCommandOutput | ModifyAquaConfigurationCommandOutput | ModifyAuthenticationProfileCommandOutput | ModifyClusterCommandOutput | ModifyClusterDbRevisionCommandOutput | ModifyClusterIamRolesCommandOutput | ModifyClusterMaintenanceCommandOutput | ModifyClusterParameterGroupCommandOutput | ModifyClusterSnapshotCommandOutput | ModifyClusterSnapshotScheduleCommandOutput | ModifyClusterSubnetGroupCommandOutput | ModifyEndpointAccessCommandOutput | ModifyEventSubscriptionCommandOutput | ModifyScheduledActionCommandOutput | ModifySnapshotCopyRetentionPeriodCommandOutput | ModifySnapshotScheduleCommandOutput | ModifyUsageLimitCommandOutput | PauseClusterCommandOutput | PurchaseReservedNodeOfferingCommandOutput | RebootClusterCommandOutput | RejectDataShareCommandOutput | ResetClusterParameterGroupCommandOutput | ResizeClusterCommandOutput | RestoreFromClusterSnapshotCommandOutput | RestoreTableFromClusterSnapshotCommandOutput | ResumeClusterCommandOutput | RevokeClusterSecurityGroupIngressCommandOutput | RevokeEndpointAccessCommandOutput | RevokeSnapshotAccessCommandOutput | RotateEncryptionKeyCommandOutput | UpdatePartnerStatusCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type RedshiftClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of RedshiftClient class constructor that set the region, credentials and other options.
        */
    export interface RedshiftClientConfig extends RedshiftClientConfigType {
    }
    type RedshiftClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of RedshiftClient class. This is resolved and normalized from the {@link RedshiftClientConfig | constructor configuration interface}.
        */
    export interface RedshiftClientResolvedConfig extends RedshiftClientResolvedConfigType {
    }
    /**
        * <fullname>Amazon Redshift</fullname>
        *         <p>
        *             <b>Overview</b>
        *         </p>
        *         <p>This is an interface reference for Amazon Redshift. It contains documentation for one of
        *             the programming or command line interfaces you can use to manage Amazon Redshift clusters.
        *             Note that Amazon Redshift is asynchronous, which means that some interfaces may require
        *             techniques, such as polling or asynchronous callback handlers, to determine when a
        *             command has been applied. In this reference, the parameter descriptions indicate whether
        *             a change is applied immediately, on the next instance reboot, or during the next
        *             maintenance window. For a summary of the Amazon Redshift cluster management interfaces, go to
        *                 <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/using-aws-sdk.html">Using the
        *                 Amazon Redshift Management Interfaces</a>.</p>
        *         <p>Amazon Redshift manages all the work of setting up, operating, and scaling a data
        *             warehouse: provisioning capacity, monitoring and backing up the cluster, and applying
        *             patches and upgrades to the Amazon Redshift engine. You can focus on using your data to
        *             acquire new insights for your business and customers.</p>
        *         <p>If you are a first-time user of Amazon Redshift, we recommend that you begin by reading
        *             the <a href="https://docs.aws.amazon.com/redshift/latest/gsg/getting-started.html">Amazon Redshift Getting Started Guide</a>.</p>
        *
        *         <p>If you are a database developer, the <a href="https://docs.aws.amazon.com/redshift/latest/dg/welcome.html">Amazon Redshift Database Developer Guide</a> explains how to design,
        *             build, query, and maintain the databases that make up your data warehouse. </p>
        */
    export class RedshiftClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, RedshiftClientResolvedConfig> {
            /**
                * The resolved configuration of RedshiftClient class. This is resolved and normalized from the {@link RedshiftClientConfig | constructor configuration interface}.
                */
            readonly config: RedshiftClientResolvedConfig;
            constructor(configuration: RedshiftClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { RedshiftServiceException as __BaseException } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/RedshiftServiceException";
    export interface AcceptReservedNodeExchangeInputMessage {
            /**
                * <p>A string representing the node identifier of the DC1 Reserved Node to be
                *             exchanged.</p>
                */
            ReservedNodeId: string | undefined;
            /**
                * <p>The unique identifier of the DC2 Reserved Node offering to be used for the exchange.
                *             You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a>
                *          </p>
                */
            TargetReservedNodeOfferingId: string | undefined;
    }
    export namespace AcceptReservedNodeExchangeInputMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AcceptReservedNodeExchangeInputMessage) => any;
    }
    /**
        * <p>Describes a recurring charge.</p>
        */
    export interface RecurringCharge {
            /**
                * <p>The amount charged per the period of time specified by the recurring charge
                *             frequency.</p>
                */
            RecurringChargeAmount?: number;
            /**
                * <p>The frequency at which the recurring charge amount is applied.</p>
                */
            RecurringChargeFrequency?: string;
    }
    export namespace RecurringCharge {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RecurringCharge) => any;
    }
    export type ReservedNodeOfferingType = "Regular" | "Upgradable";
    /**
        * <p>Describes a reserved node. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node
        *             offerings. </p>
        */
    export interface ReservedNode {
            /**
                * <p>The unique identifier for the reservation.</p>
                */
            ReservedNodeId?: string;
            /**
                * <p>The identifier for the reserved node offering.</p>
                */
            ReservedNodeOfferingId?: string;
            /**
                * <p>The node type of the reserved node.</p>
                */
            NodeType?: string;
            /**
                * <p>The time the reservation started. You purchase a reserved node offering for a
                *             duration. This is the start time of that duration.</p>
                */
            StartTime?: Date;
            /**
                * <p>The duration of the node reservation in seconds.</p>
                */
            Duration?: number;
            /**
                * <p>The fixed cost Amazon Redshift charges you for this reserved node.</p>
                */
            FixedPrice?: number;
            /**
                * <p>The hourly rate Amazon Redshift charges you for this reserved node.</p>
                */
            UsagePrice?: number;
            /**
                * <p>The currency code for the reserved cluster.</p>
                */
            CurrencyCode?: string;
            /**
                * <p>The number of reserved compute nodes.</p>
                */
            NodeCount?: number;
            /**
                * <p>The state of the reserved compute node.</p>
                *         <p>Possible Values:</p>
                *         <ul>
                *             <li>
                *                 <p>pending-payment-This reserved node has recently been purchased, and the
                *                     sale has been approved, but payment has not yet been confirmed.</p>
                *             </li>
                *             <li>
                *                 <p>active-This reserved node is owned by the caller and is available for
                *                     use.</p>
                *             </li>
                *             <li>
                *                 <p>payment-failed-Payment failed for the purchase attempt.</p>
                *             </li>
                *             <li>
                *                 <p>retired-The reserved node is no longer available. </p>
                *             </li>
                *             <li>
                *                 <p>exchanging-The owner is exchanging the reserved node for another reserved
                *                     node.</p>
                *             </li>
                *          </ul>
                */
            State?: string;
            /**
                * <p>The anticipated utilization of the reserved node, as defined in the reserved node
                *             offering.</p>
                */
            OfferingType?: string;
            /**
                * <p>The recurring charges for the reserved node.</p>
                */
            RecurringCharges?: RecurringCharge[];
            /**
                * <p></p>
                */
            ReservedNodeOfferingType?: ReservedNodeOfferingType | string;
    }
    export namespace ReservedNode {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReservedNode) => any;
    }
    export interface AcceptReservedNodeExchangeOutputMessage {
            /**
                * <p></p>
                */
            ExchangedReservedNode?: ReservedNode;
    }
    export namespace AcceptReservedNodeExchangeOutputMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AcceptReservedNodeExchangeOutputMessage) => any;
    }
    /**
        * <p>Your request cannot be completed because a dependent internal service is
        *             temporarily unavailable. Wait 30 to 60 seconds and try again.</p>
        */
    export class DependentServiceUnavailableFault extends __BaseException {
            readonly name: "DependentServiceUnavailableFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DependentServiceUnavailableFault, __BaseException>);
    }
    /**
        * <p>Indicates that the Reserved Node being exchanged is not in an active state.</p>
        */
    export class InvalidReservedNodeStateFault extends __BaseException {
            readonly name: "InvalidReservedNodeStateFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidReservedNodeStateFault, __BaseException>);
    }
    /**
        * <p>User already has a reservation with the given identifier.</p>
        */
    export class ReservedNodeAlreadyExistsFault extends __BaseException {
            readonly name: "ReservedNodeAlreadyExistsFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ReservedNodeAlreadyExistsFault, __BaseException>);
    }
    /**
        * <p>Indicates that the reserved node has already been exchanged.</p>
        */
    export class ReservedNodeAlreadyMigratedFault extends __BaseException {
            readonly name: "ReservedNodeAlreadyMigratedFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ReservedNodeAlreadyMigratedFault, __BaseException>);
    }
    /**
        * <p>The specified reserved compute node not found.</p>
        */
    export class ReservedNodeNotFoundFault extends __BaseException {
            readonly name: "ReservedNodeNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ReservedNodeNotFoundFault, __BaseException>);
    }
    /**
        * <p>Specified offering does not exist.</p>
        */
    export class ReservedNodeOfferingNotFoundFault extends __BaseException {
            readonly name: "ReservedNodeOfferingNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ReservedNodeOfferingNotFoundFault, __BaseException>);
    }
    /**
        * <p>The requested operation isn't supported.</p>
        */
    export class UnsupportedOperationFault extends __BaseException {
            readonly name: "UnsupportedOperationFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UnsupportedOperationFault, __BaseException>);
    }
    /**
        * <p>You are not authorized to access the cluster.</p>
        */
    export class AccessToClusterDeniedFault extends __BaseException {
            readonly name: "AccessToClusterDeniedFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AccessToClusterDeniedFault, __BaseException>);
    }
    /**
        * <p>The owner of the specified snapshot has not authorized your account to access the
        *             snapshot.</p>
        */
    export class AccessToSnapshotDeniedFault extends __BaseException {
            readonly name: "AccessToSnapshotDeniedFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AccessToSnapshotDeniedFault, __BaseException>);
    }
    /**
        * <p>Describes an attribute value.</p>
        */
    export interface AttributeValueTarget {
            /**
                * <p>The value of the attribute.</p>
                */
            AttributeValue?: string;
    }
    export namespace AttributeValueTarget {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AttributeValueTarget) => any;
    }
    /**
        * <p>A name value pair that describes an aspect of an account. </p>
        */
    export interface AccountAttribute {
            /**
                * <p>The name of the attribute.</p>
                */
            AttributeName?: string;
            /**
                * <p>A list of attribute values.</p>
                */
            AttributeValues?: AttributeValueTarget[];
    }
    export namespace AccountAttribute {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AccountAttribute) => any;
    }
    export interface AccountAttributeList {
            /**
                * <p>A list of attributes assigned to an account.</p>
                */
            AccountAttributes?: AccountAttribute[];
    }
    export namespace AccountAttributeList {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AccountAttributeList) => any;
    }
    /**
        * <p>Describes an Amazon Web Services account authorized to restore a snapshot.</p>
        */
    export interface AccountWithRestoreAccess {
            /**
                * <p>The identifier of an Amazon Web Services account authorized to restore a
                *             snapshot.</p>
                */
            AccountId?: string;
            /**
                * <p>The identifier of an Amazon Web Services support account authorized to restore a
                *             snapshot. For Amazon Web Services Support, the identifier is <code>amazon-redshift-support</code>. </p>
                */
            AccountAlias?: string;
    }
    export namespace AccountWithRestoreAccess {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AccountWithRestoreAccess) => any;
    }
    export enum ActionType {
            RECOMMEND_NODE_CONFIG = "recommend-node-config",
            RESIZE_CLUSTER = "resize-cluster",
            RESTORE_CLUSTER = "restore-cluster"
    }
    /**
        * <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster.
        *         </p>
        */
    export class ClusterNotFoundFault extends __BaseException {
            readonly name: "ClusterNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClusterNotFoundFault, __BaseException>);
    }
    export interface PartnerIntegrationInputMessage {
            /**
                * <p>The Amazon Web Services account ID that owns the cluster.</p>
                */
            AccountId: string | undefined;
            /**
                * <p>The cluster identifier of the cluster that receives data from the partner.</p>
                */
            ClusterIdentifier: string | undefined;
            /**
                * <p>The name of the database that receives data from the partner.</p>
                */
            DatabaseName: string | undefined;
            /**
                * <p>The name of the partner that is authorized to send data.</p>
                */
            PartnerName: string | undefined;
    }
    export namespace PartnerIntegrationInputMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PartnerIntegrationInputMessage) => any;
    }
    export interface PartnerIntegrationOutputMessage {
            /**
                * <p>The name of the database that receives data from the partner.</p>
                */
            DatabaseName?: string;
            /**
                * <p>The name of the partner that is authorized to send data.</p>
                */
            PartnerName?: string;
    }
    export namespace PartnerIntegrationOutputMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PartnerIntegrationOutputMessage) => any;
    }
    /**
        * <p>The name of the partner was not found.</p>
        */
    export class PartnerNotFoundFault extends __BaseException {
            readonly name: "PartnerNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<PartnerNotFoundFault, __BaseException>);
    }
    /**
        * <p>The partner integration is not authorized.</p>
        */
    export class UnauthorizedPartnerIntegrationFault extends __BaseException {
            readonly name: "UnauthorizedPartnerIntegrationFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UnauthorizedPartnerIntegrationFault, __BaseException>);
    }
    export enum AquaConfigurationStatus {
            AUTO = "auto",
            DISABLED = "disabled",
            ENABLED = "enabled"
    }
    export enum AquaStatus {
            APPLYING = "applying",
            DISABLED = "disabled",
            ENABLED = "enabled"
    }
    /**
        * <p>The AQUA (Advanced Query Accelerator) configuration of the cluster.</p>
        */
    export interface AquaConfiguration {
            /**
                * <p>The value indicates the status of AQUA on the cluster. Possible values include the following.</p>
                *         <ul>
                *             <li>
                *                <p>enabled - AQUA is enabled.</p>
                *             </li>
                *             <li>
                *                <p>disabled - AQUA is not enabled. </p>
                *             </li>
                *             <li>
                *                <p>applying - AQUA status is being applied. </p>
                *             </li>
                *          </ul>
                */
            AquaStatus?: AquaStatus | string;
            /**
                * <p>The value represents how the cluster is configured to use AQUA. Possible values include the following.</p>
                *         <ul>
                *             <li>
                *                <p>enabled - Use AQUA if it is available for the current Amazon Web Services Region and Amazon Redshift node type.</p>
                *             </li>
                *             <li>
                *                <p>disabled - Don't use AQUA. </p>
                *             </li>
                *             <li>
                *                <p>auto - Amazon Redshift determines whether to use AQUA.</p>
                *             </li>
                *          </ul>
                */
            AquaConfigurationStatus?: AquaConfigurationStatus | string;
    }
    export namespace AquaConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AquaConfiguration) => any;
    }
    export interface AssociateDataShareConsumerMessage {
            /**
                * <p>The Amazon Resource Name (ARN) of the datashare that the consumer is to use with the account or the namespace.</p>
                */
            DataShareArn: string | undefined;
            /**
                * <p>A value that specifies whether the datashare is associated with the entire account.</p>
                */
            AssociateEntireAccount?: boolean;
            /**
                * <p>The Amazon Resource Name (ARN) of the consumer that is associated with the
                *             datashare.</p>
                */
            ConsumerArn?: string;
            /**
                * <p>From a datashare consumer account, associates a datashare with all existing and future namespaces in the specified Amazon Web Services Region.</p>
                */
            ConsumerRegion?: string;
    }
    export namespace AssociateDataShareConsumerMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AssociateDataShareConsumerMessage) => any;
    }
    export enum DataShareStatus {
            ACTIVE = "ACTIVE",
            AUTHORIZED = "AUTHORIZED",
            AVAILABLE = "AVAILABLE",
            DEAUTHORIZED = "DEAUTHORIZED",
            PENDING_AUTHORIZATION = "PENDING_AUTHORIZATION",
            REJECTED = "REJECTED"
    }
    /**
        * <p>The association of a datashare from a producer account with a data consumer.
        * </p>
        */
    export interface DataShareAssociation {
            /**
                * <p>The name of the consumer accounts that have an association with a producer
                *             datashare.</p>
                */
            ConsumerIdentifier?: string;
            /**
                * <p>The status of the datashare that is associated.</p>
                */
            Status?: DataShareStatus | string;
            /**
                * <p>The Amazon Web Services Region of the consumer accounts that have an association with a producer datashare.</p>
                */
            ConsumerRegion?: string;
            /**
                * <p>The creation date of the datashare that is associated.</p>
                */
            CreatedDate?: Date;
            /**
                * <p>The status change data of the datashare that is associated.</p>
                */
            StatusChangeDate?: Date;
    }
    export namespace DataShareAssociation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DataShareAssociation) => any;
    }
    export interface DataShare {
            /**
                * <p>An Amazon Resource Name (ARN) that references the datashare that is owned by a specific namespace of the producer cluster. A datashare ARN is in the <code>arn:aws:redshift:{region}:{account-id}:{datashare}:{namespace-guid}/{datashare-name}</code> format.</p>
                */
            DataShareArn?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the producer.</p>
                */
            ProducerArn?: string;
            /**
                * <p>A value that specifies whether the datashare can be shared to a publicly accessible  cluster.</p>
                */
            AllowPubliclyAccessibleConsumers?: boolean;
            /**
                * <p>A value that specifies when the datashare has an association between producer and data
                *             consumers.</p>
                */
            DataShareAssociations?: DataShareAssociation[];
            /**
                * <p>The identifier of a datashare to show its managing entity.</p>
                */
            ManagedBy?: string;
    }
    export namespace DataShare {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DataShare) => any;
    }
    /**
        * <p>There is an error with the datashare.</p>
        */
    export class InvalidDataShareFault extends __BaseException {
            readonly name: "InvalidDataShareFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidDataShareFault, __BaseException>);
    }
    /**
        * <p>The namespace isn't valid because the namespace doesn't exist. Provide a valid namespace.</p>
        */
    export class InvalidNamespaceFault extends __BaseException {
            readonly name: "InvalidNamespaceFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidNamespaceFault, __BaseException>);
    }
    export type ScheduleState = "ACTIVE" | "FAILED" | "MODIFYING";
    /**
        * <p></p>
        */
    export interface ClusterAssociatedToSchedule {
            /**
                * <p></p>
                */
            ClusterIdentifier?: string;
            /**
                * <p></p>
                */
            ScheduleAssociationState?: ScheduleState | string;
    }
    export namespace ClusterAssociatedToSchedule {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterAssociatedToSchedule) => any;
    }
    /**
        * <p>Describes an authentication profile.</p>
        */
    export interface AuthenticationProfile {
            /**
                * <p>The name of the authentication profile.</p>
                */
            AuthenticationProfileName?: string;
            /**
                * <p>The content of the authentication profile in JSON format.
                *             The maximum length of the JSON string is determined by a quota for your account.</p>
                */
            AuthenticationProfileContent?: string;
    }
    export namespace AuthenticationProfile {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AuthenticationProfile) => any;
    }
    /**
        * <p>The authentication profile already exists.</p>
        */
    export class AuthenticationProfileAlreadyExistsFault extends __BaseException {
            readonly name: "AuthenticationProfileAlreadyExistsFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AuthenticationProfileAlreadyExistsFault, __BaseException>);
    }
    /**
        * <p>The authentication profile can't be found.</p>
        */
    export class AuthenticationProfileNotFoundFault extends __BaseException {
            readonly name: "AuthenticationProfileNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AuthenticationProfileNotFoundFault, __BaseException>);
    }
    /**
        * <p>The size or number of authentication profiles has exceeded the quota.
        *             The maximum length of the JSON string and maximum number of authentication profiles is determined by a quota for your account.</p>
        */
    export class AuthenticationProfileQuotaExceededFault extends __BaseException {
            readonly name: "AuthenticationProfileQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AuthenticationProfileQuotaExceededFault, __BaseException>);
    }
    /**
        * <p>The specified CIDR block or EC2 security group is already authorized for the
        *             specified cluster security group.</p>
        */
    export class AuthorizationAlreadyExistsFault extends __BaseException {
            readonly name: "AuthorizationAlreadyExistsFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AuthorizationAlreadyExistsFault, __BaseException>);
    }
    /**
        * <p>The specified CIDR IP range or EC2 security group is not authorized for the
        *             specified cluster security group.</p>
        */
    export class AuthorizationNotFoundFault extends __BaseException {
            readonly name: "AuthorizationNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AuthorizationNotFoundFault, __BaseException>);
    }
    /**
        * <p>The authorization quota for the cluster security group has been reached.</p>
        */
    export class AuthorizationQuotaExceededFault extends __BaseException {
            readonly name: "AuthorizationQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AuthorizationQuotaExceededFault, __BaseException>);
    }
    export enum AuthorizationStatus {
            AUTHORIZED = "Authorized",
            REVOKING = "Revoking"
    }
    /**
        * <p></p>
        */
    export interface AuthorizeClusterSecurityGroupIngressMessage {
            /**
                * <p>The name of the security group to which the ingress rule is added.</p>
                */
            ClusterSecurityGroupName: string | undefined;
            /**
                * <p>The IP range to be added the Amazon Redshift security group.</p>
                */
            CIDRIP?: string;
            /**
                * <p>The EC2 security group to be added the Amazon Redshift security group.</p>
                */
            EC2SecurityGroupName?: string;
            /**
                * <p>The Amazon Web Services account number of the owner of the security group specified by the
                *             <i>EC2SecurityGroupName</i> parameter. The Amazon Web Services Access Key ID is not an
                *             acceptable value. </p>
                *         <p>Example: <code>111122223333</code>
                *         </p>
                */
            EC2SecurityGroupOwnerId?: string;
    }
    export namespace AuthorizeClusterSecurityGroupIngressMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AuthorizeClusterSecurityGroupIngressMessage) => any;
    }
    /**
        * <p>A tag consisting of a name/value pair for a resource.</p>
        */
    export interface Tag {
            /**
                * <p>The key, or name, for the resource tag.</p>
                */
            Key?: string;
            /**
                * <p>The value for the resource tag.</p>
                */
            Value?: string;
    }
    export namespace Tag {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Tag) => any;
    }
    /**
        * <p>Describes an Amazon EC2 security group.</p>
        */
    export interface EC2SecurityGroup {
            /**
                * <p>The status of the EC2 security group.</p>
                */
            Status?: string;
            /**
                * <p>The name of the EC2 Security Group.</p>
                */
            EC2SecurityGroupName?: string;
            /**
                * <p>The Amazon Web Services account ID of the owner of the EC2 security group specified in the
                *                 <code>EC2SecurityGroupName</code> field. </p>
                */
            EC2SecurityGroupOwnerId?: string;
            /**
                * <p>The list of tags for the EC2 security group.</p>
                */
            Tags?: Tag[];
    }
    export namespace EC2SecurityGroup {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EC2SecurityGroup) => any;
    }
    /**
        * <p>Describes an IP range used in a security group.</p>
        */
    export interface IPRange {
            /**
                * <p>The status of the IP range, for example, "authorized".</p>
                */
            Status?: string;
            /**
                * <p>The IP range in Classless Inter-Domain Routing (CIDR) notation.</p>
                */
            CIDRIP?: string;
            /**
                * <p>The list of tags for the IP range.</p>
                */
            Tags?: Tag[];
    }
    export namespace IPRange {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: IPRange) => any;
    }
    /**
        * <p>Describes a security group.</p>
        */
    export interface ClusterSecurityGroup {
            /**
                * <p>The name of the cluster security group to which the operation was
                *             applied.</p>
                */
            ClusterSecurityGroupName?: string;
            /**
                * <p>A description of the security group.</p>
                */
            Description?: string;
            /**
                * <p>A list of EC2 security groups that are permitted to access clusters associated with
                *             this cluster security group.</p>
                */
            EC2SecurityGroups?: EC2SecurityGroup[];
            /**
                * <p>A list of IP ranges (CIDR blocks) that are permitted to access clusters associated
                *             with this cluster security group.</p>
                */
            IPRanges?: IPRange[];
            /**
                * <p>The list of tags for the cluster security group.</p>
                */
            Tags?: Tag[];
    }
    export namespace ClusterSecurityGroup {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterSecurityGroup) => any;
    }
    export interface AuthorizeClusterSecurityGroupIngressResult {
            /**
                * <p>Describes a security group.</p>
                */
            ClusterSecurityGroup?: ClusterSecurityGroup;
    }
    export namespace AuthorizeClusterSecurityGroupIngressResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AuthorizeClusterSecurityGroupIngressResult) => any;
    }
    /**
        * <p>The cluster security group name does not refer to an existing cluster security
        *             group.</p>
        */
    export class ClusterSecurityGroupNotFoundFault extends __BaseException {
            readonly name: "ClusterSecurityGroupNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClusterSecurityGroupNotFoundFault, __BaseException>);
    }
    /**
        * <p>The state of the cluster security group is not <code>available</code>. </p>
        */
    export class InvalidClusterSecurityGroupStateFault extends __BaseException {
            readonly name: "InvalidClusterSecurityGroupStateFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidClusterSecurityGroupStateFault, __BaseException>);
    }
    export interface AuthorizeDataShareMessage {
            /**
                * <p>The Amazon Resource Name (ARN) of the datashare that producers are to authorize
                *             sharing for.</p>
                */
            DataShareArn: string | undefined;
            /**
                * <p>The identifier of the data consumer that is authorized to access the datashare. This identifier is an Amazon Web Services account ID or a keyword, such as ADX.</p>
                */
            ConsumerIdentifier: string | undefined;
    }
    export namespace AuthorizeDataShareMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AuthorizeDataShareMessage) => any;
    }
    export interface AuthorizeEndpointAccessMessage {
            /**
                * <p>The cluster identifier of the cluster to grant access to.</p>
                */
            ClusterIdentifier?: string;
            /**
                * <p>The Amazon Web Services account ID to grant access to.</p>
                */
            Account: string | undefined;
            /**
                * <p>The virtual private cloud (VPC) identifiers to grant access to.</p>
                */
            VpcIds?: string[];
    }
    export namespace AuthorizeEndpointAccessMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AuthorizeEndpointAccessMessage) => any;
    }
    /**
        * <p>Describes an endpoint authorization for authorizing Redshift-managed VPC endpoint access to a cluster across Amazon Web Services accounts.</p>
        */
    export interface EndpointAuthorization {
            /**
                * <p>The Amazon Web Services account ID of the cluster owner.</p>
                */
            Grantor?: string;
            /**
                * <p>The Amazon Web Services account ID of the grantee of the cluster.</p>
                */
            Grantee?: string;
            /**
                * <p>The cluster identifier.</p>
                */
            ClusterIdentifier?: string;
            /**
                * <p>The time (UTC) when the authorization was created.</p>
                */
            AuthorizeTime?: Date;
            /**
                * <p>The status of the cluster.</p>
                */
            ClusterStatus?: string;
            /**
                * <p>The status of the authorization action.</p>
                */
            Status?: AuthorizationStatus | string;
            /**
                * <p>Indicates whether all VPCs in the grantee account are allowed access to the cluster.</p>
                */
            AllowedAllVPCs?: boolean;
            /**
                * <p>The VPCs allowed access to the cluster.</p>
                */
            AllowedVPCs?: string[];
            /**
                * <p>The number of Redshift-managed VPC endpoints created for the authorization.</p>
                */
            EndpointCount?: number;
    }
    export namespace EndpointAuthorization {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EndpointAuthorization) => any;
    }
    /**
        * <p>The authorization already exists for this endpoint.</p>
        */
    export class EndpointAuthorizationAlreadyExistsFault extends __BaseException {
            readonly name: "EndpointAuthorizationAlreadyExistsFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<EndpointAuthorizationAlreadyExistsFault, __BaseException>);
    }
    /**
        * <p>The number of endpoint authorizations per cluster has exceeded its limit.</p>
        */
    export class EndpointAuthorizationsPerClusterLimitExceededFault extends __BaseException {
            readonly name: "EndpointAuthorizationsPerClusterLimitExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<EndpointAuthorizationsPerClusterLimitExceededFault, __BaseException>);
    }
    /**
        * <p>The status of the authorization is not valid.</p>
        */
    export class InvalidAuthorizationStateFault extends __BaseException {
            readonly name: "InvalidAuthorizationStateFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidAuthorizationStateFault, __BaseException>);
    }
    /**
        * <p>The specified cluster is not in the <code>available</code> state. </p>
        */
    export class InvalidClusterStateFault extends __BaseException {
            readonly name: "InvalidClusterStateFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidClusterStateFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export interface AuthorizeSnapshotAccessMessage {
            /**
                * <p>The identifier of the snapshot the account is authorized to restore.</p>
                */
            SnapshotIdentifier?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the snapshot to authorize access to.</p>
                */
            SnapshotArn?: string;
            /**
                * <p>The identifier of the cluster the snapshot was created from. This parameter is
                *             required if your IAM user has a policy containing a snapshot resource element that
                *             specifies anything other than * for the cluster name.</p>
                */
            SnapshotClusterIdentifier?: string;
            /**
                * <p>The identifier of the Amazon Web Services account authorized to restore the specified
                *             snapshot.</p>
                *         <p>To share a snapshot with Amazon Web Services Support, specify amazon-redshift-support.</p>
                */
            AccountWithRestoreAccess: string | undefined;
    }
    export namespace AuthorizeSnapshotAccessMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AuthorizeSnapshotAccessMessage) => any;
    }
    /**
        * <p>Describes a snapshot.</p>
        */
    export interface Snapshot {
            /**
                * <p>The snapshot identifier that is provided in the request.</p>
                */
            SnapshotIdentifier?: string;
            /**
                * <p>The identifier of the cluster for which the snapshot was taken.</p>
                */
            ClusterIdentifier?: string;
            /**
                * <p>The time (in UTC format) when Amazon Redshift began the snapshot. A snapshot contains a
                *             copy of the cluster data as of this exact time.</p>
                */
            SnapshotCreateTime?: Date;
            /**
                * <p>The snapshot status. The value of the status depends on the API operation used: </p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <a>CreateClusterSnapshot</a> and <a>CopyClusterSnapshot</a> returns status as "creating". </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <a>DescribeClusterSnapshots</a> returns status as "creating",
                *                     "available", "final snapshot", or "failed".</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <a>DeleteClusterSnapshot</a> returns status as "deleted".</p>
                *             </li>
                *          </ul>
                */
            Status?: string;
            /**
                * <p>The port that the cluster is listening on.</p>
                */
            Port?: number;
            /**
                * <p>The Availability Zone in which the cluster was created.</p>
                */
            AvailabilityZone?: string;
            /**
                * <p>The time (UTC) when the cluster was originally created.</p>
                */
            ClusterCreateTime?: Date;
            /**
                * <p>The admin user name for the cluster.</p>
                */
            MasterUsername?: string;
            /**
                * <p>The version ID of the Amazon Redshift engine that is running on the cluster.</p>
                */
            ClusterVersion?: string;
            /**
                * <p>The cluster version of the cluster used to create the snapshot. For example, 1.0.15503. </p>
                */
            EngineFullVersion?: string;
            /**
                * <p>The snapshot type. Snapshots created using <a>CreateClusterSnapshot</a>
                *             and <a>CopyClusterSnapshot</a> are of type "manual". </p>
                */
            SnapshotType?: string;
            /**
                * <p>The node type of the nodes in the cluster.</p>
                */
            NodeType?: string;
            /**
                * <p>The number of nodes in the cluster.</p>
                */
            NumberOfNodes?: number;
            /**
                * <p>The name of the database that was created when the cluster was created.</p>
                */
            DBName?: string;
            /**
                * <p>The VPC identifier of the cluster if the snapshot is from a cluster in a VPC.
                *             Otherwise, this field is not in the output.</p>
                */
            VpcId?: string;
            /**
                * <p>If <code>true</code>, the data in the snapshot is encrypted at rest.</p>
                */
            Encrypted?: boolean;
            /**
                * <p>The Key Management Service (KMS) key ID of the encryption key that was used to
                *             encrypt data in the cluster from which the snapshot was taken.</p>
                */
            KmsKeyId?: string;
            /**
                * <p>A boolean that indicates whether the snapshot data is encrypted using the HSM keys
                *             of the source cluster. <code>true</code> indicates that the data is encrypted using HSM
                *             keys.</p>
                */
            EncryptedWithHSM?: boolean;
            /**
                * <p>A list of the Amazon Web Services accounts authorized to restore the snapshot. Returns
                *                 <code>null</code> if no accounts are authorized. Visible only to the snapshot owner.
                *         </p>
                */
            AccountsWithRestoreAccess?: AccountWithRestoreAccess[];
            /**
                * <p>For manual snapshots, the Amazon Web Services account used to create or copy the snapshot.
                *             For automatic snapshots, the owner of the cluster. The owner can perform all snapshot
                *             actions, such as sharing a manual snapshot.</p>
                */
            OwnerAccount?: string;
            /**
                * <p>The size of the complete set of backup data that would be used to restore the
                *             cluster.</p>
                */
            TotalBackupSizeInMegaBytes?: number;
            /**
                * <p>The size of the incremental backup.</p>
                */
            ActualIncrementalBackupSizeInMegaBytes?: number;
            /**
                * <p>The number of megabytes that have been transferred to the snapshot
                *             backup.</p>
                */
            BackupProgressInMegaBytes?: number;
            /**
                * <p>The number of megabytes per second being transferred to the snapshot backup.
                *             Returns <code>0</code> for a completed backup. </p>
                */
            CurrentBackupRateInMegaBytesPerSecond?: number;
            /**
                * <p>The estimate of the time remaining before the snapshot backup will complete.
                *             Returns <code>0</code> for a completed backup. </p>
                */
            EstimatedSecondsToCompletion?: number;
            /**
                * <p>The amount of time an in-progress snapshot backup has been running, or the amount
                *             of time it took a completed backup to finish.</p>
                */
            ElapsedTimeInSeconds?: number;
            /**
                * <p>The source region from which the snapshot was copied.</p>
                */
            SourceRegion?: string;
            /**
                * <p>The list of tags for the cluster snapshot.</p>
                */
            Tags?: Tag[];
            /**
                * <p>The list of node types that this cluster snapshot is able to restore
                *             into.</p>
                */
            RestorableNodeTypes?: string[];
            /**
                * <p>An option that specifies whether to create the cluster with enhanced VPC routing
                *             enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
                *             VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
                *             the Amazon Redshift Cluster Management Guide.</p>
                *         <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
                *         <p>Default: false</p>
                */
            EnhancedVpcRouting?: boolean;
            /**
                * <p>The name of the maintenance track for the snapshot.</p>
                */
            MaintenanceTrackName?: string;
            /**
                * <p>The number of days that a manual snapshot is retained. If the value is -1, the manual
                *             snapshot is retained indefinitely. </p>
                *
                *         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
                */
            ManualSnapshotRetentionPeriod?: number;
            /**
                * <p>The number of days until a manual snapshot will pass its retention period.</p>
                */
            ManualSnapshotRemainingDays?: number;
            /**
                * <p>A timestamp representing the start of the retention period for the snapshot.</p>
                */
            SnapshotRetentionStartTime?: Date;
    }
    export namespace Snapshot {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Snapshot) => any;
    }
    export interface AuthorizeSnapshotAccessResult {
            /**
                * <p>Describes a snapshot.</p>
                */
            Snapshot?: Snapshot;
    }
    export namespace AuthorizeSnapshotAccessResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AuthorizeSnapshotAccessResult) => any;
    }
    /**
        * <p>The snapshot identifier does not refer to an existing cluster snapshot.</p>
        */
    export class ClusterSnapshotNotFoundFault extends __BaseException {
            readonly name: "ClusterSnapshotNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClusterSnapshotNotFoundFault, __BaseException>);
    }
    /**
        * <p>The request cannot be completed because a dependent service is throttling requests
        *             made by Amazon Redshift on your behalf. Wait and retry the request.</p>
        */
    export class DependentServiceRequestThrottlingFault extends __BaseException {
            readonly name: "DependentServiceRequestThrottlingFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DependentServiceRequestThrottlingFault, __BaseException>);
    }
    /**
        * <p>The specified cluster snapshot is not in the <code>available</code> state, or other
        *             accounts are authorized to access the snapshot. </p>
        */
    export class InvalidClusterSnapshotStateFault extends __BaseException {
            readonly name: "InvalidClusterSnapshotStateFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidClusterSnapshotStateFault, __BaseException>);
    }
    /**
        * <p>The encryption key has exceeded its grant limit in Amazon Web Services KMS.</p>
        */
    export class LimitExceededFault extends __BaseException {
            readonly name: "LimitExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<LimitExceededFault, __BaseException>);
    }
    /**
        * <p>A list of supported platforms for orderable clusters.</p>
        */
    export interface SupportedPlatform {
            /**
                * <p></p>
                */
            Name?: string;
    }
    export namespace SupportedPlatform {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SupportedPlatform) => any;
    }
    /**
        * <p>Describes an availability zone.</p>
        */
    export interface AvailabilityZone {
            /**
                * <p>The name of the availability zone.</p>
                */
            Name?: string;
            /**
                * <p></p>
                */
            SupportedPlatforms?: SupportedPlatform[];
    }
    export namespace AvailabilityZone {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AvailabilityZone) => any;
    }
    /**
        * <p></p>
        */
    export interface DeleteClusterSnapshotMessage {
            /**
                * <p>The unique identifier of the manual snapshot to be deleted.</p>
                *         <p>Constraints: Must be the name of an existing snapshot that is in the
                *                 <code>available</code>, <code>failed</code>, or <code>cancelled</code>
                *             state.</p>
                */
            SnapshotIdentifier: string | undefined;
            /**
                * <p>The unique identifier of the cluster the snapshot was created from. This parameter
                *             is required if your IAM user has a policy containing a snapshot resource element that
                *             specifies anything other than * for the cluster name.</p>
                *         <p>Constraints: Must be the name of valid cluster.</p>
                */
            SnapshotClusterIdentifier?: string;
    }
    export namespace DeleteClusterSnapshotMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteClusterSnapshotMessage) => any;
    }
    export interface BatchDeleteClusterSnapshotsRequest {
            /**
                * <p>A list of identifiers for the snapshots that you want to delete.</p>
                */
            Identifiers: DeleteClusterSnapshotMessage[] | undefined;
    }
    export namespace BatchDeleteClusterSnapshotsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchDeleteClusterSnapshotsRequest) => any;
    }
    /**
        * <p>Describes the errors returned by a snapshot.</p>
        */
    export interface SnapshotErrorMessage {
            /**
                * <p>A unique identifier for the snapshot returning the error.</p>
                */
            SnapshotIdentifier?: string;
            /**
                * <p>A unique identifier for the cluster.</p>
                */
            SnapshotClusterIdentifier?: string;
            /**
                * <p>The failure code for the error.</p>
                */
            FailureCode?: string;
            /**
                * <p>The text message describing the error.</p>
                */
            FailureReason?: string;
    }
    export namespace SnapshotErrorMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SnapshotErrorMessage) => any;
    }
    export interface BatchDeleteClusterSnapshotsResult {
            /**
                * <p>A list of the snapshot identifiers that were deleted. </p>
                */
            Resources?: string[];
            /**
                * <p>A list of any errors returned.</p>
                */
            Errors?: SnapshotErrorMessage[];
    }
    export namespace BatchDeleteClusterSnapshotsResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchDeleteClusterSnapshotsResult) => any;
    }
    /**
        * <p>The maximum number for a batch delete of snapshots has been reached. The limit is
        *             100. </p>
        */
    export class BatchDeleteRequestSizeExceededFault extends __BaseException {
            readonly name: "BatchDeleteRequestSizeExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<BatchDeleteRequestSizeExceededFault, __BaseException>);
    }
    /**
        * <p>The maximum number for snapshot identifiers has been reached. The limit is 100.
        *         </p>
        */
    export class BatchModifyClusterSnapshotsLimitExceededFault extends __BaseException {
            readonly name: "BatchModifyClusterSnapshotsLimitExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<BatchModifyClusterSnapshotsLimitExceededFault, __BaseException>);
    }
    export interface BatchModifyClusterSnapshotsMessage {
            /**
                * <p>A list of snapshot identifiers you want to modify.</p>
                */
            SnapshotIdentifierList: string[] | undefined;
            /**
                * <p>The number of days that a manual snapshot is retained. If you specify the value -1,
                *             the manual snapshot is retained indefinitely.</p>
                *         <p>The number must be either -1 or an integer between 1 and 3,653.</p>
                *         <p>If you decrease the manual snapshot retention period from its current value, existing
                *             manual snapshots that fall outside of the new retention period will return an error. If
                *             you want to suppress the errors and delete the snapshots, use the force option. </p>
                */
            ManualSnapshotRetentionPeriod?: number;
            /**
                * <p>A boolean value indicating whether to override an exception if the retention period
                *             has passed. </p>
                */
            Force?: boolean;
    }
    export namespace BatchModifyClusterSnapshotsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchModifyClusterSnapshotsMessage) => any;
    }
    export interface BatchModifyClusterSnapshotsOutputMessage {
            /**
                * <p>A list of the snapshots that were modified.</p>
                */
            Resources?: string[];
            /**
                * <p>A list of any errors returned.</p>
                */
            Errors?: SnapshotErrorMessage[];
    }
    export namespace BatchModifyClusterSnapshotsOutputMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchModifyClusterSnapshotsOutputMessage) => any;
    }
    /**
        * <p>The retention period specified is either in the past or is not a valid value.</p>
        *         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
        */
    export class InvalidRetentionPeriodFault extends __BaseException {
            readonly name: "InvalidRetentionPeriodFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidRetentionPeriodFault, __BaseException>);
    }
    /**
        * <p>Could not find the specified S3 bucket.</p>
        */
    export class BucketNotFoundFault extends __BaseException {
            readonly name: "BucketNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<BucketNotFoundFault, __BaseException>);
    }
    export interface CancelResizeMessage {
            /**
                * <p>The unique identifier for the cluster that you want to cancel a resize operation
                *             for.</p>
                */
            ClusterIdentifier: string | undefined;
    }
    export namespace CancelResizeMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CancelResizeMessage) => any;
    }
    /**
        * <p>A resize operation for the specified cluster is not found.</p>
        */
    export class ResizeNotFoundFault extends __BaseException {
            readonly name: "ResizeNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResizeNotFoundFault, __BaseException>);
    }
    /**
        * <p>Describes the result of a cluster resize operation.</p>
        */
    export interface ResizeProgressMessage {
            /**
                * <p>The node type that the cluster will have after the resize operation is
                *             complete.</p>
                */
            TargetNodeType?: string;
            /**
                * <p>The number of nodes that the cluster will have after the resize operation is
                *             complete.</p>
                */
            TargetNumberOfNodes?: number;
            /**
                * <p>The cluster type after the resize operation is complete.</p>
                *         <p>Valid Values: <code>multi-node</code> | <code>single-node</code>
                *         </p>
                */
            TargetClusterType?: string;
            /**
                * <p>The status of the resize operation.</p>
                *         <p>Valid Values: <code>NONE</code> | <code>IN_PROGRESS</code> | <code>FAILED</code> |
                *                 <code>SUCCEEDED</code> | <code>CANCELLING</code>
                *         </p>
                */
            Status?: string;
            /**
                * <p>The names of tables that have been completely imported .</p>
                *         <p>Valid Values: List of table names.</p>
                */
            ImportTablesCompleted?: string[];
            /**
                * <p>The names of tables that are being currently imported.</p>
                *         <p>Valid Values: List of table names.</p>
                */
            ImportTablesInProgress?: string[];
            /**
                * <p>The names of tables that have not been yet imported.</p>
                *         <p>Valid Values: List of table names</p>
                */
            ImportTablesNotStarted?: string[];
            /**
                * <p>The average rate of the resize operation over the last few minutes, measured in
                *             megabytes per second. After the resize operation completes, this value shows the average
                *             rate of the entire resize operation.</p>
                */
            AvgResizeRateInMegaBytesPerSecond?: number;
            /**
                * <p>The estimated total amount of data, in megabytes, on the cluster before the resize
                *             operation began.</p>
                */
            TotalResizeDataInMegaBytes?: number;
            /**
                * <p>While the resize operation is in progress, this value shows the current amount of
                *             data, in megabytes, that has been processed so far. When the resize operation is
                *             complete, this value shows the total amount of data, in megabytes, on the cluster, which
                *             may be more or less than TotalResizeDataInMegaBytes (the estimated total amount of data
                *             before resize).</p>
                */
            ProgressInMegaBytes?: number;
            /**
                * <p>The amount of seconds that have elapsed since the resize operation began. After the
                *             resize operation completes, this value shows the total actual time, in seconds, for the
                *             resize operation.</p>
                */
            ElapsedTimeInSeconds?: number;
            /**
                * <p>The estimated time remaining, in seconds, until the resize operation is complete.
                *             This value is calculated based on the average resize rate and the estimated amount of
                *             data remaining to be processed. Once the resize operation is complete, this value will
                *             be 0.</p>
                */
            EstimatedTimeToCompletionInSeconds?: number;
            /**
                * <p>An enum with possible values of <code>ClassicResize</code> and
                *                 <code>ElasticResize</code>. These values describe the type of resize operation being
                *             performed. </p>
                */
            ResizeType?: string;
            /**
                * <p>An optional string to provide additional details about the resize action.</p>
                */
            Message?: string;
            /**
                * <p>The type of encryption for the cluster after the resize is complete.</p>
                *         <p>Possible values are <code>KMS</code> and <code>None</code>. </p>
                */
            TargetEncryptionType?: string;
            /**
                * <p>The percent of data transferred from source cluster to target cluster.</p>
                */
            DataTransferProgressPercent?: number;
    }
    export namespace ResizeProgressMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResizeProgressMessage) => any;
    }
    /**
        * <p>The identifier of a node in a cluster.</p>
        */
    export interface ClusterNode {
            /**
                * <p>Whether the node is a leader node or a compute node.</p>
                */
            NodeRole?: string;
            /**
                * <p>The private IP address of a node within a cluster.</p>
                */
            PrivateIPAddress?: string;
            /**
                * <p>The public IP address of a node within a cluster.</p>
                */
            PublicIPAddress?: string;
    }
    export namespace ClusterNode {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterNode) => any;
    }
    /**
        * <p>Describes the status of a parameter group.</p>
        */
    export interface ClusterParameterStatus {
            /**
                * <p>The name of the parameter.</p>
                */
            ParameterName?: string;
            /**
                * <p>The status of the parameter that indicates whether the parameter is in sync with
                *             the database, waiting for a cluster reboot, or encountered an error when being
                *             applied.</p>
                *         <p>The following are possible statuses and descriptions.</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>in-sync</code>: The parameter value is in sync with the
                *                     database.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>pending-reboot</code>: The parameter value will be applied after the
                *                     cluster reboots.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>applying</code>: The parameter value is being applied to the
                *                     database.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>invalid-parameter</code>: Cannot apply the parameter value because it has
                *                     an invalid value or syntax.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>apply-deferred</code>: The parameter contains static property changes. The
                *                     changes are deferred until the cluster reboots.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>apply-error</code>: Cannot connect to the cluster. The parameter change
                *                     will be applied after the cluster reboots.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>unknown-error</code>: Cannot apply the parameter change right now. The
                *                     change will be applied after the cluster reboots.</p>
                *             </li>
                *          </ul>
                */
            ParameterApplyStatus?: string;
            /**
                * <p>The error that prevented the parameter from being applied to the
                *             database.</p>
                */
            ParameterApplyErrorDescription?: string;
    }
    export namespace ClusterParameterStatus {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterParameterStatus) => any;
    }
    /**
        * <p>Describes the status of a parameter group.</p>
        */
    export interface ClusterParameterGroupStatus {
            /**
                * <p>The name of the cluster parameter group.</p>
                */
            ParameterGroupName?: string;
            /**
                * <p>The status of parameter updates.</p>
                */
            ParameterApplyStatus?: string;
            /**
                * <p>The list of parameter statuses.</p>
                *         <p>
                * For more information about parameters and parameter groups, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            ClusterParameterStatusList?: ClusterParameterStatus[];
    }
    export namespace ClusterParameterGroupStatus {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterParameterGroupStatus) => any;
    }
    /**
        * <p>Describes a cluster security group.</p>
        */
    export interface ClusterSecurityGroupMembership {
            /**
                * <p>The name of the cluster security group.</p>
                */
            ClusterSecurityGroupName?: string;
            /**
                * <p>The status of the cluster security group.</p>
                */
            Status?: string;
    }
    export namespace ClusterSecurityGroupMembership {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterSecurityGroupMembership) => any;
    }
    /**
        * <p>Returns the destination region and retention period that are configured for
        *             cross-region snapshot copy.</p>
        */
    export interface ClusterSnapshotCopyStatus {
            /**
                * <p>The destination region that snapshots are automatically copied to when cross-region
                *             snapshot copy is enabled.</p>
                */
            DestinationRegion?: string;
            /**
                * <p>The number of days that automated snapshots are retained in the destination region
                *             after they are copied from a source region.</p>
                */
            RetentionPeriod?: number;
            /**
                * <p>The number of days that automated snapshots are retained in the destination region
                *             after they are copied from a source region. If the value is -1, the manual snapshot is
                *             retained indefinitely. </p>
                *         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
                */
            ManualSnapshotRetentionPeriod?: number;
            /**
                * <p>The name of the snapshot copy grant.</p>
                */
            SnapshotCopyGrantName?: string;
    }
    export namespace ClusterSnapshotCopyStatus {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterSnapshotCopyStatus) => any;
    }
    /**
        * <p>Describes the status of a cluster while it is in the process of resizing with an
        *             incremental resize.</p>
        */
    export interface DataTransferProgress {
            /**
                * <p>Describes the status of the cluster. While the transfer is in progress the status is
                *                 <code>transferringdata</code>.</p>
                */
            Status?: string;
            /**
                * <p>Describes the data transfer rate in MB's per second.</p>
                */
            CurrentRateInMegaBytesPerSecond?: number;
            /**
                * <p>Describes the total amount of data to be transfered in megabytes.</p>
                */
            TotalDataInMegaBytes?: number;
            /**
                * <p>Describes the total amount of data that has been transfered in MB's.</p>
                */
            DataTransferredInMegaBytes?: number;
            /**
                * <p>Describes the estimated number of seconds remaining to complete the transfer.</p>
                */
            EstimatedTimeToCompletionInSeconds?: number;
            /**
                * <p>Describes the number of seconds that have elapsed during the data transfer.</p>
                */
            ElapsedTimeInSeconds?: number;
    }
    export namespace DataTransferProgress {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DataTransferProgress) => any;
    }
    /**
        * <p>Describes a deferred maintenance window</p>
        */
    export interface DeferredMaintenanceWindow {
            /**
                * <p>A unique identifier for the maintenance window.</p>
                */
            DeferMaintenanceIdentifier?: string;
            /**
                * <p> A timestamp for the beginning of the time period when we defer maintenance.</p>
                */
            DeferMaintenanceStartTime?: Date;
            /**
                * <p> A timestamp for the end of the time period when we defer maintenance.</p>
                */
            DeferMaintenanceEndTime?: Date;
    }
    export namespace DeferredMaintenanceWindow {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeferredMaintenanceWindow) => any;
    }
    /**
        * <p>Describes the status of the elastic IP (EIP) address.</p>
        */
    export interface ElasticIpStatus {
            /**
                * <p>The elastic IP (EIP) address for the cluster.</p>
                */
            ElasticIp?: string;
            /**
                * <p>The status of the elastic IP (EIP) address.</p>
                */
            Status?: string;
    }
    export namespace ElasticIpStatus {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ElasticIpStatus) => any;
    }
    /**
        * <p>Describes a network interface. </p>
        */
    export interface NetworkInterface {
            /**
                * <p>The network interface identifier. </p>
                */
            NetworkInterfaceId?: string;
            /**
                * <p>The subnet identifier. </p>
                */
            SubnetId?: string;
            /**
                * <p>The IPv4 address of the network interface within the subnet. </p>
                */
            PrivateIpAddress?: string;
            /**
                * <p>The Availability Zone. </p>
                */
            AvailabilityZone?: string;
    }
    export namespace NetworkInterface {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: NetworkInterface) => any;
    }
    /**
        * <p>The connection endpoint for connecting to an Amazon Redshift cluster through the proxy.</p>
        */
    export interface VpcEndpoint {
            /**
                * <p>The connection endpoint ID for connecting an Amazon Redshift cluster through the proxy.</p>
                */
            VpcEndpointId?: string;
            /**
                * <p>The VPC identifier that the endpoint is associated. </p>
                */
            VpcId?: string;
            /**
                * <p>One or more network interfaces of the endpoint. Also known as an interface endpoint. </p>
                */
            NetworkInterfaces?: NetworkInterface[];
    }
    export namespace VpcEndpoint {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: VpcEndpoint) => any;
    }
    /**
        * <p>Describes a connection endpoint.</p>
        */
    export interface Endpoint {
            /**
                * <p>The DNS address of the Cluster.</p>
                */
            Address?: string;
            /**
                * <p>The port that the database engine is listening on.</p>
                */
            Port?: number;
            /**
                * <p>Describes a connection endpoint.</p>
                */
            VpcEndpoints?: VpcEndpoint[];
    }
    export namespace Endpoint {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Endpoint) => any;
    }
    /**
        * <p>Describes the status of changes to HSM settings.</p>
        */
    export interface HsmStatus {
            /**
                * <p>Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to
                *             retrieve the data encryption keys stored in an HSM.</p>
                */
            HsmClientCertificateIdentifier?: string;
            /**
                * <p>Specifies the name of the HSM configuration that contains the information the
                *             Amazon Redshift cluster can use to retrieve and store keys in an HSM.</p>
                */
            HsmConfigurationIdentifier?: string;
            /**
                * <p>Reports whether the Amazon Redshift cluster has finished applying any HSM settings
                *             changes specified in a modify cluster command.</p>
                *         <p>Values: active, applying</p>
                */
            Status?: string;
    }
    export namespace HsmStatus {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: HsmStatus) => any;
    }
    /**
        * <p>An Identity and Access Management (IAM) role that can be used by the associated
        *             Amazon Redshift cluster to access other Amazon Web Services services.</p>
        */
    export interface ClusterIamRole {
            /**
                * <p>The Amazon Resource Name (ARN) of the IAM role, for example,
                *                 <code>arn:aws:iam::123456789012:role/RedshiftCopyUnload</code>. </p>
                */
            IamRoleArn?: string;
            /**
                * <p>A value that describes the status of the IAM role's association with an Amazon
                *             Redshift cluster.</p>
                *         <p>The following are possible statuses and descriptions.</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>in-sync</code>: The role is available for use by the cluster.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>adding</code>: The role is in the process of being associated with the
                *                     cluster.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>removing</code>: The role is in the process of being disassociated with
                *                     the cluster.</p>
                *             </li>
                *          </ul>
                */
            ApplyStatus?: string;
    }
    export namespace ClusterIamRole {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterIamRole) => any;
    }
    /**
        * <p>Describes cluster attributes that are in a pending state. A change to one or more
        *             the attributes was requested and is in progress or will be applied.</p>
        */
    export interface PendingModifiedValues {
            /**
                * <p>The pending or in-progress change of the admin user password for the
                *             cluster.</p>
                */
            MasterUserPassword?: string;
            /**
                * <p>The pending or in-progress change of the cluster's node type.</p>
                */
            NodeType?: string;
            /**
                * <p>The pending or in-progress change of the number of nodes in the cluster.</p>
                */
            NumberOfNodes?: number;
            /**
                * <p>The pending or in-progress change of the cluster type.</p>
                */
            ClusterType?: string;
            /**
                * <p>The pending or in-progress change of the service version.</p>
                */
            ClusterVersion?: string;
            /**
                * <p>The pending or in-progress change of the automated snapshot retention
                *             period.</p>
                */
            AutomatedSnapshotRetentionPeriod?: number;
            /**
                * <p>The pending or in-progress change of the new identifier for the cluster.</p>
                */
            ClusterIdentifier?: string;
            /**
                * <p>The pending or in-progress change of the ability to connect to the cluster from the
                *             public network.</p>
                */
            PubliclyAccessible?: boolean;
            /**
                * <p>An option that specifies whether to create the cluster with enhanced VPC routing
                *             enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
                *             VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
                *             the Amazon Redshift Cluster Management Guide.</p>
                *         <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
                *         <p>Default: false</p>
                */
            EnhancedVpcRouting?: boolean;
            /**
                * <p>The name of the maintenance track that the cluster will change to during the next
                *             maintenance window.</p>
                */
            MaintenanceTrackName?: string;
            /**
                * <p>The encryption type for a cluster. Possible values are: KMS and None. </p>
                */
            EncryptionType?: string;
    }
    export namespace PendingModifiedValues {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PendingModifiedValues) => any;
    }
    export enum ReservedNodeExchangeStatusType {
            FAILED = "FAILED",
            IN_PROGRESS = "IN_PROGRESS",
            PENDING = "PENDING",
            REQUESTED = "REQUESTED",
            RETRYING = "RETRYING",
            SUCCEEDED = "SUCCEEDED"
    }
    /**
        * <p>Reserved-node status details, such as the source reserved-node
        *             identifier, the target reserved-node identifier, the node type, the node count, and
        *             other details.</p>
        */
    export interface ReservedNodeExchangeStatus {
            /**
                * <p>The identifier of the reserved-node exchange request.</p>
                */
            ReservedNodeExchangeRequestId?: string;
            /**
                * <p>The status of the reserved-node exchange request. Statuses include in-progress and requested.</p>
                */
            Status?: ReservedNodeExchangeStatusType | string;
            /**
                * <p>A date and time that indicate when the reserved-node exchange was requested.</p>
                */
            RequestTime?: Date;
            /**
                * <p>The identifier of the source reserved node.</p>
                */
            SourceReservedNodeId?: string;
            /**
                * <p>The source reserved-node type, for example ds2.xlarge.</p>
                */
            SourceReservedNodeType?: string;
            /**
                * <p>The source reserved-node count in the cluster.</p>
                */
            SourceReservedNodeCount?: number;
            /**
                * <p>The identifier of the target reserved node offering.</p>
                */
            TargetReservedNodeOfferingId?: string;
            /**
                * <p>The node type of the target reserved node, for example ra3.4xlarge.</p>
                */
            TargetReservedNodeType?: string;
            /**
                * <p>The count of target reserved nodes in the cluster.</p>
                */
            TargetReservedNodeCount?: number;
    }
    export namespace ReservedNodeExchangeStatus {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReservedNodeExchangeStatus) => any;
    }
    /**
        * <p>Describes a resize operation.</p>
        */
    export interface ResizeInfo {
            /**
                * <p>Returns the value <code>ClassicResize</code>.</p>
                */
            ResizeType?: string;
            /**
                * <p>A boolean value indicating if the resize operation can be cancelled.</p>
                */
            AllowCancelResize?: boolean;
    }
    export namespace ResizeInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResizeInfo) => any;
    }
    /**
        * <p>Describes the status of a cluster restore action. Returns null if the cluster was
        *             not created by restoring a snapshot.</p>
        */
    export interface RestoreStatus {
            /**
                * <p>The status of the restore action. Returns starting, restoring, completed, or
                *             failed.</p>
                */
            Status?: string;
            /**
                * <p>The number of megabytes per second being transferred from the backup storage.
                *             Returns the average rate for a completed backup.
                *             This field is only updated when you restore to DC2 and DS2 node types. </p>
                */
            CurrentRestoreRateInMegaBytesPerSecond?: number;
            /**
                * <p>The size of the set of snapshot data used to restore the cluster.
                *             This field is only updated when you restore to DC2 and DS2 node types. </p>
                */
            SnapshotSizeInMegaBytes?: number;
            /**
                * <p>The number of megabytes that have been transferred from snapshot storage.
                *             This field is only updated when you restore to DC2 and DS2 node types. </p>
                */
            ProgressInMegaBytes?: number;
            /**
                * <p>The amount of time an in-progress restore has been running, or the amount of time
                *             it took a completed restore to finish.
                *             This field is only updated when you restore to DC2 and DS2 node types. </p>
                */
            ElapsedTimeInSeconds?: number;
            /**
                * <p>The estimate of the time remaining before the restore will complete. Returns 0 for
                *             a completed restore.
                *             This field is only updated when you restore to DC2 and DS2 node types. </p>
                */
            EstimatedTimeToCompletionInSeconds?: number;
    }
    export namespace RestoreStatus {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RestoreStatus) => any;
    }
    /**
        * <p>Describes the members of a VPC security group.</p>
        */
    export interface VpcSecurityGroupMembership {
            /**
                * <p>The identifier of the VPC security group.</p>
                */
            VpcSecurityGroupId?: string;
            /**
                * <p>The status of the VPC security group.</p>
                */
            Status?: string;
    }
    export namespace VpcSecurityGroupMembership {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: VpcSecurityGroupMembership) => any;
    }
    /**
        * <p>Describes a cluster.</p>
        */
    export interface Cluster {
            /**
                * <p>The unique identifier of the cluster.</p>
                */
            ClusterIdentifier?: string;
            /**
                * <p>The node type for the nodes in the cluster.</p>
                */
            NodeType?: string;
            /**
                * <p> The current state of the cluster. Possible values are the following:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>available</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>available, prep-for-resize</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>available, resize-cleanup</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>cancelling-resize</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>creating</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>deleting</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>final-snapshot</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>hardware-failure</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>incompatible-hsm</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>incompatible-network</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>incompatible-parameters</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>incompatible-restore</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>modifying</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>paused</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>rebooting</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>renaming</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>resizing</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>rotating-keys</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>storage-full</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>updating-hsm</code>
                *                 </p>
                *             </li>
                *          </ul>
                */
            ClusterStatus?: string;
            /**
                * <p>The availability status of the cluster for queries. Possible values are the following:</p>
                *         <ul>
                *             <li>
                *                <p>Available - The cluster is available for queries. </p>
                *             </li>
                *             <li>
                *                <p>Unavailable - The cluster is not available for queries.</p>
                *             </li>
                *             <li>
                *                <p>Maintenance - The cluster is intermittently available for queries due to maintenance activities.</p>
                *             </li>
                *             <li>
                *                <p>Modifying - The cluster is intermittently available for queries due to changes that modify the cluster.</p>
                *             </li>
                *             <li>
                *                <p>Failed - The cluster failed and is not available for queries.</p>
                *             </li>
                *          </ul>
                */
            ClusterAvailabilityStatus?: string;
            /**
                * <p>The status of a modify operation, if any, initiated for the cluster.</p>
                */
            ModifyStatus?: string;
            /**
                * <p>The admin user name for the cluster. This name is used to connect to the database
                *             that is specified in the <b>DBName</b> parameter. </p>
                */
            MasterUsername?: string;
            /**
                * <p>The name of the initial database that was created when the cluster was created.
                *             This same name is returned for the life of the cluster. If an initial database was not
                *             specified, a database named <code>dev</code>dev was created by default. </p>
                */
            DBName?: string;
            /**
                * <p>The connection endpoint.</p>
                */
            Endpoint?: Endpoint;
            /**
                * <p>The date and time that the cluster was created.</p>
                */
            ClusterCreateTime?: Date;
            /**
                * <p>The number of days that automatic cluster snapshots are retained.</p>
                */
            AutomatedSnapshotRetentionPeriod?: number;
            /**
                * <p>The default number of days to retain a manual snapshot. If the value is -1, the
                *             snapshot is retained indefinitely. This setting doesn't change the retention period
                *             of existing snapshots.</p>
                *         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
                */
            ManualSnapshotRetentionPeriod?: number;
            /**
                * <p>A list of cluster security group that are associated with the cluster. Each
                *             security group is represented by an element that contains
                *                 <code>ClusterSecurityGroup.Name</code> and <code>ClusterSecurityGroup.Status</code>
                *             subelements. </p>
                *         <p>Cluster security groups are used when the cluster is not created in an Amazon
                *             Virtual Private Cloud (VPC). Clusters that are created in a VPC use VPC security groups,
                *             which are listed by the <b>VpcSecurityGroups</b> parameter.
                *         </p>
                */
            ClusterSecurityGroups?: ClusterSecurityGroupMembership[];
            /**
                * <p>A list of Amazon Virtual Private Cloud (Amazon VPC) security groups that are
                *             associated with the cluster. This parameter is returned only if the cluster is in a
                *             VPC.</p>
                */
            VpcSecurityGroups?: VpcSecurityGroupMembership[];
            /**
                * <p>The list of cluster parameter groups that are associated with this cluster. Each
                *             parameter group in the list is returned with its status.</p>
                */
            ClusterParameterGroups?: ClusterParameterGroupStatus[];
            /**
                * <p>The name of the subnet group that is associated with the cluster. This parameter is
                *             valid only when the cluster is in a VPC.</p>
                */
            ClusterSubnetGroupName?: string;
            /**
                * <p>The identifier of the VPC the cluster is in, if the cluster is in a VPC.</p>
                */
            VpcId?: string;
            /**
                * <p>The name of the Availability Zone in which the cluster is located.</p>
                */
            AvailabilityZone?: string;
            /**
                * <p>The weekly time range, in Universal Coordinated Time (UTC), during which system
                *             maintenance can occur.</p>
                */
            PreferredMaintenanceWindow?: string;
            /**
                * <p>A value that, if present, indicates that changes to the cluster are pending.
                *             Specific pending changes are identified by subelements.</p>
                */
            PendingModifiedValues?: PendingModifiedValues;
            /**
                * <p>The version ID of the Amazon Redshift engine that is running on the cluster.</p>
                */
            ClusterVersion?: string;
            /**
                * <p>A boolean value that, if <code>true</code>, indicates that major version upgrades
                *             will be applied automatically to the cluster during the maintenance window. </p>
                */
            AllowVersionUpgrade?: boolean;
            /**
                * <p>The number of compute nodes in the cluster.</p>
                */
            NumberOfNodes?: number;
            /**
                * <p>A boolean value that, if <code>true</code>, indicates that the cluster can be
                *             accessed from a public network.</p>
                */
            PubliclyAccessible?: boolean;
            /**
                * <p>A boolean value that, if <code>true</code>, indicates that data in the cluster is
                *             encrypted at rest.</p>
                */
            Encrypted?: boolean;
            /**
                * <p>A value that describes the status of a cluster restore action. This parameter
                *             returns null if the cluster was not created by restoring a snapshot.</p>
                */
            RestoreStatus?: RestoreStatus;
            /**
                * <p></p>
                */
            DataTransferProgress?: DataTransferProgress;
            /**
                * <p>A value that reports whether the Amazon Redshift cluster has finished applying any
                *             hardware security module (HSM) settings changes specified in a modify cluster
                *             command.</p>
                *         <p>Values: active, applying</p>
                */
            HsmStatus?: HsmStatus;
            /**
                * <p>A value that returns the destination region and retention period that are
                *             configured for cross-region snapshot copy.</p>
                */
            ClusterSnapshotCopyStatus?: ClusterSnapshotCopyStatus;
            /**
                * <p>The public key for the cluster.</p>
                */
            ClusterPublicKey?: string;
            /**
                * <p>The nodes in the cluster.</p>
                */
            ClusterNodes?: ClusterNode[];
            /**
                * <p>The status of the elastic IP (EIP) address.</p>
                */
            ElasticIpStatus?: ElasticIpStatus;
            /**
                * <p>The specific revision number of the database in the cluster.</p>
                */
            ClusterRevisionNumber?: string;
            /**
                * <p>The list of tags for the cluster.</p>
                */
            Tags?: Tag[];
            /**
                * <p>The Key Management Service (KMS) key ID of the encryption key used to
                *             encrypt data in the cluster.</p>
                */
            KmsKeyId?: string;
            /**
                * <p>An option that specifies whether to create the cluster with enhanced VPC routing
                *             enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
                *             VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
                *             the Amazon Redshift Cluster Management Guide.</p>
                *         <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
                *         <p>Default: false</p>
                */
            EnhancedVpcRouting?: boolean;
            /**
                * <p>A list of Identity and Access Management (IAM) roles that can be used by the
                *             cluster to access other Amazon Web Services services.</p>
                */
            IamRoles?: ClusterIamRole[];
            /**
                * <p>Cluster operations that are waiting to be started.</p>
                */
            PendingActions?: string[];
            /**
                * <p>The name of the maintenance track for the cluster.</p>
                */
            MaintenanceTrackName?: string;
            /**
                * <p>The number of nodes that you can resize the cluster to with the elastic resize method.
                *         </p>
                */
            ElasticResizeNumberOfNodeOptions?: string;
            /**
                * <p>Describes a group of <code>DeferredMaintenanceWindow</code> objects.</p>
                */
            DeferredMaintenanceWindows?: DeferredMaintenanceWindow[];
            /**
                * <p>A unique identifier for the cluster snapshot schedule.</p>
                */
            SnapshotScheduleIdentifier?: string;
            /**
                * <p>The current state of the cluster snapshot schedule.</p>
                */
            SnapshotScheduleState?: ScheduleState | string;
            /**
                * <p>The date and time when the next snapshot is expected to be taken for clusters with a valid snapshot schedule and backups enabled. </p>
                */
            ExpectedNextSnapshotScheduleTime?: Date;
            /**
                * <p> The status of next expected snapshot for clusters having a valid snapshot schedule and backups enabled.  Possible values are the following:</p>
                *         <ul>
                *             <li>
                *                <p>OnTrack - The next snapshot is expected to be taken on time. </p>
                *             </li>
                *             <li>
                *                <p>Pending - The next snapshot is pending to be taken. </p>
                *             </li>
                *          </ul>
                */
            ExpectedNextSnapshotScheduleTimeStatus?: string;
            /**
                * <p>The date and time in UTC when system maintenance can begin.</p>
                */
            NextMaintenanceWindowStartTime?: Date;
            /**
                * <p>Returns the following:</p>
                *         <ul>
                *             <li>
                *                 <p>AllowCancelResize: a boolean value indicating if the resize operation can be
                *                     cancelled.</p>
                *             </li>
                *             <li>
                *                 <p>ResizeType: Returns ClassicResize</p>
                *             </li>
                *          </ul>
                */
            ResizeInfo?: ResizeInfo;
            /**
                * <p>Describes the status of the Availability Zone relocation operation.</p>
                */
            AvailabilityZoneRelocationStatus?: string;
            /**
                * <p>The namespace Amazon Resource Name (ARN) of the cluster.</p>
                */
            ClusterNamespaceArn?: string;
            /**
                * <p>The total storage capacity of the cluster in megabytes. </p>
                */
            TotalStorageCapacityInMegaBytes?: number;
            /**
                * <p>The AQUA (Advanced Query Accelerator) configuration of the cluster.</p>
                */
            AquaConfiguration?: AquaConfiguration;
            /**
                * <p>The Amazon Resource Name (ARN) for the IAM role set as default for the cluster.</p>
                */
            DefaultIamRoleArn?: string;
            /**
                * <p>The status of the reserved-node exchange request. Statuses include in-progress and requested.</p>
                */
            ReservedNodeExchangeStatus?: ReservedNodeExchangeStatus;
    }
    export namespace Cluster {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Cluster) => any;
    }
    /**
        * <p>The account already has a cluster with the given identifier.</p>
        */
    export class ClusterAlreadyExistsFault extends __BaseException {
            readonly name: "ClusterAlreadyExistsFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClusterAlreadyExistsFault, __BaseException>);
    }
    /**
        * <p>Temporary credentials with authorization to log on to an Amazon Redshift database.
        *         </p>
        */
    export interface ClusterCredentials {
            /**
                * <p>A database user name that is authorized to log on to the database <code>DbName</code>
                *             using the password <code>DbPassword</code>. If the specified DbUser exists in the
                *             database, the new user name has the same database permissions as the the user named in
                *             DbUser. By default, the user is added to PUBLIC. If the <code>DbGroups</code> parameter
                *             is specifed, <code>DbUser</code> is added to the listed groups for any sessions created
                *             using these credentials.</p>
                */
            DbUser?: string;
            /**
                * <p>A temporary password that authorizes the user name returned by <code>DbUser</code>
                *             to log on to the database <code>DbName</code>. </p>
                */
            DbPassword?: string;
            /**
                * <p>The date and time the password in <code>DbPassword</code> expires.</p>
                */
            Expiration?: Date;
    }
    export namespace ClusterCredentials {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterCredentials) => any;
    }
    /**
        * <p>Describes a <code>RevisionTarget</code>.</p>
        */
    export interface RevisionTarget {
            /**
                * <p>A unique string that identifies the version to update the cluster to. You can use this
                *             value in <a>ModifyClusterDbRevision</a>.</p>
                */
            DatabaseRevision?: string;
            /**
                * <p>A string that describes the changes and features that will be applied to the cluster
                *             when it is updated to the corresponding <a>ClusterDbRevision</a>.</p>
                */
            Description?: string;
            /**
                * <p>The date on which the database revision was released.</p>
                */
            DatabaseRevisionReleaseDate?: Date;
    }
    export namespace RevisionTarget {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RevisionTarget) => any;
    }
    /**
        * <p>Describes a <code>ClusterDbRevision</code>.</p>
        */
    export interface ClusterDbRevision {
            /**
                * <p>The unique identifier of the cluster.</p>
                */
            ClusterIdentifier?: string;
            /**
                * <p>A string representing the current cluster version.</p>
                */
            CurrentDatabaseRevision?: string;
            /**
                * <p>The date on which the database revision was released.</p>
                */
            DatabaseRevisionReleaseDate?: Date;
            /**
                * <p>A list of <code>RevisionTarget</code> objects, where each object describes the
                *             database revision that a cluster can be updated to.</p>
                */
            RevisionTargets?: RevisionTarget[];
    }
    export namespace ClusterDbRevision {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterDbRevision) => any;
    }
    export interface ClusterDbRevisionsMessage {
            /**
                * <p>A string representing the starting point for the next set of revisions. If a value is
                *             returned in a response, you can retrieve the next set of revisions by providing the
                *             value in the <code>marker</code> parameter and retrying the command. If the
                *                 <code>marker</code> field is empty, all revisions have already been returned.</p>
                */
            Marker?: string;
            /**
                * <p>A list of revisions.</p>
                */
            ClusterDbRevisions?: ClusterDbRevision[];
    }
    export namespace ClusterDbRevisionsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterDbRevisionsMessage) => any;
    }
    export interface ClusterExtendedCredentials {
            /**
                * <p>A database user name that you provide when you connect to a database. The database user is mapped 1:1 to the source IAM identity. </p>
                */
            DbUser?: string;
            /**
                * <p>A temporary password that you provide when you connect to a database.</p>
                */
            DbPassword?: string;
            /**
                * <p>The time (UTC) when the temporary password expires. After this timestamp, a log in with the temporary password fails.</p>
                */
            Expiration?: Date;
            /**
                * <p>Reserved for future use.</p>
                */
            NextRefreshTime?: Date;
    }
    export namespace ClusterExtendedCredentials {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterExtendedCredentials) => any;
    }
    /**
        * <p>Cluster is already on the latest database revision.</p>
        */
    export class ClusterOnLatestRevisionFault extends __BaseException {
            readonly name: "ClusterOnLatestRevisionFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClusterOnLatestRevisionFault, __BaseException>);
    }
    /**
        * <p>Describes a parameter group.</p>
        */
    export interface ClusterParameterGroup {
            /**
                * <p>The name of the cluster parameter group.</p>
                */
            ParameterGroupName?: string;
            /**
                * <p>The name of the cluster parameter group family that this cluster parameter group is
                *             compatible with.</p>
                */
            ParameterGroupFamily?: string;
            /**
                * <p>The description of the parameter group.</p>
                */
            Description?: string;
            /**
                * <p>The list of tags for the cluster parameter group.</p>
                */
            Tags?: Tag[];
    }
    export namespace ClusterParameterGroup {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterParameterGroup) => any;
    }
    /**
        * <p>A cluster parameter group with the same name already exists.</p>
        */
    export class ClusterParameterGroupAlreadyExistsFault extends __BaseException {
            readonly name: "ClusterParameterGroupAlreadyExistsFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClusterParameterGroupAlreadyExistsFault, __BaseException>);
    }
    export type ParameterApplyType = "dynamic" | "static";
    /**
        * <p>Describes a parameter in a cluster parameter group.</p>
        */
    export interface Parameter {
            /**
                * <p>The name of the parameter.</p>
                */
            ParameterName?: string;
            /**
                * <p>The value of the parameter. If <code>ParameterName</code> is <code>wlm_json_configuration</code>,
                *             then the maximum size of <code>ParameterValue</code> is 8000 characters.</p>
                */
            ParameterValue?: string;
            /**
                * <p>A description of the parameter.</p>
                */
            Description?: string;
            /**
                * <p>The source of the parameter value, such as "engine-default" or "user".</p>
                */
            Source?: string;
            /**
                * <p>The data type of the parameter.</p>
                */
            DataType?: string;
            /**
                * <p>The valid range of values for the parameter.</p>
                */
            AllowedValues?: string;
            /**
                * <p>Specifies how to apply the WLM configuration parameter. Some properties can be
                *             applied dynamically, while other properties require that any associated clusters be
                *             rebooted for the configuration changes to be applied.
                * For more information about parameters and parameter groups, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            ApplyType?: ParameterApplyType | string;
            /**
                * <p>If <code>true</code>, the parameter can be modified. Some parameters have security
                *             or operational implications that prevent them from being changed. </p>
                */
            IsModifiable?: boolean;
            /**
                * <p>The earliest engine version to which the parameter can apply.</p>
                */
            MinimumEngineVersion?: string;
    }
    export namespace Parameter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Parameter) => any;
    }
    /**
        * <p>Contains the output from the <a>DescribeClusterParameters</a> action.
        *         </p>
        */
    export interface ClusterParameterGroupDetails {
            /**
                * <p>A list of <a>Parameter</a> instances. Each instance lists the parameters
                *             of one cluster parameter group. </p>
                */
            Parameters?: Parameter[];
            /**
                * <p>A value that indicates the starting point for the next set of response records in a
                *             subsequent request. If a value is returned in a response, you can retrieve the next set
                *             of records by providing this returned marker value in the <code>Marker</code> parameter
                *             and retrying the command. If the <code>Marker</code> field is empty, all response
                *             records have been retrieved for the request. </p>
                */
            Marker?: string;
    }
    export namespace ClusterParameterGroupDetails {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterParameterGroupDetails) => any;
    }
    /**
        * <p></p>
        */
    export interface ClusterParameterGroupNameMessage {
            /**
                * <p>The name of the cluster parameter group.</p>
                */
            ParameterGroupName?: string;
            /**
                * <p>The status of the parameter group. For example, if you made a change to a parameter
                *             group name-value pair, then the change could be pending a reboot of an associated
                *             cluster.</p>
                */
            ParameterGroupStatus?: string;
    }
    export namespace ClusterParameterGroupNameMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterParameterGroupNameMessage) => any;
    }
    /**
        * <p>The parameter group name does not refer to an existing parameter group.</p>
        */
    export class ClusterParameterGroupNotFoundFault extends __BaseException {
            readonly name: "ClusterParameterGroupNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClusterParameterGroupNotFoundFault, __BaseException>);
    }
    /**
        * <p>The request would result in the user exceeding the allowed number of cluster
        *             parameter groups.
        * For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.
        * </p>
        */
    export class ClusterParameterGroupQuotaExceededFault extends __BaseException {
            readonly name: "ClusterParameterGroupQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClusterParameterGroupQuotaExceededFault, __BaseException>);
    }
    /**
        * <p>Contains the output from the <a>DescribeClusterParameterGroups</a>
        *             action. </p>
        */
    export interface ClusterParameterGroupsMessage {
            /**
                * <p>A value that indicates the starting point for the next set of response records in a
                *             subsequent request. If a value is returned in a response, you can retrieve the next set
                *             of records by providing this returned marker value in the <code>Marker</code> parameter
                *             and retrying the command. If the <code>Marker</code> field is empty, all response
                *             records have been retrieved for the request. </p>
                */
            Marker?: string;
            /**
                * <p>A list of <a>ClusterParameterGroup</a> instances. Each instance
                *             describes one cluster parameter group. </p>
                */
            ParameterGroups?: ClusterParameterGroup[];
    }
    export namespace ClusterParameterGroupsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterParameterGroupsMessage) => any;
    }
    /**
        * <p>The request would exceed the allowed number of cluster instances for this account.
        *
        * For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.
        * </p>
        */
    export class ClusterQuotaExceededFault extends __BaseException {
            readonly name: "ClusterQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClusterQuotaExceededFault, __BaseException>);
    }
    /**
        * <p>A cluster security group with the same name already exists.</p>
        */
    export class ClusterSecurityGroupAlreadyExistsFault extends __BaseException {
            readonly name: "ClusterSecurityGroupAlreadyExistsFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClusterSecurityGroupAlreadyExistsFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export interface ClusterSecurityGroupMessage {
            /**
                * <p>A value that indicates the starting point for the next set of response records in a
                *             subsequent request. If a value is returned in a response, you can retrieve the next set
                *             of records by providing this returned marker value in the <code>Marker</code> parameter
                *             and retrying the command. If the <code>Marker</code> field is empty, all response
                *             records have been retrieved for the request. </p>
                */
            Marker?: string;
            /**
                * <p>A list of <a>ClusterSecurityGroup</a> instances. </p>
                */
            ClusterSecurityGroups?: ClusterSecurityGroup[];
    }
    export namespace ClusterSecurityGroupMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterSecurityGroupMessage) => any;
    }
    /**
        * <p>The request would result in the user exceeding the allowed number of cluster
        *             security groups.
        * For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.
        * </p>
        */
    export class ClusterSecurityGroupQuotaExceededFault extends __BaseException {
            readonly name: "ClusterSecurityGroupQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClusterSecurityGroupQuotaExceededFault, __BaseException>);
    }
    /**
        * <p>Contains the output from the <a>DescribeClusters</a> action. </p>
        */
    export interface ClustersMessage {
            /**
                * <p>A value that indicates the starting point for the next set of response records in a
                *             subsequent request. If a value is returned in a response, you can retrieve the next set
                *             of records by providing this returned marker value in the <code>Marker</code> parameter
                *             and retrying the command. If the <code>Marker</code> field is empty, all response
                *             records have been retrieved for the request. </p>
                */
            Marker?: string;
            /**
                * <p>A list of <code>Cluster</code> objects, where each object describes one cluster.
                *         </p>
                */
            Clusters?: Cluster[];
    }
    export namespace ClustersMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClustersMessage) => any;
    }
    /**
        * <p>The value specified as a snapshot identifier is already used by an existing
        *             snapshot.</p>
        */
    export class ClusterSnapshotAlreadyExistsFault extends __BaseException {
            readonly name: "ClusterSnapshotAlreadyExistsFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClusterSnapshotAlreadyExistsFault, __BaseException>);
    }
    /**
        * <p>The request would result in the user exceeding the allowed number of cluster
        *             snapshots.</p>
        */
    export class ClusterSnapshotQuotaExceededFault extends __BaseException {
            readonly name: "ClusterSnapshotQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClusterSnapshotQuotaExceededFault, __BaseException>);
    }
    /**
        * <p>Describes a subnet.</p>
        */
    export interface Subnet {
            /**
                * <p>The identifier of the subnet.</p>
                */
            SubnetIdentifier?: string;
            /**
                * <p></p>
                */
            SubnetAvailabilityZone?: AvailabilityZone;
            /**
                * <p>The status of the subnet.</p>
                */
            SubnetStatus?: string;
    }
    export namespace Subnet {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Subnet) => any;
    }
    /**
        * <p>Describes a subnet group.</p>
        */
    export interface ClusterSubnetGroup {
            /**
                * <p>The name of the cluster subnet group.</p>
                */
            ClusterSubnetGroupName?: string;
            /**
                * <p>The description of the cluster subnet group.</p>
                */
            Description?: string;
            /**
                * <p>The VPC ID of the cluster subnet group.</p>
                */
            VpcId?: string;
            /**
                * <p>The status of the cluster subnet group. Possible values are <code>Complete</code>,
                *                 <code>Incomplete</code> and <code>Invalid</code>. </p>
                */
            SubnetGroupStatus?: string;
            /**
                * <p>A list of the VPC <a>Subnet</a> elements. </p>
                */
            Subnets?: Subnet[];
            /**
                * <p>The list of tags for the cluster subnet group.</p>
                */
            Tags?: Tag[];
    }
    export namespace ClusterSubnetGroup {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterSubnetGroup) => any;
    }
    /**
        * <p>A <i>ClusterSubnetGroupName</i> is already used by an existing
        *             cluster subnet group. </p>
        */
    export class ClusterSubnetGroupAlreadyExistsFault extends __BaseException {
            readonly name: "ClusterSubnetGroupAlreadyExistsFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClusterSubnetGroupAlreadyExistsFault, __BaseException>);
    }
    /**
        * <p>Contains the output from the <a>DescribeClusterSubnetGroups</a> action.
        *         </p>
        */
    export interface ClusterSubnetGroupMessage {
            /**
                * <p>A value that indicates the starting point for the next set of response records in a
                *             subsequent request. If a value is returned in a response, you can retrieve the next set
                *             of records by providing this returned marker value in the <code>Marker</code> parameter
                *             and retrying the command. If the <code>Marker</code> field is empty, all response
                *             records have been retrieved for the request. </p>
                */
            Marker?: string;
            /**
                * <p>A list of <a>ClusterSubnetGroup</a> instances. </p>
                */
            ClusterSubnetGroups?: ClusterSubnetGroup[];
    }
    export namespace ClusterSubnetGroupMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterSubnetGroupMessage) => any;
    }
    /**
        * <p>The cluster subnet group name does not refer to an existing cluster subnet
        *             group.</p>
        */
    export class ClusterSubnetGroupNotFoundFault extends __BaseException {
            readonly name: "ClusterSubnetGroupNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClusterSubnetGroupNotFoundFault, __BaseException>);
    }
    /**
        * <p>The request would result in user exceeding the allowed number of cluster subnet
        *             groups.
        * For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.
        * </p>
        */
    export class ClusterSubnetGroupQuotaExceededFault extends __BaseException {
            readonly name: "ClusterSubnetGroupQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClusterSubnetGroupQuotaExceededFault, __BaseException>);
    }
    /**
        * <p>The request would result in user exceeding the allowed number of subnets in a
        *             cluster subnet groups.
        * For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.
        * </p>
        */
    export class ClusterSubnetQuotaExceededFault extends __BaseException {
            readonly name: "ClusterSubnetQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClusterSubnetQuotaExceededFault, __BaseException>);
    }
    /**
        * <p>Describes a cluster version, including the parameter group family and description
        *             of the version.</p>
        */
    export interface ClusterVersion {
            /**
                * <p>The version number used by the cluster.</p>
                */
            ClusterVersion?: string;
            /**
                * <p>The name of the cluster parameter group family for the cluster.</p>
                */
            ClusterParameterGroupFamily?: string;
            /**
                * <p>The description of the cluster version.</p>
                */
            Description?: string;
    }
    export namespace ClusterVersion {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterVersion) => any;
    }
    /**
        * <p>Contains the output from the <a>DescribeClusterVersions</a> action.
        *         </p>
        */
    export interface ClusterVersionsMessage {
            /**
                * <p>A value that indicates the starting point for the next set of response records in a
                *             subsequent request. If a value is returned in a response, you can retrieve the next set
                *             of records by providing this returned marker value in the <code>Marker</code> parameter
                *             and retrying the command. If the <code>Marker</code> field is empty, all response
                *             records have been retrieved for the request. </p>
                */
            Marker?: string;
            /**
                * <p>A list of <code>Version</code> elements. </p>
                */
            ClusterVersions?: ClusterVersion[];
    }
    export namespace ClusterVersionsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterVersionsMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface CopyClusterSnapshotMessage {
            /**
                * <p>The identifier for the source snapshot.</p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Must be the identifier for a valid automated snapshot whose state is
                *                         <code>available</code>.</p>
                *             </li>
                *          </ul>
                */
            SourceSnapshotIdentifier: string | undefined;
            /**
                * <p>The identifier of the cluster the source snapshot was created from. This parameter
                *             is required if your IAM user has a policy containing a snapshot resource element that
                *             specifies anything other than * for the cluster name.</p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Must be the identifier for a valid cluster.</p>
                *             </li>
                *          </ul>
                */
            SourceSnapshotClusterIdentifier?: string;
            /**
                * <p>The identifier given to the new manual snapshot.</p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Cannot be null, empty, or blank.</p>
                *             </li>
                *             <li>
                *                 <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p>
                *             </li>
                *             <li>
                *                 <p>First character must be a letter.</p>
                *             </li>
                *             <li>
                *                 <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
                *             </li>
                *             <li>
                *                 <p>Must be unique for the Amazon Web Services account that is making the request.</p>
                *             </li>
                *          </ul>
                */
            TargetSnapshotIdentifier: string | undefined;
            /**
                * <p>The number of days that a manual snapshot is retained. If the value is -1, the manual
                *             snapshot is retained indefinitely. </p>
                *         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
                *         <p>The default value is -1.</p>
                */
            ManualSnapshotRetentionPeriod?: number;
    }
    export namespace CopyClusterSnapshotMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CopyClusterSnapshotMessage) => any;
    }
    export interface CopyClusterSnapshotResult {
            /**
                * <p>Describes a snapshot.</p>
                */
            Snapshot?: Snapshot;
    }
    export namespace CopyClusterSnapshotResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CopyClusterSnapshotResult) => any;
    }
    /**
        * <p>Cross-region snapshot copy was temporarily disabled. Try your request
        *             again.</p>
        */
    export class CopyToRegionDisabledFault extends __BaseException {
            readonly name: "CopyToRegionDisabledFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<CopyToRegionDisabledFault, __BaseException>);
    }
    export interface CreateAuthenticationProfileMessage {
            /**
                * <p>The name of the authentication profile to be created.</p>
                */
            AuthenticationProfileName: string | undefined;
            /**
                * <p>The content of the authentication profile in JSON format.
                *             The maximum length of the JSON string is determined by a quota for your account.</p>
                */
            AuthenticationProfileContent: string | undefined;
    }
    export namespace CreateAuthenticationProfileMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateAuthenticationProfileMessage) => any;
    }
    export interface CreateAuthenticationProfileResult {
            /**
                * <p>The name of the authentication profile that was created.</p>
                */
            AuthenticationProfileName?: string;
            /**
                * <p>The content of the authentication profile in JSON format.</p>
                */
            AuthenticationProfileContent?: string;
    }
    export namespace CreateAuthenticationProfileResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateAuthenticationProfileResult) => any;
    }
    /**
        * <p>The authentication profile request is not valid. The profile name can't be null or empty.
        *             The authentication profile API operation must be available in the Amazon Web Services Region.</p>
        */
    export class InvalidAuthenticationProfileRequestFault extends __BaseException {
            readonly name: "InvalidAuthenticationProfileRequestFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidAuthenticationProfileRequestFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export interface CreateClusterMessage {
            /**
                * <p>The name of the first database to be created when the cluster is created.</p>
                *         <p>To create additional databases after the cluster is created, connect to the cluster
                *             with a SQL client and use SQL commands to create a database. For more information, go to
                *                 <a href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create
                *                 a Database</a> in the Amazon Redshift Database Developer Guide. </p>
                *         <p>Default: <code>dev</code>
                *         </p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Must contain 1 to 64 alphanumeric characters.</p>
                *             </li>
                *             <li>
                *                 <p>Must contain only lowercase letters.</p>
                *             </li>
                *             <li>
                *                 <p>Cannot be a word that is reserved by the service. A list of reserved words
                *                     can be found in <a href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the
                *                     Amazon Redshift Database Developer Guide. </p>
                *             </li>
                *          </ul>
                */
            DBName?: string;
            /**
                * <p>A unique identifier for the cluster. You use this identifier to refer to the
                *             cluster for any subsequent cluster operations such as deleting or modifying. The
                *             identifier also appears in the Amazon Redshift console.</p>
                *          <p>Constraints:</p>
                *          <ul>
                *             <li>
                *                <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p>
                *             </li>
                *             <li>
                *                <p>Alphabetic characters must be lowercase.</p>
                *             </li>
                *             <li>
                *                <p>First character must be a letter.</p>
                *             </li>
                *             <li>
                *                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
                *             </li>
                *             <li>
                *                <p>Must be unique for all clusters within an Amazon Web Services account.</p>
                *             </li>
                *          </ul>
                *
                *             <p>Example: <code>myexamplecluster</code>
                *         </p>
                */
            ClusterIdentifier: string | undefined;
            /**
                * <p>The type of the cluster. When cluster type is specified as</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>single-node</code>, the <b>NumberOfNodes</b>
                *                     parameter is not required.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>multi-node</code>, the <b>NumberOfNodes</b>
                *                     parameter is required.</p>
                *             </li>
                *          </ul>
                *         <p>Valid Values: <code>multi-node</code> | <code>single-node</code>
                *         </p>
                *         <p>Default: <code>multi-node</code>
                *         </p>
                */
            ClusterType?: string;
            /**
                * <p>The node type to be provisioned for the cluster. For information about node types,
                *             go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with
                *                 Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
                *         <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> |
                *                 <code>dc1.large</code> | <code>dc1.8xlarge</code> |
                *                 <code>dc2.large</code> | <code>dc2.8xlarge</code> |
                *                 <code>ra3.xlplus</code> |  <code>ra3.4xlarge</code> | <code>ra3.16xlarge</code>
                *          </p>
                */
            NodeType: string | undefined;
            /**
                * <p>The user name associated with the admin user account for the cluster that is being
                *             created.</p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Must be 1 - 128 alphanumeric characters. The user name can't be
                *                         <code>PUBLIC</code>.</p>
                *             </li>
                *             <li>
                *                 <p>First character must be a letter.</p>
                *             </li>
                *             <li>
                *
                *                 <p>Cannot be a reserved word. A list of reserved words can be found in <a href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved
                *                         Words</a> in the Amazon Redshift Database Developer Guide. </p>
                *             </li>
                *          </ul>
                */
            MasterUsername: string | undefined;
            /**
                * <p>The password associated with the admin user account for the cluster that is being
                *             created.</p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Must be between 8 and 64 characters in length.</p>
                *             </li>
                *             <li>
                *                 <p>Must contain at least one uppercase letter.</p>
                *             </li>
                *             <li>
                *                 <p>Must contain at least one lowercase letter.</p>
                *             </li>
                *             <li>
                *                 <p>Must contain one number.</p>
                *             </li>
                *             <li>
                *                 <p>Can be any printable ASCII character (ASCII code 33-126) except <code>'</code>
                *                     (single quote), <code>"</code> (double quote), <code>\</code>, <code>/</code>, or <code>@</code>.</p>
                *             </li>
                *          </ul>
                */
            MasterUserPassword: string | undefined;
            /**
                * <p>A list of security groups to be associated with this cluster.</p>
                *         <p>Default: The default cluster security group for Amazon Redshift.</p>
                */
            ClusterSecurityGroups?: string[];
            /**
                * <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the
                *             cluster.</p>
                *         <p>Default: The default VPC security group is associated with the cluster.</p>
                */
            VpcSecurityGroupIds?: string[];
            /**
                * <p>The name of a cluster subnet group to be associated with this cluster.</p>
                *         <p>If this parameter is not provided the resulting cluster will be deployed outside
                *             virtual private cloud (VPC).</p>
                */
            ClusterSubnetGroupName?: string;
            /**
                * <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the
                *             cluster. For example, if you have several EC2 instances running in a specific
                *             Availability Zone, then you might want the cluster to be provisioned in the same zone in
                *             order to decrease network latency.</p>
                *         <p>Default: A random, system-chosen Availability Zone in the region that is specified
                *             by the endpoint.</p>
                *         <p>Example: <code>us-east-2d</code>
                *         </p>
                *         <p>Constraint: The specified Availability Zone must be in the same region as the
                *             current endpoint.</p>
                */
            AvailabilityZone?: string;
            /**
                * <p>The weekly time range (in UTC) during which automated cluster maintenance can
                *             occur.</p>
                *         <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code>
                *         </p>
                *         <p> Default: A 30-minute window selected at random from an 8-hour block of time per
                *             region, occurring on a random day of the week. For more information about the time
                *             blocks for each region, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p>
                *         <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p>
                *         <p>Constraints: Minimum 30-minute window.</p>
                */
            PreferredMaintenanceWindow?: string;
            /**
                * <p>The name of the parameter group to be associated with this cluster.</p>
                *         <p>Default: The default Amazon Redshift cluster parameter group. For information about the
                *             default parameter group, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon
                *                 Redshift Parameter Groups</a>
                *         </p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Must be 1 to 255 alphanumeric characters or hyphens.</p>
                *             </li>
                *             <li>
                *                 <p>First character must be a letter.</p>
                *             </li>
                *             <li>
                *                 <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
                *             </li>
                *          </ul>
                */
            ClusterParameterGroupName?: string;
            /**
                * <p>The number of days that automated snapshots are retained. If the value is 0,
                *             automated snapshots are disabled. Even if automated snapshots are disabled, you can
                *             still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p>
                *
                *         <p>You can't disable automated snapshots for RA3 node types. Set the automated retention period from 1-35 days.</p>
                *         <p>Default: <code>1</code>
                *         </p>
                *         <p>Constraints: Must be a value from 0 to 35.</p>
                */
            AutomatedSnapshotRetentionPeriod?: number;
            /**
                * <p>The default number of days to retain a manual snapshot. If the value is -1, the
                *             snapshot is retained indefinitely. This setting doesn't change the retention period
                *             of existing snapshots.</p>
                *         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
                */
            ManualSnapshotRetentionPeriod?: number;
            /**
                * <p>The port number on which the cluster accepts incoming connections.</p>
                *         <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of
                *             the connection string requires the port on which the cluster will listen for incoming
                *             connections.</p>
                *         <p>Default: <code>5439</code>
                *         </p>
                *         <p>Valid Values: <code>1150-65535</code>
                *         </p>
                */
            Port?: number;
            /**
                * <p>The version of the Amazon Redshift engine software that you want to deploy on the
                *             cluster.</p>
                *         <p>The version selected runs on all the nodes in the cluster.</p>
                *         <p>Constraints: Only version 1.0 is currently available.</p>
                *         <p>Example: <code>1.0</code>
                *         </p>
                */
            ClusterVersion?: string;
            /**
                * <p>If <code>true</code>, major version upgrades can be applied during the maintenance
                *             window to the Amazon Redshift engine that is running on the cluster.</p>
                *         <p>When a new major version of the Amazon Redshift engine is released, you can request that
                *             the service automatically apply upgrades during the maintenance window to the Amazon Redshift
                *             engine that is running on your cluster.</p>
                *         <p>Default: <code>true</code>
                *         </p>
                */
            AllowVersionUpgrade?: boolean;
            /**
                * <p>The number of compute nodes in the cluster. This parameter is required when the
                *                 <b>ClusterType</b> parameter is specified as
                *                 <code>multi-node</code>. </p>
                *         <p>For information about determining how many nodes you need, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with
                *                 Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
                *         <p>If you don't specify this parameter, you get a single-node cluster. When requesting
                *             a multi-node cluster, you must specify the number of nodes that you want in the
                *             cluster.</p>
                *         <p>Default: <code>1</code>
                *         </p>
                *         <p>Constraints: Value must be at least 1 and no more than 100.</p>
                */
            NumberOfNodes?: number;
            /**
                * <p>If <code>true</code>, the cluster can be accessed from a public network. </p>
                */
            PubliclyAccessible?: boolean;
            /**
                * <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p>
                *         <p>Default: false</p>
                */
            Encrypted?: boolean;
            /**
                * <p>Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to
                *             retrieve the data encryption keys stored in an HSM.</p>
                */
            HsmClientCertificateIdentifier?: string;
            /**
                * <p>Specifies the name of the HSM configuration that contains the information the
                *             Amazon Redshift cluster can use to retrieve and store keys in an HSM.</p>
                */
            HsmConfigurationIdentifier?: string;
            /**
                * <p>The Elastic IP (EIP) address for the cluster. You don't have to specify the EIP for a
                *             publicly accessible cluster with AvailabilityZoneRelocation turned on.</p>
                *         <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible
                *             through an Internet gateway. For more information about provisioning clusters in
                *             EC2-VPC, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported
                *                 Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
                */
            ElasticIp?: string;
            /**
                * <p>A list of tag instances.</p>
                */
            Tags?: Tag[];
            /**
                * <p>The Key Management Service (KMS) key ID of the encryption key that you want to
                *             use to encrypt data in the cluster.</p>
                */
            KmsKeyId?: string;
            /**
                * <p>An option that specifies whether to create the cluster with enhanced VPC routing
                *             enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
                *             VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
                *             the Amazon Redshift Cluster Management Guide.</p>
                *         <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
                *         <p>Default: false</p>
                */
            EnhancedVpcRouting?: boolean;
            /**
                * <p>Reserved.</p>
                */
            AdditionalInfo?: string;
            /**
                * <p>A list of Identity and Access Management (IAM) roles that can be used by the
                *             cluster to access other Amazon Web Services services. You must supply the IAM roles in their Amazon
                *             Resource Name (ARN) format. </p>
                *         <p>The maximum number of IAM roles that you can associate is subject to a quota.
                *             For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Quotas and limits</a>
                *             in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            IamRoles?: string[];
            /**
                * <p>An optional parameter for the name of the maintenance track for the cluster. If you
                *             don't provide a maintenance track name, the cluster is assigned to the
                *                 <code>current</code> track.</p>
                */
            MaintenanceTrackName?: string;
            /**
                * <p>A unique identifier for the snapshot schedule.</p>
                */
            SnapshotScheduleIdentifier?: string;
            /**
                * <p>The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster is created.</p>
                */
            AvailabilityZoneRelocation?: boolean;
            /**
                * <p>The value represents how the cluster is configured to use AQUA (Advanced Query Accelerator) when it is created. Possible values include the following.</p>
                *         <ul>
                *             <li>
                *                <p>enabled - Use AQUA if it is available for the current Amazon Web Services Region and Amazon Redshift node type.</p>
                *             </li>
                *             <li>
                *                <p>disabled - Don't use AQUA. </p>
                *             </li>
                *             <li>
                *                <p>auto - Amazon Redshift determines whether to use AQUA.</p>
                *             </li>
                *          </ul>
                */
            AquaConfigurationStatus?: AquaConfigurationStatus | string;
            /**
                * <p>The Amazon Resource Name (ARN) for the IAM role that was set as default for the cluster when the cluster was created. </p>
                */
            DefaultIamRoleArn?: string;
            /**
                * <p>A flag that specifies whether to load sample data once the cluster is created.</p>
                */
            LoadSampleData?: string;
    }
    export namespace CreateClusterMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateClusterMessage) => any;
    }
    export interface CreateClusterResult {
            /**
                * <p>Describes a cluster.</p>
                */
            Cluster?: Cluster;
    }
    export namespace CreateClusterResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateClusterResult) => any;
    }
    /**
        * <p>There is no Amazon Redshift HSM client certificate with the specified
        *             identifier.</p>
        */
    export class HsmClientCertificateNotFoundFault extends __BaseException {
            readonly name: "HsmClientCertificateNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<HsmClientCertificateNotFoundFault, __BaseException>);
    }
    /**
        * <p>There is no Amazon Redshift HSM configuration with the specified identifier.</p>
        */
    export class HsmConfigurationNotFoundFault extends __BaseException {
            readonly name: "HsmConfigurationNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<HsmConfigurationNotFoundFault, __BaseException>);
    }
    /**
        * <p>The number of nodes specified exceeds the allotted capacity of the
        *             cluster.</p>
        */
    export class InsufficientClusterCapacityFault extends __BaseException {
            readonly name: "InsufficientClusterCapacityFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InsufficientClusterCapacityFault, __BaseException>);
    }
    /**
        * <p>The cluster subnet group cannot be deleted because it is in use.</p>
        */
    export class InvalidClusterSubnetGroupStateFault extends __BaseException {
            readonly name: "InvalidClusterSubnetGroupStateFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidClusterSubnetGroupStateFault, __BaseException>);
    }
    /**
        * <p>The provided cluster track name is not valid.</p>
        */
    export class InvalidClusterTrackFault extends __BaseException {
            readonly name: "InvalidClusterTrackFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidClusterTrackFault, __BaseException>);
    }
    /**
        * <p>The Elastic IP (EIP) is invalid or cannot be found.</p>
        */
    export class InvalidElasticIpFault extends __BaseException {
            readonly name: "InvalidElasticIpFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidElasticIpFault, __BaseException>);
    }
    /**
        * <p>The requested subnet is not valid, or not all of the subnets are in the same
        *             VPC.</p>
        */
    export class InvalidSubnet extends __BaseException {
            readonly name: "InvalidSubnet";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidSubnet, __BaseException>);
    }
    /**
        * <p>The tag is invalid.</p>
        */
    export class InvalidTagFault extends __BaseException {
            readonly name: "InvalidTagFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidTagFault, __BaseException>);
    }
    /**
        * <p>The cluster subnet group does not cover all Availability Zones.</p>
        */
    export class InvalidVPCNetworkStateFault extends __BaseException {
            readonly name: "InvalidVPCNetworkStateFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidVPCNetworkStateFault, __BaseException>);
    }
    /**
        * <p>The operation would exceed the number of nodes allowed for a cluster.</p>
        */
    export class NumberOfNodesPerClusterLimitExceededFault extends __BaseException {
            readonly name: "NumberOfNodesPerClusterLimitExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NumberOfNodesPerClusterLimitExceededFault, __BaseException>);
    }
    /**
        * <p>The operation would exceed the number of nodes allotted to the account.
        *
        * For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.
        * </p>
        */
    export class NumberOfNodesQuotaExceededFault extends __BaseException {
            readonly name: "NumberOfNodesQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NumberOfNodesQuotaExceededFault, __BaseException>);
    }
    /**
        * <p>We could not find the specified snapshot schedule. </p>
        */
    export class SnapshotScheduleNotFoundFault extends __BaseException {
            readonly name: "SnapshotScheduleNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SnapshotScheduleNotFoundFault, __BaseException>);
    }
    /**
        * <p>You have exceeded the number of tags allowed.</p>
        */
    export class TagLimitExceededFault extends __BaseException {
            readonly name: "TagLimitExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TagLimitExceededFault, __BaseException>);
    }
    /**
        * <p>Your account is not authorized to perform the requested operation.</p>
        */
    export class UnauthorizedOperation extends __BaseException {
            readonly name: "UnauthorizedOperation";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UnauthorizedOperation, __BaseException>);
    }
    /**
        * <p></p>
        */
    export interface CreateClusterParameterGroupMessage {
            /**
                * <p>The name of the cluster parameter group.</p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Must be 1 to 255 alphanumeric characters or hyphens</p>
                *             </li>
                *             <li>
                *                 <p>First character must be a letter.</p>
                *             </li>
                *             <li>
                *                 <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
                *             </li>
                *             <li>
                *                 <p>Must be unique withing your Amazon Web Services account.</p>
                *             </li>
                *          </ul>
                *         <note>
                *             <p>This value is stored as a lower-case string.</p>
                *         </note>
                */
            ParameterGroupName: string | undefined;
            /**
                * <p>The Amazon Redshift engine version to which the cluster parameter group applies. The
                *             cluster engine version determines the set of parameters.</p>
                *         <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of
                *             all the parameter groups that are owned by your Amazon Web Services account, including the default
                *             parameter groups for each Amazon Redshift engine version. The parameter group family names
                *             associated with the default parameter groups provide you the valid values. For example,
                *             a valid family name is "redshift-1.0". </p>
                */
            ParameterGroupFamily: string | undefined;
            /**
                * <p>A description of the parameter group.</p>
                */
            Description: string | undefined;
            /**
                * <p>A list of tag instances.</p>
                */
            Tags?: Tag[];
    }
    export namespace CreateClusterParameterGroupMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateClusterParameterGroupMessage) => any;
    }
    export interface CreateClusterParameterGroupResult {
            /**
                * <p>Describes a parameter group.</p>
                */
            ClusterParameterGroup?: ClusterParameterGroup;
    }
    export namespace CreateClusterParameterGroupResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateClusterParameterGroupResult) => any;
    }
    /**
        * <p></p>
        */
    export interface CreateClusterSecurityGroupMessage {
            /**
                * <p>The name for the security group. Amazon Redshift stores the value as a lowercase
                *             string.</p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Must contain no more than 255 alphanumeric characters or hyphens.</p>
                *             </li>
                *             <li>
                *                 <p>Must not be "Default".</p>
                *             </li>
                *             <li>
                *                 <p>Must be unique for all security groups that are created by your Amazon Web Services account.</p>
                *             </li>
                *          </ul>
                *         <p>Example: <code>examplesecuritygroup</code>
                *         </p>
                */
            ClusterSecurityGroupName: string | undefined;
            /**
                * <p>A description for the security group.</p>
                */
            Description: string | undefined;
            /**
                * <p>A list of tag instances.</p>
                */
            Tags?: Tag[];
    }
    export namespace CreateClusterSecurityGroupMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateClusterSecurityGroupMessage) => any;
    }
    export interface CreateClusterSecurityGroupResult {
            /**
                * <p>Describes a security group.</p>
                */
            ClusterSecurityGroup?: ClusterSecurityGroup;
    }
    export namespace CreateClusterSecurityGroupResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateClusterSecurityGroupResult) => any;
    }
    /**
        * <p></p>
        */
    export interface CreateClusterSnapshotMessage {
            /**
                * <p>A unique identifier for the snapshot that you are requesting. This identifier must
                *             be unique for all snapshots within the Amazon Web Services account.</p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Cannot be null, empty, or blank</p>
                *             </li>
                *             <li>
                *                 <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p>
                *             </li>
                *             <li>
                *                 <p>First character must be a letter</p>
                *             </li>
                *             <li>
                *                 <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
                *             </li>
                *          </ul>
                *         <p>Example: <code>my-snapshot-id</code>
                *         </p>
                */
            SnapshotIdentifier: string | undefined;
            /**
                * <p>The cluster identifier for which you want a snapshot.</p>
                */
            ClusterIdentifier: string | undefined;
            /**
                * <p>The number of days that a manual snapshot is retained. If the value is -1, the manual
                *             snapshot is retained indefinitely. </p>
                *
                *         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
                *
                *         <p>The default value is -1.</p>
                */
            ManualSnapshotRetentionPeriod?: number;
            /**
                * <p>A list of tag instances.</p>
                */
            Tags?: Tag[];
    }
    export namespace CreateClusterSnapshotMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateClusterSnapshotMessage) => any;
    }
    export interface CreateClusterSnapshotResult {
            /**
                * <p>Describes a snapshot.</p>
                */
            Snapshot?: Snapshot;
    }
    export namespace CreateClusterSnapshotResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateClusterSnapshotResult) => any;
    }
    /**
        * <p></p>
        */
    export interface CreateClusterSubnetGroupMessage {
            /**
                * <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase
                *             string.</p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Must contain no more than 255 alphanumeric characters or hyphens.</p>
                *             </li>
                *             <li>
                *                 <p>Must not be "Default".</p>
                *             </li>
                *             <li>
                *                 <p>Must be unique for all subnet groups that are created by your Amazon Web Services account.</p>
                *             </li>
                *          </ul>
                *         <p>Example: <code>examplesubnetgroup</code>
                *         </p>
                */
            ClusterSubnetGroupName: string | undefined;
            /**
                * <p>A description for the subnet group.</p>
                */
            Description: string | undefined;
            /**
                * <p>An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single
                *             request.</p>
                */
            SubnetIds: string[] | undefined;
            /**
                * <p>A list of tag instances.</p>
                */
            Tags?: Tag[];
    }
    export namespace CreateClusterSubnetGroupMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateClusterSubnetGroupMessage) => any;
    }
    export interface CreateClusterSubnetGroupResult {
            /**
                * <p>Describes a subnet group.</p>
                */
            ClusterSubnetGroup?: ClusterSubnetGroup;
    }
    export namespace CreateClusterSubnetGroupResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateClusterSubnetGroupResult) => any;
    }
    export interface CreateEndpointAccessMessage {
            /**
                * <p>The cluster identifier of the cluster to access.</p>
                */
            ClusterIdentifier?: string;
            /**
                * <p>The Amazon Web Services account ID of the owner of the cluster. This is only required if the cluster is in another Amazon Web Services account.</p>
                */
            ResourceOwner?: string;
            /**
                * <p>The Redshift-managed VPC endpoint name.</p>
                *          <p>An endpoint name must contain 1-30 characters.
                *           Valid characters are A-Z, a-z, 0-9, and hyphen(-).
                *           The first character must be a letter.
                *           The name can't contain two consecutive hyphens or end with a hyphen.</p>
                */
            EndpointName: string | undefined;
            /**
                * <p>The subnet group from which Amazon Redshift chooses the subnet to deploy the endpoint.</p>
                */
            SubnetGroupName: string | undefined;
            /**
                * <p>The security group that defines the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.</p>
                */
            VpcSecurityGroupIds?: string[];
    }
    export namespace CreateEndpointAccessMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateEndpointAccessMessage) => any;
    }
    /**
        * <p>Describes a Redshift-managed VPC endpoint.</p>
        */
    export interface EndpointAccess {
            /**
                * <p>The cluster identifier of the cluster associated with the endpoint.</p>
                */
            ClusterIdentifier?: string;
            /**
                * <p>The Amazon Web Services account ID of the owner of the cluster.</p>
                */
            ResourceOwner?: string;
            /**
                * <p>The subnet group name where Amazon Redshift chooses to deploy the endpoint.</p>
                */
            SubnetGroupName?: string;
            /**
                * <p>The status of the endpoint.</p>
                */
            EndpointStatus?: string;
            /**
                * <p>The name of the endpoint.</p>
                */
            EndpointName?: string;
            /**
                * <p>The time (UTC) that the endpoint was created.</p>
                */
            EndpointCreateTime?: Date;
            /**
                * <p>The port number on which the cluster accepts incoming connections.</p>
                */
            Port?: number;
            /**
                * <p>The DNS address of the endpoint.</p>
                */
            Address?: string;
            /**
                * <p>The security groups associated with the endpoint.</p>
                */
            VpcSecurityGroups?: VpcSecurityGroupMembership[];
            /**
                * <p>The connection endpoint for connecting to an Amazon Redshift cluster through the proxy.</p>
                */
            VpcEndpoint?: VpcEndpoint;
    }
    export namespace EndpointAccess {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EndpointAccess) => any;
    }
    /**
        * <p>The account already has a Redshift-managed VPC endpoint with the given identifier.</p>
        */
    export class EndpointAlreadyExistsFault extends __BaseException {
            readonly name: "EndpointAlreadyExistsFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<EndpointAlreadyExistsFault, __BaseException>);
    }
    /**
        * <p>The number of Redshift-managed VPC endpoints per authorization has exceeded its limit.</p>
        */
    export class EndpointsPerAuthorizationLimitExceededFault extends __BaseException {
            readonly name: "EndpointsPerAuthorizationLimitExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<EndpointsPerAuthorizationLimitExceededFault, __BaseException>);
    }
    /**
        * <p>The number of Redshift-managed VPC endpoints per cluster has exceeded its limit.</p>
        */
    export class EndpointsPerClusterLimitExceededFault extends __BaseException {
            readonly name: "EndpointsPerClusterLimitExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<EndpointsPerClusterLimitExceededFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export interface CreateEventSubscriptionMessage {
            /**
                * <p>The name of the event subscription to be created.</p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Cannot be null, empty, or blank.</p>
                *             </li>
                *             <li>
                *                 <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p>
                *             </li>
                *             <li>
                *                 <p>First character must be a letter.</p>
                *             </li>
                *             <li>
                *                 <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
                *             </li>
                *          </ul>
                */
            SubscriptionName: string | undefined;
            /**
                * <p>The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event
                *             notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to
                *             it.</p>
                */
            SnsTopicArn: string | undefined;
            /**
                * <p>The type of source that will be generating the events. For example, if you want to
                *             be notified of events generated by a cluster, you would set this parameter to cluster.
                *             If this value is not specified, events are returned for all Amazon Redshift objects in your
                *             Amazon Web Services account. You must specify a source type in order to specify source IDs.</p>
                *         <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
                */
            SourceType?: string;
            /**
                * <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects
                *             must be of the same type as was specified in the source type parameter. The event
                *             subscription will return only events generated by the specified objects. If not
                *             specified, then events are returned for all objects within the source type
                *             specified.</p>
                *         <p>Example: my-cluster-1, my-cluster-2</p>
                *         <p>Example: my-snapshot-20131010</p>
                */
            SourceIds?: string[];
            /**
                * <p>Specifies the Amazon Redshift event categories to be published by the event notification
                *             subscription.</p>
                *         <p>Values: configuration, management, monitoring, security, pending</p>
                */
            EventCategories?: string[];
            /**
                * <p>Specifies the Amazon Redshift event severity to be published by the event notification
                *             subscription.</p>
                *         <p>Values: ERROR, INFO</p>
                */
            Severity?: string;
            /**
                * <p>A boolean value; set to <code>true</code> to activate the subscription, and set to
                *                 <code>false</code> to create the subscription but not activate it. </p>
                */
            Enabled?: boolean;
            /**
                * <p>A list of tag instances.</p>
                */
            Tags?: Tag[];
    }
    export namespace CreateEventSubscriptionMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateEventSubscriptionMessage) => any;
    }
    /**
        * <p>Describes event subscriptions.</p>
        */
    export interface EventSubscription {
            /**
                * <p>The Amazon Web Services account associated with the Amazon Redshift event notification
                *             subscription.</p>
                */
            CustomerAwsId?: string;
            /**
                * <p>The name of the Amazon Redshift event notification subscription.</p>
                */
            CustSubscriptionId?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the Amazon SNS topic used by the event
                *             notification subscription.</p>
                */
            SnsTopicArn?: string;
            /**
                * <p>The status of the Amazon Redshift event notification subscription.</p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Can be one of the following: active | no-permission |
                *                     topic-not-exist</p>
                *             </li>
                *             <li>
                *                 <p>The status "no-permission" indicates that Amazon Redshift no longer has
                *                     permission to post to the Amazon SNS topic. The status "topic-not-exist"
                *                     indicates that the topic was deleted after the subscription was
                *                     created.</p>
                *             </li>
                *          </ul>
                */
            Status?: string;
            /**
                * <p>The date and time the Amazon Redshift event notification subscription was
                *             created.</p>
                */
            SubscriptionCreationTime?: Date;
            /**
                * <p>The source type of the events returned by the Amazon Redshift event notification, such as
                *             cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, or scheduled-action. </p>
                */
            SourceType?: string;
            /**
                * <p>A list of the sources that publish events to the Amazon Redshift event notification
                *             subscription.</p>
                */
            SourceIdsList?: string[];
            /**
                * <p>The list of Amazon Redshift event categories specified in the event notification
                *             subscription.</p>
                *         <p>Values: Configuration, Management, Monitoring, Security, Pending</p>
                */
            EventCategoriesList?: string[];
            /**
                * <p>The event severity specified in the Amazon Redshift event notification
                *             subscription.</p>
                *         <p>Values: ERROR, INFO</p>
                */
            Severity?: string;
            /**
                * <p>A boolean value indicating whether the subscription is enabled; <code>true</code>
                *             indicates that the subscription is enabled.</p>
                */
            Enabled?: boolean;
            /**
                * <p>The list of tags for the event subscription.</p>
                */
            Tags?: Tag[];
    }
    export namespace EventSubscription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EventSubscription) => any;
    }
    export interface CreateEventSubscriptionResult {
            /**
                * <p>Describes event subscriptions.</p>
                */
            EventSubscription?: EventSubscription;
    }
    export namespace CreateEventSubscriptionResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateEventSubscriptionResult) => any;
    }
    /**
        * <p>The request would exceed the allowed number of event subscriptions for this
        *             account.
        * For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.
        * </p>
        */
    export class EventSubscriptionQuotaExceededFault extends __BaseException {
            readonly name: "EventSubscriptionQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<EventSubscriptionQuotaExceededFault, __BaseException>);
    }
    /**
        * <p>Amazon SNS has responded that there is a problem with the specified Amazon SNS
        *             topic.</p>
        */
    export class SNSInvalidTopicFault extends __BaseException {
            readonly name: "SNSInvalidTopicFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SNSInvalidTopicFault, __BaseException>);
    }
    /**
        * <p>You do not have permission to publish to the specified Amazon SNS topic.</p>
        */
    export class SNSNoAuthorizationFault extends __BaseException {
            readonly name: "SNSNoAuthorizationFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SNSNoAuthorizationFault, __BaseException>);
    }
    /**
        * <p>An Amazon SNS topic with the specified Amazon Resource Name (ARN) does not
        *             exist.</p>
        */
    export class SNSTopicArnNotFoundFault extends __BaseException {
            readonly name: "SNSTopicArnNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SNSTopicArnNotFoundFault, __BaseException>);
    }
    /**
        * <p>The specified Amazon Redshift event source could not be found.</p>
        */
    export class SourceNotFoundFault extends __BaseException {
            readonly name: "SourceNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SourceNotFoundFault, __BaseException>);
    }
    /**
        * <p>There is already an existing event notification subscription with the specified
        *             name.</p>
        */
    export class SubscriptionAlreadyExistFault extends __BaseException {
            readonly name: "SubscriptionAlreadyExistFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SubscriptionAlreadyExistFault, __BaseException>);
    }
    /**
        * <p>The value specified for the event category was not one of the allowed values, or it
        *             specified a category that does not apply to the specified source type. The allowed
        *             values are Configuration, Management, Monitoring, and Security.</p>
        */
    export class SubscriptionCategoryNotFoundFault extends __BaseException {
            readonly name: "SubscriptionCategoryNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SubscriptionCategoryNotFoundFault, __BaseException>);
    }
    /**
        * <p>An Amazon Redshift event with the specified event ID does not exist.</p>
        */
    export class SubscriptionEventIdNotFoundFault extends __BaseException {
            readonly name: "SubscriptionEventIdNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SubscriptionEventIdNotFoundFault, __BaseException>);
    }
    /**
        * <p>The value specified for the event severity was not one of the allowed values, or it
        *             specified a severity that does not apply to the specified source type. The allowed
        *             values are ERROR and INFO.</p>
        */
    export class SubscriptionSeverityNotFoundFault extends __BaseException {
            readonly name: "SubscriptionSeverityNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SubscriptionSeverityNotFoundFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export interface CreateHsmClientCertificateMessage {
            /**
                * <p>The identifier to be assigned to the new HSM client certificate that the cluster
                *             will use to connect to the HSM to use the database encryption keys.</p>
                */
            HsmClientCertificateIdentifier: string | undefined;
            /**
                * <p>A list of tag instances.</p>
                */
            Tags?: Tag[];
    }
    export namespace CreateHsmClientCertificateMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateHsmClientCertificateMessage) => any;
    }
    /**
        * <p>Returns information about an HSM client certificate. The certificate is stored in a
        *             secure Hardware Storage Module (HSM), and used by the Amazon Redshift cluster to encrypt data
        *             files.</p>
        */
    export interface HsmClientCertificate {
            /**
                * <p>The identifier of the HSM client certificate.</p>
                */
            HsmClientCertificateIdentifier?: string;
            /**
                * <p>The public key that the Amazon Redshift cluster will use to connect to the HSM. You must
                *             register the public key in the HSM.</p>
                */
            HsmClientCertificatePublicKey?: string;
            /**
                * <p>The list of tags for the HSM client certificate.</p>
                */
            Tags?: Tag[];
    }
    export namespace HsmClientCertificate {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: HsmClientCertificate) => any;
    }
    export interface CreateHsmClientCertificateResult {
            /**
                * <p>Returns information about an HSM client certificate. The certificate is stored in a
                *             secure Hardware Storage Module (HSM), and used by the Amazon Redshift cluster to encrypt data
                *             files.</p>
                */
            HsmClientCertificate?: HsmClientCertificate;
    }
    export namespace CreateHsmClientCertificateResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateHsmClientCertificateResult) => any;
    }
    /**
        * <p>There is already an existing Amazon Redshift HSM client certificate with the specified
        *             identifier.</p>
        */
    export class HsmClientCertificateAlreadyExistsFault extends __BaseException {
            readonly name: "HsmClientCertificateAlreadyExistsFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<HsmClientCertificateAlreadyExistsFault, __BaseException>);
    }
    /**
        * <p>The quota for HSM client certificates has been reached.
        * For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.
        * </p>
        */
    export class HsmClientCertificateQuotaExceededFault extends __BaseException {
            readonly name: "HsmClientCertificateQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<HsmClientCertificateQuotaExceededFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export interface CreateHsmConfigurationMessage {
            /**
                * <p>The identifier to be assigned to the new Amazon Redshift HSM configuration.</p>
                */
            HsmConfigurationIdentifier: string | undefined;
            /**
                * <p>A text description of the HSM configuration to be created.</p>
                */
            Description: string | undefined;
            /**
                * <p>The IP address that the Amazon Redshift cluster must use to access the HSM.</p>
                */
            HsmIpAddress: string | undefined;
            /**
                * <p>The name of the partition in the HSM where the Amazon Redshift clusters will store their
                *             database encryption keys.</p>
                */
            HsmPartitionName: string | undefined;
            /**
                * <p>The password required to access the HSM partition.</p>
                */
            HsmPartitionPassword: string | undefined;
            /**
                * <p>The HSMs public certificate file. When using Cloud HSM, the file name is
                *             server.pem.</p>
                */
            HsmServerPublicCertificate: string | undefined;
            /**
                * <p>A list of tag instances.</p>
                */
            Tags?: Tag[];
    }
    export namespace CreateHsmConfigurationMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateHsmConfigurationMessage) => any;
    }
    /**
        * <p>Returns information about an HSM configuration, which is an object that describes
        *             to Amazon Redshift clusters the information they require to connect to an HSM where they can
        *             store database encryption keys.</p>
        */
    export interface HsmConfiguration {
            /**
                * <p>The name of the Amazon Redshift HSM configuration.</p>
                */
            HsmConfigurationIdentifier?: string;
            /**
                * <p>A text description of the HSM configuration.</p>
                */
            Description?: string;
            /**
                * <p>The IP address that the Amazon Redshift cluster must use to access the HSM.</p>
                */
            HsmIpAddress?: string;
            /**
                * <p>The name of the partition in the HSM where the Amazon Redshift clusters will store their
                *             database encryption keys.</p>
                */
            HsmPartitionName?: string;
            /**
                * <p>The list of tags for the HSM configuration.</p>
                */
            Tags?: Tag[];
    }
    export namespace HsmConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: HsmConfiguration) => any;
    }
    export interface CreateHsmConfigurationResult {
            /**
                * <p>Returns information about an HSM configuration, which is an object that describes
                *             to Amazon Redshift clusters the information they require to connect to an HSM where they can
                *             store database encryption keys.</p>
                */
            HsmConfiguration?: HsmConfiguration;
    }
    export namespace CreateHsmConfigurationResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateHsmConfigurationResult) => any;
    }
    /**
        * <p>There is already an existing Amazon Redshift HSM configuration with the specified
        *             identifier.</p>
        */
    export class HsmConfigurationAlreadyExistsFault extends __BaseException {
            readonly name: "HsmConfigurationAlreadyExistsFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<HsmConfigurationAlreadyExistsFault, __BaseException>);
    }
    /**
        * <p>The quota for HSM configurations has been reached.
        * For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.
        * </p>
        */
    export class HsmConfigurationQuotaExceededFault extends __BaseException {
            readonly name: "HsmConfigurationQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<HsmConfigurationQuotaExceededFault, __BaseException>);
    }
    /**
        * <p>Describes a pause cluster operation. For example, a scheduled action to run the <code>PauseCluster</code> API operation. </p>
        */
    export interface PauseClusterMessage {
            /**
                * <p>The identifier of the cluster to be paused.</p>
                */
            ClusterIdentifier: string | undefined;
    }
    export namespace PauseClusterMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PauseClusterMessage) => any;
    }
    /**
        * <p>Describes a resize cluster operation. For example, a scheduled action to run the <code>ResizeCluster</code> API operation. </p>
        */
    export interface ResizeClusterMessage {
            /**
                * <p>The unique identifier for the cluster to resize.</p>
                */
            ClusterIdentifier: string | undefined;
            /**
                * <p>The new cluster type for the specified cluster.</p>
                */
            ClusterType?: string;
            /**
                * <p>The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.</p>
                */
            NodeType?: string;
            /**
                * <p>The new number of nodes for the cluster. If not specified, the cluster's current number of nodes is used.</p>
                */
            NumberOfNodes?: number;
            /**
                * <p>A boolean value indicating whether the resize operation is using the classic resize
                *             process. If you don't provide this parameter or set the value to
                *             <code>false</code>, the resize type is elastic. </p>
                */
            Classic?: boolean;
            /**
                * <p>The identifier of the reserved node.</p>
                */
            ReservedNodeId?: string;
            /**
                * <p>The identifier of the target reserved node offering.</p>
                */
            TargetReservedNodeOfferingId?: string;
    }
    export namespace ResizeClusterMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResizeClusterMessage) => any;
    }
    /**
        * <p>Describes a resume cluster operation. For example, a scheduled action to run the <code>ResumeCluster</code> API operation. </p>
        */
    export interface ResumeClusterMessage {
            /**
                * <p>The identifier of the cluster to be resumed.</p>
                */
            ClusterIdentifier: string | undefined;
    }
    export namespace ResumeClusterMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResumeClusterMessage) => any;
    }
    /**
        * <p>The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. </p>
        */
    export interface ScheduledActionType {
            /**
                * <p>An action that runs a <code>ResizeCluster</code> API operation. </p>
                */
            ResizeCluster?: ResizeClusterMessage;
            /**
                * <p>An action that runs a <code>PauseCluster</code> API operation. </p>
                */
            PauseCluster?: PauseClusterMessage;
            /**
                * <p>An action that runs a <code>ResumeCluster</code> API operation. </p>
                */
            ResumeCluster?: ResumeClusterMessage;
    }
    export namespace ScheduledActionType {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ScheduledActionType) => any;
    }
    export interface CreateScheduledActionMessage {
            /**
                * <p>The name of the scheduled action. The name must be unique within an account.
                *             For more information about this parameter, see <a>ScheduledAction</a>. </p>
                */
            ScheduledActionName: string | undefined;
            /**
                * <p>A JSON format string of the Amazon Redshift API operation with input parameters.
                *             For more information about this parameter, see <a>ScheduledAction</a>. </p>
                */
            TargetAction: ScheduledActionType | undefined;
            /**
                * <p>The schedule in <code>at( )</code> or <code>cron( )</code> format.
                *             For more information about this parameter, see <a>ScheduledAction</a>.</p>
                */
            Schedule: string | undefined;
            /**
                * <p>The IAM role to assume to run the target action.
                *             For more information about this parameter, see <a>ScheduledAction</a>. </p>
                */
            IamRole: string | undefined;
            /**
                * <p>The description of the scheduled action.
                *             </p>
                */
            ScheduledActionDescription?: string;
            /**
                * <p>The start time in UTC of the scheduled action.
                *             Before this time, the scheduled action does not trigger.
                *             For more information about this parameter, see <a>ScheduledAction</a>.</p>
                */
            StartTime?: Date;
            /**
                * <p>The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger.
                *             For more information about this parameter, see <a>ScheduledAction</a>. </p>
                */
            EndTime?: Date;
            /**
                * <p>If true, the schedule is enabled. If false, the scheduled action does not trigger.
                *             For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. </p>
                */
            Enable?: boolean;
    }
    export namespace CreateScheduledActionMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateScheduledActionMessage) => any;
    }
    /**
        * <p>The scheduled action is not valid. </p>
        */
    export class InvalidScheduledActionFault extends __BaseException {
            readonly name: "InvalidScheduledActionFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidScheduledActionFault, __BaseException>);
    }
    /**
        * <p>The schedule you submitted isn't valid.</p>
        */
    export class InvalidScheduleFault extends __BaseException {
            readonly name: "InvalidScheduleFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidScheduleFault, __BaseException>);
    }
    export enum ScheduledActionState {
            ACTIVE = "ACTIVE",
            DISABLED = "DISABLED"
    }
    /**
        * <p>Describes a scheduled action. You can use a scheduled action to trigger some Amazon Redshift API operations on a schedule.
        *             For information about which API operations can be scheduled, see  <a>ScheduledActionType</a>. </p>
        */
    export interface ScheduledAction {
            /**
                * <p>The name of the scheduled action. </p>
                */
            ScheduledActionName?: string;
            /**
                * <p>A JSON format string of the Amazon Redshift API operation with input parameters. </p>
                *         <p>"<code>{\"ResizeCluster\":{\"NodeType\":\"ds2.8xlarge\",\"ClusterIdentifier\":\"my-test-cluster\",\"NumberOfNodes\":3}}</code>". </p>
                */
            TargetAction?: ScheduledActionType;
            /**
                * <p>The schedule for a one-time (at format) or recurring (cron format) scheduled action.
                *             Schedule invocations must be separated by at least one hour.</p>
                *         <p>Format of at expressions is "<code>at(yyyy-mm-ddThh:mm:ss)</code>". For example, "<code>at(2016-03-04T17:27:00)</code>".</p>
                *         <p>Format of cron expressions is "<code>cron(Minutes Hours Day-of-month Month Day-of-week Year)</code>".
                *             For example, "<code>cron(0 10 ? * MON *)</code>". For more information, see
                *             <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions">Cron Expressions</a>
                *             in the <i>Amazon CloudWatch Events User Guide</i>.</p>
                */
            Schedule?: string;
            /**
                * <p>The IAM role to assume to run the scheduled action.
                *             This IAM role must have permission to run the Amazon Redshift API operation in the scheduled action.
                *             This IAM role must allow the Amazon Redshift scheduler (Principal scheduler.redshift.amazonaws.com) to assume permissions on your behalf.
                *
                * For more information about the IAM role to use with the Amazon Redshift scheduler, see
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html">Using Identity-Based Policies for Amazon Redshift</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.
                * </p>
                */
            IamRole?: string;
            /**
                * <p>The description of the scheduled action. </p>
                */
            ScheduledActionDescription?: string;
            /**
                * <p>The state of the scheduled action. For example, <code>DISABLED</code>. </p>
                */
            State?: ScheduledActionState | string;
            /**
                * <p>List of times when the scheduled action will run. </p>
                */
            NextInvocations?: Date[];
            /**
                * <p>The start time in UTC when the schedule is active. Before this time, the scheduled action does not trigger. </p>
                */
            StartTime?: Date;
            /**
                * <p>The end time in UTC when the schedule is no longer active. After this time, the scheduled action does not trigger. </p>
                */
            EndTime?: Date;
    }
    export namespace ScheduledAction {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ScheduledAction) => any;
    }
    /**
        * <p>The scheduled action already exists. </p>
        */
    export class ScheduledActionAlreadyExistsFault extends __BaseException {
            readonly name: "ScheduledActionAlreadyExistsFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ScheduledActionAlreadyExistsFault, __BaseException>);
    }
    /**
        * <p>The quota for scheduled actions exceeded. </p>
        */
    export class ScheduledActionQuotaExceededFault extends __BaseException {
            readonly name: "ScheduledActionQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ScheduledActionQuotaExceededFault, __BaseException>);
    }
    /**
        * <p>The action type specified for a scheduled action is not supported. </p>
        */
    export class ScheduledActionTypeUnsupportedFault extends __BaseException {
            readonly name: "ScheduledActionTypeUnsupportedFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ScheduledActionTypeUnsupportedFault, __BaseException>);
    }
    /**
        * <p>The result of the <code>CreateSnapshotCopyGrant</code> action.</p>
        */
    export interface CreateSnapshotCopyGrantMessage {
            /**
                * <p>The name of the snapshot copy grant. This name must be unique in the region for the
                *             Amazon Web Services account.</p>
                *          <p>Constraints:</p>
                *          <ul>
                *             <li>
                *                <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p>
                *             </li>
                *             <li>
                *                <p>Alphabetic characters must be lowercase.</p>
                *             </li>
                *             <li>
                *                <p>First character must be a letter.</p>
                *             </li>
                *             <li>
                *                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
                *             </li>
                *             <li>
                *                <p>Must be unique for all clusters within an Amazon Web Services account.</p>
                *             </li>
                *          </ul>
                */
            SnapshotCopyGrantName: string | undefined;
            /**
                * <p>The unique identifier of the encrypted symmetric key to which to grant Amazon Redshift
                *             permission. If no key is specified, the default key is used.</p>
                */
            KmsKeyId?: string;
            /**
                * <p>A list of tag instances.</p>
                */
            Tags?: Tag[];
    }
    export namespace CreateSnapshotCopyGrantMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateSnapshotCopyGrantMessage) => any;
    }
    /**
        * <p>The snapshot copy grant that grants Amazon Redshift permission to encrypt copied
        *             snapshots with the specified encrypted symmetric key from Amazon Web Services KMS in the destination
        *             region.</p>
        *         <p>
        * For more information about managing snapshot copy grants, go to
        * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.
        * </p>
        */
    export interface SnapshotCopyGrant {
            /**
                * <p>The name of the snapshot copy grant.</p>
                */
            SnapshotCopyGrantName?: string;
            /**
                * <p>The unique identifier of the encrypted symmetric key in Amazon Web Services KMS to which
                *             Amazon Redshift is granted permission.</p>
                */
            KmsKeyId?: string;
            /**
                * <p>A list of tag instances.</p>
                */
            Tags?: Tag[];
    }
    export namespace SnapshotCopyGrant {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SnapshotCopyGrant) => any;
    }
    export interface CreateSnapshotCopyGrantResult {
            /**
                * <p>The snapshot copy grant that grants Amazon Redshift permission to encrypt copied
                *             snapshots with the specified encrypted symmetric key from Amazon Web Services KMS in the destination
                *             region.</p>
                *         <p>
                * For more information about managing snapshot copy grants, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.
                * </p>
                */
            SnapshotCopyGrant?: SnapshotCopyGrant;
    }
    export namespace CreateSnapshotCopyGrantResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateSnapshotCopyGrantResult) => any;
    }
    /**
        * <p>The snapshot copy grant can't be created because a grant with the same name already
        *             exists.</p>
        */
    export class SnapshotCopyGrantAlreadyExistsFault extends __BaseException {
            readonly name: "SnapshotCopyGrantAlreadyExistsFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SnapshotCopyGrantAlreadyExistsFault, __BaseException>);
    }
    /**
        * <p>The Amazon Web Services account has exceeded the maximum number of snapshot copy grants in this
        *             region.</p>
        */
    export class SnapshotCopyGrantQuotaExceededFault extends __BaseException {
            readonly name: "SnapshotCopyGrantQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SnapshotCopyGrantQuotaExceededFault, __BaseException>);
    }
    export interface CreateSnapshotScheduleMessage {
            /**
                * <p>The definition of the snapshot schedule. The definition is made up of schedule
                *             expressions, for example "cron(30 12 *)" or "rate(12 hours)". </p>
                */
            ScheduleDefinitions?: string[];
            /**
                * <p>A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed
                *             for the identifier.</p>
                */
            ScheduleIdentifier?: string;
            /**
                * <p>The description of the snapshot schedule.</p>
                */
            ScheduleDescription?: string;
            /**
                * <p>An optional set of tags you can use to search for the schedule.</p>
                */
            Tags?: Tag[];
            /**
                * <p></p>
                */
            DryRun?: boolean;
            /**
                * <p></p>
                */
            NextInvocations?: number;
    }
    export namespace CreateSnapshotScheduleMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateSnapshotScheduleMessage) => any;
    }
    /**
        * <p>The definition you submitted is not supported.</p>
        */
    export class ScheduleDefinitionTypeUnsupportedFault extends __BaseException {
            readonly name: "ScheduleDefinitionTypeUnsupportedFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ScheduleDefinitionTypeUnsupportedFault, __BaseException>);
    }
    /**
        * <p>Describes a snapshot schedule. You can set a regular interval for creating
        *             snapshots of a cluster. You can also schedule snapshots for specific dates. </p>
        */
    export interface SnapshotSchedule {
            /**
                * <p>A list of ScheduleDefinitions.</p>
                */
            ScheduleDefinitions?: string[];
            /**
                * <p>A unique identifier for the schedule.</p>
                */
            ScheduleIdentifier?: string;
            /**
                * <p>The description of the schedule.</p>
                */
            ScheduleDescription?: string;
            /**
                * <p>An optional set of tags describing the schedule.</p>
                */
            Tags?: Tag[];
            /**
                * <p></p>
                */
            NextInvocations?: Date[];
            /**
                * <p>The number of clusters associated with the schedule.</p>
                */
            AssociatedClusterCount?: number;
            /**
                * <p>A list of clusters associated with the schedule. A maximum of 100 clusters is returned.</p>
                */
            AssociatedClusters?: ClusterAssociatedToSchedule[];
    }
    export namespace SnapshotSchedule {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SnapshotSchedule) => any;
    }
    /**
        * <p>The specified snapshot schedule already exists. </p>
        */
    export class SnapshotScheduleAlreadyExistsFault extends __BaseException {
            readonly name: "SnapshotScheduleAlreadyExistsFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SnapshotScheduleAlreadyExistsFault, __BaseException>);
    }
    /**
        * <p>You have exceeded the quota of snapshot schedules. </p>
        */
    export class SnapshotScheduleQuotaExceededFault extends __BaseException {
            readonly name: "SnapshotScheduleQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SnapshotScheduleQuotaExceededFault, __BaseException>);
    }
    /**
        * <p>Contains the output from the <code>CreateTags</code> action. </p>
        */
    export interface CreateTagsMessage {
            /**
                * <p>The Amazon Resource Name (ARN) to which you want to add the tag or tags. For
                *             example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. </p>
                */
            ResourceName: string | undefined;
            /**
                * <p>One or more name/value pairs to add as tags to the specified resource. Each tag
                *             name is passed in with the parameter <code>Key</code> and the corresponding value is
                *             passed in with the parameter <code>Value</code>. The <code>Key</code> and
                *                 <code>Value</code> parameters are separated by a comma (,). Separate multiple tags
                *             with a space. For example, <code>--tags "Key"="owner","Value"="admin"
                *                 "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. </p>
                */
            Tags: Tag[] | undefined;
    }
    export namespace CreateTagsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateTagsMessage) => any;
    }
    /**
        * <p>The resource could not be found.</p>
        */
    export class ResourceNotFoundFault extends __BaseException {
            readonly name: "ResourceNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceNotFoundFault, __BaseException>);
    }
    export enum UsageLimitBreachAction {
            DISABLE = "disable",
            EMIT_METRIC = "emit-metric",
            LOG = "log"
    }
    export enum UsageLimitFeatureType {
            CONCURRENCY_SCALING = "concurrency-scaling",
            CROSS_REGION_DATASHARING = "cross-region-datasharing",
            SPECTRUM = "spectrum"
    }
    export enum UsageLimitLimitType {
            DATA_SCANNED = "data-scanned",
            TIME = "time"
    }
    export enum UsageLimitPeriod {
            DAILY = "daily",
            MONTHLY = "monthly",
            WEEKLY = "weekly"
    }
    export interface CreateUsageLimitMessage {
            /**
                * <p>The identifier of the cluster that you want to limit usage.</p>
                */
            ClusterIdentifier: string | undefined;
            /**
                * <p>The Amazon Redshift feature that you want to limit.</p>
                */
            FeatureType: UsageLimitFeatureType | string | undefined;
            /**
                * <p>The type of limit. Depending on the feature type, this can be based on a time duration or data size.
                *             If <code>FeatureType</code> is <code>spectrum</code>, then <code>LimitType</code> must be <code>data-scanned</code>.
                *             If <code>FeatureType</code> is <code>concurrency-scaling</code>, then <code>LimitType</code> must be <code>time</code>.
                *             If <code>FeatureType</code> is <code>cross-region-datasharing</code>, then <code>LimitType</code> must be <code>data-scanned</code>.
                *            </p>
                */
            LimitType: UsageLimitLimitType | string | undefined;
            /**
                * <p>The limit amount. If time-based, this amount is in minutes. If data-based, this amount is in terabytes (TB).
                *             The value must be a positive number.
                *             </p>
                */
            Amount: number | undefined;
            /**
                * <p>The time period that the amount applies to. A <code>weekly</code> period begins on Sunday. The default is <code>monthly</code>.
                *             </p>
                */
            Period?: UsageLimitPeriod | string;
            /**
                * <p>The action that Amazon Redshift takes when the limit is reached. The default is log.
                *             For more information about this parameter, see <a>UsageLimit</a>.</p>
                */
            BreachAction?: UsageLimitBreachAction | string;
            /**
                * <p>A list of tag instances.</p>
                */
            Tags?: Tag[];
    }
    export namespace CreateUsageLimitMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateUsageLimitMessage) => any;
    }
    /**
        * <p>The usage limit is not valid.</p>
        */
    export class InvalidUsageLimitFault extends __BaseException {
            readonly name: "InvalidUsageLimitFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidUsageLimitFault, __BaseException>);
    }
    /**
        * <p>Describes a usage limit object for a cluster. </p>
        */
    export interface UsageLimit {
            /**
                * <p>The identifier of the usage limit.</p>
                */
            UsageLimitId?: string;
            /**
                * <p>The identifier of the cluster with a usage limit.</p>
                */
            ClusterIdentifier?: string;
            /**
                * <p>The Amazon Redshift feature to which the limit applies.</p>
                */
            FeatureType?: UsageLimitFeatureType | string;
            /**
                * <p>The type of limit. Depending on the feature type, this can be based on a time duration or data size.</p>
                */
            LimitType?: UsageLimitLimitType | string;
            /**
                * <p>The limit amount. If time-based, this amount is in minutes. If data-based, this amount is in terabytes (TB).</p>
                */
            Amount?: number;
            /**
                * <p>The time period that the amount applies to. A <code>weekly</code> period begins on Sunday. The default is <code>monthly</code>. </p>
                */
            Period?: UsageLimitPeriod | string;
            /**
                * <p>The action that Amazon Redshift takes when the limit is reached. Possible values are: </p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <b>log</b> - To log an event in a system table. The default is log.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>emit-metric</b> - To emit CloudWatch metrics.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>disable</b> - To disable the feature until the next usage period begins.</p>
                *             </li>
                *          </ul>
                */
            BreachAction?: UsageLimitBreachAction | string;
            /**
                * <p>A list of tag instances.</p>
                */
            Tags?: Tag[];
    }
    export namespace UsageLimit {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UsageLimit) => any;
    }
    /**
        * <p>The usage limit already exists. </p>
        */
    export class UsageLimitAlreadyExistsFault extends __BaseException {
            readonly name: "UsageLimitAlreadyExistsFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UsageLimitAlreadyExistsFault, __BaseException>);
    }
    export interface CustomerStorageMessage {
            /**
                * <p>The total amount of storage currently used for snapshots.</p>
                */
            TotalBackupSizeInMegaBytes?: number;
            /**
                * <p>The total amount of storage currently provisioned.</p>
                */
            TotalProvisionedStorageInMegaBytes?: number;
    }
    export namespace CustomerStorageMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CustomerStorageMessage) => any;
    }
    export enum DataShareStatusForConsumer {
            ACTIVE = "ACTIVE",
            AVAILABLE = "AVAILABLE"
    }
    export enum DataShareStatusForProducer {
            ACTIVE = "ACTIVE",
            AUTHORIZED = "AUTHORIZED",
            DEAUTHORIZED = "DEAUTHORIZED",
            PENDING_AUTHORIZATION = "PENDING_AUTHORIZATION",
            REJECTED = "REJECTED"
    }
    export interface DeauthorizeDataShareMessage {
            /**
                * <p>The Amazon Resource Name (ARN) of the datashare to remove authorization from.</p>
                */
            DataShareArn: string | undefined;
            /**
                * <p>The identifier of the data consumer that is to have authorization removed from the datashare.
                *             This identifier is an Amazon Web Services account ID or a keyword, such as ADX.</p>
                */
            ConsumerIdentifier: string | undefined;
    }
    export namespace DeauthorizeDataShareMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeauthorizeDataShareMessage) => any;
    }
    /**
        * <p>Describes the default cluster parameters for a parameter group family.</p>
        */
    export interface DefaultClusterParameters {
            /**
                * <p>The name of the cluster parameter group family to which the engine default
                *             parameters apply.</p>
                */
            ParameterGroupFamily?: string;
            /**
                * <p>A value that indicates the starting point for the next set of response records in a
                *             subsequent request. If a value is returned in a response, you can retrieve the next set
                *             of records by providing this returned marker value in the <code>Marker</code> parameter
                *             and retrying the command. If the <code>Marker</code> field is empty, all response
                *             records have been retrieved for the request. </p>
                */
            Marker?: string;
            /**
                * <p>The list of cluster default parameters.</p>
                */
            Parameters?: Parameter[];
    }
    export namespace DefaultClusterParameters {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DefaultClusterParameters) => any;
    }
    export interface DeleteAuthenticationProfileMessage {
            /**
                * <p>The name of the authentication profile to delete.</p>
                */
            AuthenticationProfileName: string | undefined;
    }
    export namespace DeleteAuthenticationProfileMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteAuthenticationProfileMessage) => any;
    }
    export interface DeleteAuthenticationProfileResult {
            /**
                * <p>The name of the authentication profile that was deleted.</p>
                */
            AuthenticationProfileName?: string;
    }
    export namespace DeleteAuthenticationProfileResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteAuthenticationProfileResult) => any;
    }
    /**
        * <p></p>
        */
    export interface DeleteClusterMessage {
            /**
                * <p>The identifier of the cluster to be deleted.</p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Must contain lowercase characters.</p>
                *             </li>
                *             <li>
                *                 <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p>
                *             </li>
                *             <li>
                *                 <p>First character must be a letter.</p>
                *             </li>
                *             <li>
                *                 <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
                *             </li>
                *          </ul>
                */
            ClusterIdentifier: string | undefined;
            /**
                * <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift
                *             deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If
                *                 <code>false</code>, a final cluster snapshot is created before the cluster is
                *             deleted. </p>
                *         <note>
                *             <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be
                *                 specified if <i>SkipFinalClusterSnapshot</i> is
                *                 <code>false</code>.</p>
                *         </note>
                *         <p>Default: <code>false</code>
                *         </p>
                */
            SkipFinalClusterSnapshot?: boolean;
            /**
                * <p>The identifier of the final snapshot that is to be created immediately before
                *             deleting the cluster. If this parameter is provided,
                *                 <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Must be 1 to 255 alphanumeric characters.</p>
                *             </li>
                *             <li>
                *                 <p>First character must be a letter.</p>
                *             </li>
                *             <li>
                *                 <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
                *             </li>
                *          </ul>
                */
            FinalClusterSnapshotIdentifier?: string;
            /**
                * <p>The number of days that a manual snapshot is retained. If the value is -1, the manual
                *             snapshot is retained indefinitely.</p>
                *         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
                *         <p>The default value is -1.</p>
                */
            FinalClusterSnapshotRetentionPeriod?: number;
    }
    export namespace DeleteClusterMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteClusterMessage) => any;
    }
    export interface DeleteClusterResult {
            /**
                * <p>Describes a cluster.</p>
                */
            Cluster?: Cluster;
    }
    export namespace DeleteClusterResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteClusterResult) => any;
    }
    /**
        * <p></p>
        */
    export interface DeleteClusterParameterGroupMessage {
            /**
                * <p>The name of the parameter group to be deleted.</p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Must be the name of an existing cluster parameter group.</p>
                *             </li>
                *             <li>
                *                 <p>Cannot delete a default cluster parameter group.</p>
                *             </li>
                *          </ul>
                */
            ParameterGroupName: string | undefined;
    }
    export namespace DeleteClusterParameterGroupMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteClusterParameterGroupMessage) => any;
    }
    /**
        * <p>The cluster parameter group action can not be completed because another task is in
        *             progress that involves the parameter group. Wait a few moments and try the operation
        *             again.</p>
        */
    export class InvalidClusterParameterGroupStateFault extends __BaseException {
            readonly name: "InvalidClusterParameterGroupStateFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidClusterParameterGroupStateFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export interface DeleteClusterSecurityGroupMessage {
            /**
                * <p>The name of the cluster security group to be deleted.</p>
                */
            ClusterSecurityGroupName: string | undefined;
    }
    export namespace DeleteClusterSecurityGroupMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteClusterSecurityGroupMessage) => any;
    }
    export interface DeleteClusterSnapshotResult {
            /**
                * <p>Describes a snapshot.</p>
                */
            Snapshot?: Snapshot;
    }
    export namespace DeleteClusterSnapshotResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteClusterSnapshotResult) => any;
    }
    /**
        * <p></p>
        */
    export interface DeleteClusterSubnetGroupMessage {
            /**
                * <p>The name of the cluster subnet group name to be deleted.</p>
                */
            ClusterSubnetGroupName: string | undefined;
    }
    export namespace DeleteClusterSubnetGroupMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteClusterSubnetGroupMessage) => any;
    }
    /**
        * <p>The state of the subnet is invalid.</p>
        */
    export class InvalidClusterSubnetStateFault extends __BaseException {
            readonly name: "InvalidClusterSubnetStateFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidClusterSubnetStateFault, __BaseException>);
    }
    export interface DeleteEndpointAccessMessage {
            /**
                * <p>The Redshift-managed VPC endpoint to delete.</p>
                */
            EndpointName: string | undefined;
    }
    export namespace DeleteEndpointAccessMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteEndpointAccessMessage) => any;
    }
    /**
        * <p>The endpoint name doesn't refer to an existing endpoint.</p>
        */
    export class EndpointNotFoundFault extends __BaseException {
            readonly name: "EndpointNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<EndpointNotFoundFault, __BaseException>);
    }
    /**
        * <p>The status of the endpoint is not valid.</p>
        */
    export class InvalidEndpointStateFault extends __BaseException {
            readonly name: "InvalidEndpointStateFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidEndpointStateFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export interface DeleteEventSubscriptionMessage {
            /**
                * <p>The name of the Amazon Redshift event notification subscription to be deleted.</p>
                */
            SubscriptionName: string | undefined;
    }
    export namespace DeleteEventSubscriptionMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteEventSubscriptionMessage) => any;
    }
    /**
        * <p>The subscription request is invalid because it is a duplicate request. This
        *             subscription request is already in progress.</p>
        */
    export class InvalidSubscriptionStateFault extends __BaseException {
            readonly name: "InvalidSubscriptionStateFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidSubscriptionStateFault, __BaseException>);
    }
    /**
        * <p>An Amazon Redshift event notification subscription with the specified name does not
        *             exist.</p>
        */
    export class SubscriptionNotFoundFault extends __BaseException {
            readonly name: "SubscriptionNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SubscriptionNotFoundFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export interface DeleteHsmClientCertificateMessage {
            /**
                * <p>The identifier of the HSM client certificate to be deleted.</p>
                */
            HsmClientCertificateIdentifier: string | undefined;
    }
    export namespace DeleteHsmClientCertificateMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteHsmClientCertificateMessage) => any;
    }
    /**
        * <p>The specified HSM client certificate is not in the <code>available</code> state, or
        *             it is still in use by one or more Amazon Redshift clusters.</p>
        */
    export class InvalidHsmClientCertificateStateFault extends __BaseException {
            readonly name: "InvalidHsmClientCertificateStateFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidHsmClientCertificateStateFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export interface DeleteHsmConfigurationMessage {
            /**
                * <p>The identifier of the Amazon Redshift HSM configuration to be deleted.</p>
                */
            HsmConfigurationIdentifier: string | undefined;
    }
    export namespace DeleteHsmConfigurationMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteHsmConfigurationMessage) => any;
    }
    /**
        * <p>The specified HSM configuration is not in the <code>available</code> state, or it
        *             is still in use by one or more Amazon Redshift clusters.</p>
        */
    export class InvalidHsmConfigurationStateFault extends __BaseException {
            readonly name: "InvalidHsmConfigurationStateFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidHsmConfigurationStateFault, __BaseException>);
    }
    export interface DeleteScheduledActionMessage {
            /**
                * <p>The name of the scheduled action to delete. </p>
                */
            ScheduledActionName: string | undefined;
    }
    export namespace DeleteScheduledActionMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteScheduledActionMessage) => any;
    }
    /**
        * <p>The scheduled action cannot be found. </p>
        */
    export class ScheduledActionNotFoundFault extends __BaseException {
            readonly name: "ScheduledActionNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ScheduledActionNotFoundFault, __BaseException>);
    }
    /**
        * <p>The result of the <code>DeleteSnapshotCopyGrant</code> action.</p>
        */
    export interface DeleteSnapshotCopyGrantMessage {
            /**
                * <p>The name of the snapshot copy grant to delete.</p>
                */
            SnapshotCopyGrantName: string | undefined;
    }
    export namespace DeleteSnapshotCopyGrantMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteSnapshotCopyGrantMessage) => any;
    }
    /**
        * <p>The snapshot copy grant can't be deleted because it is used by one or more
        *             clusters.</p>
        */
    export class InvalidSnapshotCopyGrantStateFault extends __BaseException {
            readonly name: "InvalidSnapshotCopyGrantStateFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidSnapshotCopyGrantStateFault, __BaseException>);
    }
    /**
        * <p>The specified snapshot copy grant can't be found. Make sure that the name is typed
        *             correctly and that the grant exists in the destination region.</p>
        */
    export class SnapshotCopyGrantNotFoundFault extends __BaseException {
            readonly name: "SnapshotCopyGrantNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SnapshotCopyGrantNotFoundFault, __BaseException>);
    }
    export interface DeleteSnapshotScheduleMessage {
            /**
                * <p>A unique identifier of the snapshot schedule to delete.</p>
                */
            ScheduleIdentifier: string | undefined;
    }
    export namespace DeleteSnapshotScheduleMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteSnapshotScheduleMessage) => any;
    }
    /**
        * <p>The cluster snapshot schedule state is not valid.</p>
        */
    export class InvalidClusterSnapshotScheduleStateFault extends __BaseException {
            readonly name: "InvalidClusterSnapshotScheduleStateFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidClusterSnapshotScheduleStateFault, __BaseException>);
    }
    /**
        * <p>Contains the output from the <code>DeleteTags</code> action. </p>
        */
    export interface DeleteTagsMessage {
            /**
                * <p>The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For
                *             example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. </p>
                */
            ResourceName: string | undefined;
            /**
                * <p>The tag key that you want to delete.</p>
                */
            TagKeys: string[] | undefined;
    }
    export namespace DeleteTagsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteTagsMessage) => any;
    }
    export interface DeleteUsageLimitMessage {
            /**
                * <p>The identifier of the usage limit to delete.</p>
                */
            UsageLimitId: string | undefined;
    }
    export namespace DeleteUsageLimitMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteUsageLimitMessage) => any;
    }
    /**
        * <p>The usage limit identifier can't be found.</p>
        */
    export class UsageLimitNotFoundFault extends __BaseException {
            readonly name: "UsageLimitNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UsageLimitNotFoundFault, __BaseException>);
    }
    export interface DescribeAccountAttributesMessage {
            /**
                * <p>A list of attribute names.</p>
                */
            AttributeNames?: string[];
    }
    export namespace DescribeAccountAttributesMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeAccountAttributesMessage) => any;
    }
    export interface DescribeAuthenticationProfilesMessage {
            /**
                * <p>The name of the authentication profile to describe. If not specified then all authentication profiles owned by the account are listed.</p>
                */
            AuthenticationProfileName?: string;
    }
    export namespace DescribeAuthenticationProfilesMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeAuthenticationProfilesMessage) => any;
    }
    export interface DescribeAuthenticationProfilesResult {
            /**
                * <p>The list of authentication profiles.</p>
                */
            AuthenticationProfiles?: AuthenticationProfile[];
    }
    export namespace DescribeAuthenticationProfilesResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeAuthenticationProfilesResult) => any;
    }
    export interface DescribeClusterDbRevisionsMessage {
            /**
                * <p>A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are
                *             requesting. This parameter is case sensitive. All clusters defined for an account are
                *             returned by default.</p>
                */
            ClusterIdentifier?: string;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified MaxRecords value, a value is returned
                *             in the <code>marker</code> field of the response. You can retrieve the next set of
                *             response records by providing the returned <code>marker</code> value in the
                *                 <code>marker</code> parameter and retrying the request. </p>
                *         <p>Default: 100</p>
                *         <p>Constraints: minimum 20, maximum 100.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional parameter that specifies the starting point for returning a set of
                *             response records. When the results of a <code>DescribeClusterDbRevisions</code> request
                *             exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value
                *             in the <code>marker</code> field of the response. You can retrieve the next set of
                *             response records by providing the returned <code>marker</code> value in the
                *                 <code>marker</code> parameter and retrying the request. </p>
                *         <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or
                *             the <code>marker</code> parameter, but not both.</p>
                */
            Marker?: string;
    }
    export namespace DescribeClusterDbRevisionsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeClusterDbRevisionsMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeClusterParameterGroupsMessage {
            /**
                * <p>The name of a specific parameter group for which to return details. By default,
                *             details about all parameter groups and the default parameter group are
                *             returned.</p>
                */
            ParameterGroupName?: string;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value. </p>
                *         <p>Default: <code>100</code>
                *         </p>
                *         <p>Constraints: minimum 20, maximum 100.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <a>DescribeClusterParameterGroups</a> request
                *             exceed the value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the
                *                 <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                */
            Marker?: string;
            /**
                * <p>A tag key or keys for which you want to return all matching cluster parameter
                *             groups that are associated with the specified key or keys. For example, suppose that you
                *             have parameter groups that are tagged with keys called <code>owner</code> and
                *                 <code>environment</code>. If you specify both of these tag keys in the request,
                *             Amazon Redshift returns a response with the parameter groups that have either or both of these
                *             tag keys associated with them.</p>
                */
            TagKeys?: string[];
            /**
                * <p>A tag value or values for which you want to return all matching cluster parameter
                *             groups that are associated with the specified tag value or values. For example, suppose
                *             that you have parameter groups that are tagged with values called <code>admin</code> and
                *                 <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift
                *             returns a response with the parameter groups that have either or both of these tag
                *             values associated with them.</p>
                */
            TagValues?: string[];
    }
    export namespace DescribeClusterParameterGroupsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeClusterParameterGroupsMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeClusterParametersMessage {
            /**
                * <p>The name of a cluster parameter group for which to return details.</p>
                */
            ParameterGroupName: string | undefined;
            /**
                * <p>The parameter types to return. Specify <code>user</code> to show parameters that
                *             are different form the default. Similarly, specify <code>engine-default</code> to show
                *             parameters that are the same as the default parameter group. </p>
                *         <p>Default: All parameter types returned.</p>
                *         <p>Valid Values: <code>user</code> | <code>engine-default</code>
                *         </p>
                */
            Source?: string;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value. </p>
                *         <p>Default: <code>100</code>
                *         </p>
                *         <p>Constraints: minimum 20, maximum 100.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <a>DescribeClusterParameters</a> request
                *             exceed the value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the
                *                 <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                */
            Marker?: string;
    }
    export namespace DescribeClusterParametersMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeClusterParametersMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeClustersMessage {
            /**
                * <p>The unique identifier of a cluster whose properties you are requesting. This
                *             parameter is case sensitive.</p>
                *         <p>The default is that all clusters defined for an account are returned.</p>
                */
            ClusterIdentifier?: string;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value. </p>
                *         <p>Default: <code>100</code>
                *         </p>
                *         <p>Constraints: minimum 20, maximum 100.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <a>DescribeClusters</a> request exceed the
                *             value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the
                *                 <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                *         <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
                */
            Marker?: string;
            /**
                * <p>A tag key or keys for which you want to return all matching clusters that are
                *             associated with the specified key or keys. For example, suppose that you have clusters
                *             that are tagged with keys called <code>owner</code> and <code>environment</code>. If you
                *             specify both of these tag keys in the request, Amazon Redshift returns a response with the
                *             clusters that have either or both of these tag keys associated with them.</p>
                */
            TagKeys?: string[];
            /**
                * <p>A tag value or values for which you want to return all matching clusters that are
                *             associated with the specified tag value or values. For example, suppose that you have
                *             clusters that are tagged with values called <code>admin</code> and <code>test</code>. If
                *             you specify both of these tag values in the request, Amazon Redshift returns a response with
                *             the clusters that have either or both of these tag values associated with
                *             them.</p>
                */
            TagValues?: string[];
    }
    export namespace DescribeClustersMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeClustersMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeClusterSecurityGroupsMessage {
            /**
                * <p>The name of a cluster security group for which you are requesting details. You can
                *             specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p>
                *         <p> Example: <code>securitygroup1</code>
                *         </p>
                */
            ClusterSecurityGroupName?: string;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value. </p>
                *         <p>Default: <code>100</code>
                *         </p>
                *         <p>Constraints: minimum 20, maximum 100.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <a>DescribeClusterSecurityGroups</a> request
                *             exceed the value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the
                *                 <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                *         <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
                */
            Marker?: string;
            /**
                * <p>A tag key or keys for which you want to return all matching cluster security groups
                *             that are associated with the specified key or keys. For example, suppose that you have
                *             security groups that are tagged with keys called <code>owner</code> and
                *                 <code>environment</code>. If you specify both of these tag keys in the request,
                *             Amazon Redshift returns a response with the security groups that have either or both of these
                *             tag keys associated with them.</p>
                */
            TagKeys?: string[];
            /**
                * <p>A tag value or values for which you want to return all matching cluster security
                *             groups that are associated with the specified tag value or values. For example, suppose
                *             that you have security groups that are tagged with values called <code>admin</code> and
                *                 <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift
                *             returns a response with the security groups that have either or both of these tag values
                *             associated with them.</p>
                */
            TagValues?: string[];
    }
    export namespace DescribeClusterSecurityGroupsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeClusterSecurityGroupsMessage) => any;
    }
    export enum SnapshotAttributeToSortBy {
            CREATE_TIME = "CREATE_TIME",
            SOURCE_TYPE = "SOURCE_TYPE",
            TOTAL_SIZE = "TOTAL_SIZE"
    }
    export enum SortByOrder {
            ASCENDING = "ASC",
            DESCENDING = "DESC"
    }
    /**
        * <p>Describes a sorting entity</p>
        */
    export interface SnapshotSortingEntity {
            /**
                * <p>The category for sorting the snapshots.</p>
                */
            Attribute: SnapshotAttributeToSortBy | string | undefined;
            /**
                * <p>The order for listing the attributes.</p>
                */
            SortOrder?: SortByOrder | string;
    }
    export namespace SnapshotSortingEntity {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SnapshotSortingEntity) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeClusterSnapshotsMessage {
            /**
                * <p>The identifier of the cluster which generated the requested snapshots.</p>
                */
            ClusterIdentifier?: string;
            /**
                * <p>The snapshot identifier of the snapshot about which to return
                *             information.</p>
                */
            SnapshotIdentifier?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the snapshot associated with the message to describe cluster snapshots.</p>
                */
            SnapshotArn?: string;
            /**
                * <p>The type of snapshots for which you are requesting information. By default,
                *             snapshots of all types are returned.</p>
                *         <p>Valid Values: <code>automated</code> | <code>manual</code>
                *         </p>
                */
            SnapshotType?: string;
            /**
                * <p>A value that requests only snapshots created at or after the specified time. The
                *             time value is specified in ISO 8601 format. For more information about ISO 8601, go to
                *             the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a>
                *         </p>
                *         <p>Example: <code>2012-07-16T18:00:00Z</code>
                *         </p>
                */
            StartTime?: Date;
            /**
                * <p>A time value that requests only snapshots created at or before the specified time.
                *             The time value is specified in ISO 8601 format. For more information about ISO 8601, go
                *             to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia
                *                 page.</a>
                *         </p>
                *         <p>Example: <code>2012-07-16T18:00:00Z</code>
                *         </p>
                */
            EndTime?: Date;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value. </p>
                *         <p>Default: <code>100</code>
                *         </p>
                *         <p>Constraints: minimum 20, maximum 100.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <a>DescribeClusterSnapshots</a> request exceed
                *             the value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the
                *                 <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                */
            Marker?: string;
            /**
                * <p>The Amazon Web Services account used to create or copy the snapshot. Use this field to
                *             filter the results to snapshots owned by a particular account. To describe snapshots you
                *             own, either specify your Amazon Web Services account, or do not specify the
                *             parameter.</p>
                */
            OwnerAccount?: string;
            /**
                * <p>A tag key or keys for which you want to return all matching cluster snapshots that
                *             are associated with the specified key or keys. For example, suppose that you have
                *             snapshots that are tagged with keys called <code>owner</code> and
                *                 <code>environment</code>. If you specify both of these tag keys in the request,
                *             Amazon Redshift returns a response with the snapshots that have either or both of these tag
                *             keys associated with them.</p>
                */
            TagKeys?: string[];
            /**
                * <p>A tag value or values for which you want to return all matching cluster snapshots
                *             that are associated with the specified tag value or values. For example, suppose that
                *             you have snapshots that are tagged with values called <code>admin</code> and
                *                 <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift
                *             returns a response with the snapshots that have either or both of these tag values
                *             associated with them.</p>
                */
            TagValues?: string[];
            /**
                * <p>A value that indicates whether to return snapshots only for an existing cluster.
                *             You can perform table-level restore only by using a snapshot of an existing cluster,
                *             that is, a cluster that has not been deleted. Values for this parameter work as follows: </p>
                *         <ul>
                *             <li>
                *                 <p>If <code>ClusterExists</code> is set to <code>true</code>,
                *                         <code>ClusterIdentifier</code> is required.</p>
                *             </li>
                *             <li>
                *                 <p>If <code>ClusterExists</code> is set to <code>false</code> and
                *                         <code>ClusterIdentifier</code> isn't specified, all snapshots
                *                     associated with deleted clusters (orphaned snapshots) are returned. </p>
                *             </li>
                *             <li>
                *                 <p>If <code>ClusterExists</code> is set to <code>false</code> and
                *                         <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots
                *                     associated with that cluster are returned.</p>
                *             </li>
                *             <li>
                *                 <p>If <code>ClusterExists</code> is set to <code>false</code> and
                *                         <code>ClusterIdentifier</code> is specified for an existing cluster, no
                *                     snapshots are returned. </p>
                *             </li>
                *          </ul>
                */
            ClusterExists?: boolean;
            /**
                * <p></p>
                */
            SortingEntities?: SnapshotSortingEntity[];
    }
    export namespace DescribeClusterSnapshotsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeClusterSnapshotsMessage) => any;
    }
    /**
        * <p>Contains the output from the <a>DescribeClusterSnapshots</a> action.
        *         </p>
        */
    export interface SnapshotMessage {
            /**
                * <p>A value that indicates the starting point for the next set of response records in a
                *             subsequent request. If a value is returned in a response, you can retrieve the next set
                *             of records by providing this returned marker value in the <code>Marker</code> parameter
                *             and retrying the command. If the <code>Marker</code> field is empty, all response
                *             records have been retrieved for the request. </p>
                */
            Marker?: string;
            /**
                * <p>A list of <a>Snapshot</a> instances. </p>
                */
            Snapshots?: Snapshot[];
    }
    export namespace SnapshotMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SnapshotMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeClusterSubnetGroupsMessage {
            /**
                * <p>The name of the cluster subnet group for which information is requested.</p>
                */
            ClusterSubnetGroupName?: string;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value. </p>
                *         <p>Default: <code>100</code>
                *         </p>
                *         <p>Constraints: minimum 20, maximum 100.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <a>DescribeClusterSubnetGroups</a> request
                *             exceed the value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the
                *                 <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                */
            Marker?: string;
            /**
                * <p>A tag key or keys for which you want to return all matching cluster subnet groups
                *             that are associated with the specified key or keys. For example, suppose that you have
                *             subnet groups that are tagged with keys called <code>owner</code> and
                *                 <code>environment</code>. If you specify both of these tag keys in the request,
                *             Amazon Redshift returns a response with the subnet groups that have either or both of these
                *             tag keys associated with them.</p>
                */
            TagKeys?: string[];
            /**
                * <p>A tag value or values for which you want to return all matching cluster subnet
                *             groups that are associated with the specified tag value or values. For example, suppose
                *             that you have subnet groups that are tagged with values called <code>admin</code> and
                *                 <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift
                *             returns a response with the subnet groups that have either or both of these tag values
                *             associated with them.</p>
                */
            TagValues?: string[];
    }
    export namespace DescribeClusterSubnetGroupsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeClusterSubnetGroupsMessage) => any;
    }
    export interface DescribeClusterTracksMessage {
            /**
                * <p>The name of the maintenance track. </p>
                */
            MaintenanceTrackName?: string;
            /**
                * <p>An integer value for the maximum number of maintenance tracks to return.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <code>DescribeClusterTracks</code> request exceed the
                *             value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the
                *                 <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                */
            Marker?: string;
    }
    export namespace DescribeClusterTracksMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeClusterTracksMessage) => any;
    }
    /**
        * <p>Describes the operations that are allowed on a maintenance track.</p>
        */
    export interface SupportedOperation {
            /**
                * <p>A list of the supported operations.</p>
                */
            OperationName?: string;
    }
    export namespace SupportedOperation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SupportedOperation) => any;
    }
    /**
        * <p>A maintenance track that you can switch the current track to.</p>
        */
    export interface UpdateTarget {
            /**
                * <p>The name of the new maintenance track.</p>
                */
            MaintenanceTrackName?: string;
            /**
                * <p>The cluster version for the new maintenance track.</p>
                */
            DatabaseVersion?: string;
            /**
                * <p>A list of operations supported by the maintenance track.</p>
                */
            SupportedOperations?: SupportedOperation[];
    }
    export namespace UpdateTarget {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateTarget) => any;
    }
    /**
        * <p>Defines a maintenance track that determines which Amazon Redshift version to apply
        *             during a maintenance window. If the value for <code>MaintenanceTrack</code> is
        *                 <code>current</code>, the cluster is updated to the most recently certified
        *             maintenance release. If the value is <code>trailing</code>, the cluster is updated to
        *             the previously certified maintenance release. </p>
        */
    export interface MaintenanceTrack {
            /**
                * <p>The name of the maintenance track. Possible values are <code>current</code> and
                *                 <code>trailing</code>.</p>
                */
            MaintenanceTrackName?: string;
            /**
                * <p>The version number for the cluster release.</p>
                */
            DatabaseVersion?: string;
            /**
                * <p>An array of <a>UpdateTarget</a> objects to update with the maintenance
                *             track. </p>
                */
            UpdateTargets?: UpdateTarget[];
    }
    export namespace MaintenanceTrack {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: MaintenanceTrack) => any;
    }
    export interface TrackListMessage {
            /**
                * <p>A list of maintenance tracks output by the <code>DescribeClusterTracks</code>
                *             operation. </p>
                */
            MaintenanceTracks?: MaintenanceTrack[];
            /**
                * <p>The starting point to return a set of response tracklist records. You can retrieve the
                *             next set of response records by providing the returned marker value in the
                *                 <code>Marker</code> parameter and retrying the request.</p>
                */
            Marker?: string;
    }
    export namespace TrackListMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TrackListMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeClusterVersionsMessage {
            /**
                * <p>The specific cluster version to return.</p>
                *         <p>Example: <code>1.0</code>
                *         </p>
                */
            ClusterVersion?: string;
            /**
                * <p>The name of a specific cluster parameter group family to return details
                *             for.</p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Must be 1 to 255 alphanumeric characters</p>
                *             </li>
                *             <li>
                *                 <p>First character must be a letter</p>
                *             </li>
                *             <li>
                *                 <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
                *             </li>
                *          </ul>
                */
            ClusterParameterGroupFamily?: string;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value. </p>
                *         <p>Default: <code>100</code>
                *         </p>
                *         <p>Constraints: minimum 20, maximum 100.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <a>DescribeClusterVersions</a> request exceed
                *             the value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the
                *                 <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                */
            Marker?: string;
    }
    export namespace DescribeClusterVersionsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeClusterVersionsMessage) => any;
    }
    export interface DescribeDataSharesMessage {
            /**
                * <p>The identifier of the datashare to describe details of.</p>
                */
            DataShareArn?: string;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value. </p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDataShares</a> request exceed the value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p>
                */
            Marker?: string;
    }
    export namespace DescribeDataSharesMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeDataSharesMessage) => any;
    }
    export interface DescribeDataSharesResult {
            /**
                * <p>The results returned from describing datashares.</p>
                */
            DataShares?: DataShare[];
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDataShares</a> request exceed the value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p>
                */
            Marker?: string;
    }
    export namespace DescribeDataSharesResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeDataSharesResult) => any;
    }
    export interface DescribeDataSharesForConsumerMessage {
            /**
                * <p>The Amazon Resource Name (ARN) of the consumer that returns in the list of datashares.</p>
                */
            ConsumerArn?: string;
            /**
                * <p>An identifier giving the status of a datashare in the consumer cluster. If this field is specified, Amazon
                *             Redshift returns the list of datashares that have the specified status.</p>
                */
            Status?: DataShareStatusForConsumer | string;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value. </p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <a>DescribeDataSharesForConsumer</a> request
                *             exceed the value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the
                *             <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                */
            Marker?: string;
    }
    export namespace DescribeDataSharesForConsumerMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeDataSharesForConsumerMessage) => any;
    }
    export interface DescribeDataSharesForConsumerResult {
            /**
                * <p>Shows the results of datashares available for consumers.</p>
                */
            DataShares?: DataShare[];
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <a>DescribeDataSharesForConsumer</a> request
                *             exceed the value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the
                *             <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                */
            Marker?: string;
    }
    export namespace DescribeDataSharesForConsumerResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeDataSharesForConsumerResult) => any;
    }
    export interface DescribeDataSharesForProducerMessage {
            /**
                * <p>The Amazon Resource Name (ARN) of the producer that returns in the list of datashares.</p>
                */
            ProducerArn?: string;
            /**
                * <p>An identifier giving the status of a datashare in the producer. If this field is specified, Amazon
                *             Redshift returns the list of datashares that have the specified status.</p>
                */
            Status?: DataShareStatusForProducer | string;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value. </p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <a>DescribeDataSharesForProducer</a> request
                *             exceed the value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the
                *             <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                */
            Marker?: string;
    }
    export namespace DescribeDataSharesForProducerMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeDataSharesForProducerMessage) => any;
    }
    export interface DescribeDataSharesForProducerResult {
            /**
                * <p>Shows the results of datashares available for producers.</p>
                */
            DataShares?: DataShare[];
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <a>DescribeDataSharesForProducer</a> request
                *             exceed the value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the
                *             <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                */
            Marker?: string;
    }
    export namespace DescribeDataSharesForProducerResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeDataSharesForProducerResult) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeDefaultClusterParametersMessage {
            /**
                * <p>The name of the cluster parameter group family.</p>
                */
            ParameterGroupFamily: string | undefined;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value. </p>
                *         <p>Default: <code>100</code>
                *         </p>
                *         <p>Constraints: minimum 20, maximum 100.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <a>DescribeDefaultClusterParameters</a>
                *             request exceed the value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in
                *             the <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                */
            Marker?: string;
    }
    export namespace DescribeDefaultClusterParametersMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeDefaultClusterParametersMessage) => any;
    }
    export interface DescribeDefaultClusterParametersResult {
            /**
                * <p>Describes the default cluster parameters for a parameter group family.</p>
                */
            DefaultClusterParameters?: DefaultClusterParameters;
    }
    export namespace DescribeDefaultClusterParametersResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeDefaultClusterParametersResult) => any;
    }
    export interface DescribeEndpointAccessMessage {
            /**
                * <p>The cluster identifier associated with the described endpoint.</p>
                */
            ClusterIdentifier?: string;
            /**
                * <p>The Amazon Web Services account ID of the owner of the cluster.</p>
                */
            ResourceOwner?: string;
            /**
                * <p>The name of the endpoint to be described.</p>
                */
            EndpointName?: string;
            /**
                * <p>The virtual private cloud (VPC) identifier with access to the cluster.</p>
                */
            VpcId?: string;
            /**
                * <p>The maximum number of records to include in the response. If more records exist
                *             than the specified <code>MaxRecords</code> value, a pagination token called a <code>Marker</code> is
                *             included in the response so that the remaining results can be retrieved.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional pagination token provided by a previous
                *             <code>DescribeEndpointAccess</code> request. If this parameter is specified, the
                *             response includes only records beyond the marker, up to the value specified by the
                *             <code>MaxRecords</code> parameter.</p>
                */
            Marker?: string;
    }
    export namespace DescribeEndpointAccessMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeEndpointAccessMessage) => any;
    }
    export interface EndpointAccessList {
            /**
                * <p>The list of endpoints with access to the cluster.</p>
                */
            EndpointAccessList?: EndpointAccess[];
            /**
                * <p>An optional pagination token provided by a previous
                *             <code>DescribeEndpointAccess</code> request. If this parameter is specified, the
                *             response includes only records beyond the marker, up to the value specified by the
                *             <code>MaxRecords</code> parameter.</p>
                */
            Marker?: string;
    }
    export namespace EndpointAccessList {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EndpointAccessList) => any;
    }
    export interface DescribeEndpointAuthorizationMessage {
            /**
                * <p>The cluster identifier of the cluster to access.</p>
                */
            ClusterIdentifier?: string;
            /**
                * <p>The AAmazon Web Services account ID of either the cluster owner (grantor) or grantee.
                *        If <code>Grantee</code> parameter is true, then the <code>Account</code> value is of the grantor.</p>
                */
            Account?: string;
            /**
                * <p>Indicates whether to check authorization from a grantor or grantee point of view.
                *            If true, Amazon Redshift returns endpoint authorizations that you've been granted.
                *            If false (default), checks authorization from a grantor point of view.</p>
                */
            Grantee?: boolean;
            /**
                * <p>The maximum number of records to include in the response. If more records exist
                *             than the specified <code>MaxRecords</code> value, a pagination token called a <code>Marker</code> is
                *             included in the response so that the remaining results can be retrieved.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional pagination token provided by a previous
                *             <code>DescribeEndpointAuthorization</code> request. If this parameter is specified, the
                *             response includes only records beyond the marker, up to the value specified by the
                *             <code>MaxRecords</code> parameter.</p>
                */
            Marker?: string;
    }
    export namespace DescribeEndpointAuthorizationMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeEndpointAuthorizationMessage) => any;
    }
    export interface EndpointAuthorizationList {
            /**
                * <p>The authorizations to an endpoint.</p>
                */
            EndpointAuthorizationList?: EndpointAuthorization[];
            /**
                * <p>An optional pagination token provided by a previous
                *             <code>DescribeEndpointAuthorization</code> request. If this parameter is specified, the
                *             response includes only records beyond the marker, up to the value specified by the
                *             <code>MaxRecords</code> parameter.</p>
                */
            Marker?: string;
    }
    export namespace EndpointAuthorizationList {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EndpointAuthorizationList) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeEventCategoriesMessage {
            /**
                * <p>The source type, such as cluster or parameter group, to which the described event
                *             categories apply.</p>
                *         <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.</p>
                */
            SourceType?: string;
    }
    export namespace DescribeEventCategoriesMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeEventCategoriesMessage) => any;
    }
    /**
        * <p>Describes event information.</p>
        */
    export interface EventInfoMap {
            /**
                * <p>The identifier of an Amazon Redshift event.</p>
                */
            EventId?: string;
            /**
                * <p>The category of an Amazon Redshift event.</p>
                */
            EventCategories?: string[];
            /**
                * <p>The description of an Amazon Redshift event.</p>
                */
            EventDescription?: string;
            /**
                * <p>The severity of the event.</p>
                *         <p>Values: ERROR, INFO</p>
                */
            Severity?: string;
    }
    export namespace EventInfoMap {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EventInfoMap) => any;
    }
    /**
        * <p>Describes event categories.</p>
        */
    export interface EventCategoriesMap {
            /**
                * <p>The source type, such as cluster or cluster-snapshot, that the returned categories
                *             belong to.</p>
                */
            SourceType?: string;
            /**
                * <p>The events in the event category.</p>
                */
            Events?: EventInfoMap[];
    }
    export namespace EventCategoriesMap {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EventCategoriesMap) => any;
    }
    /**
        * <p></p>
        */
    export interface EventCategoriesMessage {
            /**
                * <p>A list of event categories descriptions.</p>
                */
            EventCategoriesMapList?: EventCategoriesMap[];
    }
    export namespace EventCategoriesMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EventCategoriesMessage) => any;
    }
    export type SourceType = "cluster" | "cluster-parameter-group" | "cluster-security-group" | "cluster-snapshot" | "scheduled-action";
    /**
        * <p></p>
        */
    export interface DescribeEventsMessage {
            /**
                * <p>The identifier of the event source for which events will be returned. If this
                *             parameter is not specified, then all sources are included in the response.</p>
                *         <p>Constraints:</p>
                *         <p>If <i>SourceIdentifier</i> is supplied,
                *                 <i>SourceType</i> must also be provided.</p>
                *         <ul>
                *             <li>
                *                 <p>Specify a cluster identifier when <i>SourceType</i> is
                *                         <code>cluster</code>.</p>
                *             </li>
                *             <li>
                *                 <p>Specify a cluster security group name when <i>SourceType</i>
                *                     is <code>cluster-security-group</code>.</p>
                *             </li>
                *             <li>
                *                 <p>Specify a cluster parameter group name when <i>SourceType</i>
                *                     is <code>cluster-parameter-group</code>.</p>
                *             </li>
                *             <li>
                *                 <p>Specify a cluster snapshot identifier when <i>SourceType</i>
                *                     is <code>cluster-snapshot</code>.</p>
                *             </li>
                *          </ul>
                */
            SourceIdentifier?: string;
            /**
                * <p>The event source to retrieve events for. If no value is specified, all events are
                *             returned.</p>
                *         <p>Constraints:</p>
                *         <p>If <i>SourceType</i> is supplied,
                *                 <i>SourceIdentifier</i> must also be provided.</p>
                *         <ul>
                *             <li>
                *                 <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is
                *                     a cluster identifier.</p>
                *             </li>
                *             <li>
                *                 <p>Specify <code>cluster-security-group</code> when
                *                         <i>SourceIdentifier</i> is a cluster security group
                *                     name.</p>
                *             </li>
                *             <li>
                *                 <p>Specify <code>cluster-parameter-group</code> when
                *                         <i>SourceIdentifier</i> is a cluster parameter group
                *                     name.</p>
                *             </li>
                *             <li>
                *                 <p>Specify <code>cluster-snapshot</code> when
                *                         <i>SourceIdentifier</i> is a cluster snapshot
                *                     identifier.</p>
                *             </li>
                *          </ul>
                */
            SourceType?: SourceType | string;
            /**
                * <p>The beginning of the time interval to retrieve events for, specified in ISO 8601
                *             format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a>
                *         </p>
                *         <p>Example: <code>2009-07-08T18:00Z</code>
                *         </p>
                */
            StartTime?: Date;
            /**
                * <p>The end of the time interval for which to retrieve events, specified in ISO 8601
                *             format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a>
                *         </p>
                *         <p>Example: <code>2009-07-08T18:00Z</code>
                *         </p>
                */
            EndTime?: Date;
            /**
                * <p>The number of minutes prior to the time of the request for which to retrieve
                *             events. For example, if the request is sent at 18:00 and you specify a duration of 60,
                *             then only events which have occurred after 17:00 will be returned.</p>
                *         <p>Default: <code>60</code>
                *         </p>
                */
            Duration?: number;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value. </p>
                *         <p>Default: <code>100</code>
                *         </p>
                *         <p>Constraints: minimum 20, maximum 100.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <a>DescribeEvents</a> request exceed the value
                *             specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the <code>Marker</code>
                *             field of the response. You can retrieve the next set of response records by providing
                *             the returned marker value in the <code>Marker</code> parameter and retrying the request.
                *         </p>
                */
            Marker?: string;
    }
    export namespace DescribeEventsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeEventsMessage) => any;
    }
    /**
        * <p>Describes an event.</p>
        */
    export interface Event {
            /**
                * <p>The identifier for the source of the event.</p>
                */
            SourceIdentifier?: string;
            /**
                * <p>The source type for this event.</p>
                */
            SourceType?: SourceType | string;
            /**
                * <p>The text of this event.</p>
                */
            Message?: string;
            /**
                * <p>A list of the event categories.</p>
                *         <p>Values: Configuration, Management, Monitoring, Security, Pending</p>
                */
            EventCategories?: string[];
            /**
                * <p>The severity of the event.</p>
                *         <p>Values: ERROR, INFO</p>
                */
            Severity?: string;
            /**
                * <p>The date and time of the event.</p>
                */
            Date?: Date;
            /**
                * <p>The identifier of the event.</p>
                */
            EventId?: string;
    }
    export namespace Event {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Event) => any;
    }
    /**
        * <p></p>
        */
    export interface EventsMessage {
            /**
                * <p>A value that indicates the starting point for the next set of response records in a
                *             subsequent request. If a value is returned in a response, you can retrieve the next set
                *             of records by providing this returned marker value in the <code>Marker</code> parameter
                *             and retrying the command. If the <code>Marker</code> field is empty, all response
                *             records have been retrieved for the request. </p>
                */
            Marker?: string;
            /**
                * <p>A list of <code>Event</code> instances. </p>
                */
            Events?: Event[];
    }
    export namespace EventsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EventsMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeEventSubscriptionsMessage {
            /**
                * <p>The name of the Amazon Redshift event notification subscription to be
                *             described.</p>
                */
            SubscriptionName?: string;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value. </p>
                *         <p>Default: <code>100</code>
                *         </p>
                *         <p>Constraints: minimum 20, maximum 100.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a DescribeEventSubscriptions request exceed the value
                *             specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the <code>Marker</code>
                *             field of the response. You can retrieve the next set of response records by providing
                *             the returned marker value in the <code>Marker</code> parameter and retrying the request.
                *         </p>
                */
            Marker?: string;
            /**
                * <p>A tag key or keys for which you want to return all matching event notification
                *             subscriptions that are associated with the specified key or keys. For example, suppose
                *             that you have subscriptions that are tagged with keys called <code>owner</code> and
                *                 <code>environment</code>. If you specify both of these tag keys in the request,
                *             Amazon Redshift returns a response with the subscriptions that have either or both of these
                *             tag keys associated with them.</p>
                */
            TagKeys?: string[];
            /**
                * <p>A tag value or values for which you want to return all matching event notification
                *             subscriptions that are associated with the specified tag value or values. For example,
                *             suppose that you have subscriptions that are tagged with values called
                *                 <code>admin</code> and <code>test</code>. If you specify both of these tag values in
                *             the request, Amazon Redshift returns a response with the subscriptions that have either or
                *             both of these tag values associated with them.</p>
                */
            TagValues?: string[];
    }
    export namespace DescribeEventSubscriptionsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeEventSubscriptionsMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface EventSubscriptionsMessage {
            /**
                * <p>A value that indicates the starting point for the next set of response records in a
                *             subsequent request. If a value is returned in a response, you can retrieve the next set
                *             of records by providing this returned marker value in the <code>Marker</code> parameter
                *             and retrying the command. If the <code>Marker</code> field is empty, all response
                *             records have been retrieved for the request. </p>
                */
            Marker?: string;
            /**
                * <p>A list of event subscriptions.</p>
                */
            EventSubscriptionsList?: EventSubscription[];
    }
    export namespace EventSubscriptionsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EventSubscriptionsMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeHsmClientCertificatesMessage {
            /**
                * <p>The identifier of a specific HSM client certificate for which you want information.
                *             If no identifier is specified, information is returned for all HSM client certificates
                *             owned by your Amazon Web Services account.</p>
                */
            HsmClientCertificateIdentifier?: string;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value. </p>
                *         <p>Default: <code>100</code>
                *         </p>
                *         <p>Constraints: minimum 20, maximum 100.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <a>DescribeHsmClientCertificates</a> request
                *             exceed the value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the
                *                 <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                */
            Marker?: string;
            /**
                * <p>A tag key or keys for which you want to return all matching HSM client certificates
                *             that are associated with the specified key or keys. For example, suppose that you have
                *             HSM client certificates that are tagged with keys called <code>owner</code> and
                *                 <code>environment</code>. If you specify both of these tag keys in the request,
                *             Amazon Redshift returns a response with the HSM client certificates that have either or both
                *             of these tag keys associated with them.</p>
                */
            TagKeys?: string[];
            /**
                * <p>A tag value or values for which you want to return all matching HSM client
                *             certificates that are associated with the specified tag value or values. For example,
                *             suppose that you have HSM client certificates that are tagged with values called
                *                 <code>admin</code> and <code>test</code>. If you specify both of these tag values in
                *             the request, Amazon Redshift returns a response with the HSM client certificates that have
                *             either or both of these tag values associated with them.</p>
                */
            TagValues?: string[];
    }
    export namespace DescribeHsmClientCertificatesMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeHsmClientCertificatesMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface HsmClientCertificateMessage {
            /**
                * <p>A value that indicates the starting point for the next set of response records in a
                *             subsequent request. If a value is returned in a response, you can retrieve the next set
                *             of records by providing this returned marker value in the <code>Marker</code> parameter
                *             and retrying the command. If the <code>Marker</code> field is empty, all response
                *             records have been retrieved for the request. </p>
                */
            Marker?: string;
            /**
                * <p>A list of the identifiers for one or more HSM client certificates used by Amazon Redshift
                *             clusters to store and retrieve database encryption keys in an HSM.</p>
                */
            HsmClientCertificates?: HsmClientCertificate[];
    }
    export namespace HsmClientCertificateMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: HsmClientCertificateMessage) => any;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_1' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { ActionType, AquaConfiguration, AquaConfigurationStatus, AvailabilityZone, Cluster, ClusterSecurityGroup, ClusterSubnetGroup, EventSubscription, HsmConfiguration, Parameter, RecurringCharge, ReservedNode, ReservedNodeExchangeStatus, ReservedNodeOfferingType, ScheduledAction, ScheduledActionType, Snapshot, SnapshotCopyGrant, SnapshotSchedule, Tag, UsageLimit, UsageLimitBreachAction, UsageLimitFeatureType } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/models_0";
    import { RedshiftServiceException as __BaseException } from "@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/RedshiftServiceException";
    /**
        * <p></p>
        */
    export interface DescribeHsmConfigurationsMessage {
            /**
                * <p>The identifier of a specific Amazon Redshift HSM configuration to be described. If no
                *             identifier is specified, information is returned for all HSM configurations owned by
                *             your Amazon Web Services account.</p>
                */
            HsmConfigurationIdentifier?: string;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value. </p>
                *         <p>Default: <code>100</code>
                *         </p>
                *         <p>Constraints: minimum 20, maximum 100.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <a>DescribeHsmConfigurations</a> request
                *             exceed the value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the
                *                 <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                */
            Marker?: string;
            /**
                * <p>A tag key or keys for which you want to return all matching HSM configurations that
                *             are associated with the specified key or keys. For example, suppose that you have HSM
                *             configurations that are tagged with keys called <code>owner</code> and
                *                 <code>environment</code>. If you specify both of these tag keys in the request,
                *             Amazon Redshift returns a response with the HSM configurations that have either or both of
                *             these tag keys associated with them.</p>
                */
            TagKeys?: string[];
            /**
                * <p>A tag value or values for which you want to return all matching HSM configurations
                *             that are associated with the specified tag value or values. For example, suppose that
                *             you have HSM configurations that are tagged with values called <code>admin</code> and
                *                 <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift
                *             returns a response with the HSM configurations that have either or both of these tag
                *             values associated with them.</p>
                */
            TagValues?: string[];
    }
    export namespace DescribeHsmConfigurationsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeHsmConfigurationsMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface HsmConfigurationMessage {
            /**
                * <p>A value that indicates the starting point for the next set of response records in a
                *             subsequent request. If a value is returned in a response, you can retrieve the next set
                *             of records by providing this returned marker value in the <code>Marker</code> parameter
                *             and retrying the command. If the <code>Marker</code> field is empty, all response
                *             records have been retrieved for the request. </p>
                */
            Marker?: string;
            /**
                * <p>A list of <code>HsmConfiguration</code> objects.</p>
                */
            HsmConfigurations?: HsmConfiguration[];
    }
    export namespace HsmConfigurationMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: HsmConfigurationMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeLoggingStatusMessage {
            /**
                * <p>The identifier of the cluster from which to get the logging status.</p>
                *         <p>Example: <code>examplecluster</code>
                *         </p>
                */
            ClusterIdentifier: string | undefined;
    }
    export namespace DescribeLoggingStatusMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeLoggingStatusMessage) => any;
    }
    export enum LogDestinationType {
            CLOUDWATCH = "cloudwatch",
            S3 = "s3"
    }
    /**
        * <p>Describes the status of logging for a cluster.</p>
        */
    export interface LoggingStatus {
            /**
                * <p>
                *             <code>true</code> if logging is on, <code>false</code> if logging is off.</p>
                */
            LoggingEnabled?: boolean;
            /**
                * <p>The name of the S3 bucket where the log files are stored.</p>
                */
            BucketName?: string;
            /**
                * <p>The prefix applied to the log file names.</p>
                */
            S3KeyPrefix?: string;
            /**
                * <p>The last time that logs were delivered.</p>
                */
            LastSuccessfulDeliveryTime?: Date;
            /**
                * <p>The last time when logs failed to be delivered.</p>
                */
            LastFailureTime?: Date;
            /**
                * <p>The message indicating that logs failed to be delivered.</p>
                */
            LastFailureMessage?: string;
            /**
                * <p>The log destination type. An enum with possible values of <code>s3</code> and <code>cloudwatch</code>.</p>
                */
            LogDestinationType?: LogDestinationType | string;
            /**
                * <p>The collection of exported log types. Log types include the connection log, user log and user activity log.</p>
                */
            LogExports?: string[];
    }
    export namespace LoggingStatus {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LoggingStatus) => any;
    }
    export enum NodeConfigurationOptionsFilterName {
            ESTIMATED_DISK_UTILIZATION_PERCENT = "EstimatedDiskUtilizationPercent",
            MODE = "Mode",
            NODE_TYPE = "NodeType",
            NUM_NODES = "NumberOfNodes"
    }
    export enum OperatorType {
            BETWEEN = "between",
            EQ = "eq",
            GE = "ge",
            GT = "gt",
            IN = "in",
            LE = "le",
            LT = "lt"
    }
    /**
        * <p>A set of elements to filter the returned node configurations.</p>
        */
    export interface NodeConfigurationOptionsFilter {
            /**
                * <p>The name of the element to filter.</p>
                */
            Name?: NodeConfigurationOptionsFilterName | string;
            /**
                * <p>The filter operator.
                *             If filter Name is NodeType only the 'in' operator is supported.
                *             Provide one value to evaluate for 'eq', 'lt', 'le', 'gt', and 'ge'.
                *             Provide two values to evaluate for 'between'.
                *             Provide a list of values for 'in'.</p>
                */
            Operator?: OperatorType | string;
            /**
                * <p>List of values. Compare Name using Operator to Values.
                *             If filter Name is NumberOfNodes, then values can range from 0 to 200.
                *             If filter Name is EstimatedDiskUtilizationPercent, then values can range from 0 to 100.
                *             For example, filter NumberOfNodes (name) GT (operator) 3 (values).</p>
                */
            Values?: string[];
    }
    export namespace NodeConfigurationOptionsFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: NodeConfigurationOptionsFilter) => any;
    }
    export interface DescribeNodeConfigurationOptionsMessage {
            /**
                * <p>The action type to evaluate for possible node configurations.
                *             Specify "restore-cluster" to get configuration combinations based on an existing snapshot.
                *             Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot.
                *             Specify "resize-cluster" to get configuration combinations for elastic resize based on an existing cluster.
                *         </p>
                */
            ActionType: ActionType | string | undefined;
            /**
                * <p>The identifier of the cluster to evaluate for possible node configurations.</p>
                */
            ClusterIdentifier?: string;
            /**
                * <p>The identifier of the snapshot to evaluate for possible node configurations.</p>
                */
            SnapshotIdentifier?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the snapshot associated with the message to describe node configuration.</p>
                */
            SnapshotArn?: string;
            /**
                * <p>The Amazon Web Services account used to create or copy the snapshot.
                *             Required if you are restoring a snapshot you do not own,
                *             optional if you own the snapshot.</p>
                */
            OwnerAccount?: string;
            /**
                * <p>A set of name, operator, and value items to filter the results.</p>
                */
            Filters?: NodeConfigurationOptionsFilter[];
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <a>DescribeNodeConfigurationOptions</a> request
                *             exceed the value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the
                *             <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                */
            Marker?: string;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value. </p>
                *         <p>Default: <code>500</code>
                *         </p>
                *         <p>Constraints: minimum 100, maximum 500.</p>
                */
            MaxRecords?: number;
    }
    export namespace DescribeNodeConfigurationOptionsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeNodeConfigurationOptionsMessage) => any;
    }
    export enum Mode {
            HIGH_PERFORMANCE = "high-performance",
            STANDARD = "standard"
    }
    /**
        * <p>A list of node configurations.</p>
        */
    export interface NodeConfigurationOption {
            /**
                * <p>The node type, such as, "ds2.8xlarge".</p>
                */
            NodeType?: string;
            /**
                * <p>The number of nodes.</p>
                */
            NumberOfNodes?: number;
            /**
                * <p>The estimated disk utilizaton percentage.</p>
                */
            EstimatedDiskUtilizationPercent?: number;
            /**
                * <p>The category of the node configuration recommendation.</p>
                */
            Mode?: Mode | string;
    }
    export namespace NodeConfigurationOption {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: NodeConfigurationOption) => any;
    }
    export interface NodeConfigurationOptionsMessage {
            /**
                * <p>A list of valid node configurations.</p>
                */
            NodeConfigurationOptionList?: NodeConfigurationOption[];
            /**
                * <p>A value that indicates the starting point for the next set of response records in a
                *             subsequent request. If a value is returned in a response, you can retrieve the next set
                *             of records by providing this returned marker value in the <code>Marker</code> parameter
                *             and retrying the command. If the <code>Marker</code> field is empty, all response
                *             records have been retrieved for the request. </p>
                */
            Marker?: string;
    }
    export namespace NodeConfigurationOptionsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: NodeConfigurationOptionsMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeOrderableClusterOptionsMessage {
            /**
                * <p>The version filter value. Specify this parameter to show only the available
                *             offerings matching the specified version.</p>
                *         <p>Default: All versions.</p>
                *         <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
                */
            ClusterVersion?: string;
            /**
                * <p>The node type filter value. Specify this parameter to show only the available
                *             offerings matching the specified node type.</p>
                */
            NodeType?: string;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value. </p>
                *         <p>Default: <code>100</code>
                *         </p>
                *         <p>Constraints: minimum 20, maximum 100.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <a>DescribeOrderableClusterOptions</a> request
                *             exceed the value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the
                *                 <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                */
            Marker?: string;
    }
    export namespace DescribeOrderableClusterOptionsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeOrderableClusterOptionsMessage) => any;
    }
    /**
        * <p>Describes an orderable cluster option.</p>
        */
    export interface OrderableClusterOption {
            /**
                * <p>The version of the orderable cluster.</p>
                */
            ClusterVersion?: string;
            /**
                * <p>The cluster type, for example <code>multi-node</code>. </p>
                */
            ClusterType?: string;
            /**
                * <p>The node type for the orderable cluster.</p>
                */
            NodeType?: string;
            /**
                * <p>A list of availability zones for the orderable cluster.</p>
                */
            AvailabilityZones?: AvailabilityZone[];
    }
    export namespace OrderableClusterOption {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OrderableClusterOption) => any;
    }
    /**
        * <p>Contains the output from the <a>DescribeOrderableClusterOptions</a>
        *             action. </p>
        */
    export interface OrderableClusterOptionsMessage {
            /**
                * <p>An <code>OrderableClusterOption</code> structure containing information about
                *             orderable options for the cluster.</p>
                */
            OrderableClusterOptions?: OrderableClusterOption[];
            /**
                * <p>A value that indicates the starting point for the next set of response records in a
                *             subsequent request. If a value is returned in a response, you can retrieve the next set
                *             of records by providing this returned marker value in the <code>Marker</code> parameter
                *             and retrying the command. If the <code>Marker</code> field is empty, all response
                *             records have been retrieved for the request. </p>
                */
            Marker?: string;
    }
    export namespace OrderableClusterOptionsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OrderableClusterOptionsMessage) => any;
    }
    export interface DescribePartnersInputMessage {
            /**
                * <p>The Amazon Web Services account ID that owns the cluster.</p>
                */
            AccountId: string | undefined;
            /**
                * <p>The cluster identifier of the cluster whose partner integration is being described.</p>
                */
            ClusterIdentifier: string | undefined;
            /**
                * <p>The name of the database whose partner integration is being described. If database name is not specified, then all databases in the cluster are described.</p>
                */
            DatabaseName?: string;
            /**
                * <p>The name of the partner that is being described. If partner name is not specified, then all partner integrations are described.</p>
                */
            PartnerName?: string;
    }
    export namespace DescribePartnersInputMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribePartnersInputMessage) => any;
    }
    export enum PartnerIntegrationStatus {
            Active = "Active",
            ConnectionFailure = "ConnectionFailure",
            Inactive = "Inactive",
            RuntimeFailure = "RuntimeFailure"
    }
    /**
        * <p>Describes a partner integration.</p>
        */
    export interface PartnerIntegrationInfo {
            /**
                * <p>The name of the database that receives data from a partner.</p>
                */
            DatabaseName?: string;
            /**
                * <p>The name of the partner.</p>
                */
            PartnerName?: string;
            /**
                * <p>The partner integration status.</p>
                */
            Status?: PartnerIntegrationStatus | string;
            /**
                * <p>The status message provided by the partner.</p>
                */
            StatusMessage?: string;
            /**
                * <p>The date (UTC) that the partner integration was created.</p>
                */
            CreatedAt?: Date;
            /**
                * <p>The date (UTC) that the partner integration status was last updated by the partner.</p>
                */
            UpdatedAt?: Date;
    }
    export namespace PartnerIntegrationInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PartnerIntegrationInfo) => any;
    }
    export interface DescribePartnersOutputMessage {
            /**
                * <p>A list of partner integrations.</p>
                */
            PartnerIntegrationInfoList?: PartnerIntegrationInfo[];
    }
    export namespace DescribePartnersOutputMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribePartnersOutputMessage) => any;
    }
    export interface DescribeReservedNodeExchangeStatusInputMessage {
            /**
                * <p>The identifier of the source reserved node in a reserved-node exchange request.</p>
                */
            ReservedNodeId?: string;
            /**
                * <p>The identifier of the reserved-node exchange request.</p>
                */
            ReservedNodeExchangeRequestId?: string;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>Marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional pagination token provided by a previous <code>DescribeReservedNodeExchangeStatus</code> request. If this
                *             parameter is specified, the response includes only records beyond the marker, up to the value
                *             specified by the <code>MaxRecords</code> parameter. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request.</p>
                */
            Marker?: string;
    }
    export namespace DescribeReservedNodeExchangeStatusInputMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeReservedNodeExchangeStatusInputMessage) => any;
    }
    export interface DescribeReservedNodeExchangeStatusOutputMessage {
            /**
                * <p>The details of the reserved-node exchange request, including the status, request
                *             time, source reserved-node identifier, and additional details.</p>
                */
            ReservedNodeExchangeStatusDetails?: ReservedNodeExchangeStatus[];
            /**
                * <p>A pagination token provided by a previous <code>DescribeReservedNodeExchangeStatus</code> request.</p>
                */
            Marker?: string;
    }
    export namespace DescribeReservedNodeExchangeStatusOutputMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeReservedNodeExchangeStatusOutputMessage) => any;
    }
    /**
        * <p>The reserved-node exchange status wasn't found.</p>
        */
    export class ReservedNodeExchangeNotFoundFault extends __BaseException {
            readonly name: "ReservedNodeExchangeNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ReservedNodeExchangeNotFoundFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export interface DescribeReservedNodeOfferingsMessage {
            /**
                * <p>The unique identifier for the offering.</p>
                */
            ReservedNodeOfferingId?: string;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value. </p>
                *         <p>Default: <code>100</code>
                *         </p>
                *         <p>Constraints: minimum 20, maximum 100.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <a>DescribeReservedNodeOfferings</a> request
                *             exceed the value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the
                *                 <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                */
            Marker?: string;
    }
    export namespace DescribeReservedNodeOfferingsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeReservedNodeOfferingsMessage) => any;
    }
    /**
        * <p>Describes a reserved node offering.</p>
        */
    export interface ReservedNodeOffering {
            /**
                * <p>The offering identifier.</p>
                */
            ReservedNodeOfferingId?: string;
            /**
                * <p>The node type offered by the reserved node offering.</p>
                */
            NodeType?: string;
            /**
                * <p>The duration, in seconds, for which the offering will reserve the node.</p>
                */
            Duration?: number;
            /**
                * <p>The upfront fixed charge you will pay to purchase the specific reserved node
                *             offering.</p>
                */
            FixedPrice?: number;
            /**
                * <p>The rate you are charged for each hour the cluster that is using the offering is
                *             running.</p>
                */
            UsagePrice?: number;
            /**
                * <p>The currency code for the compute nodes offering.</p>
                */
            CurrencyCode?: string;
            /**
                * <p>The anticipated utilization of the reserved node, as defined in the reserved node
                *             offering.</p>
                */
            OfferingType?: string;
            /**
                * <p>The charge to your account regardless of whether you are creating any clusters
                *             using the node offering. Recurring charges are only in effect for heavy-utilization
                *             reserved nodes.</p>
                */
            RecurringCharges?: RecurringCharge[];
            /**
                * <p></p>
                */
            ReservedNodeOfferingType?: ReservedNodeOfferingType | string;
    }
    export namespace ReservedNodeOffering {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReservedNodeOffering) => any;
    }
    /**
        * <p></p>
        */
    export interface ReservedNodeOfferingsMessage {
            /**
                * <p>A value that indicates the starting point for the next set of response records in a
                *             subsequent request. If a value is returned in a response, you can retrieve the next set
                *             of records by providing this returned marker value in the <code>Marker</code> parameter
                *             and retrying the command. If the <code>Marker</code> field is empty, all response
                *             records have been retrieved for the request. </p>
                */
            Marker?: string;
            /**
                * <p>A list of <code>ReservedNodeOffering</code> objects.</p>
                */
            ReservedNodeOfferings?: ReservedNodeOffering[];
    }
    export namespace ReservedNodeOfferingsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReservedNodeOfferingsMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeReservedNodesMessage {
            /**
                * <p>Identifier for the node reservation.</p>
                */
            ReservedNodeId?: string;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value. </p>
                *         <p>Default: <code>100</code>
                *         </p>
                *         <p>Constraints: minimum 20, maximum 100.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <a>DescribeReservedNodes</a> request exceed
                *             the value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the
                *                 <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                */
            Marker?: string;
    }
    export namespace DescribeReservedNodesMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeReservedNodesMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface ReservedNodesMessage {
            /**
                * <p>A value that indicates the starting point for the next set of response records in a
                *             subsequent request. If a value is returned in a response, you can retrieve the next set
                *             of records by providing this returned marker value in the <code>Marker</code> parameter
                *             and retrying the command. If the <code>Marker</code> field is empty, all response
                *             records have been retrieved for the request. </p>
                */
            Marker?: string;
            /**
                * <p>The list of <code>ReservedNode</code> objects.</p>
                */
            ReservedNodes?: ReservedNode[];
    }
    export namespace ReservedNodesMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReservedNodesMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeResizeMessage {
            /**
                * <p>The unique identifier of a cluster whose resize progress you are requesting. This
                *             parameter is case-sensitive.</p>
                *         <p>By default, resize operations for all clusters defined for an Amazon Web Services account are
                *             returned.</p>
                */
            ClusterIdentifier: string | undefined;
    }
    export namespace DescribeResizeMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeResizeMessage) => any;
    }
    export enum ScheduledActionFilterName {
            CLUSTER_IDENTIFIER = "cluster-identifier",
            IAM_ROLE = "iam-role"
    }
    /**
        * <p>A set of elements to filter the returned scheduled actions. </p>
        */
    export interface ScheduledActionFilter {
            /**
                * <p>The type of element to filter. </p>
                */
            Name: ScheduledActionFilterName | string | undefined;
            /**
                * <p>List of values. Compare if the value (of type defined by <code>Name</code>) equals an item in the list of scheduled actions. </p>
                */
            Values: string[] | undefined;
    }
    export namespace ScheduledActionFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ScheduledActionFilter) => any;
    }
    export enum ScheduledActionTypeValues {
            PAUSE_CLUSTER = "PauseCluster",
            RESIZE_CLUSTER = "ResizeCluster",
            RESUME_CLUSTER = "ResumeCluster"
    }
    export interface DescribeScheduledActionsMessage {
            /**
                * <p>The name of the scheduled action to retrieve. </p>
                */
            ScheduledActionName?: string;
            /**
                * <p>The type of the scheduled actions to retrieve. </p>
                */
            TargetActionType?: ScheduledActionTypeValues | string;
            /**
                * <p>The start time in UTC of the scheduled actions to retrieve.
                *             Only active scheduled actions that have invocations after this time are retrieved.</p>
                */
            StartTime?: Date;
            /**
                * <p>The end time in UTC of the scheduled action to retrieve.
                *             Only active scheduled actions that have invocations before this time are retrieved.</p>
                */
            EndTime?: Date;
            /**
                * <p>If true, retrieve only active scheduled actions.
                *            If false, retrieve only disabled scheduled actions. </p>
                */
            Active?: boolean;
            /**
                * <p>List of scheduled action filters. </p>
                */
            Filters?: ScheduledActionFilter[];
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <a>DescribeScheduledActions</a> request
                *             exceed the value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the
                *             <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                */
            Marker?: string;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value. </p>
                *             <p>Default: <code>100</code>
                *             </p>
                *             <p>Constraints: minimum 20, maximum 100.</p>
                */
            MaxRecords?: number;
    }
    export namespace DescribeScheduledActionsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeScheduledActionsMessage) => any;
    }
    export interface ScheduledActionsMessage {
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <a>DescribeScheduledActions</a> request
                *             exceed the value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the
                *             <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                */
            Marker?: string;
            /**
                * <p>List of retrieved scheduled actions. </p>
                */
            ScheduledActions?: ScheduledAction[];
    }
    export namespace ScheduledActionsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ScheduledActionsMessage) => any;
    }
    /**
        * <p>The result of the <code>DescribeSnapshotCopyGrants</code> action.</p>
        */
    export interface DescribeSnapshotCopyGrantsMessage {
            /**
                * <p>The name of the snapshot copy grant.</p>
                */
            SnapshotCopyGrantName?: string;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value. </p>
                *         <p>Default: <code>100</code>
                *         </p>
                *         <p>Constraints: minimum 20, maximum 100.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the
                *             value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the
                *                 <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                *         <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
                */
            Marker?: string;
            /**
                * <p>A tag key or keys for which you want to return all matching resources that are
                *             associated with the specified key or keys. For example, suppose that you have resources
                *             tagged with keys called <code>owner</code> and <code>environment</code>. If you specify
                *             both of these tag keys in the request, Amazon Redshift returns a response with all resources
                *             that have either or both of these tag keys associated with them.</p>
                */
            TagKeys?: string[];
            /**
                * <p>A tag value or values for which you want to return all matching resources that are
                *             associated with the specified value or values. For example, suppose that you have
                *             resources tagged with values called <code>admin</code> and <code>test</code>. If you
                *             specify both of these tag values in the request, Amazon Redshift returns a response with all
                *             resources that have either or both of these tag values associated with them.</p>
                */
            TagValues?: string[];
    }
    export namespace DescribeSnapshotCopyGrantsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeSnapshotCopyGrantsMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface SnapshotCopyGrantMessage {
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the
                *             value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the
                *                 <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                *         <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
                */
            Marker?: string;
            /**
                * <p>The list of <code>SnapshotCopyGrant</code> objects.</p>
                */
            SnapshotCopyGrants?: SnapshotCopyGrant[];
    }
    export namespace SnapshotCopyGrantMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SnapshotCopyGrantMessage) => any;
    }
    export interface DescribeSnapshotSchedulesMessage {
            /**
                * <p>The unique identifier for the cluster whose snapshot schedules you want to
                *             view.</p>
                */
            ClusterIdentifier?: string;
            /**
                * <p>A unique identifier for a snapshot schedule.</p>
                */
            ScheduleIdentifier?: string;
            /**
                * <p>The key value for a snapshot schedule tag.</p>
                */
            TagKeys?: string[];
            /**
                * <p>The value corresponding to the key of the snapshot schedule tag.</p>
                */
            TagValues?: string[];
            /**
                * <p>A value that indicates the starting point for the next set of response records in a
                *             subsequent request. If a value is returned in a response, you can retrieve the next set
                *             of records by providing this returned marker value in the <code>marker</code> parameter
                *             and retrying the command. If the <code>marker</code> field is empty, all response
                *             records have been retrieved for the request.</p>
                */
            Marker?: string;
            /**
                * <p>The maximum number or response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned <code>marker</code>
                *             value.</p>
                */
            MaxRecords?: number;
    }
    export namespace DescribeSnapshotSchedulesMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeSnapshotSchedulesMessage) => any;
    }
    export interface DescribeSnapshotSchedulesOutputMessage {
            /**
                * <p>A list of SnapshotSchedules.</p>
                */
            SnapshotSchedules?: SnapshotSchedule[];
            /**
                * <p>A value that indicates the starting point for the next set of response records in a
                *             subsequent request. If a value is returned in a response, you can retrieve the next set
                *             of records by providing this returned marker value in the <code>marker</code> parameter
                *             and retrying the command. If the <code>marker</code> field is empty, all response
                *             records have been retrieved for the request.</p>
                */
            Marker?: string;
    }
    export namespace DescribeSnapshotSchedulesOutputMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeSnapshotSchedulesOutputMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeTableRestoreStatusMessage {
            /**
                * <p>The Amazon Redshift cluster that the table is being restored to.</p>
                */
            ClusterIdentifier?: string;
            /**
                * <p>The identifier of the table restore request to return status for. If you don't
                *             specify a <code>TableRestoreRequestId</code> value, then
                *                 <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table
                *             restore requests.</p>
                */
            TableRestoreRequestId?: string;
            /**
                * <p>The maximum number of records to include in the response. If more records exist
                *             than the specified <code>MaxRecords</code> value, a pagination token called a marker is
                *             included in the response so that the remaining results can be retrieved.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional pagination token provided by a previous
                *                 <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the
                *             response includes only records beyond the marker, up to the value specified by the
                *                 <code>MaxRecords</code> parameter.</p>
                */
            Marker?: string;
    }
    export namespace DescribeTableRestoreStatusMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeTableRestoreStatusMessage) => any;
    }
    /**
        * <p>The specified <code>TableRestoreRequestId</code> value was not found.</p>
        */
    export class TableRestoreNotFoundFault extends __BaseException {
            readonly name: "TableRestoreNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TableRestoreNotFoundFault, __BaseException>);
    }
    export type TableRestoreStatusType = "CANCELED" | "FAILED" | "IN_PROGRESS" | "PENDING" | "SUCCEEDED";
    /**
        * <p>Describes the status of a <a>RestoreTableFromClusterSnapshot</a>
        *             operation.</p>
        */
    export interface TableRestoreStatus {
            /**
                * <p>The unique identifier for the table restore request.</p>
                */
            TableRestoreRequestId?: string;
            /**
                * <p>A value that describes the current state of the table restore request.</p>
                *         <p>Valid Values: <code>SUCCEEDED</code>, <code>FAILED</code>, <code>CANCELED</code>,
                *                 <code>PENDING</code>, <code>IN_PROGRESS</code>
                *         </p>
                */
            Status?: TableRestoreStatusType | string;
            /**
                * <p>A description of the status of the table restore request. Status values include
                *                 <code>SUCCEEDED</code>, <code>FAILED</code>, <code>CANCELED</code>,
                *                 <code>PENDING</code>, <code>IN_PROGRESS</code>.</p>
                */
            Message?: string;
            /**
                * <p>The time that the table restore request was made, in Universal Coordinated Time
                *             (UTC).</p>
                */
            RequestTime?: Date;
            /**
                * <p>The amount of data restored to the new table so far, in megabytes (MB).</p>
                */
            ProgressInMegaBytes?: number;
            /**
                * <p>The total amount of data to restore to the new table, in megabytes (MB).</p>
                */
            TotalDataInMegaBytes?: number;
            /**
                * <p>The identifier of the Amazon Redshift cluster that the table is being restored
                *             to.</p>
                */
            ClusterIdentifier?: string;
            /**
                * <p>The identifier of the snapshot that the table is being restored from.</p>
                */
            SnapshotIdentifier?: string;
            /**
                * <p>The name of the source database that contains the table being restored.</p>
                */
            SourceDatabaseName?: string;
            /**
                * <p>The name of the source schema that contains the table being restored.</p>
                */
            SourceSchemaName?: string;
            /**
                * <p>The name of the source table being restored.</p>
                */
            SourceTableName?: string;
            /**
                * <p>The name of the database to restore the table to.</p>
                */
            TargetDatabaseName?: string;
            /**
                * <p>The name of the schema to restore the table to.</p>
                */
            TargetSchemaName?: string;
            /**
                * <p>The name of the table to create as a result of the table restore request.</p>
                */
            NewTableName?: string;
    }
    export namespace TableRestoreStatus {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TableRestoreStatus) => any;
    }
    /**
        * <p></p>
        */
    export interface TableRestoreStatusMessage {
            /**
                * <p>A list of status details for one or more table restore requests.</p>
                */
            TableRestoreStatusDetails?: TableRestoreStatus[];
            /**
                * <p>A pagination token that can be used in a subsequent <a>DescribeTableRestoreStatus</a> request.</p>
                */
            Marker?: string;
    }
    export namespace TableRestoreStatusMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TableRestoreStatusMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface DescribeTagsMessage {
            /**
                * <p>The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For
                *             example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. </p>
                */
            ResourceName?: string;
            /**
                * <p>The type of resource with which you want to view tags. Valid resource types are: </p>
                *         <ul>
                *             <li>
                *                 <p>Cluster</p>
                *             </li>
                *             <li>
                *                 <p>CIDR/IP</p>
                *             </li>
                *             <li>
                *                 <p>EC2 security group</p>
                *             </li>
                *             <li>
                *                 <p>Snapshot</p>
                *             </li>
                *             <li>
                *                 <p>Cluster security group</p>
                *             </li>
                *             <li>
                *                 <p>Subnet group</p>
                *             </li>
                *             <li>
                *                 <p>HSM connection</p>
                *             </li>
                *             <li>
                *                 <p>HSM certificate</p>
                *             </li>
                *             <li>
                *                 <p>Parameter group</p>
                *             </li>
                *             <li>
                *                 <p>Snapshot copy grant</p>
                *             </li>
                *          </ul>
                *         <p>For more information about Amazon Redshift resource types and constructing ARNs, go to
                *                 <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in
                *             the Amazon Redshift Cluster Management Guide. </p>
                */
            ResourceType?: string;
            /**
                * <p>The maximum number or response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned <code>marker</code> value.
                *         </p>
                */
            MaxRecords?: number;
            /**
                * <p>A value that indicates the starting point for the next set of response records in a
                *             subsequent request. If a value is returned in a response, you can retrieve the next set
                *             of records by providing this returned marker value in the <code>marker</code> parameter
                *             and retrying the command. If the <code>marker</code> field is empty, all response
                *             records have been retrieved for the request. </p>
                */
            Marker?: string;
            /**
                * <p>A tag key or keys for which you want to return all matching resources that are
                *             associated with the specified key or keys. For example, suppose that you have resources
                *             tagged with keys called <code>owner</code> and <code>environment</code>. If you specify
                *             both of these tag keys in the request, Amazon Redshift returns a response with all resources
                *             that have either or both of these tag keys associated with them.</p>
                */
            TagKeys?: string[];
            /**
                * <p>A tag value or values for which you want to return all matching resources that are
                *             associated with the specified value or values. For example, suppose that you have
                *             resources tagged with values called <code>admin</code> and <code>test</code>. If you
                *             specify both of these tag values in the request, Amazon Redshift returns a response with all
                *             resources that have either or both of these tag values associated with them.</p>
                */
            TagValues?: string[];
    }
    export namespace DescribeTagsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeTagsMessage) => any;
    }
    /**
        * <p>A tag and its associated resource.</p>
        */
    export interface TaggedResource {
            /**
                * <p>The tag for the resource.</p>
                */
            Tag?: Tag;
            /**
                * <p>The Amazon Resource Name (ARN) with which the tag is associated, for example:
                *                 <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>.</p>
                */
            ResourceName?: string;
            /**
                * <p>The type of resource with which the tag is associated. Valid resource types are: </p>
                *         <ul>
                *             <li>
                *                 <p>Cluster</p>
                *             </li>
                *             <li>
                *                 <p>CIDR/IP</p>
                *             </li>
                *             <li>
                *                 <p>EC2 security group</p>
                *             </li>
                *             <li>
                *                 <p>Snapshot</p>
                *             </li>
                *             <li>
                *                 <p>Cluster security group</p>
                *             </li>
                *             <li>
                *                 <p>Subnet group</p>
                *             </li>
                *             <li>
                *                 <p>HSM connection</p>
                *             </li>
                *             <li>
                *                 <p>HSM certificate</p>
                *             </li>
                *             <li>
                *                 <p>Parameter group</p>
                *             </li>
                *          </ul>
                *         <p>For more information about Amazon Redshift resource types and constructing ARNs, go to
                *                 <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Constructing an Amazon Redshift Amazon Resource Name (ARN)</a> in the
                *             Amazon Redshift Cluster Management Guide. </p>
                */
            ResourceType?: string;
    }
    export namespace TaggedResource {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TaggedResource) => any;
    }
    /**
        * <p></p>
        */
    export interface TaggedResourceListMessage {
            /**
                * <p>A list of tags with their associated resources.</p>
                */
            TaggedResources?: TaggedResource[];
            /**
                * <p>A value that indicates the starting point for the next set of response records in a
                *             subsequent request. If a value is returned in a response, you can retrieve the next set
                *             of records by providing this returned marker value in the <code>Marker</code> parameter
                *             and retrying the command. If the <code>Marker</code> field is empty, all response
                *             records have been retrieved for the request. </p>
                */
            Marker?: string;
    }
    export namespace TaggedResourceListMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TaggedResourceListMessage) => any;
    }
    export interface DescribeUsageLimitsMessage {
            /**
                * <p>The identifier of the usage limit to describe.</p>
                */
            UsageLimitId?: string;
            /**
                * <p>The identifier of the cluster for which you want to describe usage limits.</p>
                */
            ClusterIdentifier?: string;
            /**
                * <p>The feature type for which you want to describe usage limits.</p>
                */
            FeatureType?: UsageLimitFeatureType | string;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value. </p>
                *         <p>Default: <code>100</code>
                *         </p>
                *         <p>Constraints: minimum 20, maximum 100.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional parameter that specifies the starting point to return a set of response
                *             records. When the results of a <a>DescribeUsageLimits</a> request
                *             exceed the value specified in <code>MaxRecords</code>, Amazon Web Services returns a value in the
                *             <code>Marker</code> field of the response. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request. </p>
                */
            Marker?: string;
            /**
                * <p>A tag key or keys for which you want to return all matching usage limit objects
                *             that are associated with the specified key or keys. For example, suppose that you
                *             have parameter groups that are tagged with keys called <code>owner</code> and
                *             <code>environment</code>. If you specify both of these tag keys in the request,
                *             Amazon Redshift returns a response with the usage limit objects have either or both of these
                *             tag keys associated with them.</p>
                */
            TagKeys?: string[];
            /**
                * <p>A tag value or values for which you want to return all matching usage limit objects
                *             that are associated with the specified tag value or values. For example, suppose
                *             that you have parameter groups that are tagged with values called <code>admin</code> and
                *             <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift
                *             returns a response with the usage limit objects that have either or both of these tag
                *             values associated with them.</p>
                */
            TagValues?: string[];
    }
    export namespace DescribeUsageLimitsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeUsageLimitsMessage) => any;
    }
    export interface UsageLimitList {
            /**
                * <p>Contains the output from the <a>DescribeUsageLimits</a>
                *             action. </p>
                */
            UsageLimits?: UsageLimit[];
            /**
                * <p>A value that indicates the starting point for the next set of response records in a
                *             subsequent request. If a value is returned in a response, you can retrieve the next set
                *             of records by providing this returned marker value in the <code>Marker</code> parameter
                *             and retrying the command. If the <code>Marker</code> field is empty, all response
                *             records have been retrieved for the request. </p>
                */
            Marker?: string;
    }
    export namespace UsageLimitList {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UsageLimitList) => any;
    }
    /**
        * <p></p>
        */
    export interface DisableLoggingMessage {
            /**
                * <p>The identifier of the cluster on which logging is to be stopped.</p>
                *         <p>Example: <code>examplecluster</code>
                *         </p>
                */
            ClusterIdentifier: string | undefined;
    }
    export namespace DisableLoggingMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DisableLoggingMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface DisableSnapshotCopyMessage {
            /**
                * <p>The unique identifier of the source cluster that you want to disable copying of
                *             snapshots to a destination region.</p>
                *         <p>Constraints: Must be the valid name of an existing cluster that has cross-region
                *             snapshot copy enabled.</p>
                */
            ClusterIdentifier: string | undefined;
    }
    export namespace DisableSnapshotCopyMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DisableSnapshotCopyMessage) => any;
    }
    export interface DisableSnapshotCopyResult {
            /**
                * <p>Describes a cluster.</p>
                */
            Cluster?: Cluster;
    }
    export namespace DisableSnapshotCopyResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DisableSnapshotCopyResult) => any;
    }
    /**
        * <p>The cluster already has cross-region snapshot copy disabled.</p>
        */
    export class SnapshotCopyAlreadyDisabledFault extends __BaseException {
            readonly name: "SnapshotCopyAlreadyDisabledFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SnapshotCopyAlreadyDisabledFault, __BaseException>);
    }
    export interface DisassociateDataShareConsumerMessage {
            /**
                * <p>The Amazon Resource Name (ARN) of the datashare to remove association for. </p>
                */
            DataShareArn: string | undefined;
            /**
                * <p>A value that specifies whether association for the datashare is removed from the
                *             entire account.</p>
                */
            DisassociateEntireAccount?: boolean;
            /**
                * <p>The Amazon Resource Name (ARN) of the consumer that association for
                *             the datashare is removed from.</p>
                */
            ConsumerArn?: string;
            /**
                * <p>From a datashare consumer account, removes association of a datashare from all the existing and future namespaces in the specified Amazon Web Services Region.</p>
                */
            ConsumerRegion?: string;
    }
    export namespace DisassociateDataShareConsumerMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DisassociateDataShareConsumerMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface EnableLoggingMessage {
            /**
                * <p>The identifier of the cluster on which logging is to be started.</p>
                *         <p>Example: <code>examplecluster</code>
                *         </p>
                */
            ClusterIdentifier: string | undefined;
            /**
                * <p>The name of an existing S3 bucket where the log files are to be stored.</p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Must be in the same region as the cluster</p>
                *             </li>
                *             <li>
                *                 <p>The cluster must have read bucket and put object permissions</p>
                *             </li>
                *          </ul>
                */
            BucketName?: string;
            /**
                * <p>The prefix applied to the log file names.</p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Cannot exceed 512 characters</p>
                *             </li>
                *             <li>
                *                 <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash
                *                     (\), or control characters. The hexadecimal codes for invalid characters are: </p>
                *                 <ul>
                *                   <li>
                *                         <p>x00 to x20</p>
                *                     </li>
                *                   <li>
                *                         <p>x22</p>
                *                     </li>
                *                   <li>
                *                         <p>x27</p>
                *                     </li>
                *                   <li>
                *                         <p>x5c</p>
                *                     </li>
                *                   <li>
                *                         <p>x7f or larger</p>
                *                     </li>
                *                </ul>
                *             </li>
                *          </ul>
                */
            S3KeyPrefix?: string;
            /**
                * <p>The log destination type. An enum with possible values of <code>s3</code> and <code>cloudwatch</code>.</p>
                */
            LogDestinationType?: LogDestinationType | string;
            /**
                * <p>The collection of exported log types. Log types include the connection log, user log and user activity log.</p>
                */
            LogExports?: string[];
    }
    export namespace EnableLoggingMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EnableLoggingMessage) => any;
    }
    /**
        * <p>The cluster does not have read bucket or put object permissions on the S3 bucket
        *             specified when enabling logging.</p>
        */
    export class InsufficientS3BucketPolicyFault extends __BaseException {
            readonly name: "InsufficientS3BucketPolicyFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InsufficientS3BucketPolicyFault, __BaseException>);
    }
    /**
        * <p>The S3 bucket name is invalid. For more information about naming rules, go to
        *                 <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html">Bucket
        *                 Restrictions and Limitations</a> in the Amazon Simple Storage Service (S3)
        *             Developer Guide.</p>
        */
    export class InvalidS3BucketNameFault extends __BaseException {
            readonly name: "InvalidS3BucketNameFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidS3BucketNameFault, __BaseException>);
    }
    /**
        * <p>The string specified for the logging S3 key prefix does not comply with the
        *             documented constraints.</p>
        */
    export class InvalidS3KeyPrefixFault extends __BaseException {
            readonly name: "InvalidS3KeyPrefixFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidS3KeyPrefixFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export interface EnableSnapshotCopyMessage {
            /**
                * <p>The unique identifier of the source cluster to copy snapshots from.</p>
                *         <p>Constraints: Must be the valid name of an existing cluster that does not already
                *             have cross-region snapshot copy enabled.</p>
                */
            ClusterIdentifier: string | undefined;
            /**
                * <p>The destination Amazon Web Services Region that you want to copy snapshots to.</p>
                *         <p>Constraints: Must be the name of a valid Amazon Web Services Region. For more information, see
                *                 <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference.
                *         </p>
                */
            DestinationRegion: string | undefined;
            /**
                * <p>The number of days to retain automated snapshots in the destination region after
                *             they are copied from the source region.</p>
                *         <p>Default: 7.</p>
                *         <p>Constraints: Must be at least 1 and no more than 35.</p>
                */
            RetentionPeriod?: number;
            /**
                * <p>The name of the snapshot copy grant to use when snapshots of an Amazon Web Services KMS-encrypted
                *             cluster are copied to the destination region.</p>
                */
            SnapshotCopyGrantName?: string;
            /**
                * <p>The number of days to retain newly copied snapshots in the destination Amazon Web Services Region
                *             after they are copied from the source Amazon Web Services Region. If the value is -1, the manual
                *             snapshot is retained indefinitely. </p>
                *         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
                */
            ManualSnapshotRetentionPeriod?: number;
    }
    export namespace EnableSnapshotCopyMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EnableSnapshotCopyMessage) => any;
    }
    export interface EnableSnapshotCopyResult {
            /**
                * <p>Describes a cluster.</p>
                */
            Cluster?: Cluster;
    }
    export namespace EnableSnapshotCopyResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EnableSnapshotCopyResult) => any;
    }
    /**
        * <p>The specified options are incompatible.</p>
        */
    export class IncompatibleOrderableOptions extends __BaseException {
            readonly name: "IncompatibleOrderableOptions";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<IncompatibleOrderableOptions, __BaseException>);
    }
    /**
        * <p>The cluster already has cross-region snapshot copy enabled.</p>
        */
    export class SnapshotCopyAlreadyEnabledFault extends __BaseException {
            readonly name: "SnapshotCopyAlreadyEnabledFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SnapshotCopyAlreadyEnabledFault, __BaseException>);
    }
    /**
        * <p>The specified region is incorrect or does not exist.</p>
        */
    export class UnknownSnapshotCopyRegionFault extends __BaseException {
            readonly name: "UnknownSnapshotCopyRegionFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UnknownSnapshotCopyRegionFault, __BaseException>);
    }
    /**
        * <p>The authorization for this endpoint can't be found.</p>
        */
    export class EndpointAuthorizationNotFoundFault extends __BaseException {
            readonly name: "EndpointAuthorizationNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<EndpointAuthorizationNotFoundFault, __BaseException>);
    }
    /**
        * <p>The request parameters to get cluster credentials.</p>
        */
    export interface GetClusterCredentialsMessage {
            /**
                * <p>The name of a database user. If a user name matching <code>DbUser</code> exists in
                *             the database, the temporary user credentials have the same permissions as the existing
                *             user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code>
                *             is <code>True</code>, a new user is created using the value for <code>DbUser</code> with
                *             PUBLIC permissions. If a database user matching the value for <code>DbUser</code>
                *             doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command
                *             succeeds but the connection attempt will fail because the user doesn't exist in the
                *             database.</p>
                *         <p>For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon
                *             Redshift Database Developer Guide. </p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be
                *                         <code>PUBLIC</code>.</p>
                *             </li>
                *             <li>
                *                 <p>Must contain only lowercase letters, numbers, underscore, plus sign, period
                *                     (dot), at symbol (@), or hyphen.</p>
                *             </li>
                *             <li>
                *                 <p>First character must be a letter.</p>
                *             </li>
                *             <li>
                *                 <p>Must not contain a colon ( : ) or slash ( / ). </p>
                *             </li>
                *             <li>
                *                 <p>Cannot be a reserved word. A list of reserved words can be found in <a href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon
                *                     Redshift Database Developer Guide.</p>
                *             </li>
                *          </ul>
                */
            DbUser: string | undefined;
            /**
                * <p>The name of a database that <code>DbUser</code> is authorized to log on to. If
                *                 <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing
                *             database.</p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Must be 1 to 64 alphanumeric characters or hyphens</p>
                *             </li>
                *             <li>
                *                 <p>Must contain only lowercase letters, numbers, underscore, plus sign, period
                *                     (dot), at symbol (@), or hyphen.</p>
                *             </li>
                *             <li>
                *                 <p>First character must be a letter.</p>
                *             </li>
                *             <li>
                *                 <p>Must not contain a colon ( : ) or slash ( / ). </p>
                *             </li>
                *             <li>
                *                 <p>Cannot be a reserved word. A list of reserved words can be found in <a href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon
                *                     Redshift Database Developer Guide.</p>
                *             </li>
                *          </ul>
                */
            DbName?: string;
            /**
                * <p>The unique identifier of the cluster that contains the database for which you are
                *             requesting credentials. This parameter is case sensitive.</p>
                */
            ClusterIdentifier: string | undefined;
            /**
                * <p>The number of seconds until the returned temporary password expires.</p>
                *         <p>Constraint: minimum 900, maximum 3600.</p>
                *         <p>Default: 900</p>
                */
            DurationSeconds?: number;
            /**
                * <p>Create a database user with the name specified for the user named in
                *                 <code>DbUser</code> if one does not exist.</p>
                */
            AutoCreate?: boolean;
            /**
                * <p>A list of the names of existing database groups that the user named in
                *                 <code>DbUser</code> will join for the current session, in addition to any group
                *             memberships for an existing user. If not specified, a new user is added only to
                *             PUBLIC.</p>
                *         <p>Database group name constraints</p>
                *         <ul>
                *             <li>
                *                 <p>Must be 1 to 64 alphanumeric characters or hyphens</p>
                *             </li>
                *             <li>
                *                 <p>Must contain only lowercase letters, numbers, underscore, plus sign, period
                *                     (dot), at symbol (@), or hyphen.</p>
                *             </li>
                *             <li>
                *                 <p>First character must be a letter.</p>
                *             </li>
                *             <li>
                *                 <p>Must not contain a colon ( : ) or slash ( / ). </p>
                *             </li>
                *             <li>
                *                 <p>Cannot be a reserved word. A list of reserved words can be found in <a href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon
                *                     Redshift Database Developer Guide.</p>
                *             </li>
                *          </ul>
                */
            DbGroups?: string[];
    }
    export namespace GetClusterCredentialsMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetClusterCredentialsMessage) => any;
    }
    export interface GetClusterCredentialsWithIAMMessage {
            /**
                * <p>The name of the database for which you are requesting credentials.
                *             If the database name is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name.
                *             If the database name is not specified, access to all databases is allowed.</p>
                */
            DbName?: string;
            /**
                * <p>The unique identifier of the cluster that contains the database for which you are
                *             requesting credentials. </p>
                */
            ClusterIdentifier: string | undefined;
            /**
                * <p>The number of seconds until the returned temporary password expires.</p>
                *         <p>Range: 900-3600. Default: 900.</p>
                */
            DurationSeconds?: number;
    }
    export namespace GetClusterCredentialsWithIAMMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetClusterCredentialsWithIAMMessage) => any;
    }
    export enum ReservedNodeExchangeActionType {
            RESIZE_CLUSTER = "resize-cluster",
            RESTORE_CLUSTER = "restore-cluster"
    }
    export interface GetReservedNodeExchangeConfigurationOptionsInputMessage {
            /**
                * <p>The action type of the reserved-node configuration. The action type can be an exchange initiated from either a snapshot or a resize.</p>
                */
            ActionType: ReservedNodeExchangeActionType | string | undefined;
            /**
                * <p>The identifier for the cluster that is the source for a reserved-node exchange.</p>
                */
            ClusterIdentifier?: string;
            /**
                * <p>The identifier for the snapshot that is the source for the reserved-node exchange.</p>
                */
            SnapshotIdentifier?: string;
            /**
                * <p>The maximum number of response records to return in each call. If the number of
                *             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
                *             is returned in a <code>Marker</code> field of the response. You can retrieve the next
                *             set of records by retrying the command with the returned marker value.</p>
                */
            MaxRecords?: number;
            /**
                * <p>An optional pagination token provided by a previous <code>GetReservedNodeExchangeConfigurationOptions</code> request. If this
                *             parameter is specified, the response includes only records beyond the marker, up to the value
                *             specified by the <code>MaxRecords</code> parameter. You can retrieve the next set of response
                *             records by providing the returned marker value in the <code>Marker</code> parameter and
                *             retrying the request.</p>
                */
            Marker?: string;
    }
    export namespace GetReservedNodeExchangeConfigurationOptionsInputMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetReservedNodeExchangeConfigurationOptionsInputMessage) => any;
    }
    /**
        * <p>Details for a reserved-node exchange. Examples include the node type for a
        *             reserved node, the price for a node, the node's state, and other details.</p>
        */
    export interface ReservedNodeConfigurationOption {
            /**
                * <p>Describes a reserved node. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node
                *             offerings. </p>
                */
            SourceReservedNode?: ReservedNode;
            /**
                * <p>The target reserved-node count.</p>
                */
            TargetReservedNodeCount?: number;
            /**
                * <p>Describes a reserved node offering.</p>
                */
            TargetReservedNodeOffering?: ReservedNodeOffering;
    }
    export namespace ReservedNodeConfigurationOption {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReservedNodeConfigurationOption) => any;
    }
    export interface GetReservedNodeExchangeConfigurationOptionsOutputMessage {
            /**
                * <p>A pagination token provided by a previous <code>GetReservedNodeExchangeConfigurationOptions</code> request.</p>
                */
            Marker?: string;
            /**
                * <p>the configuration options for the reserved-node
                *             exchange. These options include information about the source reserved node and target reserved
                *             node. Details include the node type, the price, the node count, and the offering
                *             type.</p>
                */
            ReservedNodeConfigurationOptionList?: ReservedNodeConfigurationOption[];
    }
    export namespace GetReservedNodeExchangeConfigurationOptionsOutputMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetReservedNodeExchangeConfigurationOptionsOutputMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface GetReservedNodeExchangeOfferingsInputMessage {
            /**
                * <p>A string representing the node identifier for the DC1 Reserved Node to be
                *             exchanged.</p>
                */
            ReservedNodeId: string | undefined;
            /**
                * <p>An integer setting the maximum number of ReservedNodeOfferings to
                *             retrieve.</p>
                */
            MaxRecords?: number;
            /**
                * <p>A value that indicates the starting point for the next set of
                *             ReservedNodeOfferings.</p>
                */
            Marker?: string;
    }
    export namespace GetReservedNodeExchangeOfferingsInputMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetReservedNodeExchangeOfferingsInputMessage) => any;
    }
    export interface GetReservedNodeExchangeOfferingsOutputMessage {
            /**
                * <p>An optional parameter that specifies the starting point for returning a set of
                *             response records. When the results of a <code>GetReservedNodeExchangeOfferings</code>
                *             request exceed the value specified in MaxRecords, Amazon Redshift returns a value in the
                *             marker field of the response. You can retrieve the next set of response records by
                *             providing the returned marker value in the marker parameter and retrying the request.
                *         </p>
                */
            Marker?: string;
            /**
                * <p>Returns an array of <a>ReservedNodeOffering</a> objects.</p>
                */
            ReservedNodeOfferings?: ReservedNodeOffering[];
    }
    export namespace GetReservedNodeExchangeOfferingsOutputMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetReservedNodeExchangeOfferingsOutputMessage) => any;
    }
    /**
        * <p>You have exceeded the allowed number of table restore requests. Wait for your
        *             current table restore requests to complete before making a new request.</p>
        */
    export class InProgressTableRestoreQuotaExceededFault extends __BaseException {
            readonly name: "InProgressTableRestoreQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InProgressTableRestoreQuotaExceededFault, __BaseException>);
    }
    /**
        * <p>The restore is invalid.</p>
        */
    export class InvalidRestoreFault extends __BaseException {
            readonly name: "InvalidRestoreFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidRestoreFault, __BaseException>);
    }
    /**
        * <p>The value specified for the <code>sourceDatabaseName</code>,
        *                 <code>sourceSchemaName</code>, or <code>sourceTableName</code> parameter, or a
        *             combination of these, doesn't exist in the snapshot.</p>
        */
    export class InvalidTableRestoreArgumentFault extends __BaseException {
            readonly name: "InvalidTableRestoreArgumentFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidTableRestoreArgumentFault, __BaseException>);
    }
    export interface ModifyAquaInputMessage {
            /**
                * <p>The identifier of the cluster to be modified.</p>
                */
            ClusterIdentifier: string | undefined;
            /**
                * <p>The new value of AQUA configuration status. Possible values include the following.</p>
                *         <ul>
                *             <li>
                *                <p>enabled - Use AQUA if it is available for the current Amazon Web Services Region and Amazon Redshift node type.</p>
                *             </li>
                *             <li>
                *                <p>disabled - Don't use AQUA. </p>
                *             </li>
                *             <li>
                *                <p>auto - Amazon Redshift determines whether to use AQUA.</p>
                *             </li>
                *          </ul>
                */
            AquaConfigurationStatus?: AquaConfigurationStatus | string;
    }
    export namespace ModifyAquaInputMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyAquaInputMessage) => any;
    }
    export interface ModifyAquaOutputMessage {
            /**
                * <p>The updated AQUA configuration of the cluster. </p>
                */
            AquaConfiguration?: AquaConfiguration;
    }
    export namespace ModifyAquaOutputMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyAquaOutputMessage) => any;
    }
    export interface ModifyAuthenticationProfileMessage {
            /**
                * <p>The name of the authentication profile to replace.</p>
                */
            AuthenticationProfileName: string | undefined;
            /**
                * <p>The new content of the authentication profile in JSON format.
                *             The maximum length of the JSON string is determined by a quota for your account.</p>
                */
            AuthenticationProfileContent: string | undefined;
    }
    export namespace ModifyAuthenticationProfileMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyAuthenticationProfileMessage) => any;
    }
    export interface ModifyAuthenticationProfileResult {
            /**
                * <p>The name of the authentication profile that was replaced.</p>
                */
            AuthenticationProfileName?: string;
            /**
                * <p>The updated content of the authentication profile in JSON format.</p>
                */
            AuthenticationProfileContent?: string;
    }
    export namespace ModifyAuthenticationProfileResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyAuthenticationProfileResult) => any;
    }
    /**
        * <p></p>
        */
    export interface ModifyClusterMessage {
            /**
                * <p>The unique identifier of the cluster to be modified.</p>
                *         <p>Example: <code>examplecluster</code>
                *         </p>
                */
            ClusterIdentifier: string | undefined;
            /**
                * <p>The new cluster type.</p>
                *         <p>When you submit your cluster resize request, your existing cluster goes into a
                *             read-only mode. After Amazon Redshift provisions a new cluster based on your resize
                *             requirements, there will be outage for a period while the old cluster is deleted and
                *             your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p>
                *         <p>Valid Values: <code> multi-node | single-node </code>
                *         </p>
                */
            ClusterType?: string;
            /**
                * <p>The new node type of the cluster. If you specify a new node type, you must also
                *             specify the number of nodes parameter.</p>
                *         <p>
                * For more information about resizing clusters, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                *
                *         <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> |
                *             <code>dc1.large</code> | <code>dc1.8xlarge</code> |
                *             <code>dc2.large</code> | <code>dc2.8xlarge</code> |
                *             <code>ra3.xlplus</code> |  <code>ra3.4xlarge</code> | <code>ra3.16xlarge</code>
                *          </p>
                */
            NodeType?: string;
            /**
                * <p>The new number of nodes of the cluster. If you specify a new number of nodes, you
                *             must also specify the node type parameter.</p>
                *         <p>
                * For more information about resizing clusters, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                *
                *         <p>Valid Values: Integer greater than <code>0</code>.</p>
                */
            NumberOfNodes?: number;
            /**
                * <p>A list of cluster security groups to be authorized on this cluster. This change is
                *             asynchronously applied as soon as possible.</p>
                *         <p>Security groups currently associated with the cluster, and not in the list of
                *             groups to apply, will be revoked from the cluster.</p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Must be 1 to 255 alphanumeric characters or hyphens</p>
                *             </li>
                *             <li>
                *                 <p>First character must be a letter</p>
                *             </li>
                *             <li>
                *                 <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
                *             </li>
                *          </ul>
                */
            ClusterSecurityGroups?: string[];
            /**
                * <p>A list of virtual private cloud (VPC) security groups to be associated with the
                *             cluster. This change is asynchronously applied as soon as possible.</p>
                */
            VpcSecurityGroupIds?: string[];
            /**
                * <p>The new password for the cluster admin user. This change is asynchronously applied
                *             as soon as possible. Between the time of the request and the completion of the request,
                *             the <code>MasterUserPassword</code> element exists in the
                *                 <code>PendingModifiedValues</code> element of the operation response. </p>
                *         <note>
                *             <p>Operations never return the password, so this operation provides a way to
                *                 regain access to the admin user account for a cluster if the password is
                *                 lost.</p>
                *         </note>
                *         <p>Default: Uses existing setting.</p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Must be between 8 and 64 characters in length.</p>
                *             </li>
                *             <li>
                *                 <p>Must contain at least one uppercase letter.</p>
                *             </li>
                *             <li>
                *                 <p>Must contain at least one lowercase letter.</p>
                *             </li>
                *             <li>
                *                 <p>Must contain one number.</p>
                *             </li>
                *             <li>
                *                 <p>Can be any printable ASCII character (ASCII code 33-126) except <code>'</code>
                *                     (single quote), <code>"</code> (double quote), <code>\</code>, <code>/</code>, or <code>@</code>.</p>
                *             </li>
                *          </ul>
                */
            MasterUserPassword?: string;
            /**
                * <p>The name of the cluster parameter group to apply to this cluster. This change is
                *             applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p>
                *         <p>Default: Uses existing setting.</p>
                *         <p>Constraints: The cluster parameter group must be in the same parameter group family
                *             that matches the cluster version.</p>
                */
            ClusterParameterGroupName?: string;
            /**
                * <p>The number of days that automated snapshots are retained. If the value is 0,
                *             automated snapshots are disabled. Even if automated snapshots are disabled, you can
                *             still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p>
                *         <p>If you decrease the automated snapshot retention period from its current value,
                *             existing automated snapshots that fall outside of the new retention period will be
                *             immediately deleted.</p>
                *
                *         <p>You can't disable automated snapshots for RA3 node types. Set the automated retention period from 1-35 days.</p>
                *         <p>Default: Uses existing setting.</p>
                *         <p>Constraints: Must be a value from 0 to 35.</p>
                */
            AutomatedSnapshotRetentionPeriod?: number;
            /**
                * <p>The default for number of days that a newly created manual snapshot is retained. If
                *             the value is -1, the manual snapshot is retained indefinitely. This value doesn't
                *             retroactively change the retention periods of existing manual snapshots.</p>
                *         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
                *         <p>The default value is -1.</p>
                */
            ManualSnapshotRetentionPeriod?: number;
            /**
                * <p>The weekly time range (in UTC) during which system maintenance can occur, if
                *             necessary. If system maintenance is necessary during the window, it may result in an
                *             outage.</p>
                *         <p>This maintenance window change is made immediately. If the new maintenance window
                *             indicates the current time, there must be at least 120 minutes between the current time
                *             and end of the window in order to ensure that pending changes are applied.</p>
                *         <p>Default: Uses existing setting.</p>
                *         <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example
                *             <code>wed:07:30-wed:08:00</code>.</p>
                *         <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p>
                *         <p>Constraints: Must be at least 30 minutes.</p>
                */
            PreferredMaintenanceWindow?: string;
            /**
                * <p>The new version number of the Amazon Redshift engine to upgrade to.</p>
                *         <p>For major version upgrades, if a non-default cluster parameter group is currently
                *             in use, a new cluster parameter group in the cluster parameter group family for the new
                *             version must be specified. The new cluster parameter group can be the default for that
                *             cluster parameter group family.
                * For more information about parameters and parameter groups, go to
                * <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
                * in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                *         <p>Example: <code>1.0</code>
                *         </p>
                */
            ClusterVersion?: string;
            /**
                * <p>If <code>true</code>, major version upgrades will be applied automatically to the
                *             cluster during the maintenance window. </p>
                *         <p>Default: <code>false</code>
                *         </p>
                */
            AllowVersionUpgrade?: boolean;
            /**
                * <p>Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to
                *             retrieve the data encryption keys stored in an HSM.</p>
                */
            HsmClientCertificateIdentifier?: string;
            /**
                * <p>Specifies the name of the HSM configuration that contains the information the
                *             Amazon Redshift cluster can use to retrieve and store keys in an HSM.</p>
                */
            HsmConfigurationIdentifier?: string;
            /**
                * <p>The new identifier for the cluster.</p>
                *          <p>Constraints:</p>
                *          <ul>
                *             <li>
                *                <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p>
                *             </li>
                *             <li>
                *                <p>Alphabetic characters must be lowercase.</p>
                *             </li>
                *             <li>
                *                <p>First character must be a letter.</p>
                *             </li>
                *             <li>
                *                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
                *             </li>
                *             <li>
                *                <p>Must be unique for all clusters within an Amazon Web Services account.</p>
                *             </li>
                *          </ul>
                *
                *             <p>Example: <code>examplecluster</code>
                *         </p>
                */
            NewClusterIdentifier?: string;
            /**
                * <p>If <code>true</code>, the cluster can be accessed from a public network. Only
                *             clusters in VPCs can be set to be publicly available.</p>
                */
            PubliclyAccessible?: boolean;
            /**
                * <p>The Elastic IP (EIP) address for the cluster.</p>
                *         <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible
                *             through an Internet gateway. For more information about provisioning clusters in
                *             EC2-VPC, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported
                *                 Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
                */
            ElasticIp?: string;
            /**
                * <p>An option that specifies whether to create the cluster with enhanced VPC routing
                *             enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
                *             VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
                *             the Amazon Redshift Cluster Management Guide.</p>
                *         <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
                *         <p>Default: false</p>
                */
            EnhancedVpcRouting?: boolean;
            /**
                * <p>The name for the maintenance track that you want to assign for the cluster. This name
                *             change is asynchronous. The new track name stays in the
                *                 <code>PendingModifiedValues</code> for the cluster until the next maintenance
                *             window. When the maintenance track changes, the cluster is switched to the latest
                *             cluster release available for the maintenance track. At this point, the maintenance
                *             track name is applied.</p>
                */
            MaintenanceTrackName?: string;
            /**
                * <p>Indicates whether the cluster is encrypted. If the value is encrypted (true) and you
                *             provide a value for the <code>KmsKeyId</code> parameter, we encrypt the cluster
                *             with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>,
                *             we encrypt with the default key. </p>
                *             <p>If the value is not encrypted (false), then the cluster is decrypted. </p>
                */
            Encrypted?: boolean;
            /**
                * <p>The Key Management Service (KMS) key ID of the encryption key that you want to use
                *             to encrypt data in the cluster.</p>
                */
            KmsKeyId?: string;
            /**
                * <p>The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster modification is complete.</p>
                */
            AvailabilityZoneRelocation?: boolean;
            /**
                * <p>The option to initiate relocation for an Amazon Redshift cluster to the target Availability Zone.</p>
                */
            AvailabilityZone?: string;
            /**
                * <p>The option to change the port of an Amazon Redshift cluster.</p>
                */
            Port?: number;
    }
    export namespace ModifyClusterMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyClusterMessage) => any;
    }
    export interface ModifyClusterResult {
            /**
                * <p>Describes a cluster.</p>
                */
            Cluster?: Cluster;
    }
    export namespace ModifyClusterResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyClusterResult) => any;
    }
    /**
        * <p>The number of tables in the cluster exceeds the limit for the requested new cluster
        *             node type. </p>
        */
    export class TableLimitExceededFault extends __BaseException {
            readonly name: "TableLimitExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TableLimitExceededFault, __BaseException>);
    }
    /**
        * <p>A request option was specified that is not supported.</p>
        */
    export class UnsupportedOptionFault extends __BaseException {
            readonly name: "UnsupportedOptionFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UnsupportedOptionFault, __BaseException>);
    }
    export interface ModifyClusterDbRevisionMessage {
            /**
                * <p>The unique identifier of a cluster whose database revision you want to modify. </p>
                *         <p>Example: <code>examplecluster</code>
                *         </p>
                */
            ClusterIdentifier: string | undefined;
            /**
                * <p>The identifier of the database revision. You can retrieve this value from the
                *             response to the <a>DescribeClusterDbRevisions</a> request.</p>
                */
            RevisionTarget: string | undefined;
    }
    export namespace ModifyClusterDbRevisionMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyClusterDbRevisionMessage) => any;
    }
    export interface ModifyClusterDbRevisionResult {
            /**
                * <p>Describes a cluster.</p>
                */
            Cluster?: Cluster;
    }
    export namespace ModifyClusterDbRevisionResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyClusterDbRevisionResult) => any;
    }
    /**
        * <p></p>
        */
    export interface ModifyClusterIamRolesMessage {
            /**
                * <p>The unique identifier of the cluster for which you want to associate or
                *             disassociate IAM roles.</p>
                */
            ClusterIdentifier: string | undefined;
            /**
                * <p>Zero or more IAM roles to associate with the cluster. The roles must be in their
                *             Amazon Resource Name (ARN) format. </p>
                */
            AddIamRoles?: string[];
            /**
                * <p>Zero or more IAM roles in ARN format to disassociate from the cluster. </p>
                */
            RemoveIamRoles?: string[];
            /**
                * <p>The Amazon Resource Name (ARN) for the IAM role that was set as default for the cluster when the cluster was last modified.</p>
                */
            DefaultIamRoleArn?: string;
    }
    export namespace ModifyClusterIamRolesMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyClusterIamRolesMessage) => any;
    }
    export interface ModifyClusterIamRolesResult {
            /**
                * <p>Describes a cluster.</p>
                */
            Cluster?: Cluster;
    }
    export namespace ModifyClusterIamRolesResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyClusterIamRolesResult) => any;
    }
    export interface ModifyClusterMaintenanceMessage {
            /**
                * <p>A unique identifier for the cluster.</p>
                */
            ClusterIdentifier: string | undefined;
            /**
                * <p>A boolean indicating whether to enable the deferred maintenance window. </p>
                */
            DeferMaintenance?: boolean;
            /**
                * <p>A unique identifier for the deferred maintenance window.</p>
                */
            DeferMaintenanceIdentifier?: string;
            /**
                * <p>A timestamp indicating the start time for the deferred maintenance window.</p>
                */
            DeferMaintenanceStartTime?: Date;
            /**
                * <p>A timestamp indicating end time for the deferred maintenance window. If you specify an
                *             end time, you can't specify a duration.</p>
                */
            DeferMaintenanceEndTime?: Date;
            /**
                * <p>An integer indicating the duration of the maintenance window in days. If you specify a
                *             duration, you can't specify an end time. The duration must be 45 days or less.</p>
                */
            DeferMaintenanceDuration?: number;
    }
    export namespace ModifyClusterMaintenanceMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyClusterMaintenanceMessage) => any;
    }
    export interface ModifyClusterMaintenanceResult {
            /**
                * <p>Describes a cluster.</p>
                */
            Cluster?: Cluster;
    }
    export namespace ModifyClusterMaintenanceResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyClusterMaintenanceResult) => any;
    }
    /**
        * <p>Describes a modify cluster parameter group operation. </p>
        */
    export interface ModifyClusterParameterGroupMessage {
            /**
                * <p>The name of the parameter group to be modified.</p>
                */
            ParameterGroupName: string | undefined;
            /**
                * <p>An array of parameters to be modified. A maximum of 20 parameters can be modified
                *             in a single request.</p>
                *         <p>For each parameter to be modified, you must supply at least the parameter name and
                *             parameter value; other name-value pairs of the parameter are optional.</p>
                *         <p>For the workload management (WLM) configuration, you must supply all the name-value
                *             pairs in the wlm_json_configuration parameter.</p>
                */
            Parameters: Parameter[] | undefined;
    }
    export namespace ModifyClusterParameterGroupMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyClusterParameterGroupMessage) => any;
    }
    export interface ModifyClusterSnapshotMessage {
            /**
                * <p>The identifier of the snapshot whose setting you want to modify.</p>
                */
            SnapshotIdentifier: string | undefined;
            /**
                * <p>The number of days that a manual snapshot is retained. If the value is -1, the manual
                *             snapshot is retained indefinitely.</p>
                *         <p>If the manual snapshot falls outside of the new retention period, you can specify the
                *             force option to immediately delete the snapshot.</p>
                *         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
                */
            ManualSnapshotRetentionPeriod?: number;
            /**
                * <p>A Boolean option to override an exception if the retention period has already
                *             passed.</p>
                */
            Force?: boolean;
    }
    export namespace ModifyClusterSnapshotMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyClusterSnapshotMessage) => any;
    }
    export interface ModifyClusterSnapshotResult {
            /**
                * <p>Describes a snapshot.</p>
                */
            Snapshot?: Snapshot;
    }
    export namespace ModifyClusterSnapshotResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyClusterSnapshotResult) => any;
    }
    export interface ModifyClusterSnapshotScheduleMessage {
            /**
                * <p>A unique identifier for the cluster whose snapshot schedule you want to modify.
                *         </p>
                */
            ClusterIdentifier: string | undefined;
            /**
                * <p>A unique alphanumeric identifier for the schedule that you want to associate with the
                *             cluster.</p>
                */
            ScheduleIdentifier?: string;
            /**
                * <p>A boolean to indicate whether to remove the assoiciation between the cluster and the
                *             schedule.</p>
                */
            DisassociateSchedule?: boolean;
    }
    export namespace ModifyClusterSnapshotScheduleMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyClusterSnapshotScheduleMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface ModifyClusterSubnetGroupMessage {
            /**
                * <p>The name of the subnet group to be modified.</p>
                */
            ClusterSubnetGroupName: string | undefined;
            /**
                * <p>A text description of the subnet group to be modified.</p>
                */
            Description?: string;
            /**
                * <p>An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single
                *             request.</p>
                */
            SubnetIds: string[] | undefined;
    }
    export namespace ModifyClusterSubnetGroupMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyClusterSubnetGroupMessage) => any;
    }
    export interface ModifyClusterSubnetGroupResult {
            /**
                * <p>Describes a subnet group.</p>
                */
            ClusterSubnetGroup?: ClusterSubnetGroup;
    }
    export namespace ModifyClusterSubnetGroupResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyClusterSubnetGroupResult) => any;
    }
    /**
        * <p>A specified subnet is already in use by another cluster.</p>
        */
    export class SubnetAlreadyInUse extends __BaseException {
            readonly name: "SubnetAlreadyInUse";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SubnetAlreadyInUse, __BaseException>);
    }
    export interface ModifyEndpointAccessMessage {
            /**
                * <p>The endpoint to be modified.</p>
                */
            EndpointName: string | undefined;
            /**
                * <p>The complete list of VPC security groups associated with the endpoint after the endpoint is modified.</p>
                */
            VpcSecurityGroupIds?: string[];
    }
    export namespace ModifyEndpointAccessMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyEndpointAccessMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface ModifyEventSubscriptionMessage {
            /**
                * <p>The name of the modified Amazon Redshift event notification subscription.</p>
                */
            SubscriptionName: string | undefined;
            /**
                * <p>The Amazon Resource Name (ARN) of the SNS topic to be used by the event
                *             notification subscription.</p>
                */
            SnsTopicArn?: string;
            /**
                * <p>The type of source that will be generating the events. For example, if you want to
                *             be notified of events generated by a cluster, you would set this parameter to cluster.
                *             If this value is not specified, events are returned for all Amazon Redshift objects in your
                *             Amazon Web Services account. You must specify a source type in order to specify source IDs.</p>
                *         <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
                */
            SourceType?: string;
            /**
                * <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects
                *             must be of the same type as was specified in the source type parameter. The event
                *             subscription will return only events generated by the specified objects. If not
                *             specified, then events are returned for all objects within the source type
                *             specified.</p>
                *         <p>Example: my-cluster-1, my-cluster-2</p>
                *         <p>Example: my-snapshot-20131010</p>
                */
            SourceIds?: string[];
            /**
                * <p>Specifies the Amazon Redshift event categories to be published by the event notification
                *             subscription.</p>
                *         <p>Values: configuration, management, monitoring, security, pending</p>
                */
            EventCategories?: string[];
            /**
                * <p>Specifies the Amazon Redshift event severity to be published by the event notification
                *             subscription.</p>
                *         <p>Values: ERROR, INFO</p>
                */
            Severity?: string;
            /**
                * <p>A Boolean value indicating if the subscription is enabled. <code>true</code>
                *             indicates the subscription is enabled </p>
                */
            Enabled?: boolean;
    }
    export namespace ModifyEventSubscriptionMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyEventSubscriptionMessage) => any;
    }
    export interface ModifyEventSubscriptionResult {
            /**
                * <p>Describes event subscriptions.</p>
                */
            EventSubscription?: EventSubscription;
    }
    export namespace ModifyEventSubscriptionResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyEventSubscriptionResult) => any;
    }
    export interface ModifyScheduledActionMessage {
            /**
                * <p>The name of the scheduled action to modify. </p>
                */
            ScheduledActionName: string | undefined;
            /**
                * <p>A modified JSON format of the scheduled action.
                *             For more information about this parameter, see <a>ScheduledAction</a>. </p>
                */
            TargetAction?: ScheduledActionType;
            /**
                * <p>A modified schedule in either <code>at( )</code> or <code>cron( )</code> format.
                *             For more information about this parameter, see <a>ScheduledAction</a>.</p>
                */
            Schedule?: string;
            /**
                * <p>A different IAM role to assume to run the target action.
                *             For more information about this parameter, see <a>ScheduledAction</a>.</p>
                */
            IamRole?: string;
            /**
                * <p>A modified description of the scheduled action. </p>
                */
            ScheduledActionDescription?: string;
            /**
                * <p>A modified start time of the scheduled action.
                *             For more information about this parameter, see <a>ScheduledAction</a>. </p>
                */
            StartTime?: Date;
            /**
                * <p>A modified end time of the scheduled action.
                *             For more information about this parameter, see <a>ScheduledAction</a>. </p>
                */
            EndTime?: Date;
            /**
                * <p>A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. </p>
                */
            Enable?: boolean;
    }
    export namespace ModifyScheduledActionMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyScheduledActionMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface ModifySnapshotCopyRetentionPeriodMessage {
            /**
                * <p>The unique identifier of the cluster for which you want to change the retention
                *             period for either automated or manual snapshots that are copied to a destination Amazon Web Services Region.</p>
                *         <p>Constraints: Must be the valid name of an existing cluster that has cross-region
                *             snapshot copy enabled.</p>
                */
            ClusterIdentifier: string | undefined;
            /**
                * <p>The number of days to retain automated snapshots in the destination Amazon Web Services Region
                *             after they are copied from the source Amazon Web Services Region.</p>
                *         <p>By default, this only changes the retention period of copied automated snapshots. </p>
                *         <p>If you decrease the retention period for automated snapshots that are copied to a
                *             destination Amazon Web Services Region, Amazon Redshift deletes any existing automated snapshots that were
                *             copied to the destination Amazon Web Services Region and that fall outside of the new retention
                *             period.</p>
                *         <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p>
                *         <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will
                *             have the new retention period. </p>
                *         <p>If you specify the value of -1 newly copied manual snapshots are retained
                *             indefinitely.</p>
                *         <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653
                *             for manual snapshots.</p>
                */
            RetentionPeriod: number | undefined;
            /**
                * <p>Indicates whether to apply the snapshot retention period to newly copied manual
                *             snapshots instead of automated snapshots.</p>
                */
            Manual?: boolean;
    }
    export namespace ModifySnapshotCopyRetentionPeriodMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifySnapshotCopyRetentionPeriodMessage) => any;
    }
    export interface ModifySnapshotCopyRetentionPeriodResult {
            /**
                * <p>Describes a cluster.</p>
                */
            Cluster?: Cluster;
    }
    export namespace ModifySnapshotCopyRetentionPeriodResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifySnapshotCopyRetentionPeriodResult) => any;
    }
    /**
        * <p>Cross-region snapshot copy was temporarily disabled. Try your request
        *             again.</p>
        */
    export class SnapshotCopyDisabledFault extends __BaseException {
            readonly name: "SnapshotCopyDisabledFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SnapshotCopyDisabledFault, __BaseException>);
    }
    export interface ModifySnapshotScheduleMessage {
            /**
                * <p>A unique alphanumeric identifier of the schedule to modify.</p>
                */
            ScheduleIdentifier: string | undefined;
            /**
                * <p>An updated list of schedule definitions. A schedule definition is made up of schedule
                *             expressions, for example, "cron(30 12 *)" or "rate(12 hours)".</p>
                */
            ScheduleDefinitions: string[] | undefined;
    }
    export namespace ModifySnapshotScheduleMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifySnapshotScheduleMessage) => any;
    }
    /**
        * <p>The specified snapshot schedule is already being updated.</p>
        */
    export class SnapshotScheduleUpdateInProgressFault extends __BaseException {
            readonly name: "SnapshotScheduleUpdateInProgressFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SnapshotScheduleUpdateInProgressFault, __BaseException>);
    }
    export interface ModifyUsageLimitMessage {
            /**
                * <p>The identifier of the usage limit to modify.</p>
                */
            UsageLimitId: string | undefined;
            /**
                * <p>The new limit amount.
                *             For more information about this parameter, see <a>UsageLimit</a>. </p>
                */
            Amount?: number;
            /**
                * <p>The new action that Amazon Redshift takes when the limit is reached.
                *             For more information about this parameter, see <a>UsageLimit</a>. </p>
                */
            BreachAction?: UsageLimitBreachAction | string;
    }
    export namespace ModifyUsageLimitMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ModifyUsageLimitMessage) => any;
    }
    export interface PauseClusterResult {
            /**
                * <p>Describes a cluster.</p>
                */
            Cluster?: Cluster;
    }
    export namespace PauseClusterResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PauseClusterResult) => any;
    }
    /**
        * <p></p>
        */
    export interface PurchaseReservedNodeOfferingMessage {
            /**
                * <p>The unique identifier of the reserved node offering you want to purchase.</p>
                */
            ReservedNodeOfferingId: string | undefined;
            /**
                * <p>The number of reserved nodes that you want to purchase.</p>
                *         <p>Default: <code>1</code>
                *         </p>
                */
            NodeCount?: number;
    }
    export namespace PurchaseReservedNodeOfferingMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PurchaseReservedNodeOfferingMessage) => any;
    }
    export interface PurchaseReservedNodeOfferingResult {
            /**
                * <p>Describes a reserved node. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node
                *             offerings. </p>
                */
            ReservedNode?: ReservedNode;
    }
    export namespace PurchaseReservedNodeOfferingResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PurchaseReservedNodeOfferingResult) => any;
    }
    /**
        * <p>Request would exceed the user's compute node quota.
        * For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
        * in the <i>Amazon Redshift Cluster Management Guide</i>.
        * </p>
        */
    export class ReservedNodeQuotaExceededFault extends __BaseException {
            readonly name: "ReservedNodeQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ReservedNodeQuotaExceededFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export interface RebootClusterMessage {
            /**
                * <p>The cluster identifier.</p>
                */
            ClusterIdentifier: string | undefined;
    }
    export namespace RebootClusterMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RebootClusterMessage) => any;
    }
    export interface RebootClusterResult {
            /**
                * <p>Describes a cluster.</p>
                */
            Cluster?: Cluster;
    }
    export namespace RebootClusterResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RebootClusterResult) => any;
    }
    export interface RejectDataShareMessage {
            /**
                * <p>The Amazon Resource Name (ARN) of the datashare to reject.</p>
                */
            DataShareArn: string | undefined;
    }
    export namespace RejectDataShareMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RejectDataShareMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface ResetClusterParameterGroupMessage {
            /**
                * <p>The name of the cluster parameter group to be reset.</p>
                */
            ParameterGroupName: string | undefined;
            /**
                * <p>If <code>true</code>, all parameters in the specified parameter group will be reset
                *             to their default values. </p>
                *         <p>Default: <code>true</code>
                *         </p>
                */
            ResetAllParameters?: boolean;
            /**
                * <p>An array of names of parameters to be reset. If
                *                 <i>ResetAllParameters</i> option is not used, then at least one
                *             parameter name must be supplied. </p>
                *         <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
                */
            Parameters?: Parameter[];
    }
    export namespace ResetClusterParameterGroupMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResetClusterParameterGroupMessage) => any;
    }
    export interface ResizeClusterResult {
            /**
                * <p>Describes a cluster.</p>
                */
            Cluster?: Cluster;
    }
    export namespace ResizeClusterResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResizeClusterResult) => any;
    }
    /**
        * <p></p>
        */
    export interface RestoreFromClusterSnapshotMessage {
            /**
                * <p>The identifier of the cluster that will be created from restoring the
                *             snapshot.</p>
                *          <p>Constraints:</p>
                *          <ul>
                *             <li>
                *                <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p>
                *             </li>
                *             <li>
                *                <p>Alphabetic characters must be lowercase.</p>
                *             </li>
                *             <li>
                *                <p>First character must be a letter.</p>
                *             </li>
                *             <li>
                *                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
                *             </li>
                *             <li>
                *                <p>Must be unique for all clusters within an Amazon Web Services account.</p>
                *             </li>
                *          </ul>
                */
            ClusterIdentifier: string | undefined;
            /**
                * <p>The name of the snapshot from which to create the new cluster. This parameter isn't
                *             case sensitive.</p>
                *         <p>Example: <code>my-snapshot-id</code>
                *         </p>
                */
            SnapshotIdentifier?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the snapshot associated with the message to restore from a cluster.</p>
                */
            SnapshotArn?: string;
            /**
                * <p>The name of the cluster the source snapshot was created from. This parameter is
                *             required if your IAM user has a policy containing a snapshot resource element that
                *             specifies anything other than * for the cluster name.</p>
                */
            SnapshotClusterIdentifier?: string;
            /**
                * <p>The port number on which the cluster accepts connections.</p>
                *         <p>Default: The same port as the original cluster.</p>
                *         <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
                */
            Port?: number;
            /**
                * <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p>
                *         <p>Default: A random, system-chosen Availability Zone.</p>
                *         <p>Example: <code>us-east-2a</code>
                *         </p>
                */
            AvailabilityZone?: string;
            /**
                * <p>If <code>true</code>, major version upgrades can be applied during the maintenance
                *             window to the Amazon Redshift engine that is running on the cluster. </p>
                *         <p>Default: <code>true</code>
                *         </p>
                */
            AllowVersionUpgrade?: boolean;
            /**
                * <p>The name of the subnet group where you want to cluster restored.</p>
                *         <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must
                *             provide subnet group name where you want the cluster restored.</p>
                */
            ClusterSubnetGroupName?: string;
            /**
                * <p>If <code>true</code>, the cluster can be accessed from a public network. </p>
                */
            PubliclyAccessible?: boolean;
            /**
                * <p>The Amazon Web Services account used to create or copy the snapshot. Required if you are
                *             restoring a snapshot you do not own, optional if you own the snapshot.</p>
                */
            OwnerAccount?: string;
            /**
                * <p>Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to
                *             retrieve the data encryption keys stored in an HSM.</p>
                */
            HsmClientCertificateIdentifier?: string;
            /**
                * <p>Specifies the name of the HSM configuration that contains the information the
                *             Amazon Redshift cluster can use to retrieve and store keys in an HSM.</p>
                */
            HsmConfigurationIdentifier?: string;
            /**
                * <p>The elastic IP (EIP) address for the cluster. You don't have to specify the EIP for a
                *             publicly accessible cluster with AvailabilityZoneRelocation turned on.</p>
                */
            ElasticIp?: string;
            /**
                * <p>The name of the parameter group to be associated with this cluster.</p>
                *         <p>Default: The default Amazon Redshift cluster parameter group. For information about the
                *             default parameter group, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon
                *                 Redshift Parameter Groups</a>.</p>
                *         <p>Constraints:</p>
                *         <ul>
                *             <li>
                *                 <p>Must be 1 to 255 alphanumeric characters or hyphens.</p>
                *             </li>
                *             <li>
                *                 <p>First character must be a letter.</p>
                *             </li>
                *             <li>
                *                 <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
                *             </li>
                *          </ul>
                */
            ClusterParameterGroupName?: string;
            /**
                * <p>A list of security groups to be associated with this cluster.</p>
                *         <p>Default: The default cluster security group for Amazon Redshift.</p>
                *         <p>Cluster security groups only apply to clusters outside of VPCs.</p>
                */
            ClusterSecurityGroups?: string[];
            /**
                * <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the
                *             cluster.</p>
                *         <p>Default: The default VPC security group is associated with the cluster.</p>
                *         <p>VPC security groups only apply to clusters in VPCs.</p>
                */
            VpcSecurityGroupIds?: string[];
            /**
                * <p>The weekly time range (in UTC) during which automated cluster maintenance can
                *             occur.</p>
                *         <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code>
                *         </p>
                *         <p> Default: The value selected for the cluster from which the snapshot was taken. For
                *             more information about the time blocks for each region, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p>
                *         <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p>
                *         <p>Constraints: Minimum 30-minute window.</p>
                */
            PreferredMaintenanceWindow?: string;
            /**
                * <p>The number of days that automated snapshots are retained. If the value is 0,
                *             automated snapshots are disabled. Even if automated snapshots are disabled, you can
                *             still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p>
                *
                *         <p>You can't disable automated snapshots for RA3 node types. Set the automated retention period from 1-35 days.</p>
                *         <p>Default: The value selected for the cluster from which the snapshot was
                *             taken.</p>
                *         <p>Constraints: Must be a value from 0 to 35.</p>
                */
            AutomatedSnapshotRetentionPeriod?: number;
            /**
                * <p>The default number of days to retain a manual snapshot. If the value is -1, the
                *             snapshot is retained indefinitely. This setting doesn't change the retention period
                *             of existing snapshots.</p>
                *         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
                */
            ManualSnapshotRetentionPeriod?: number;
            /**
                * <p>The Key Management Service (KMS) key ID of the encryption key that encrypts data in the cluster
                *             restored from a shared snapshot. You can also provide
                *             the key ID when you restore from an unencrypted snapshot to an encrypted cluster in
                *             the same account. Additionally, you can specify a new KMS key ID when you restore from an encrypted
                *             snapshot in the same account in order to change it. In that case, the restored cluster is encrypted
                *             with the new KMS key ID.</p>
                */
            KmsKeyId?: string;
            /**
                * <p>The node type that the restored cluster will be provisioned with.</p>
                *         <p>Default: The node type of the cluster from which the snapshot was taken. You can
                *             modify this if you are using any DS node type. In that case, you can choose to restore
                *             into another DS node type of the same size. For example, you can restore ds1.8xlarge
                *             into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you
                *             must restore into that same instance type and size. In other words, you can only restore
                *             a dc1.large instance type into another dc1.large instance type or dc2.large instance
                *             type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlarge
                *             cluster, then resize to a dc2.8large cluster. For more information about node types, see
                *                 <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes">
                *                 About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
                */
            NodeType?: string;
            /**
                * <p>An option that specifies whether to create the cluster with enhanced VPC routing
                *             enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
                *             VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
                *             the Amazon Redshift Cluster Management Guide.</p>
                *         <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
                *         <p>Default: false</p>
                */
            EnhancedVpcRouting?: boolean;
            /**
                * <p>Reserved.</p>
                */
            AdditionalInfo?: string;
            /**
                * <p>A list of Identity and Access Management (IAM) roles that can be used by the
                *             cluster to access other Amazon Web Services services. You must supply the IAM roles in their Amazon
                *             Resource Name (ARN) format. </p>
                *         <p>The maximum number of IAM roles that you can associate is subject to a quota.
                *             For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Quotas and limits</a>
                *             in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
                */
            IamRoles?: string[];
            /**
                * <p>The name of the maintenance track for the restored cluster. When you take a snapshot,
                *             the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The
                *             snapshot might be on a different track than the cluster that was the source for the
                *             snapshot. For example, suppose that you take a snapshot of a cluster that is on the
                *             current track and then change the cluster to be on the trailing track. In this case, the
                *             snapshot and the source cluster are on different tracks.</p>
                */
            MaintenanceTrackName?: string;
            /**
                * <p>A unique identifier for the snapshot schedule.</p>
                */
            SnapshotScheduleIdentifier?: string;
            /**
                * <p>The number of nodes specified when provisioning the restored cluster.</p>
                */
            NumberOfNodes?: number;
            /**
                * <p>The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster is restored.</p>
                */
            AvailabilityZoneRelocation?: boolean;
            /**
                * <p>The value represents how the cluster is configured to use AQUA (Advanced Query Accelerator) after the cluster is restored. Possible values include the following.</p>
                *         <ul>
                *             <li>
                *                <p>enabled - Use AQUA if it is available for the current Amazon Web Services Region and Amazon Redshift node type.</p>
                *             </li>
                *             <li>
                *                <p>disabled - Don't use AQUA. </p>
                *             </li>
                *             <li>
                *                <p>auto - Amazon Redshift determines whether to use AQUA.</p>
                *             </li>
                *          </ul>
                */
            AquaConfigurationStatus?: AquaConfigurationStatus | string;
            /**
                * <p>The Amazon Resource Name (ARN) for the IAM role that was set as default for the cluster when the cluster was last modified while it was restored from a snapshot.</p>
                */
            DefaultIamRoleArn?: string;
            /**
                * <p>The identifier of the target reserved node offering.</p>
                */
            ReservedNodeId?: string;
            /**
                * <p>The identifier of the target reserved node offering.</p>
                */
            TargetReservedNodeOfferingId?: string;
            /**
                * <p>Enables support for restoring an unencrypted snapshot to a cluster encrypted
                *             with Key Management Service (KMS) and a customer managed key.</p>
                */
            Encrypted?: boolean;
    }
    export namespace RestoreFromClusterSnapshotMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RestoreFromClusterSnapshotMessage) => any;
    }
    export interface RestoreFromClusterSnapshotResult {
            /**
                * <p>Describes a cluster.</p>
                */
            Cluster?: Cluster;
    }
    export namespace RestoreFromClusterSnapshotResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RestoreFromClusterSnapshotResult) => any;
    }
    /**
        * <p></p>
        */
    export interface RestoreTableFromClusterSnapshotMessage {
            /**
                * <p>The identifier of the Amazon Redshift cluster to restore the table to.</p>
                */
            ClusterIdentifier: string | undefined;
            /**
                * <p>The identifier of the snapshot to restore the table from. This snapshot must have
                *             been created from the Amazon Redshift cluster specified by the
                *                 <code>ClusterIdentifier</code> parameter.</p>
                */
            SnapshotIdentifier: string | undefined;
            /**
                * <p>The name of the source database that contains the table to restore from.</p>
                */
            SourceDatabaseName: string | undefined;
            /**
                * <p>The name of the source schema that contains the table to restore from. If you do
                *             not specify a <code>SourceSchemaName</code> value, the default is
                *             <code>public</code>.</p>
                */
            SourceSchemaName?: string;
            /**
                * <p>The name of the source table to restore from.</p>
                */
            SourceTableName: string | undefined;
            /**
                * <p>The name of the database to restore the table to.</p>
                */
            TargetDatabaseName?: string;
            /**
                * <p>The name of the schema to restore the table to.</p>
                */
            TargetSchemaName?: string;
            /**
                * <p>The name of the table to create as a result of the current request.</p>
                */
            NewTableName: string | undefined;
            /**
                * <p>Indicates whether name identifiers for database, schema, and table are case sensitive.
                *             If <code>true</code>, the names are case sensitive.
                *             If <code>false</code> (default), the names are not case sensitive.</p>
                */
            EnableCaseSensitiveIdentifier?: boolean;
    }
    export namespace RestoreTableFromClusterSnapshotMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RestoreTableFromClusterSnapshotMessage) => any;
    }
    export interface RestoreTableFromClusterSnapshotResult {
            /**
                * <p>Describes the status of a <a>RestoreTableFromClusterSnapshot</a>
                *             operation.</p>
                */
            TableRestoreStatus?: TableRestoreStatus;
    }
    export namespace RestoreTableFromClusterSnapshotResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RestoreTableFromClusterSnapshotResult) => any;
    }
    export interface ResumeClusterResult {
            /**
                * <p>Describes a cluster.</p>
                */
            Cluster?: Cluster;
    }
    export namespace ResumeClusterResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResumeClusterResult) => any;
    }
    /**
        * <p></p>
        */
    export interface RevokeClusterSecurityGroupIngressMessage {
            /**
                * <p>The name of the security Group from which to revoke the ingress rule.</p>
                */
            ClusterSecurityGroupName: string | undefined;
            /**
                * <p>The IP range for which to revoke access. This range must be a valid Classless
                *             Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified,
                *                 <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be
                *             provided. </p>
                */
            CIDRIP?: string;
            /**
                * <p>The name of the EC2 Security Group whose access is to be revoked. If
                *                 <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code>
                *             must also be provided and <code>CIDRIP</code> cannot be provided. </p>
                */
            EC2SecurityGroupName?: string;
            /**
                * <p>The Amazon Web Services account number of the owner of the security group specified in the
                *                 <code>EC2SecurityGroupName</code> parameter. The Amazon Web Services access key ID is not an
                *             acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified,
                *                 <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code>
                *             cannot be provided. </p>
                *         <p>Example: <code>111122223333</code>
                *         </p>
                */
            EC2SecurityGroupOwnerId?: string;
    }
    export namespace RevokeClusterSecurityGroupIngressMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RevokeClusterSecurityGroupIngressMessage) => any;
    }
    export interface RevokeClusterSecurityGroupIngressResult {
            /**
                * <p>Describes a security group.</p>
                */
            ClusterSecurityGroup?: ClusterSecurityGroup;
    }
    export namespace RevokeClusterSecurityGroupIngressResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RevokeClusterSecurityGroupIngressResult) => any;
    }
    export interface RevokeEndpointAccessMessage {
            /**
                * <p>The cluster to revoke access from.</p>
                */
            ClusterIdentifier?: string;
            /**
                * <p>The Amazon Web Services account ID whose access is to be revoked.</p>
                */
            Account?: string;
            /**
                * <p>The virtual private cloud (VPC) identifiers for which access is to be revoked.</p>
                */
            VpcIds?: string[];
            /**
                * <p>Indicates whether to force the revoke action.
                *            If true, the Redshift-managed VPC endpoints associated with the endpoint authorization are also deleted.</p>
                */
            Force?: boolean;
    }
    export namespace RevokeEndpointAccessMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RevokeEndpointAccessMessage) => any;
    }
    /**
        * <p></p>
        */
    export interface RevokeSnapshotAccessMessage {
            /**
                * <p>The identifier of the snapshot that the account can no longer access.</p>
                */
            SnapshotIdentifier?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the snapshot associated with the message to revoke access.</p>
                */
            SnapshotArn?: string;
            /**
                * <p>The identifier of the cluster the snapshot was created from. This parameter is
                *             required if your IAM user has a policy containing a snapshot resource element that
                *             specifies anything other than * for the cluster name.</p>
                */
            SnapshotClusterIdentifier?: string;
            /**
                * <p>The identifier of the Amazon Web Services account that can no longer restore the specified
                *             snapshot.</p>
                */
            AccountWithRestoreAccess: string | undefined;
    }
    export namespace RevokeSnapshotAccessMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RevokeSnapshotAccessMessage) => any;
    }
    export interface RevokeSnapshotAccessResult {
            /**
                * <p>Describes a snapshot.</p>
                */
            Snapshot?: Snapshot;
    }
    export namespace RevokeSnapshotAccessResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RevokeSnapshotAccessResult) => any;
    }
    /**
        * <p></p>
        */
    export interface RotateEncryptionKeyMessage {
            /**
                * <p>The unique identifier of the cluster that you want to rotate the encryption keys
                *             for.</p>
                *         <p>Constraints: Must be the name of valid cluster that has encryption
                *             enabled.</p>
                */
            ClusterIdentifier: string | undefined;
    }
    export namespace RotateEncryptionKeyMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RotateEncryptionKeyMessage) => any;
    }
    export interface RotateEncryptionKeyResult {
            /**
                * <p>Describes a cluster.</p>
                */
            Cluster?: Cluster;
    }
    export namespace RotateEncryptionKeyResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RotateEncryptionKeyResult) => any;
    }
    export interface UpdatePartnerStatusInputMessage {
            /**
                * <p>The Amazon Web Services account ID that owns the cluster.</p>
                */
            AccountId: string | undefined;
            /**
                * <p>The cluster identifier of the cluster whose partner integration status is being updated.</p>
                */
            ClusterIdentifier: string | undefined;
            /**
                * <p>The name of the database whose partner integration status is being updated.</p>
                */
            DatabaseName: string | undefined;
            /**
                * <p>The name of the partner whose integration status is being updated.</p>
                */
            PartnerName: string | undefined;
            /**
                * <p>The value of the updated status.</p>
                */
            Status: PartnerIntegrationStatus | string | undefined;
            /**
                * <p>The status message provided by the partner.</p>
                */
            StatusMessage?: string;
    }
    export namespace UpdatePartnerStatusInputMessage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdatePartnerStatusInputMessage) => any;
    }
}

declare module '@aws-sdk/client-redshift/node_modules/@aws-sdk/client-redshift/dist-types/models/RedshiftServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from Redshift service.
        */
    export class RedshiftServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

