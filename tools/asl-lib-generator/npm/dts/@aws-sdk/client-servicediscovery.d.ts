// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/smithy-client
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http

declare module '@aws-sdk/client-servicediscovery' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { CreateHttpNamespaceCommandInput, CreateHttpNamespaceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/CreateHttpNamespaceCommand";
    import { CreatePrivateDnsNamespaceCommandInput, CreatePrivateDnsNamespaceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/CreatePrivateDnsNamespaceCommand";
    import { CreatePublicDnsNamespaceCommandInput, CreatePublicDnsNamespaceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/CreatePublicDnsNamespaceCommand";
    import { CreateServiceCommandInput, CreateServiceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/CreateServiceCommand";
    import { DeleteNamespaceCommandInput, DeleteNamespaceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/DeleteNamespaceCommand";
    import { DeleteServiceCommandInput, DeleteServiceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/DeleteServiceCommand";
    import { DeregisterInstanceCommandInput, DeregisterInstanceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/DeregisterInstanceCommand";
    import { DiscoverInstancesCommandInput, DiscoverInstancesCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/DiscoverInstancesCommand";
    import { GetInstanceCommandInput, GetInstanceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/GetInstanceCommand";
    import { GetInstancesHealthStatusCommandInput, GetInstancesHealthStatusCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/GetInstancesHealthStatusCommand";
    import { GetNamespaceCommandInput, GetNamespaceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/GetNamespaceCommand";
    import { GetOperationCommandInput, GetOperationCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/GetOperationCommand";
    import { GetServiceCommandInput, GetServiceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/GetServiceCommand";
    import { ListInstancesCommandInput, ListInstancesCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/ListInstancesCommand";
    import { ListNamespacesCommandInput, ListNamespacesCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/ListNamespacesCommand";
    import { ListOperationsCommandInput, ListOperationsCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/ListOperationsCommand";
    import { ListServicesCommandInput, ListServicesCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/ListServicesCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/ListTagsForResourceCommand";
    import { RegisterInstanceCommandInput, RegisterInstanceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/RegisterInstanceCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/UntagResourceCommand";
    import { UpdateHttpNamespaceCommandInput, UpdateHttpNamespaceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/UpdateHttpNamespaceCommand";
    import { UpdateInstanceCustomHealthStatusCommandInput, UpdateInstanceCustomHealthStatusCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/UpdateInstanceCustomHealthStatusCommand";
    import { UpdatePrivateDnsNamespaceCommandInput, UpdatePrivateDnsNamespaceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/UpdatePrivateDnsNamespaceCommand";
    import { UpdatePublicDnsNamespaceCommandInput, UpdatePublicDnsNamespaceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/UpdatePublicDnsNamespaceCommand";
    import { UpdateServiceCommandInput, UpdateServiceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/UpdateServiceCommand";
    import { ServiceDiscoveryClient } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    /**
        * <fullname>Cloud Map</fullname>
        *          <p>With Cloud Map, you can configure public DNS, private DNS, or HTTP namespaces that your microservice
        *    applications run in. When an instance becomes available, you can call the Cloud Map API to register the instance
        *    with Cloud Map. For public or private DNS namespaces, Cloud Map automatically creates DNS records and an optional
        *    health check. Clients that submit public or private DNS queries, or HTTP requests, for the service receive an answer
        *    that contains up to eight healthy records. </p>
        */
    export class ServiceDiscovery extends ServiceDiscoveryClient {
            /**
                * <p>Creates an HTTP namespace. Service instances registered using an HTTP namespace can be discovered using a
                *     <code>DiscoverInstances</code> request but can't be discovered using DNS.</p>
                *          <p>For the current quota on the number of namespaces that you can create using the same account,
                *    see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/cloud-map-limits.html">Cloud Map quotas</a> in the
                *     <i>Cloud Map Developer Guide</i>.</p>
                */
            createHttpNamespace(args: CreateHttpNamespaceCommandInput, options?: __HttpHandlerOptions): Promise<CreateHttpNamespaceCommandOutput>;
            createHttpNamespace(args: CreateHttpNamespaceCommandInput, cb: (err: any, data?: CreateHttpNamespaceCommandOutput) => void): void;
            createHttpNamespace(args: CreateHttpNamespaceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateHttpNamespaceCommandOutput) => void): void;
            /**
                * <p>Creates a private namespace based on DNS, which is visible only inside a specified Amazon VPC. The namespace
                *    defines your service naming scheme. For example, if you name your namespace <code>example.com</code> and name your
                *    service <code>backend</code>, the resulting DNS name for the service is <code>backend.example.com</code>. Service
                *    instances that are registered using a private DNS namespace can be discovered using either a
                *     <code>DiscoverInstances</code> request or using DNS. For the current quota on the number of namespaces that you can
                *    create using the same account, see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/cloud-map-limits.html">Cloud Map quotas</a> in the
                *     <i>Cloud Map Developer Guide</i>.</p>
                */
            createPrivateDnsNamespace(args: CreatePrivateDnsNamespaceCommandInput, options?: __HttpHandlerOptions): Promise<CreatePrivateDnsNamespaceCommandOutput>;
            createPrivateDnsNamespace(args: CreatePrivateDnsNamespaceCommandInput, cb: (err: any, data?: CreatePrivateDnsNamespaceCommandOutput) => void): void;
            createPrivateDnsNamespace(args: CreatePrivateDnsNamespaceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreatePrivateDnsNamespaceCommandOutput) => void): void;
            /**
                * <p>Creates a public namespace based on DNS, which is visible on the internet. The namespace defines your service
                *    naming scheme. For example, if you name your namespace <code>example.com</code> and name your service
                *     <code>backend</code>, the resulting DNS name for the service is <code>backend.example.com</code>. You can discover
                *    instances that were registered with a public DNS namespace by using either a <code>DiscoverInstances</code> request
                *    or using DNS. For the current quota on the number of namespaces that you can create using the same account, see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/cloud-map-limits.html">Cloud Map
                *     quotas</a> in the <i>Cloud Map Developer Guide</i>.</p>
                */
            createPublicDnsNamespace(args: CreatePublicDnsNamespaceCommandInput, options?: __HttpHandlerOptions): Promise<CreatePublicDnsNamespaceCommandOutput>;
            createPublicDnsNamespace(args: CreatePublicDnsNamespaceCommandInput, cb: (err: any, data?: CreatePublicDnsNamespaceCommandOutput) => void): void;
            createPublicDnsNamespace(args: CreatePublicDnsNamespaceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreatePublicDnsNamespaceCommandOutput) => void): void;
            /**
                * <p>Creates a service. This action defines the configuration for the following entities:</p>
                *          <ul>
                *             <li>
                *                <p>For public and private DNS namespaces, one of the following combinations of DNS records in Amazon Route 53:</p>
                *                <ul>
                *                   <li>
                *                      <p>
                *                         <code>A</code>
                *                      </p>
                *                   </li>
                *                   <li>
                *                      <p>
                *                         <code>AAAA</code>
                *                      </p>
                *                   </li>
                *                   <li>
                *                      <p>
                *                         <code>A</code> and <code>AAAA</code>
                *                      </p>
                *                   </li>
                *                   <li>
                *                      <p>
                *                         <code>SRV</code>
                *                      </p>
                *                   </li>
                *                   <li>
                *                      <p>
                *                         <code>CNAME</code>
                *                      </p>
                *                   </li>
                *                </ul>
                *             </li>
                *             <li>
                *                <p>Optionally, a health check</p>
                *             </li>
                *          </ul>
                *          <p>After you create the service, you can submit a <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance</a> request, and Cloud Map uses the
                *    values in the configuration to create the specified entities.</p>
                *          <p>For the current quota on the number of instances that you can register using the same namespace and using the
                *    same service, see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/cloud-map-limits.html">Cloud Map
                *     quotas</a> in the <i>Cloud Map Developer Guide</i>.</p>
                */
            createService(args: CreateServiceCommandInput, options?: __HttpHandlerOptions): Promise<CreateServiceCommandOutput>;
            createService(args: CreateServiceCommandInput, cb: (err: any, data?: CreateServiceCommandOutput) => void): void;
            createService(args: CreateServiceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateServiceCommandOutput) => void): void;
            /**
                * <p>Deletes a namespace from the current account. If the namespace still contains one or more services, the request
                *    fails.</p>
                */
            deleteNamespace(args: DeleteNamespaceCommandInput, options?: __HttpHandlerOptions): Promise<DeleteNamespaceCommandOutput>;
            deleteNamespace(args: DeleteNamespaceCommandInput, cb: (err: any, data?: DeleteNamespaceCommandOutput) => void): void;
            deleteNamespace(args: DeleteNamespaceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteNamespaceCommandOutput) => void): void;
            /**
                * <p>Deletes a specified service. If the service still contains one or more registered instances, the request
                *    fails.</p>
                */
            deleteService(args: DeleteServiceCommandInput, options?: __HttpHandlerOptions): Promise<DeleteServiceCommandOutput>;
            deleteService(args: DeleteServiceCommandInput, cb: (err: any, data?: DeleteServiceCommandOutput) => void): void;
            deleteService(args: DeleteServiceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteServiceCommandOutput) => void): void;
            /**
                * <p>Deletes the Amazon Route 53 DNS records and health check, if any, that Cloud Map created for the specified
                *    instance.</p>
                */
            deregisterInstance(args: DeregisterInstanceCommandInput, options?: __HttpHandlerOptions): Promise<DeregisterInstanceCommandOutput>;
            deregisterInstance(args: DeregisterInstanceCommandInput, cb: (err: any, data?: DeregisterInstanceCommandOutput) => void): void;
            deregisterInstance(args: DeregisterInstanceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeregisterInstanceCommandOutput) => void): void;
            /**
                * <p>Discovers registered instances for a specified namespace and service. You can use <code>DiscoverInstances</code>
                *    to discover instances for any type of namespace. For public and private DNS namespaces, you can also use DNS queries
                *    to discover instances.</p>
                */
            discoverInstances(args: DiscoverInstancesCommandInput, options?: __HttpHandlerOptions): Promise<DiscoverInstancesCommandOutput>;
            discoverInstances(args: DiscoverInstancesCommandInput, cb: (err: any, data?: DiscoverInstancesCommandOutput) => void): void;
            discoverInstances(args: DiscoverInstancesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DiscoverInstancesCommandOutput) => void): void;
            /**
                * <p>Gets information about a specified instance.</p>
                */
            getInstance(args: GetInstanceCommandInput, options?: __HttpHandlerOptions): Promise<GetInstanceCommandOutput>;
            getInstance(args: GetInstanceCommandInput, cb: (err: any, data?: GetInstanceCommandOutput) => void): void;
            getInstance(args: GetInstanceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetInstanceCommandOutput) => void): void;
            /**
                * <p>Gets the current health status (<code>Healthy</code>, <code>Unhealthy</code>, or <code>Unknown</code>) of one or
                *    more instances that are associated with a specified service.</p>
                *          <note>
                *             <p>There's a brief delay between when you register an instance and when the health status for the instance is
                *     available. </p>
                *          </note>
                */
            getInstancesHealthStatus(args: GetInstancesHealthStatusCommandInput, options?: __HttpHandlerOptions): Promise<GetInstancesHealthStatusCommandOutput>;
            getInstancesHealthStatus(args: GetInstancesHealthStatusCommandInput, cb: (err: any, data?: GetInstancesHealthStatusCommandOutput) => void): void;
            getInstancesHealthStatus(args: GetInstancesHealthStatusCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetInstancesHealthStatusCommandOutput) => void): void;
            /**
                * <p>Gets information about a namespace.</p>
                */
            getNamespace(args: GetNamespaceCommandInput, options?: __HttpHandlerOptions): Promise<GetNamespaceCommandOutput>;
            getNamespace(args: GetNamespaceCommandInput, cb: (err: any, data?: GetNamespaceCommandOutput) => void): void;
            getNamespace(args: GetNamespaceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetNamespaceCommandOutput) => void): void;
            /**
                * <p>Gets information about any operation that returns an operation ID in the response, such as a
                *     <code>CreateService</code> request.</p>
                *          <note>
                *             <p>To get a list of operations that match specified criteria, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_ListOperations.html">ListOperations</a>.</p>
                *          </note>
                */
            getOperation(args: GetOperationCommandInput, options?: __HttpHandlerOptions): Promise<GetOperationCommandOutput>;
            getOperation(args: GetOperationCommandInput, cb: (err: any, data?: GetOperationCommandOutput) => void): void;
            getOperation(args: GetOperationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetOperationCommandOutput) => void): void;
            /**
                * <p>Gets the settings for a specified service.</p>
                */
            getService(args: GetServiceCommandInput, options?: __HttpHandlerOptions): Promise<GetServiceCommandOutput>;
            getService(args: GetServiceCommandInput, cb: (err: any, data?: GetServiceCommandOutput) => void): void;
            getService(args: GetServiceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetServiceCommandOutput) => void): void;
            /**
                * <p>Lists summary information about the instances that you registered by using a specified service.</p>
                */
            listInstances(args: ListInstancesCommandInput, options?: __HttpHandlerOptions): Promise<ListInstancesCommandOutput>;
            listInstances(args: ListInstancesCommandInput, cb: (err: any, data?: ListInstancesCommandOutput) => void): void;
            listInstances(args: ListInstancesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListInstancesCommandOutput) => void): void;
            /**
                * <p>Lists summary information about the namespaces that were created by the current account.</p>
                */
            listNamespaces(args: ListNamespacesCommandInput, options?: __HttpHandlerOptions): Promise<ListNamespacesCommandOutput>;
            listNamespaces(args: ListNamespacesCommandInput, cb: (err: any, data?: ListNamespacesCommandOutput) => void): void;
            listNamespaces(args: ListNamespacesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListNamespacesCommandOutput) => void): void;
            /**
                * <p>Lists operations that match the criteria that you specify.</p>
                */
            listOperations(args: ListOperationsCommandInput, options?: __HttpHandlerOptions): Promise<ListOperationsCommandOutput>;
            listOperations(args: ListOperationsCommandInput, cb: (err: any, data?: ListOperationsCommandOutput) => void): void;
            listOperations(args: ListOperationsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListOperationsCommandOutput) => void): void;
            /**
                * <p>Lists summary information for all the services that are associated with one or more specified namespaces.</p>
                */
            listServices(args: ListServicesCommandInput, options?: __HttpHandlerOptions): Promise<ListServicesCommandOutput>;
            listServices(args: ListServicesCommandInput, cb: (err: any, data?: ListServicesCommandOutput) => void): void;
            listServices(args: ListServicesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListServicesCommandOutput) => void): void;
            /**
                * <p>Lists tags for the specified resource.</p>
                */
            listTagsForResource(args: ListTagsForResourceCommandInput, options?: __HttpHandlerOptions): Promise<ListTagsForResourceCommandOutput>;
            listTagsForResource(args: ListTagsForResourceCommandInput, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            listTagsForResource(args: ListTagsForResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            /**
                * <p>Creates or updates one or more records and, optionally, creates a health check based on the settings in a
                *    specified service. When you submit a <code>RegisterInstance</code> request, the following occurs:</p>
                *          <ul>
                *             <li>
                *                <p>For each DNS record that you define in the service that's specified by <code>ServiceId</code>, a record is
                *      created or updated in the hosted zone that's associated with the corresponding namespace.</p>
                *             </li>
                *             <li>
                *                <p>If the service includes <code>HealthCheckConfig</code>, a health check is created based on the settings in the
                *      health check configuration.</p>
                *             </li>
                *             <li>
                *                <p>The health check, if any, is associated with each of the new or updated records.</p>
                *             </li>
                *          </ul>
                *          <important>
                *             <p>One <code>RegisterInstance</code> request must complete before you can submit another request and specify the
                *     same service ID and instance ID.</p>
                *          </important>
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_CreateService.html">CreateService</a>.</p>
                *          <p>When Cloud Map receives a DNS query for the specified DNS name, it returns the applicable value:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <b>If the health check is healthy</b>: returns all the records</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>If the health check is unhealthy</b>: returns the applicable value for the last
                *      healthy instance</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>If you didn't specify a health check configuration</b>: returns all the
                *      records</p>
                *             </li>
                *          </ul>
                *          <p>For the current quota on the number of instances that you can register using the same namespace and using the
                *    same service, see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/cloud-map-limits.html">Cloud Map
                *     quotas</a> in the <i>Cloud Map Developer Guide</i>.</p>
                */
            registerInstance(args: RegisterInstanceCommandInput, options?: __HttpHandlerOptions): Promise<RegisterInstanceCommandOutput>;
            registerInstance(args: RegisterInstanceCommandInput, cb: (err: any, data?: RegisterInstanceCommandOutput) => void): void;
            registerInstance(args: RegisterInstanceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RegisterInstanceCommandOutput) => void): void;
            /**
                * <p>Adds one or more tags to the specified resource.</p>
                */
            tagResource(args: TagResourceCommandInput, options?: __HttpHandlerOptions): Promise<TagResourceCommandOutput>;
            tagResource(args: TagResourceCommandInput, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            tagResource(args: TagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            /**
                * <p>Removes one or more tags from the specified resource.</p>
                */
            untagResource(args: UntagResourceCommandInput, options?: __HttpHandlerOptions): Promise<UntagResourceCommandOutput>;
            untagResource(args: UntagResourceCommandInput, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            untagResource(args: UntagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            /**
                * <p>Updates an HTTP
                *    namespace.</p>
                */
            updateHttpNamespace(args: UpdateHttpNamespaceCommandInput, options?: __HttpHandlerOptions): Promise<UpdateHttpNamespaceCommandOutput>;
            updateHttpNamespace(args: UpdateHttpNamespaceCommandInput, cb: (err: any, data?: UpdateHttpNamespaceCommandOutput) => void): void;
            updateHttpNamespace(args: UpdateHttpNamespaceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateHttpNamespaceCommandOutput) => void): void;
            /**
                * <p>Submits a request to change the health status of a custom health check to healthy or unhealthy.</p>
                *          <p>You can use <code>UpdateInstanceCustomHealthStatus</code> to change the status only for custom health checks,
                *    which you define using <code>HealthCheckCustomConfig</code> when you create a service. You can't use it to change the
                *    status for Route 53 health checks, which you define using <code>HealthCheckConfig</code>.</p>
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_HealthCheckCustomConfig.html">HealthCheckCustomConfig</a>.</p>
                */
            updateInstanceCustomHealthStatus(args: UpdateInstanceCustomHealthStatusCommandInput, options?: __HttpHandlerOptions): Promise<UpdateInstanceCustomHealthStatusCommandOutput>;
            updateInstanceCustomHealthStatus(args: UpdateInstanceCustomHealthStatusCommandInput, cb: (err: any, data?: UpdateInstanceCustomHealthStatusCommandOutput) => void): void;
            updateInstanceCustomHealthStatus(args: UpdateInstanceCustomHealthStatusCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateInstanceCustomHealthStatusCommandOutput) => void): void;
            /**
                * <p>Updates a private DNS
                *    namespace.</p>
                */
            updatePrivateDnsNamespace(args: UpdatePrivateDnsNamespaceCommandInput, options?: __HttpHandlerOptions): Promise<UpdatePrivateDnsNamespaceCommandOutput>;
            updatePrivateDnsNamespace(args: UpdatePrivateDnsNamespaceCommandInput, cb: (err: any, data?: UpdatePrivateDnsNamespaceCommandOutput) => void): void;
            updatePrivateDnsNamespace(args: UpdatePrivateDnsNamespaceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdatePrivateDnsNamespaceCommandOutput) => void): void;
            /**
                * <p>Updates a public DNS
                *    namespace.</p>
                */
            updatePublicDnsNamespace(args: UpdatePublicDnsNamespaceCommandInput, options?: __HttpHandlerOptions): Promise<UpdatePublicDnsNamespaceCommandOutput>;
            updatePublicDnsNamespace(args: UpdatePublicDnsNamespaceCommandInput, cb: (err: any, data?: UpdatePublicDnsNamespaceCommandOutput) => void): void;
            updatePublicDnsNamespace(args: UpdatePublicDnsNamespaceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdatePublicDnsNamespaceCommandOutput) => void): void;
            /**
                * <p>Submits a request to perform the following operations:</p>
                *          <ul>
                *             <li>
                *                <p>Update the TTL setting for existing <code>DnsRecords</code> configurations</p>
                *             </li>
                *             <li>
                *                <p>Add, update, or delete <code>HealthCheckConfig</code> for a specified service</p>
                *                <note>
                *                   <p>You can't add, update, or delete a <code>HealthCheckCustomConfig</code> configuration.</p>
                *                </note>
                *             </li>
                *          </ul>
                *          <p>For public and private DNS namespaces, note the following:</p>
                *          <ul>
                *             <li>
                *                <p>If you omit any existing <code>DnsRecords</code> or <code>HealthCheckConfig</code> configurations from an
                *       <code>UpdateService</code> request, the configurations are deleted from the service.</p>
                *             </li>
                *             <li>
                *                <p>If you omit an existing <code>HealthCheckCustomConfig</code> configuration from an <code>UpdateService</code>
                *      request, the configuration isn't deleted from the service.</p>
                *             </li>
                *          </ul>
                *          <p>When you update settings for a service, Cloud Map also updates the corresponding settings in all the records
                *    and health checks that were created by using the specified service.</p>
                */
            updateService(args: UpdateServiceCommandInput, options?: __HttpHandlerOptions): Promise<UpdateServiceCommandOutput>;
            updateService(args: UpdateServiceCommandInput, cb: (err: any, data?: UpdateServiceCommandOutput) => void): void;
            updateService(args: UpdateServiceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateServiceCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/CreateHttpNamespaceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateHttpNamespaceRequest, CreateHttpNamespaceResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface CreateHttpNamespaceCommandInput extends CreateHttpNamespaceRequest {
    }
    export interface CreateHttpNamespaceCommandOutput extends CreateHttpNamespaceResponse, __MetadataBearer {
    }
    /**
        * <p>Creates an HTTP namespace. Service instances registered using an HTTP namespace can be discovered using a
        *     <code>DiscoverInstances</code> request but can't be discovered using DNS.</p>
        *          <p>For the current quota on the number of namespaces that you can create using the same account,
        *    see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/cloud-map-limits.html">Cloud Map quotas</a> in the
        *     <i>Cloud Map Developer Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, CreateHttpNamespaceCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, CreateHttpNamespaceCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new CreateHttpNamespaceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateHttpNamespaceCommandInput} for command's `input` shape.
        * @see {@link CreateHttpNamespaceCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class CreateHttpNamespaceCommand extends $Command<CreateHttpNamespaceCommandInput, CreateHttpNamespaceCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: CreateHttpNamespaceCommandInput;
            constructor(input: CreateHttpNamespaceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateHttpNamespaceCommandInput, CreateHttpNamespaceCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/CreatePrivateDnsNamespaceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreatePrivateDnsNamespaceRequest, CreatePrivateDnsNamespaceResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface CreatePrivateDnsNamespaceCommandInput extends CreatePrivateDnsNamespaceRequest {
    }
    export interface CreatePrivateDnsNamespaceCommandOutput extends CreatePrivateDnsNamespaceResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a private namespace based on DNS, which is visible only inside a specified Amazon VPC. The namespace
        *    defines your service naming scheme. For example, if you name your namespace <code>example.com</code> and name your
        *    service <code>backend</code>, the resulting DNS name for the service is <code>backend.example.com</code>. Service
        *    instances that are registered using a private DNS namespace can be discovered using either a
        *     <code>DiscoverInstances</code> request or using DNS. For the current quota on the number of namespaces that you can
        *    create using the same account, see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/cloud-map-limits.html">Cloud Map quotas</a> in the
        *     <i>Cloud Map Developer Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, CreatePrivateDnsNamespaceCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, CreatePrivateDnsNamespaceCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new CreatePrivateDnsNamespaceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreatePrivateDnsNamespaceCommandInput} for command's `input` shape.
        * @see {@link CreatePrivateDnsNamespaceCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class CreatePrivateDnsNamespaceCommand extends $Command<CreatePrivateDnsNamespaceCommandInput, CreatePrivateDnsNamespaceCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: CreatePrivateDnsNamespaceCommandInput;
            constructor(input: CreatePrivateDnsNamespaceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreatePrivateDnsNamespaceCommandInput, CreatePrivateDnsNamespaceCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/CreatePublicDnsNamespaceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreatePublicDnsNamespaceRequest, CreatePublicDnsNamespaceResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface CreatePublicDnsNamespaceCommandInput extends CreatePublicDnsNamespaceRequest {
    }
    export interface CreatePublicDnsNamespaceCommandOutput extends CreatePublicDnsNamespaceResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a public namespace based on DNS, which is visible on the internet. The namespace defines your service
        *    naming scheme. For example, if you name your namespace <code>example.com</code> and name your service
        *     <code>backend</code>, the resulting DNS name for the service is <code>backend.example.com</code>. You can discover
        *    instances that were registered with a public DNS namespace by using either a <code>DiscoverInstances</code> request
        *    or using DNS. For the current quota on the number of namespaces that you can create using the same account, see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/cloud-map-limits.html">Cloud Map
        *     quotas</a> in the <i>Cloud Map Developer Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, CreatePublicDnsNamespaceCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, CreatePublicDnsNamespaceCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new CreatePublicDnsNamespaceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreatePublicDnsNamespaceCommandInput} for command's `input` shape.
        * @see {@link CreatePublicDnsNamespaceCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class CreatePublicDnsNamespaceCommand extends $Command<CreatePublicDnsNamespaceCommandInput, CreatePublicDnsNamespaceCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: CreatePublicDnsNamespaceCommandInput;
            constructor(input: CreatePublicDnsNamespaceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreatePublicDnsNamespaceCommandInput, CreatePublicDnsNamespaceCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/CreateServiceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateServiceRequest, CreateServiceResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface CreateServiceCommandInput extends CreateServiceRequest {
    }
    export interface CreateServiceCommandOutput extends CreateServiceResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a service. This action defines the configuration for the following entities:</p>
        *          <ul>
        *             <li>
        *                <p>For public and private DNS namespaces, one of the following combinations of DNS records in Amazon Route 53:</p>
        *                <ul>
        *                   <li>
        *                      <p>
        *                         <code>A</code>
        *                      </p>
        *                   </li>
        *                   <li>
        *                      <p>
        *                         <code>AAAA</code>
        *                      </p>
        *                   </li>
        *                   <li>
        *                      <p>
        *                         <code>A</code> and <code>AAAA</code>
        *                      </p>
        *                   </li>
        *                   <li>
        *                      <p>
        *                         <code>SRV</code>
        *                      </p>
        *                   </li>
        *                   <li>
        *                      <p>
        *                         <code>CNAME</code>
        *                      </p>
        *                   </li>
        *                </ul>
        *             </li>
        *             <li>
        *                <p>Optionally, a health check</p>
        *             </li>
        *          </ul>
        *          <p>After you create the service, you can submit a <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance</a> request, and Cloud Map uses the
        *    values in the configuration to create the specified entities.</p>
        *          <p>For the current quota on the number of instances that you can register using the same namespace and using the
        *    same service, see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/cloud-map-limits.html">Cloud Map
        *     quotas</a> in the <i>Cloud Map Developer Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, CreateServiceCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, CreateServiceCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new CreateServiceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateServiceCommandInput} for command's `input` shape.
        * @see {@link CreateServiceCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class CreateServiceCommand extends $Command<CreateServiceCommandInput, CreateServiceCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: CreateServiceCommandInput;
            constructor(input: CreateServiceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateServiceCommandInput, CreateServiceCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/DeleteNamespaceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteNamespaceRequest, DeleteNamespaceResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface DeleteNamespaceCommandInput extends DeleteNamespaceRequest {
    }
    export interface DeleteNamespaceCommandOutput extends DeleteNamespaceResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes a namespace from the current account. If the namespace still contains one or more services, the request
        *    fails.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, DeleteNamespaceCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, DeleteNamespaceCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new DeleteNamespaceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteNamespaceCommandInput} for command's `input` shape.
        * @see {@link DeleteNamespaceCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class DeleteNamespaceCommand extends $Command<DeleteNamespaceCommandInput, DeleteNamespaceCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: DeleteNamespaceCommandInput;
            constructor(input: DeleteNamespaceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteNamespaceCommandInput, DeleteNamespaceCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/DeleteServiceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteServiceRequest, DeleteServiceResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface DeleteServiceCommandInput extends DeleteServiceRequest {
    }
    export interface DeleteServiceCommandOutput extends DeleteServiceResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes a specified service. If the service still contains one or more registered instances, the request
        *    fails.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, DeleteServiceCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, DeleteServiceCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new DeleteServiceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteServiceCommandInput} for command's `input` shape.
        * @see {@link DeleteServiceCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class DeleteServiceCommand extends $Command<DeleteServiceCommandInput, DeleteServiceCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: DeleteServiceCommandInput;
            constructor(input: DeleteServiceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteServiceCommandInput, DeleteServiceCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/DeregisterInstanceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeregisterInstanceRequest, DeregisterInstanceResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface DeregisterInstanceCommandInput extends DeregisterInstanceRequest {
    }
    export interface DeregisterInstanceCommandOutput extends DeregisterInstanceResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes the Amazon Route 53 DNS records and health check, if any, that Cloud Map created for the specified
        *    instance.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, DeregisterInstanceCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, DeregisterInstanceCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new DeregisterInstanceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeregisterInstanceCommandInput} for command's `input` shape.
        * @see {@link DeregisterInstanceCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class DeregisterInstanceCommand extends $Command<DeregisterInstanceCommandInput, DeregisterInstanceCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: DeregisterInstanceCommandInput;
            constructor(input: DeregisterInstanceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeregisterInstanceCommandInput, DeregisterInstanceCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/DiscoverInstancesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DiscoverInstancesRequest, DiscoverInstancesResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface DiscoverInstancesCommandInput extends DiscoverInstancesRequest {
    }
    export interface DiscoverInstancesCommandOutput extends DiscoverInstancesResponse, __MetadataBearer {
    }
    /**
        * <p>Discovers registered instances for a specified namespace and service. You can use <code>DiscoverInstances</code>
        *    to discover instances for any type of namespace. For public and private DNS namespaces, you can also use DNS queries
        *    to discover instances.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, DiscoverInstancesCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, DiscoverInstancesCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new DiscoverInstancesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DiscoverInstancesCommandInput} for command's `input` shape.
        * @see {@link DiscoverInstancesCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class DiscoverInstancesCommand extends $Command<DiscoverInstancesCommandInput, DiscoverInstancesCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: DiscoverInstancesCommandInput;
            constructor(input: DiscoverInstancesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DiscoverInstancesCommandInput, DiscoverInstancesCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/GetInstanceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetInstanceRequest, GetInstanceResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface GetInstanceCommandInput extends GetInstanceRequest {
    }
    export interface GetInstanceCommandOutput extends GetInstanceResponse, __MetadataBearer {
    }
    /**
        * <p>Gets information about a specified instance.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, GetInstanceCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, GetInstanceCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new GetInstanceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetInstanceCommandInput} for command's `input` shape.
        * @see {@link GetInstanceCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class GetInstanceCommand extends $Command<GetInstanceCommandInput, GetInstanceCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: GetInstanceCommandInput;
            constructor(input: GetInstanceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetInstanceCommandInput, GetInstanceCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/GetInstancesHealthStatusCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetInstancesHealthStatusRequest, GetInstancesHealthStatusResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface GetInstancesHealthStatusCommandInput extends GetInstancesHealthStatusRequest {
    }
    export interface GetInstancesHealthStatusCommandOutput extends GetInstancesHealthStatusResponse, __MetadataBearer {
    }
    /**
        * <p>Gets the current health status (<code>Healthy</code>, <code>Unhealthy</code>, or <code>Unknown</code>) of one or
        *    more instances that are associated with a specified service.</p>
        *          <note>
        *             <p>There's a brief delay between when you register an instance and when the health status for the instance is
        *     available. </p>
        *          </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, GetInstancesHealthStatusCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, GetInstancesHealthStatusCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new GetInstancesHealthStatusCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetInstancesHealthStatusCommandInput} for command's `input` shape.
        * @see {@link GetInstancesHealthStatusCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class GetInstancesHealthStatusCommand extends $Command<GetInstancesHealthStatusCommandInput, GetInstancesHealthStatusCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: GetInstancesHealthStatusCommandInput;
            constructor(input: GetInstancesHealthStatusCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetInstancesHealthStatusCommandInput, GetInstancesHealthStatusCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/GetNamespaceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetNamespaceRequest, GetNamespaceResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface GetNamespaceCommandInput extends GetNamespaceRequest {
    }
    export interface GetNamespaceCommandOutput extends GetNamespaceResponse, __MetadataBearer {
    }
    /**
        * <p>Gets information about a namespace.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, GetNamespaceCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, GetNamespaceCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new GetNamespaceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetNamespaceCommandInput} for command's `input` shape.
        * @see {@link GetNamespaceCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class GetNamespaceCommand extends $Command<GetNamespaceCommandInput, GetNamespaceCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: GetNamespaceCommandInput;
            constructor(input: GetNamespaceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetNamespaceCommandInput, GetNamespaceCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/GetOperationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetOperationRequest, GetOperationResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface GetOperationCommandInput extends GetOperationRequest {
    }
    export interface GetOperationCommandOutput extends GetOperationResponse, __MetadataBearer {
    }
    /**
        * <p>Gets information about any operation that returns an operation ID in the response, such as a
        *     <code>CreateService</code> request.</p>
        *          <note>
        *             <p>To get a list of operations that match specified criteria, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_ListOperations.html">ListOperations</a>.</p>
        *          </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, GetOperationCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, GetOperationCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new GetOperationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetOperationCommandInput} for command's `input` shape.
        * @see {@link GetOperationCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class GetOperationCommand extends $Command<GetOperationCommandInput, GetOperationCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: GetOperationCommandInput;
            constructor(input: GetOperationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetOperationCommandInput, GetOperationCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/GetServiceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetServiceRequest, GetServiceResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface GetServiceCommandInput extends GetServiceRequest {
    }
    export interface GetServiceCommandOutput extends GetServiceResponse, __MetadataBearer {
    }
    /**
        * <p>Gets the settings for a specified service.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, GetServiceCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, GetServiceCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new GetServiceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetServiceCommandInput} for command's `input` shape.
        * @see {@link GetServiceCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class GetServiceCommand extends $Command<GetServiceCommandInput, GetServiceCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: GetServiceCommandInput;
            constructor(input: GetServiceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetServiceCommandInput, GetServiceCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/ListInstancesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListInstancesRequest, ListInstancesResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface ListInstancesCommandInput extends ListInstancesRequest {
    }
    export interface ListInstancesCommandOutput extends ListInstancesResponse, __MetadataBearer {
    }
    /**
        * <p>Lists summary information about the instances that you registered by using a specified service.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, ListInstancesCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, ListInstancesCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new ListInstancesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListInstancesCommandInput} for command's `input` shape.
        * @see {@link ListInstancesCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class ListInstancesCommand extends $Command<ListInstancesCommandInput, ListInstancesCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: ListInstancesCommandInput;
            constructor(input: ListInstancesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListInstancesCommandInput, ListInstancesCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/ListNamespacesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListNamespacesRequest, ListNamespacesResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface ListNamespacesCommandInput extends ListNamespacesRequest {
    }
    export interface ListNamespacesCommandOutput extends ListNamespacesResponse, __MetadataBearer {
    }
    /**
        * <p>Lists summary information about the namespaces that were created by the current account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, ListNamespacesCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, ListNamespacesCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new ListNamespacesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListNamespacesCommandInput} for command's `input` shape.
        * @see {@link ListNamespacesCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class ListNamespacesCommand extends $Command<ListNamespacesCommandInput, ListNamespacesCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: ListNamespacesCommandInput;
            constructor(input: ListNamespacesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListNamespacesCommandInput, ListNamespacesCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/ListOperationsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListOperationsRequest, ListOperationsResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface ListOperationsCommandInput extends ListOperationsRequest {
    }
    export interface ListOperationsCommandOutput extends ListOperationsResponse, __MetadataBearer {
    }
    /**
        * <p>Lists operations that match the criteria that you specify.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, ListOperationsCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, ListOperationsCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new ListOperationsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListOperationsCommandInput} for command's `input` shape.
        * @see {@link ListOperationsCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class ListOperationsCommand extends $Command<ListOperationsCommandInput, ListOperationsCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: ListOperationsCommandInput;
            constructor(input: ListOperationsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListOperationsCommandInput, ListOperationsCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/ListServicesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListServicesRequest, ListServicesResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface ListServicesCommandInput extends ListServicesRequest {
    }
    export interface ListServicesCommandOutput extends ListServicesResponse, __MetadataBearer {
    }
    /**
        * <p>Lists summary information for all the services that are associated with one or more specified namespaces.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, ListServicesCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, ListServicesCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new ListServicesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListServicesCommandInput} for command's `input` shape.
        * @see {@link ListServicesCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class ListServicesCommand extends $Command<ListServicesCommandInput, ListServicesCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: ListServicesCommandInput;
            constructor(input: ListServicesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListServicesCommandInput, ListServicesCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/ListTagsForResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListTagsForResourceRequest, ListTagsForResourceResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface ListTagsForResourceCommandInput extends ListTagsForResourceRequest {
    }
    export interface ListTagsForResourceCommandOutput extends ListTagsForResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Lists tags for the specified resource.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, ListTagsForResourceCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, ListTagsForResourceCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new ListTagsForResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTagsForResourceCommandInput} for command's `input` shape.
        * @see {@link ListTagsForResourceCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class ListTagsForResourceCommand extends $Command<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: ListTagsForResourceCommandInput;
            constructor(input: ListTagsForResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/RegisterInstanceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { RegisterInstanceRequest, RegisterInstanceResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface RegisterInstanceCommandInput extends RegisterInstanceRequest {
    }
    export interface RegisterInstanceCommandOutput extends RegisterInstanceResponse, __MetadataBearer {
    }
    /**
        * <p>Creates or updates one or more records and, optionally, creates a health check based on the settings in a
        *    specified service. When you submit a <code>RegisterInstance</code> request, the following occurs:</p>
        *          <ul>
        *             <li>
        *                <p>For each DNS record that you define in the service that's specified by <code>ServiceId</code>, a record is
        *      created or updated in the hosted zone that's associated with the corresponding namespace.</p>
        *             </li>
        *             <li>
        *                <p>If the service includes <code>HealthCheckConfig</code>, a health check is created based on the settings in the
        *      health check configuration.</p>
        *             </li>
        *             <li>
        *                <p>The health check, if any, is associated with each of the new or updated records.</p>
        *             </li>
        *          </ul>
        *          <important>
        *             <p>One <code>RegisterInstance</code> request must complete before you can submit another request and specify the
        *     same service ID and instance ID.</p>
        *          </important>
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_CreateService.html">CreateService</a>.</p>
        *          <p>When Cloud Map receives a DNS query for the specified DNS name, it returns the applicable value:</p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <b>If the health check is healthy</b>: returns all the records</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <b>If the health check is unhealthy</b>: returns the applicable value for the last
        *      healthy instance</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <b>If you didn't specify a health check configuration</b>: returns all the
        *      records</p>
        *             </li>
        *          </ul>
        *          <p>For the current quota on the number of instances that you can register using the same namespace and using the
        *    same service, see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/cloud-map-limits.html">Cloud Map
        *     quotas</a> in the <i>Cloud Map Developer Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, RegisterInstanceCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, RegisterInstanceCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new RegisterInstanceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RegisterInstanceCommandInput} for command's `input` shape.
        * @see {@link RegisterInstanceCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class RegisterInstanceCommand extends $Command<RegisterInstanceCommandInput, RegisterInstanceCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: RegisterInstanceCommandInput;
            constructor(input: RegisterInstanceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RegisterInstanceCommandInput, RegisterInstanceCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/TagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { TagResourceRequest, TagResourceResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface TagResourceCommandInput extends TagResourceRequest {
    }
    export interface TagResourceCommandOutput extends TagResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Adds one or more tags to the specified resource.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, TagResourceCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, TagResourceCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new TagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TagResourceCommandInput} for command's `input` shape.
        * @see {@link TagResourceCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class TagResourceCommand extends $Command<TagResourceCommandInput, TagResourceCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: TagResourceCommandInput;
            constructor(input: TagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TagResourceCommandInput, TagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/UntagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UntagResourceRequest, UntagResourceResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface UntagResourceCommandInput extends UntagResourceRequest {
    }
    export interface UntagResourceCommandOutput extends UntagResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Removes one or more tags from the specified resource.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, UntagResourceCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, UntagResourceCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new UntagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UntagResourceCommandInput} for command's `input` shape.
        * @see {@link UntagResourceCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class UntagResourceCommand extends $Command<UntagResourceCommandInput, UntagResourceCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: UntagResourceCommandInput;
            constructor(input: UntagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UntagResourceCommandInput, UntagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/UpdateHttpNamespaceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UpdateHttpNamespaceRequest, UpdateHttpNamespaceResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface UpdateHttpNamespaceCommandInput extends UpdateHttpNamespaceRequest {
    }
    export interface UpdateHttpNamespaceCommandOutput extends UpdateHttpNamespaceResponse, __MetadataBearer {
    }
    /**
        * <p>Updates an HTTP
        *    namespace.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, UpdateHttpNamespaceCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, UpdateHttpNamespaceCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new UpdateHttpNamespaceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateHttpNamespaceCommandInput} for command's `input` shape.
        * @see {@link UpdateHttpNamespaceCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class UpdateHttpNamespaceCommand extends $Command<UpdateHttpNamespaceCommandInput, UpdateHttpNamespaceCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: UpdateHttpNamespaceCommandInput;
            constructor(input: UpdateHttpNamespaceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateHttpNamespaceCommandInput, UpdateHttpNamespaceCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/UpdateInstanceCustomHealthStatusCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UpdateInstanceCustomHealthStatusRequest } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface UpdateInstanceCustomHealthStatusCommandInput extends UpdateInstanceCustomHealthStatusRequest {
    }
    export interface UpdateInstanceCustomHealthStatusCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Submits a request to change the health status of a custom health check to healthy or unhealthy.</p>
        *          <p>You can use <code>UpdateInstanceCustomHealthStatus</code> to change the status only for custom health checks,
        *    which you define using <code>HealthCheckCustomConfig</code> when you create a service. You can't use it to change the
        *    status for Route 53 health checks, which you define using <code>HealthCheckConfig</code>.</p>
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_HealthCheckCustomConfig.html">HealthCheckCustomConfig</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, UpdateInstanceCustomHealthStatusCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, UpdateInstanceCustomHealthStatusCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new UpdateInstanceCustomHealthStatusCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateInstanceCustomHealthStatusCommandInput} for command's `input` shape.
        * @see {@link UpdateInstanceCustomHealthStatusCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class UpdateInstanceCustomHealthStatusCommand extends $Command<UpdateInstanceCustomHealthStatusCommandInput, UpdateInstanceCustomHealthStatusCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: UpdateInstanceCustomHealthStatusCommandInput;
            constructor(input: UpdateInstanceCustomHealthStatusCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateInstanceCustomHealthStatusCommandInput, UpdateInstanceCustomHealthStatusCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/UpdatePrivateDnsNamespaceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UpdatePrivateDnsNamespaceRequest, UpdatePrivateDnsNamespaceResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface UpdatePrivateDnsNamespaceCommandInput extends UpdatePrivateDnsNamespaceRequest {
    }
    export interface UpdatePrivateDnsNamespaceCommandOutput extends UpdatePrivateDnsNamespaceResponse, __MetadataBearer {
    }
    /**
        * <p>Updates a private DNS
        *    namespace.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, UpdatePrivateDnsNamespaceCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, UpdatePrivateDnsNamespaceCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new UpdatePrivateDnsNamespaceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdatePrivateDnsNamespaceCommandInput} for command's `input` shape.
        * @see {@link UpdatePrivateDnsNamespaceCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class UpdatePrivateDnsNamespaceCommand extends $Command<UpdatePrivateDnsNamespaceCommandInput, UpdatePrivateDnsNamespaceCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: UpdatePrivateDnsNamespaceCommandInput;
            constructor(input: UpdatePrivateDnsNamespaceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdatePrivateDnsNamespaceCommandInput, UpdatePrivateDnsNamespaceCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/UpdatePublicDnsNamespaceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UpdatePublicDnsNamespaceRequest, UpdatePublicDnsNamespaceResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface UpdatePublicDnsNamespaceCommandInput extends UpdatePublicDnsNamespaceRequest {
    }
    export interface UpdatePublicDnsNamespaceCommandOutput extends UpdatePublicDnsNamespaceResponse, __MetadataBearer {
    }
    /**
        * <p>Updates a public DNS
        *    namespace.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, UpdatePublicDnsNamespaceCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, UpdatePublicDnsNamespaceCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new UpdatePublicDnsNamespaceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdatePublicDnsNamespaceCommandInput} for command's `input` shape.
        * @see {@link UpdatePublicDnsNamespaceCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class UpdatePublicDnsNamespaceCommand extends $Command<UpdatePublicDnsNamespaceCommandInput, UpdatePublicDnsNamespaceCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: UpdatePublicDnsNamespaceCommandInput;
            constructor(input: UpdatePublicDnsNamespaceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdatePublicDnsNamespaceCommandInput, UpdatePublicDnsNamespaceCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/UpdateServiceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UpdateServiceRequest, UpdateServiceResponse } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0";
    import { ServiceDiscoveryClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient";
    export interface UpdateServiceCommandInput extends UpdateServiceRequest {
    }
    export interface UpdateServiceCommandOutput extends UpdateServiceResponse, __MetadataBearer {
    }
    /**
        * <p>Submits a request to perform the following operations:</p>
        *          <ul>
        *             <li>
        *                <p>Update the TTL setting for existing <code>DnsRecords</code> configurations</p>
        *             </li>
        *             <li>
        *                <p>Add, update, or delete <code>HealthCheckConfig</code> for a specified service</p>
        *                <note>
        *                   <p>You can't add, update, or delete a <code>HealthCheckCustomConfig</code> configuration.</p>
        *                </note>
        *             </li>
        *          </ul>
        *          <p>For public and private DNS namespaces, note the following:</p>
        *          <ul>
        *             <li>
        *                <p>If you omit any existing <code>DnsRecords</code> or <code>HealthCheckConfig</code> configurations from an
        *       <code>UpdateService</code> request, the configurations are deleted from the service.</p>
        *             </li>
        *             <li>
        *                <p>If you omit an existing <code>HealthCheckCustomConfig</code> configuration from an <code>UpdateService</code>
        *      request, the configuration isn't deleted from the service.</p>
        *             </li>
        *          </ul>
        *          <p>When you update settings for a service, Cloud Map also updates the corresponding settings in all the records
        *    and health checks that were created by using the specified service.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ServiceDiscoveryClient, UpdateServiceCommand } from "@aws-sdk/client-servicediscovery"; // ES Modules import
        * // const { ServiceDiscoveryClient, UpdateServiceCommand } = require("@aws-sdk/client-servicediscovery"); // CommonJS import
        * const client = new ServiceDiscoveryClient(config);
        * const command = new UpdateServiceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateServiceCommandInput} for command's `input` shape.
        * @see {@link UpdateServiceCommandOutput} for command's `response` shape.
        * @see {@link ServiceDiscoveryClientResolvedConfig | config} for ServiceDiscoveryClient's `config` shape.
        *
        */
    export class UpdateServiceCommand extends $Command<UpdateServiceCommandInput, UpdateServiceCommandOutput, ServiceDiscoveryClientResolvedConfig> {
            readonly input: UpdateServiceCommandInput;
            constructor(input: UpdateServiceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ServiceDiscoveryClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateServiceCommandInput, UpdateServiceCommandOutput>;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/ServiceDiscoveryClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { CreateHttpNamespaceCommandInput, CreateHttpNamespaceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/CreateHttpNamespaceCommand";
    import { CreatePrivateDnsNamespaceCommandInput, CreatePrivateDnsNamespaceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/CreatePrivateDnsNamespaceCommand";
    import { CreatePublicDnsNamespaceCommandInput, CreatePublicDnsNamespaceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/CreatePublicDnsNamespaceCommand";
    import { CreateServiceCommandInput, CreateServiceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/CreateServiceCommand";
    import { DeleteNamespaceCommandInput, DeleteNamespaceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/DeleteNamespaceCommand";
    import { DeleteServiceCommandInput, DeleteServiceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/DeleteServiceCommand";
    import { DeregisterInstanceCommandInput, DeregisterInstanceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/DeregisterInstanceCommand";
    import { DiscoverInstancesCommandInput, DiscoverInstancesCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/DiscoverInstancesCommand";
    import { GetInstanceCommandInput, GetInstanceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/GetInstanceCommand";
    import { GetInstancesHealthStatusCommandInput, GetInstancesHealthStatusCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/GetInstancesHealthStatusCommand";
    import { GetNamespaceCommandInput, GetNamespaceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/GetNamespaceCommand";
    import { GetOperationCommandInput, GetOperationCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/GetOperationCommand";
    import { GetServiceCommandInput, GetServiceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/GetServiceCommand";
    import { ListInstancesCommandInput, ListInstancesCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/ListInstancesCommand";
    import { ListNamespacesCommandInput, ListNamespacesCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/ListNamespacesCommand";
    import { ListOperationsCommandInput, ListOperationsCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/ListOperationsCommand";
    import { ListServicesCommandInput, ListServicesCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/ListServicesCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/ListTagsForResourceCommand";
    import { RegisterInstanceCommandInput, RegisterInstanceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/RegisterInstanceCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/UntagResourceCommand";
    import { UpdateHttpNamespaceCommandInput, UpdateHttpNamespaceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/UpdateHttpNamespaceCommand";
    import { UpdateInstanceCustomHealthStatusCommandInput, UpdateInstanceCustomHealthStatusCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/UpdateInstanceCustomHealthStatusCommand";
    import { UpdatePrivateDnsNamespaceCommandInput, UpdatePrivateDnsNamespaceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/UpdatePrivateDnsNamespaceCommand";
    import { UpdatePublicDnsNamespaceCommandInput, UpdatePublicDnsNamespaceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/UpdatePublicDnsNamespaceCommand";
    import { UpdateServiceCommandInput, UpdateServiceCommandOutput } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/commands/UpdateServiceCommand";
    export type ServiceInputTypes = CreateHttpNamespaceCommandInput | CreatePrivateDnsNamespaceCommandInput | CreatePublicDnsNamespaceCommandInput | CreateServiceCommandInput | DeleteNamespaceCommandInput | DeleteServiceCommandInput | DeregisterInstanceCommandInput | DiscoverInstancesCommandInput | GetInstanceCommandInput | GetInstancesHealthStatusCommandInput | GetNamespaceCommandInput | GetOperationCommandInput | GetServiceCommandInput | ListInstancesCommandInput | ListNamespacesCommandInput | ListOperationsCommandInput | ListServicesCommandInput | ListTagsForResourceCommandInput | RegisterInstanceCommandInput | TagResourceCommandInput | UntagResourceCommandInput | UpdateHttpNamespaceCommandInput | UpdateInstanceCustomHealthStatusCommandInput | UpdatePrivateDnsNamespaceCommandInput | UpdatePublicDnsNamespaceCommandInput | UpdateServiceCommandInput;
    export type ServiceOutputTypes = CreateHttpNamespaceCommandOutput | CreatePrivateDnsNamespaceCommandOutput | CreatePublicDnsNamespaceCommandOutput | CreateServiceCommandOutput | DeleteNamespaceCommandOutput | DeleteServiceCommandOutput | DeregisterInstanceCommandOutput | DiscoverInstancesCommandOutput | GetInstanceCommandOutput | GetInstancesHealthStatusCommandOutput | GetNamespaceCommandOutput | GetOperationCommandOutput | GetServiceCommandOutput | ListInstancesCommandOutput | ListNamespacesCommandOutput | ListOperationsCommandOutput | ListServicesCommandOutput | ListTagsForResourceCommandOutput | RegisterInstanceCommandOutput | TagResourceCommandOutput | UntagResourceCommandOutput | UpdateHttpNamespaceCommandOutput | UpdateInstanceCustomHealthStatusCommandOutput | UpdatePrivateDnsNamespaceCommandOutput | UpdatePublicDnsNamespaceCommandOutput | UpdateServiceCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type ServiceDiscoveryClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of ServiceDiscoveryClient class constructor that set the region, credentials and other options.
        */
    export interface ServiceDiscoveryClientConfig extends ServiceDiscoveryClientConfigType {
    }
    type ServiceDiscoveryClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of ServiceDiscoveryClient class. This is resolved and normalized from the {@link ServiceDiscoveryClientConfig | constructor configuration interface}.
        */
    export interface ServiceDiscoveryClientResolvedConfig extends ServiceDiscoveryClientResolvedConfigType {
    }
    /**
        * <fullname>Cloud Map</fullname>
        *          <p>With Cloud Map, you can configure public DNS, private DNS, or HTTP namespaces that your microservice
        *    applications run in. When an instance becomes available, you can call the Cloud Map API to register the instance
        *    with Cloud Map. For public or private DNS namespaces, Cloud Map automatically creates DNS records and an optional
        *    health check. Clients that submit public or private DNS queries, or HTTP requests, for the service receive an answer
        *    that contains up to eight healthy records. </p>
        */
    export class ServiceDiscoveryClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, ServiceDiscoveryClientResolvedConfig> {
            /**
                * The resolved configuration of ServiceDiscoveryClient class. This is resolved and normalized from the {@link ServiceDiscoveryClientConfig | constructor configuration interface}.
                */
            readonly config: ServiceDiscoveryClientResolvedConfig;
            constructor(configuration: ServiceDiscoveryClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { ServiceDiscoveryServiceException as __BaseException } from "@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/ServiceDiscoveryServiceException";
    /**
        * <p>A custom key-value pair that's associated with a resource.</p>
        */
    export interface Tag {
            /**
                * <p>The key identifier, or name, of the tag.</p>
                */
            Key: string | undefined;
            /**
                * <p>The string value that's associated with the key of the tag. You can set the value of a tag to an empty string,
                *    but you can't set the value of a tag to null.</p>
                */
            Value: string | undefined;
    }
    export namespace Tag {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Tag) => any;
    }
    export interface CreateHttpNamespaceRequest {
            /**
                * <p>The name that you want to assign to this namespace.</p>
                */
            Name: string | undefined;
            /**
                * <p>A unique string that identifies the request and that allows failed <code>CreateHttpNamespace</code> requests to
                *    be retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any unique string
                *    (for example, a date/time stamp).</p>
                */
            CreatorRequestId?: string;
            /**
                * <p>A description for the namespace.</p>
                */
            Description?: string;
            /**
                * <p>The tags to add to the namespace. Each tag consists of a key and an optional value that you define.
                *    Tags keys can be up to 128 characters in length, and tag values can be up to 256
                *                                characters in length.</p>
                */
            Tags?: Tag[];
    }
    export namespace CreateHttpNamespaceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateHttpNamespaceRequest) => any;
    }
    export interface CreateHttpNamespaceResponse {
            /**
                * <p>A value that you can use to determine whether the request completed successfully.
                *                                 To get the status of the operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
                */
            OperationId?: string;
    }
    export namespace CreateHttpNamespaceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateHttpNamespaceResponse) => any;
    }
    /**
        * <p>The operation is already in progress.</p>
        */
    export class DuplicateRequest extends __BaseException {
            readonly name: "DuplicateRequest";
            readonly $fault: "client";
            Message?: string;
            /**
                * <p>The ID of the operation that's already in progress.</p>
                */
            DuplicateOperationId?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DuplicateRequest, __BaseException>);
    }
    /**
        * <p>One or more specified values aren't valid. For example, a required value might be missing, a numeric value might
        *    be outside the allowed range, or a string value might exceed length constraints.</p>
        */
    export class InvalidInput extends __BaseException {
            readonly name: "InvalidInput";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidInput, __BaseException>);
    }
    /**
        * <p>The namespace that you're trying to create already exists.</p>
        */
    export class NamespaceAlreadyExists extends __BaseException {
            readonly name: "NamespaceAlreadyExists";
            readonly $fault: "client";
            Message?: string;
            /**
                * <p>The <code>CreatorRequestId</code> that was used to create the namespace.</p>
                */
            CreatorRequestId?: string;
            /**
                * <p>The ID of the existing namespace.</p>
                */
            NamespaceId?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NamespaceAlreadyExists, __BaseException>);
    }
    /**
        * <p>The resource can't be created because you've reached the quota on the number of resources.</p>
        */
    export class ResourceLimitExceeded extends __BaseException {
            readonly name: "ResourceLimitExceeded";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceLimitExceeded, __BaseException>);
    }
    /**
        * <p>The list of tags on the resource is over the quota. The maximum number of tags that can be applied to a resource
        *    is 50.</p>
        */
    export class TooManyTagsException extends __BaseException {
            readonly name: "TooManyTagsException";
            readonly $fault: "client";
            Message?: string;
            /**
                * <p>The name of the resource.</p>
                */
            ResourceName?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyTagsException, __BaseException>);
    }
    /**
        * <p>Start of Authority (SOA) properties for a
        *    public or private DNS namespace.</p>
        */
    export interface SOA {
            /**
                * <p>The time to live (TTL) for purposes of
                *    negative caching.</p>
                */
            TTL: number | undefined;
    }
    export namespace SOA {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SOA) => any;
    }
    /**
        * <p>DNS properties for the private DNS
        *    namespace.</p>
        */
    export interface PrivateDnsPropertiesMutable {
            /**
                * <p>Fields for the Start of Authority (SOA)
                *    record for the hosted zone for the private DNS namespace.</p>
                */
            SOA: SOA | undefined;
    }
    export namespace PrivateDnsPropertiesMutable {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PrivateDnsPropertiesMutable) => any;
    }
    /**
        * <p>DNS properties for the private DNS
        *    namespace.</p>
        */
    export interface PrivateDnsNamespaceProperties {
            /**
                * <p>DNS properties for the private DNS
                *    namespace.</p>
                */
            DnsProperties: PrivateDnsPropertiesMutable | undefined;
    }
    export namespace PrivateDnsNamespaceProperties {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PrivateDnsNamespaceProperties) => any;
    }
    export interface CreatePrivateDnsNamespaceRequest {
            /**
                * <p>The name that you want to assign to this namespace. When you create a private DNS namespace, Cloud Map
                *    automatically creates an Amazon Route 53 private hosted zone that has the same name as the namespace.</p>
                */
            Name: string | undefined;
            /**
                * <p>A unique string that identifies the request and that allows failed <code>CreatePrivateDnsNamespace</code>
                *    requests to be retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any
                *    unique string (for example, a date/timestamp).</p>
                */
            CreatorRequestId?: string;
            /**
                * <p>A description for the namespace.</p>
                */
            Description?: string;
            /**
                * <p>The ID of the Amazon VPC that you want to associate the namespace with.</p>
                */
            Vpc: string | undefined;
            /**
                * <p>The tags to add to the namespace. Each tag consists of a key and an optional value that you define.
                *    Tags keys can be up to 128 characters in length, and tag values can be up to 256
                *                                characters in length.</p>
                */
            Tags?: Tag[];
            /**
                * <p>Properties for the private DNS
                *    namespace.</p>
                */
            Properties?: PrivateDnsNamespaceProperties;
    }
    export namespace CreatePrivateDnsNamespaceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreatePrivateDnsNamespaceRequest) => any;
    }
    export interface CreatePrivateDnsNamespaceResponse {
            /**
                * <p>A value that you can use to determine whether the request completed successfully.
                *                                 To get the status of the operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
                */
            OperationId?: string;
    }
    export namespace CreatePrivateDnsNamespaceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreatePrivateDnsNamespaceResponse) => any;
    }
    /**
        * <p>DNS properties for the public DNS
        *    namespace.</p>
        */
    export interface PublicDnsPropertiesMutable {
            /**
                * <p>Start of Authority (SOA) record for the
                *    hosted zone for the public DNS namespace.</p>
                */
            SOA: SOA | undefined;
    }
    export namespace PublicDnsPropertiesMutable {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PublicDnsPropertiesMutable) => any;
    }
    /**
        * <p>DNS properties for the public DNS
        *    namespace.</p>
        */
    export interface PublicDnsNamespaceProperties {
            /**
                * <p>DNS properties for the public DNS
                *    namespace.</p>
                */
            DnsProperties: PublicDnsPropertiesMutable | undefined;
    }
    export namespace PublicDnsNamespaceProperties {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PublicDnsNamespaceProperties) => any;
    }
    export interface CreatePublicDnsNamespaceRequest {
            /**
                * <p>The name that you want to assign to this namespace.</p>
                */
            Name: string | undefined;
            /**
                * <p>A unique string that identifies the request and that allows failed <code>CreatePublicDnsNamespace</code>
                *    requests to be retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any
                *    unique string (for example, a date/timestamp).</p>
                */
            CreatorRequestId?: string;
            /**
                * <p>A description for the namespace.</p>
                */
            Description?: string;
            /**
                * <p>The tags to add to the namespace. Each tag consists of a key and an optional value that you define.
                *    Tags keys can be up to 128 characters in length, and tag values can be up to 256
                *                                characters in length.</p>
                */
            Tags?: Tag[];
            /**
                * <p>Properties for the public DNS
                *    namespace.</p>
                */
            Properties?: PublicDnsNamespaceProperties;
    }
    export namespace CreatePublicDnsNamespaceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreatePublicDnsNamespaceRequest) => any;
    }
    export interface CreatePublicDnsNamespaceResponse {
            /**
                * <p>A value that you can use to determine whether the request completed successfully. To get the status of the
                *    operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
                */
            OperationId?: string;
    }
    export namespace CreatePublicDnsNamespaceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreatePublicDnsNamespaceResponse) => any;
    }
    export enum RecordType {
            A = "A",
            AAAA = "AAAA",
            CNAME = "CNAME",
            SRV = "SRV"
    }
    /**
        * <p>A complex type that contains information about the Route 53 DNS records that you want Cloud Map to create when you
        *    register an instance.</p>
        */
    export interface DnsRecord {
            /**
                * <p>The type of the resource, which indicates the type of value that Route 53 returns in response to DNS queries. You
                *    can specify values for <code>Type</code> in the following combinations:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <b>
                *                      <code>A</code>
                *                   </b>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>
                *                      <code>AAAA</code>
                *                   </b>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>
                *                      <code>A</code>
                *                   </b> and <b>
                *                      <code>AAAA</code>
                *                   </b>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>
                *                      <code>SRV</code>
                *                   </b>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>
                *                      <code>CNAME</code>
                *                   </b>
                *                </p>
                *             </li>
                *          </ul>
                *          <p>If you want Cloud Map to create a Route 53 alias record when you register an instance, specify <code>A</code> or
                *     <code>AAAA</code> for <code>Type</code>.</p>
                *          <p>You specify other settings, such as the IP address for <code>A</code> and <code>AAAA</code> records, when you
                *    register an instance. For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance</a>.</p>
                *          <p>The following values are supported:</p>
                *          <dl>
                *             <dt>A</dt>
                *             <dd>
                *                <p>Route 53 returns the IP address of the resource in IPv4 format, such as 192.0.2.44.</p>
                *             </dd>
                *             <dt>AAAA</dt>
                *             <dd>
                *                <p>Route 53 returns the IP address of the resource in IPv6 format, such as
                *       2001:0db8:85a3:0000:0000:abcd:0001:2345.</p>
                *             </dd>
                *             <dt>CNAME</dt>
                *             <dd>
                *                <p>Route 53 returns the domain name of the resource, such as www.example.com. Note the following:</p>
                *                <ul>
                *                   <li>
                *                      <p>You specify the domain name that you want to route traffic to when you register an instance. For more
                *         information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html#cloudmap-RegisterInstance-request-Attributes">Attributes</a> in the topic <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance</a>.</p>
                *                   </li>
                *                   <li>
                *                      <p>You must specify <code>WEIGHTED</code> for the value of <code>RoutingPolicy</code>.</p>
                *                   </li>
                *                   <li>
                *                      <p>You can't specify both <code>CNAME</code> for <code>Type</code> and settings for
                *          <code>HealthCheckConfig</code>. If you do, the request will fail with an <code>InvalidInput</code>
                *         error.</p>
                *                   </li>
                *                </ul>
                *             </dd>
                *             <dt>SRV</dt>
                *             <dd>
                *                <p>Route 53 returns the value for an <code>SRV</code> record. The value for an <code>SRV</code> record uses the
                *       following values:</p>
                *                <p>
                *                   <code>priority weight port service-hostname</code>
                *                </p>
                *                <p>Note the following about the values:</p>
                *                <ul>
                *                   <li>
                *                      <p>The values of <code>priority</code> and <code>weight</code> are both set to <code>1</code> and can't be
                *         changed. </p>
                *                   </li>
                *                   <li>
                *                      <p>The value of <code>port</code> comes from the value that you specify for the <code>AWS_INSTANCE_PORT</code>
                *         attribute when you submit a <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance</a> request.</p>
                *                   </li>
                *                   <li>
                *                      <p>The value of <code>service-hostname</code> is a concatenation of the following values:</p>
                *                      <ul>
                *                         <li>
                *                            <p>The value that you specify for <code>InstanceId</code> when you register an instance.</p>
                *                         </li>
                *                         <li>
                *                            <p>The name of the service.</p>
                *                         </li>
                *                         <li>
                *                            <p>The name of the namespace. </p>
                *                         </li>
                *                      </ul>
                *                      <p>For example, if the value of <code>InstanceId</code> is <code>test</code>, the name of the service is
                *          <code>backend</code>, and the name of the namespace is <code>example.com</code>, the value of
                *          <code>service-hostname</code> is the following:</p>
                *                      <p>
                *                         <code>test.backend.example.com</code>
                *                      </p>
                *                   </li>
                *                </ul>
                *                <p>If you specify settings for an <code>SRV</code> record, note the following:</p>
                *                <ul>
                *                   <li>
                *                      <p>If you specify values for <code>AWS_INSTANCE_IPV4</code>, <code>AWS_INSTANCE_IPV6</code>, or both in the
                *          <code>RegisterInstance</code> request, Cloud Map automatically creates <code>A</code> and/or <code>AAAA</code>
                *         records that have the same name as the value of <code>service-hostname</code> in the <code>SRV</code> record.
                *         You can ignore these records.</p>
                *                   </li>
                *                   <li>
                *                      <p>If you're using a system that requires a specific <code>SRV</code> format, such as HAProxy, see the <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_CreateService.html#cloudmap-CreateService-request-Name">Name</a> element in the documentation about <code>CreateService</code> for information about how to
                *         specify the correct name format.</p>
                *                   </li>
                *                </ul>
                *             </dd>
                *          </dl>
                */
            Type: RecordType | string | undefined;
            /**
                * <p>The amount of time, in seconds, that you want DNS resolvers to cache the settings for this record.</p>
                *          <note>
                *             <p>Alias records don't include a TTL because Route 53 uses the TTL for the Amazon Web Services resource that an alias record routes
                *     traffic to. If you include the <code>AWS_ALIAS_DNS_NAME</code> attribute when you submit a <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance</a> request, the
                *      <code>TTL</code> value is ignored. Always specify a TTL for the service; you can use a service to register
                *     instances that create either alias or non-alias records.</p>
                *          </note>
                */
            TTL: number | undefined;
    }
    export namespace DnsRecord {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DnsRecord) => any;
    }
    export enum RoutingPolicy {
            MULTIVALUE = "MULTIVALUE",
            WEIGHTED = "WEIGHTED"
    }
    /**
        * <p>A complex type that contains information about the Amazon Route 53 DNS records that you want Cloud Map to create when
        *    you register an instance.</p>
        */
    export interface DnsConfig {
            /**
                * @deprecated
                *
                * <p>The ID of the namespace to use for DNS configuration.</p>
                */
            NamespaceId?: string;
            /**
                * <p>The routing policy that you want to apply to all Route 53 DNS records that Cloud Map creates when you register an
                *    instance and specify this service.</p>
                *          <note>
                *             <p>If you want to use this service to register instances that create alias records, specify <code>WEIGHTED</code>
                *     for the routing policy.</p>
                *          </note>
                *          <p>You can specify the following values:</p>
                *          <dl>
                *             <dt>MULTIVALUE</dt>
                *             <dd>
                *                <p>If you define a health check for the service and the health check is healthy, Route 53 returns the applicable
                *       value for up to eight instances.</p>
                *                <p>For example, suppose that the service includes configurations for one <code>A</code> record and a health
                *       check. You use the service to register 10 instances. Route 53 responds to DNS queries with IP addresses for up to
                *       eight healthy instances. If fewer than eight instances are healthy, Route 53 responds to every DNS query with the IP
                *       addresses for all of the healthy instances.</p>
                *                <p>If you don't define a health check for the service, Route 53 assumes that all instances are healthy and returns
                *       the values for up to eight instances.</p>
                *                <p>For more information about the multivalue routing policy, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-multivalue">Multivalue Answer
                *        Routing</a> in the <i>Route 53 Developer Guide</i>.</p>
                *             </dd>
                *             <dt>WEIGHTED</dt>
                *             <dd>
                *                <p>Route 53 returns the applicable value from one randomly selected instance from among the instances that you
                *       registered using the same service. Currently, all records have the same weight, so you can't route more or less
                *       traffic to any instances.</p>
                *                <p>For example, suppose that the service includes configurations for one <code>A</code> record and a health
                *       check. You use the service to register 10 instances. Route 53 responds to DNS queries with the IP address for one
                *       randomly selected instance from among the healthy instances. If no instances are healthy, Route 53 responds to DNS
                *       queries as if all of the instances were healthy.</p>
                *                <p>If you don't define a health check for the service, Route 53 assumes that all instances are healthy and returns
                *       the applicable value for one randomly selected instance.</p>
                *                <p>For more information about the weighted routing policy, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted">Weighted Routing</a> in the
                *        <i>Route 53 Developer Guide</i>.</p>
                *             </dd>
                *          </dl>
                */
            RoutingPolicy?: RoutingPolicy | string;
            /**
                * <p>An array that contains one <code>DnsRecord</code> object for each Route 53 DNS record that you want Cloud Map to
                *    create when you register an instance.</p>
                */
            DnsRecords: DnsRecord[] | undefined;
    }
    export namespace DnsConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DnsConfig) => any;
    }
    export enum HealthCheckType {
            HTTP = "HTTP",
            HTTPS = "HTTPS",
            TCP = "TCP"
    }
    /**
        * <p>
        *             <i>Public DNS and HTTP namespaces only.</i> A complex type that contains settings for an optional
        *    health check. If you specify settings for a health check, Cloud Map associates the health check with the records
        *    that you specify in <code>DnsConfig</code>.</p>
        *          <important>
        *             <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
        *      <code>HealthCheckConfig</code> but not both.</p>
        *          </important>
        *          <p>Health checks are basic Route 53 health checks that monitor an Amazon Web Services endpoint. For information about
        *    pricing for health checks, see <a href="http://aws.amazon.com/route53/pricing/">Amazon Route 53 Pricing</a>.</p>
        *          <p>Note the following about configuring health checks.</p>
        *          <dl>
        *             <dt>A and AAAA records</dt>
        *             <dd>
        *                <p>If <code>DnsConfig</code> includes configurations for both <code>A</code> and <code>AAAA</code> records,
        *       Cloud Map creates a health check that uses the IPv4 address to check the health of the resource. If the endpoint
        *       tthat's specified by the IPv4 address is unhealthy, Route 53 considers both the <code>A</code> and <code>AAAA</code>
        *       records to be unhealthy. </p>
        *             </dd>
        *             <dt>CNAME records</dt>
        *             <dd>
        *                <p>You can't specify settings for <code>HealthCheckConfig</code> when the <code>DNSConfig</code> includes
        *        <code>CNAME</code> for the value of <code>Type</code>. If you do, the <code>CreateService</code> request will
        *       fail with an <code>InvalidInput</code> error.</p>
        *             </dd>
        *             <dt>Request interval</dt>
        *             <dd>
        *                <p>A Route 53 health checker in each health-checking Amazon Web Services Region sends a health check request to an endpoint every
        *       30 seconds. On average, your endpoint receives a health check request about every two seconds. However, health
        *       checkers don't coordinate with one another. Therefore, you might sometimes see several requests in one second
        *       that's followed by a few seconds with no health checks at all.</p>
        *             </dd>
        *             <dt>Health checking regions</dt>
        *             <dd>
        *                <p>Health checkers perform checks from all Route 53 health-checking Regions. For a list of the current Regions, see
        *        <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_HealthCheckConfig.html#Route53-Type-HealthCheckConfig-Regions">Regions</a>.</p>
        *             </dd>
        *             <dt>Alias records</dt>
        *             <dd>
        *                <p>When you register an instance, if you include the <code>AWS_ALIAS_DNS_NAME</code> attribute, Cloud Map
        *       creates a Route 53 alias record. Note the following:</p>
        *                <ul>
        *                   <li>
        *                      <p>Route 53 automatically sets <code>EvaluateTargetHealth</code> to true for alias records. When
        *          <code>EvaluateTargetHealth</code> is true, the alias record inherits the health of the referenced Amazon Web Services
        *         resource. such as an ELB load balancer. For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_AliasTarget.html#Route53-Type-AliasTarget-EvaluateTargetHealth">EvaluateTargetHealth</a>.</p>
        *                   </li>
        *                   <li>
        *                      <p>If you include <code>HealthCheckConfig</code> and then use the service to register an instance that creates
        *         an alias record, Route 53 doesn't create the health check.</p>
        *                   </li>
        *                </ul>
        *             </dd>
        *             <dt>Charges for health checks</dt>
        *             <dd>
        *                <p>Health checks are basic Route 53 health checks that monitor an Amazon Web Services endpoint. For information about pricing for
        *       health checks, see <a href="http://aws.amazon.com/route53/pricing/">Amazon Route 53 Pricing</a>.</p>
        *             </dd>
        *          </dl>
        */
    export interface HealthCheckConfig {
            /**
                * <p>The type of health check that you want to create, which indicates how Route 53 determines whether an endpoint is
                *    healthy.</p>
                *          <important>
                *             <p>You can't change the value of <code>Type</code> after you create a health check.</p>
                *          </important>
                *          <p>You can create the following types of health checks:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <b>HTTP</b>: Route 53 tries to establish a TCP connection. If successful, Route 53 submits
                *      an HTTP request and waits for an HTTP status code of 200 or greater and less than 400.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>HTTPS</b>: Route 53 tries to establish a TCP connection. If successful, Route 53
                *      submits an HTTPS request and waits for an HTTP status code of 200 or greater and less than 400.</p>
                *                <important>
                *                   <p>If you specify HTTPS for the value of <code>Type</code>, the endpoint must support TLS v1.0 or later.</p>
                *                </important>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>TCP</b>: Route 53 tries to establish a TCP connection.</p>
                *                <p>If you specify <code>TCP</code> for <code>Type</code>, don't specify a value for
                *      <code>ResourcePath</code>.</p>
                *             </li>
                *          </ul>
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html">How Route 53 Determines Whether
                *     an Endpoint Is Healthy</a> in the <i>Route 53 Developer Guide</i>.</p>
                */
            Type: HealthCheckType | string | undefined;
            /**
                * <p>The path that you want Route 53 to request when performing health checks. The path can be any value that your
                *    endpoint returns an HTTP status code of a 2xx or 3xx format for when the endpoint is healthy. An example file is
                *     <code>/docs/route53-health-check.html</code>. Route 53 automatically adds the DNS name for the service. If you don't
                *    specify a value for <code>ResourcePath</code>, the default value is <code>/</code>.</p>
                *          <p>If you specify <code>TCP</code> for <code>Type</code>, you must <i>not</i> specify a value for
                *     <code>ResourcePath</code>.</p>
                */
            ResourcePath?: string;
            /**
                * <p>The number of consecutive health checks that an endpoint must pass or fail for Route 53 to change the current
                *    status of the endpoint from unhealthy to healthy or the other way around. For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html">How Route 53
                *     Determines Whether an Endpoint Is Healthy</a> in the <i>Route 53 Developer Guide</i>.</p>
                */
            FailureThreshold?: number;
    }
    export namespace HealthCheckConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: HealthCheckConfig) => any;
    }
    /**
        * <p>A complex type that contains information about an optional custom health check. A custom health check, which
        *    requires that you use a third-party health checker to evaluate the health of your resources, is useful in the
        *    following circumstances:</p>
        *          <ul>
        *             <li>
        *                <p>You can't use a health check that's defined by <code>HealthCheckConfig</code> because the resource isn't
        *      available over the internet. For example, you can use a custom health check when the instance is in an Amazon VPC.
        *      (To check the health of resources in a VPC, the health checker must also be in the VPC.)</p>
        *             </li>
        *             <li>
        *                <p>You want to use a third-party health checker regardless of where your resources are located.</p>
        *             </li>
        *          </ul>
        *          <important>
        *             <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
        *      <code>HealthCheckConfig</code> but not both.</p>
        *          </important>
        *          <p>To change the status of a custom health check, submit an <code>UpdateInstanceCustomHealthStatus</code> request.
        *    Cloud Map doesn't monitor the status of the resource, it just keeps a record of the status specified in the most recent
        *     <code>UpdateInstanceCustomHealthStatus</code> request.</p>
        *          <p>Here's how custom health checks work:</p>
        *          <ol>
        *             <li>
        *                <p>You create a service.</p>
        *             </li>
        *             <li>
        *                <p>You register an instance.</p>
        *             </li>
        *             <li>
        *                <p>You configure a third-party health checker to monitor the resource that's associated with the new instance. </p>
        *                <note>
        *                   <p>Cloud Map doesn't check the health of the resource directly. </p>
        *                </note>
        *             </li>
        *             <li>
        *                <p>The third-party health-checker determines that the resource is unhealthy and notifies your application.</p>
        *             </li>
        *             <li>
        *                <p>Your application submits an <code>UpdateInstanceCustomHealthStatus</code> request.</p>
        *             </li>
        *             <li>
        *                <p>Cloud Map waits for 30 seconds.</p>
        *             </li>
        *             <li>
        *                <p>If another <code>UpdateInstanceCustomHealthStatus</code> request doesn't arrive during that time to change the
        *      status back to healthy, Cloud Map stops routing traffic to the resource.</p>
        *             </li>
        *          </ol>
        */
    export interface HealthCheckCustomConfig {
            /**
                * @deprecated
                *
                * <important>
                *             <p>This parameter is no longer supported and is always set to 1. Cloud Map waits for approximately 30 seconds after
                *     receiving an <code>UpdateInstanceCustomHealthStatus</code> request before changing the status of the service
                *     instance.</p>
                *          </important>
                *          <p>The number of 30-second intervals that you want Cloud Map to wait after receiving an
                *     <code>UpdateInstanceCustomHealthStatus</code> request before it changes the health status of a service
                *    instance.</p>
                *          <p>Sending a second or subsequent <code>UpdateInstanceCustomHealthStatus</code> request with the same value before
                *    30 seconds has passed doesn't accelerate the change. Cloud Map still waits <code>30</code> seconds after the first
                *    request to make the change.</p>
                */
            FailureThreshold?: number;
    }
    export namespace HealthCheckCustomConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: HealthCheckCustomConfig) => any;
    }
    export enum ServiceTypeOption {
            HTTP = "HTTP"
    }
    export interface CreateServiceRequest {
            /**
                * <p>The name that you want to assign to the service.</p>
                *          <p>If you want Cloud Map to create an <code>SRV</code> record when you register an instance and you're using a
                *    system that requires a specific <code>SRV</code> format, such as <a href="http://www.haproxy.org/">HAProxy</a>, specify the following for <code>Name</code>:</p>
                *          <ul>
                *             <li>
                *                <p>Start the name with an underscore (_), such as <code>_exampleservice</code>.</p>
                *             </li>
                *             <li>
                *                <p>End the name with <i>._protocol</i>, such as <code>._tcp</code>.</p>
                *             </li>
                *          </ul>
                *          <p>When you register an instance, Cloud Map creates an <code>SRV</code> record and assigns a name to the record by
                *    concatenating the service name and the namespace name (for example,</p>
                *          <p>
                *             <code>_exampleservice._tcp.example.com</code>).</p>
                *          <note>
                *             <p>For services that are accessible by DNS queries, you can't create multiple services with names that differ only
                *     by case (such as EXAMPLE and example). Otherwise, these services have the same DNS name and can't be distinguished.
                *     However, if you use a namespace that's only accessible by API calls, then you can create services that with names
                *     that differ only by case.</p>
                *          </note>
                */
            Name: string | undefined;
            /**
                * <p>The ID of the namespace that you want to use to create the service. The namespace ID must be specified, but it
                *    can be specified either here or in the <code>DnsConfig</code> object.</p>
                */
            NamespaceId?: string;
            /**
                * <p>A unique string that identifies the request and that allows failed <code>CreateService</code> requests to be
                *    retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any unique string (for
                *    example, a date/timestamp).</p>
                */
            CreatorRequestId?: string;
            /**
                * <p>A description for the service.</p>
                */
            Description?: string;
            /**
                * <p>A complex type that contains information about the Amazon Route 53 records that you want Cloud Map to create when you
                *    register an instance. </p>
                */
            DnsConfig?: DnsConfig;
            /**
                * <p>
                *             <i>Public DNS and HTTP namespaces only.</i> A complex type that contains settings for an optional
                *    Route 53 health check. If you specify settings for a health check, Cloud Map associates the health check with all the
                *    Route 53 DNS records that you specify in <code>DnsConfig</code>.</p>
                *          <important>
                *             <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
                *      <code>HealthCheckConfig</code> but not both.</p>
                *          </important>
                *          <p>For information about the charges for health checks, see <a href="http://aws.amazon.com/cloud-map/pricing/">Cloud Map Pricing</a>.</p>
                */
            HealthCheckConfig?: HealthCheckConfig;
            /**
                * <p>A complex type that contains information about an optional custom health check.</p>
                *          <important>
                *             <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
                *      <code>HealthCheckConfig</code> but not both.</p>
                *          </important>
                *          <p>You can't add, update, or delete a <code>HealthCheckCustomConfig</code> configuration from an existing
                *    service.</p>
                */
            HealthCheckCustomConfig?: HealthCheckCustomConfig;
            /**
                * <p>The tags to add to the service. Each tag consists of a key and an optional value that you define.
                *    Tags keys can be up to 128 characters in length, and tag values can be up to 256
                *                                characters in length.</p>
                */
            Tags?: Tag[];
            /**
                * <p>If present, specifies that the service instances are only discoverable using the <code>DiscoverInstances</code>
                *    API operation. No DNS records is registered for the service instances. The only valid value is
                *    <code>HTTP</code>.</p>
                */
            Type?: ServiceTypeOption | string;
    }
    export namespace CreateServiceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateServiceRequest) => any;
    }
    export enum ServiceType {
            DNS = "DNS",
            DNS_HTTP = "DNS_HTTP",
            HTTP = "HTTP"
    }
    /**
        * <p>A complex type that contains information about the specified service.</p>
        */
    export interface Service {
            /**
                * <p>The ID that Cloud Map assigned to the service when you created it.</p>
                */
            Id?: string;
            /**
                * <p>The Amazon Resource Name (ARN) that Cloud Map assigns to the service when you create it.</p>
                */
            Arn?: string;
            /**
                * <p>The name of the service.</p>
                */
            Name?: string;
            /**
                * <p>The ID of the namespace that was used to create the service.</p>
                */
            NamespaceId?: string;
            /**
                * <p>The description of the service.</p>
                */
            Description?: string;
            /**
                * <p>The number of instances that are currently associated with the service. Instances that were previously
                *    associated with the service but that are deleted aren't included in the count. The count might not reflect pending
                *    registrations and deregistrations.</p>
                */
            InstanceCount?: number;
            /**
                * <p>A complex type that contains information about the Route 53 DNS records that you want Cloud Map to create when you
                *    register an instance.</p>
                */
            DnsConfig?: DnsConfig;
            /**
                * <p>Describes the systems that can be used to discover the service instances.</p>
                *          <dl>
                *             <dt>DNS_HTTP</dt>
                *             <dd>
                *                <p>The service instances can be discovered using either DNS queries or the <code>DiscoverInstances</code> API
                *       operation.</p>
                *             </dd>
                *             <dt>HTTP</dt>
                *             <dd>
                *                <p>The service instances can only be discovered using the <code>DiscoverInstances</code> API operation.</p>
                *             </dd>
                *             <dt>DNS</dt>
                *             <dd>
                *                <p>Reserved.</p>
                *             </dd>
                *          </dl>
                */
            Type?: ServiceType | string;
            /**
                * <p>
                *             <i>Public DNS and HTTP namespaces only.</i> A complex type that contains settings for an optional
                *    health check. If you specify settings for a health check, Cloud Map associates the health check with the records
                *    that you specify in <code>DnsConfig</code>.</p>
                *          <p>For information about the charges for health checks, see <a href="http://aws.amazon.com/route53/pricing/">Amazon Route 53 Pricing</a>.</p>
                */
            HealthCheckConfig?: HealthCheckConfig;
            /**
                * <p>A complex type that contains information about an optional custom health check.</p>
                *          <important>
                *             <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
                *      <code>HealthCheckConfig</code> but not both.</p>
                *          </important>
                */
            HealthCheckCustomConfig?: HealthCheckCustomConfig;
            /**
                * <p>The date and time that the service was created, in Unix format and Coordinated Universal Time (UTC). The value
                *    of <code>CreateDate</code> is accurate to milliseconds. For example, the value <code>1516925490.087</code> represents
                *    Friday, January 26, 2018 12:11:30.087 AM.</p>
                */
            CreateDate?: Date;
            /**
                * <p>A unique string that identifies the request and that allows failed requests to be retried without the risk of
                *    running the operation twice. <code>CreatorRequestId</code> can be any unique string (for example, a
                *    date/timestamp).</p>
                */
            CreatorRequestId?: string;
    }
    export namespace Service {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Service) => any;
    }
    export interface CreateServiceResponse {
            /**
                * <p>A complex type that contains information about the new service.</p>
                */
            Service?: Service;
    }
    export namespace CreateServiceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateServiceResponse) => any;
    }
    /**
        * <p>No namespace exists with the specified ID.</p>
        */
    export class NamespaceNotFound extends __BaseException {
            readonly name: "NamespaceNotFound";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NamespaceNotFound, __BaseException>);
    }
    /**
        * <p>The service can't be created because a service with the same name already exists.</p>
        */
    export class ServiceAlreadyExists extends __BaseException {
            readonly name: "ServiceAlreadyExists";
            readonly $fault: "client";
            Message?: string;
            /**
                * <p>The <code>CreatorRequestId</code> that was used to create the service.</p>
                */
            CreatorRequestId?: string;
            /**
                * <p>The ID of the existing service.</p>
                */
            ServiceId?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ServiceAlreadyExists, __BaseException>);
    }
    /**
        * <p>The health check for the instance that's specified by <code>ServiceId</code> and <code>InstanceId</code> isn't a
        *    custom health check. </p>
        */
    export class CustomHealthNotFound extends __BaseException {
            readonly name: "CustomHealthNotFound";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<CustomHealthNotFound, __BaseException>);
    }
    export enum CustomHealthStatus {
            HEALTHY = "HEALTHY",
            UNHEALTHY = "UNHEALTHY"
    }
    export interface DeleteNamespaceRequest {
            /**
                * <p>The ID of the namespace that you want to delete.</p>
                */
            Id: string | undefined;
    }
    export namespace DeleteNamespaceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteNamespaceRequest) => any;
    }
    export interface DeleteNamespaceResponse {
            /**
                * <p>A value that you can use to determine whether the request completed successfully.
                *                                 To get the status of the operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
                */
            OperationId?: string;
    }
    export namespace DeleteNamespaceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteNamespaceResponse) => any;
    }
    /**
        * <p>The specified resource can't be deleted because it contains other resources. For example, you can't delete a
        *    service that contains any instances.</p>
        */
    export class ResourceInUse extends __BaseException {
            readonly name: "ResourceInUse";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceInUse, __BaseException>);
    }
    export interface DeleteServiceRequest {
            /**
                * <p>The ID of the service that you want to delete.</p>
                */
            Id: string | undefined;
    }
    export namespace DeleteServiceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteServiceRequest) => any;
    }
    export interface DeleteServiceResponse {
    }
    export namespace DeleteServiceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteServiceResponse) => any;
    }
    /**
        * <p>No service exists with the specified ID.</p>
        */
    export class ServiceNotFound extends __BaseException {
            readonly name: "ServiceNotFound";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ServiceNotFound, __BaseException>);
    }
    export interface DeregisterInstanceRequest {
            /**
                * <p>The ID of the service that the instance is associated with.</p>
                */
            ServiceId: string | undefined;
            /**
                * <p>The value that you specified for <code>Id</code> in the <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance</a> request.</p>
                */
            InstanceId: string | undefined;
    }
    export namespace DeregisterInstanceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeregisterInstanceRequest) => any;
    }
    export interface DeregisterInstanceResponse {
            /**
                * <p>A value that you can use to determine whether the request completed successfully.
                *                                 To get the status of the operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
                */
            OperationId?: string;
    }
    export namespace DeregisterInstanceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeregisterInstanceResponse) => any;
    }
    /**
        * <p>No instance exists with the specified ID, or the instance was recently registered, and information about the
        *    instance hasn't propagated yet.</p>
        */
    export class InstanceNotFound extends __BaseException {
            readonly name: "InstanceNotFound";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InstanceNotFound, __BaseException>);
    }
    export enum HealthStatusFilter {
            ALL = "ALL",
            HEALTHY = "HEALTHY",
            HEALTHY_OR_ELSE_ALL = "HEALTHY_OR_ELSE_ALL",
            UNHEALTHY = "UNHEALTHY"
    }
    export interface DiscoverInstancesRequest {
            /**
                * <p>The <code>HttpName</code> name of the namespace. It's found in the <code>HttpProperties</code> member of the
                *     <code>Properties</code> member of the namespace.</p>
                */
            NamespaceName: string | undefined;
            /**
                * <p>The name of the service that you specified when you registered the instance.</p>
                */
            ServiceName: string | undefined;
            /**
                * <p>The maximum number of instances that you want Cloud Map to return in the response to a
                *     <code>DiscoverInstances</code> request. If you don't specify a value for <code>MaxResults</code>, Cloud Map returns up
                *    to 100 instances.</p>
                */
            MaxResults?: number;
            /**
                * <p>Filters to scope the results based on custom attributes for the instance (for example, <code>{version=v1,
                *     az=1a}</code>). Only instances that match all the specified key-value pairs are returned.</p>
                */
            QueryParameters?: Record<string, string>;
            /**
                * <p>Opportunistic filters to scope the results based on custom attributes. If there are instances that match both
                *    the filters specified in both the <code>QueryParameters</code> parameter and this parameter, all of these instances
                *    are returned. Otherwise, the filters are ignored, and only instances that match the filters that are specified in the
                *     <code>QueryParameters</code> parameter are returned.</p>
                */
            OptionalParameters?: Record<string, string>;
            /**
                * <p>The health status of the instances that you want to discover. This parameter is ignored for services that don't
                *    have a health check configured, and
                *    all
                *    instances are returned.</p>
                *          <dl>
                *             <dt>HEALTHY</dt>
                *             <dd>
                *                <p>Returns healthy instances.</p>
                *             </dd>
                *             <dt>UNHEALTHY</dt>
                *             <dd>
                *                <p>Returns unhealthy instances.</p>
                *             </dd>
                *             <dt>ALL</dt>
                *             <dd>
                *                <p>Returns all instances.</p>
                *             </dd>
                *             <dt>HEALTHY_OR_ELSE_ALL</dt>
                *             <dd>
                *                <p>Returns healthy instances, unless none are reporting a healthy state. In that case, return all instances.
                *       This is also called failing open.</p>
                *             </dd>
                *          </dl>
                */
            HealthStatus?: HealthStatusFilter | string;
    }
    export namespace DiscoverInstancesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DiscoverInstancesRequest) => any;
    }
    export enum HealthStatus {
            HEALTHY = "HEALTHY",
            UNHEALTHY = "UNHEALTHY",
            UNKNOWN = "UNKNOWN"
    }
    /**
        * <p>In a response to a <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html">DiscoverInstances</a> request, <code>HttpInstanceSummary</code> contains information about one instance that
        *    matches the values that you specified in the request.</p>
        */
    export interface HttpInstanceSummary {
            /**
                * <p>The ID of an instance that matches the values that you specified in the request.</p>
                */
            InstanceId?: string;
            /**
                * <p>
                *             <code></code>
                *             <code></code>
                *             <code></code>
                *          </p>
                *          <p>The <code>HttpName</code> name of the namespace. It's found in the <code>HttpProperties</code> member of the
                *     <code>Properties</code> member of the namespace.</p>
                */
            NamespaceName?: string;
            /**
                * <p>The name of the service that you specified when you registered the instance.</p>
                */
            ServiceName?: string;
            /**
                * <p>If you configured health checking in the service, the current health status of the service instance.</p>
                */
            HealthStatus?: HealthStatus | string;
            /**
                * <p>If you included any attributes when you registered the instance, the values of those attributes.</p>
                */
            Attributes?: Record<string, string>;
    }
    export namespace HttpInstanceSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: HttpInstanceSummary) => any;
    }
    export interface DiscoverInstancesResponse {
            /**
                * <p>A complex type that contains one <code>HttpInstanceSummary</code> for each registered instance.</p>
                */
            Instances?: HttpInstanceSummary[];
    }
    export namespace DiscoverInstancesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DiscoverInstancesResponse) => any;
    }
    /**
        * <p>The operation can't be completed because you've reached the quota for the number of requests. For more
        *    information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/throttling.html">Cloud Map API request throttling
        *     quota</a> in the <i>Cloud Map Developer Guide</i>.</p>
        */
    export class RequestLimitExceeded extends __BaseException {
            readonly name: "RequestLimitExceeded";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<RequestLimitExceeded, __BaseException>);
    }
    /**
        * <p>A complex type that contains information about changes to the Route 53 DNS records that Cloud Map creates when you
        *    register an instance.</p>
        */
    export interface DnsConfigChange {
            /**
                * <p>An array that contains one <code>DnsRecord</code> object for each Route 53 record that you want Cloud Map to
                *    create when you register an instance.</p>
                */
            DnsRecords: DnsRecord[] | undefined;
    }
    export namespace DnsConfigChange {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DnsConfigChange) => any;
    }
    /**
        * <p>A complex type that contains the ID for the Route 53 hosted zone that Cloud Map creates when you create a
        *    namespace.</p>
        */
    export interface DnsProperties {
            /**
                * <p>The ID for the Route 53 hosted zone that Cloud Map creates when you create a namespace.</p>
                */
            HostedZoneId?: string;
            /**
                * <p>Start of Authority (SOA) record for the hosted zone.</p>
                */
            SOA?: SOA;
    }
    export namespace DnsProperties {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DnsProperties) => any;
    }
    export enum FilterCondition {
            BETWEEN = "BETWEEN",
            EQ = "EQ",
            IN = "IN"
    }
    export interface GetInstanceRequest {
            /**
                * <p>The ID of the service that the instance is associated with.</p>
                */
            ServiceId: string | undefined;
            /**
                * <p>The ID of the instance that you want to get information about.</p>
                */
            InstanceId: string | undefined;
    }
    export namespace GetInstanceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetInstanceRequest) => any;
    }
    /**
        * <p>A complex type that contains information about an instance that Cloud Map creates when you submit a
        *     <code>RegisterInstance</code> request.</p>
        */
    export interface Instance {
            /**
                * <p>An identifier that you want to associate with the instance. Note the following:</p>
                *          <ul>
                *             <li>
                *                <p>If the service that's specified by <code>ServiceId</code> includes settings for an <code>SRV</code> record,
                *      the value of <code>InstanceId</code> is automatically included as part of the value for the <code>SRV</code>
                *      record. For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_DnsRecord.html#cloudmap-Type-DnsRecord-Type">DnsRecord > Type</a>.</p>
                *             </li>
                *             <li>
                *                <p>You can use this value to update an existing instance.</p>
                *             </li>
                *             <li>
                *                <p>To register a new instance, you must specify a value that's unique among instances that you register by using
                *      the same service. </p>
                *             </li>
                *             <li>
                *                <p>If you specify an existing <code>InstanceId</code> and <code>ServiceId</code>, Cloud Map updates the existing
                *      DNS records. If there's also an existing health check, Cloud Map deletes the old health check and creates a new
                *      one. </p>
                *                <note>
                *                   <p>The health check isn't deleted immediately, so it will still appear for a while if you submit a
                *        <code>ListHealthChecks</code> request, for example.</p>
                *                </note>
                *             </li>
                *          </ul>
                */
            Id: string | undefined;
            /**
                * <p>A unique string that identifies the request and that allows failed <code>RegisterInstance</code> requests to be
                *    retried without the risk of executing the operation twice. You must use a unique <code>CreatorRequestId</code> string
                *    every time you submit a <code>RegisterInstance</code> request if you're registering additional instances for the same
                *    namespace and service. <code>CreatorRequestId</code> can be any unique string (for example, a date/time
                *    stamp).</p>
                */
            CreatorRequestId?: string;
            /**
                * <p>A string map that contains the following information for the service that you specify in
                *    <code>ServiceId</code>:</p>
                *          <ul>
                *             <li>
                *                <p>The attributes that apply to the records that are defined in the service. </p>
                *             </li>
                *             <li>
                *                <p>For each attribute, the applicable value.</p>
                *             </li>
                *          </ul>
                *          <p>Supported attribute keys include the following:</p>
                *          <dl>
                *             <dt>AWS_ALIAS_DNS_NAME</dt>
                *             <dd>
                *                <p>If you want Cloud Map to create a Route 53 alias record that routes traffic to an Elastic Load Balancing load balancer, specify
                *       the DNS name that's associated with the load balancer. For information about how to get the DNS name, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_AliasTarget.html#Route53-Type-AliasTarget-DNSName">AliasTarget->DNSName</a> in the <i>Route 53 API Reference</i>.</p>
                *                <p>Note the following:</p>
                *                <ul>
                *                   <li>
                *                      <p>The configuration for the service that's specified by <code>ServiceId</code> must include settings for an
                *          <code>A</code> record, an <code>AAAA</code> record, or both.</p>
                *                   </li>
                *                   <li>
                *                      <p>In the service that's specified by <code>ServiceId</code>, the value of <code>RoutingPolicy</code> must be
                *          <code>WEIGHTED</code>.</p>
                *                   </li>
                *                   <li>
                *                      <p>If the service that's specified by <code>ServiceId</code> includes <code>HealthCheckConfig</code> settings,
                *         Cloud Map creates the health check, but it won't associate the health check with the alias record.</p>
                *                   </li>
                *                   <li>
                *                      <p>Auto naming currently doesn't support creating alias records that route traffic to Amazon Web Services resources other
                *         than ELB load balancers.</p>
                *                   </li>
                *                   <li>
                *                      <p>If you specify a value for <code>AWS_ALIAS_DNS_NAME</code>, don't specify values for any of the
                *          <code>AWS_INSTANCE</code> attributes.</p>
                *                   </li>
                *                </ul>
                *             </dd>
                *             <dt>AWS_EC2_INSTANCE_ID</dt>
                *             <dd>
                *                <p>
                *                   <i>HTTP namespaces only.</i> The Amazon EC2 instance ID for the instance. The
                *        <code>AWS_INSTANCE_IPV4</code> attribute contains the primary private IPv4 address.</p>
                *             </dd>
                *             <dt>AWS_INIT_HEALTH_STATUS</dt>
                *             <dd>
                *                <p>If the service configuration includes <code>HealthCheckCustomConfig</code>, you can optionally use
                *        <code>AWS_INIT_HEALTH_STATUS</code> to specify the initial status of the custom health check,
                *        <code>HEALTHY</code> or <code>UNHEALTHY</code>. If you don't specify a value for
                *        <code>AWS_INIT_HEALTH_STATUS</code>, the initial status is <code>HEALTHY</code>.</p>
                *             </dd>
                *             <dt>AWS_INSTANCE_CNAME</dt>
                *             <dd>
                *                <p>If the service configuration includes a <code>CNAME</code> record, the domain name that you want Route 53 to
                *       return in response to DNS queries (for example, <code>example.com</code>).</p>
                *                <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
                *        <code>CNAME</code> record.</p>
                *             </dd>
                *             <dt>AWS_INSTANCE_IPV4</dt>
                *             <dd>
                *                <p>If the service configuration includes an <code>A</code> record, the IPv4 address that you want Route 53 to
                *       return in response to DNS queries (for example, <code>192.0.2.44</code>).</p>
                *                <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
                *        <code>A</code> record. If the service includes settings for an <code>SRV</code> record, you must specify a value
                *       for <code>AWS_INSTANCE_IPV4</code>, <code>AWS_INSTANCE_IPV6</code>, or both.</p>
                *             </dd>
                *             <dt>AWS_INSTANCE_IPV6</dt>
                *             <dd>
                *                <p>If the service configuration includes an <code>AAAA</code> record, the IPv6 address that you want Route 53 to
                *       return in response to DNS queries (for example, <code>2001:0db8:85a3:0000:0000:abcd:0001:2345</code>).</p>
                *                <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
                *        <code>AAAA</code> record. If the service includes settings for an <code>SRV</code> record, you must specify a
                *       value for <code>AWS_INSTANCE_IPV4</code>, <code>AWS_INSTANCE_IPV6</code>, or both.</p>
                *             </dd>
                *             <dt>AWS_INSTANCE_PORT</dt>
                *             <dd>
                *                <p>If the service includes an <code>SRV</code> record, the value that you want Route 53 to return for the
                *       port.</p>
                *                <p>If the service includes <code>HealthCheckConfig</code>, the port on the endpoint that you want Route 53 to send
                *       requests to. </p>
                *                <p>This value is required if you specified settings for an <code>SRV</code> record or a Route 53 health check when
                *       you created the service.</p>
                *             </dd>
                *          </dl>
                */
            Attributes?: Record<string, string>;
    }
    export namespace Instance {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Instance) => any;
    }
    export interface GetInstanceResponse {
            /**
                * <p>A complex type that contains information about a specified instance.</p>
                */
            Instance?: Instance;
    }
    export namespace GetInstanceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetInstanceResponse) => any;
    }
    export interface GetInstancesHealthStatusRequest {
            /**
                * <p>The ID of the service that the instance is associated with.</p>
                */
            ServiceId: string | undefined;
            /**
                * <p>An array that contains the IDs of all the instances that you want to get the health status for.</p>
                *          <p>If you omit <code>Instances</code>, Cloud Map returns the health status for all the instances that are
                *    associated with the specified service.</p>
                *          <note>
                *             <p>To get the IDs for the instances that you've registered by using a specified service, submit a <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_ListInstances.html">ListInstances</a> request.</p>
                *          </note>
                */
            Instances?: string[];
            /**
                * <p>The maximum number of instances that you want Cloud Map to return in the response to a
                *     <code>GetInstancesHealthStatus</code> request. If you don't specify a value for <code>MaxResults</code>, Cloud Map
                *    returns up to 100 instances.</p>
                */
            MaxResults?: number;
            /**
                * <p>For the first <code>GetInstancesHealthStatus</code> request, omit this value.</p>
                *          <p>If more than <code>MaxResults</code> instances match the specified criteria, you can submit another
                *     <code>GetInstancesHealthStatus</code> request to get the next group of results. Specify the value of
                *     <code>NextToken</code> from the previous response in the next request.</p>
                */
            NextToken?: string;
    }
    export namespace GetInstancesHealthStatusRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetInstancesHealthStatusRequest) => any;
    }
    export interface GetInstancesHealthStatusResponse {
            /**
                * <p>A complex type that contains the IDs and the health status of the instances that you specified in the
                *     <code>GetInstancesHealthStatus</code> request.</p>
                */
            Status?: Record<string, HealthStatus | string>;
            /**
                * <p>If more than <code>MaxResults</code> instances match the specified criteria, you can submit another
                *     <code>GetInstancesHealthStatus</code> request to get the next group of results. Specify the value of
                *     <code>NextToken</code> from the previous response in the next request.</p>
                */
            NextToken?: string;
    }
    export namespace GetInstancesHealthStatusResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetInstancesHealthStatusResponse) => any;
    }
    export interface GetNamespaceRequest {
            /**
                * <p>The ID of the namespace that you want to get information about.</p>
                */
            Id: string | undefined;
    }
    export namespace GetNamespaceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetNamespaceRequest) => any;
    }
    /**
        * <p>A complex type that contains the name of an HTTP namespace.</p>
        */
    export interface HttpProperties {
            /**
                * <p>The name of an HTTP namespace.</p>
                */
            HttpName?: string;
    }
    export namespace HttpProperties {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: HttpProperties) => any;
    }
    /**
        * <p>A complex type that contains information that's specific to the namespace type.</p>
        */
    export interface NamespaceProperties {
            /**
                * <p>A complex type that contains the ID for the Route 53 hosted zone that Cloud Map creates when you create a
                *    namespace.</p>
                */
            DnsProperties?: DnsProperties;
            /**
                * <p>A complex type that contains the name of an HTTP namespace.</p>
                */
            HttpProperties?: HttpProperties;
    }
    export namespace NamespaceProperties {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: NamespaceProperties) => any;
    }
    export enum NamespaceType {
            DNS_PRIVATE = "DNS_PRIVATE",
            DNS_PUBLIC = "DNS_PUBLIC",
            HTTP = "HTTP"
    }
    /**
        * <p>A complex type that contains information about a specified namespace.</p>
        */
    export interface Namespace {
            /**
                * <p>The ID of a namespace.</p>
                */
            Id?: string;
            /**
                * <p>The Amazon Resource Name (ARN) that Cloud Map assigns to the namespace when you create it.</p>
                */
            Arn?: string;
            /**
                * <p>The name of the namespace, such as <code>example.com</code>.</p>
                */
            Name?: string;
            /**
                * <p>The type of the namespace. The methods for discovering instances depends on the value that you specify:</p>
                *          <dl>
                *             <dt>HTTP</dt>
                *             <dd>
                *                <p>Instances can be discovered only programmatically, using the Cloud Map <code>DiscoverInstances</code>
                *       API.</p>
                *             </dd>
                *             <dt>DNS_PUBLIC</dt>
                *             <dd>
                *                <p>Instances can be discovered using public DNS queries and using the <code>DiscoverInstances</code> API.</p>
                *             </dd>
                *             <dt>DNS_PRIVATE</dt>
                *             <dd>
                *                <p>Instances can be discovered using DNS queries in VPCs and using the <code>DiscoverInstances</code>
                *       API.</p>
                *             </dd>
                *          </dl>
                */
            Type?: NamespaceType | string;
            /**
                * <p>The description that you specify for the namespace when you create it.</p>
                */
            Description?: string;
            /**
                * <p>The number of services that are associated with the namespace.</p>
                */
            ServiceCount?: number;
            /**
                * <p>A complex type that contains information that's specific to the type of the namespace.</p>
                */
            Properties?: NamespaceProperties;
            /**
                * <p>The date that the namespace was created, in Unix date/time format and Coordinated Universal Time (UTC). The
                *    value of <code>CreateDate</code> is accurate to milliseconds. For example, the value <code>1516925490.087</code>
                *    represents Friday, January 26, 2018 12:11:30.087 AM.</p>
                */
            CreateDate?: Date;
            /**
                * <p>A unique string that identifies the request and that allows failed requests to be retried without the risk of
                *    running an operation twice. </p>
                */
            CreatorRequestId?: string;
    }
    export namespace Namespace {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Namespace) => any;
    }
    export interface GetNamespaceResponse {
            /**
                * <p>A complex type that contains information about the specified namespace.</p>
                */
            Namespace?: Namespace;
    }
    export namespace GetNamespaceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetNamespaceResponse) => any;
    }
    export interface GetOperationRequest {
            /**
                * <p>The ID of the operation that you want to get more information about.</p>
                */
            OperationId: string | undefined;
    }
    export namespace GetOperationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetOperationRequest) => any;
    }
    export enum OperationStatus {
            FAIL = "FAIL",
            PENDING = "PENDING",
            SUBMITTED = "SUBMITTED",
            SUCCESS = "SUCCESS"
    }
    export enum OperationTargetType {
            INSTANCE = "INSTANCE",
            NAMESPACE = "NAMESPACE",
            SERVICE = "SERVICE"
    }
    export enum OperationType {
            CREATE_NAMESPACE = "CREATE_NAMESPACE",
            DELETE_NAMESPACE = "DELETE_NAMESPACE",
            DEREGISTER_INSTANCE = "DEREGISTER_INSTANCE",
            REGISTER_INSTANCE = "REGISTER_INSTANCE",
            UPDATE_NAMESPACE = "UPDATE_NAMESPACE",
            UPDATE_SERVICE = "UPDATE_SERVICE"
    }
    /**
        * <p>A complex type that contains information about a specified operation.</p>
        */
    export interface Operation {
            /**
                * <p>The ID of the operation that you want to get information about.</p>
                */
            Id?: string;
            /**
                * <p>The name of the operation that's associated with the specified ID.</p>
                */
            Type?: OperationType | string;
            /**
                * <p>The status of the operation. Values include the following:</p>
                *          <dl>
                *             <dt>SUBMITTED</dt>
                *             <dd>
                *                <p>This is the initial state that occurs immediately after you submit a request.</p>
                *             </dd>
                *             <dt>PENDING</dt>
                *             <dd>
                *                <p>Cloud Map is performing the operation.</p>
                *             </dd>
                *             <dt>SUCCESS</dt>
                *             <dd>
                *                <p>The operation succeeded.</p>
                *             </dd>
                *             <dt>FAIL</dt>
                *             <dd>
                *                <p>The operation failed. For the failure reason, see <code>ErrorMessage</code>.</p>
                *             </dd>
                *          </dl>
                */
            Status?: OperationStatus | string;
            /**
                * <p>If the value of <code>Status</code> is <code>FAIL</code>, the reason that the operation failed.</p>
                */
            ErrorMessage?: string;
            /**
                * <p>The code associated with <code>ErrorMessage</code>. Values for <code>ErrorCode</code> include the
                *    following:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>ACCESS_DENIED</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>CANNOT_CREATE_HOSTED_ZONE</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>EXPIRED_TOKEN</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>HOSTED_ZONE_NOT_FOUND</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>INTERNAL_FAILURE</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>INVALID_CHANGE_BATCH</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>THROTTLED_REQUEST</code>
                *                </p>
                *             </li>
                *          </ul>
                */
            ErrorCode?: string;
            /**
                * <p>The date and time that the request was submitted, in Unix date/time format and Coordinated Universal Time (UTC).
                *    The value of <code>CreateDate</code> is accurate to milliseconds. For example, the value <code>1516925490.087</code>
                *    represents Friday, January 26, 2018 12:11:30.087 AM.</p>
                */
            CreateDate?: Date;
            /**
                * <p>The date and time that the value of <code>Status</code> changed to the current value, in Unix date/time format
                *    and Coordinated Universal Time (UTC). The value of <code>UpdateDate</code> is accurate to milliseconds. For example,
                *    the value <code>1516925490.087</code> represents Friday, January 26, 2018 12:11:30.087 AM.</p>
                */
            UpdateDate?: Date;
            /**
                * <p>The name of the target entity that's associated with the operation:</p>
                *          <dl>
                *             <dt>NAMESPACE</dt>
                *             <dd>
                *                <p>The namespace ID is returned in the <code>ResourceId</code> property.</p>
                *             </dd>
                *             <dt>SERVICE</dt>
                *             <dd>
                *                <p>The service ID is returned in the <code>ResourceId</code> property.</p>
                *             </dd>
                *             <dt>INSTANCE</dt>
                *             <dd>
                *                <p>The instance ID is returned in the <code>ResourceId</code> property.</p>
                *             </dd>
                *          </dl>
                */
            Targets?: Record<string, string>;
    }
    export namespace Operation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Operation) => any;
    }
    export interface GetOperationResponse {
            /**
                * <p>A complex type that contains information about the operation.</p>
                */
            Operation?: Operation;
    }
    export namespace GetOperationResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetOperationResponse) => any;
    }
    /**
        * <p>No operation exists with the specified ID.</p>
        */
    export class OperationNotFound extends __BaseException {
            readonly name: "OperationNotFound";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<OperationNotFound, __BaseException>);
    }
    export interface GetServiceRequest {
            /**
                * <p>The ID of the service that you want to get settings for.</p>
                */
            Id: string | undefined;
    }
    export namespace GetServiceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetServiceRequest) => any;
    }
    export interface GetServiceResponse {
            /**
                * <p>A complex type that contains information about the service.</p>
                */
            Service?: Service;
    }
    export namespace GetServiceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetServiceResponse) => any;
    }
    /**
        * <p>Updated properties for the HTTP
        *    namespace.</p>
        */
    export interface HttpNamespaceChange {
            /**
                * <p>An updated description for the HTTP
                *    namespace.</p>
                */
            Description: string | undefined;
    }
    export namespace HttpNamespaceChange {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: HttpNamespaceChange) => any;
    }
    /**
        * <p>A complex type that contains information about the instances that you registered by using a specified
        *    service.</p>
        */
    export interface InstanceSummary {
            /**
                * <p>The ID for an instance that you created by using a specified service.</p>
                */
            Id?: string;
            /**
                * <p>A string map that contains the following information:</p>
                *          <ul>
                *             <li>
                *                <p>The attributes that are associated with the instance. </p>
                *             </li>
                *             <li>
                *                <p>For each attribute, the applicable value.</p>
                *             </li>
                *          </ul>
                *          <p>Supported attribute keys include the following:</p>
                *          <dl>
                *             <dt>AWS_ALIAS_DNS_NAME</dt>
                *             <dd>
                *                <p>For an alias record that routes traffic to an Elastic Load Balancing load balancer, the DNS name that's associated with the
                *       load balancer. </p>
                *             </dd>
                *             <dt>AWS_EC2_INSTANCE_ID (HTTP namespaces only)</dt>
                *             <dd>
                *                <p>The Amazon EC2 instance ID for the instance. When the <code>AWS_EC2_INSTANCE_ID</code> attribute is specified,
                *       then the <code>AWS_INSTANCE_IPV4</code> attribute contains the primary private IPv4 address.</p>
                *             </dd>
                *             <dt>AWS_INIT_HEALTH_STATUS</dt>
                *             <dd>
                *                <p>If the service configuration includes <code>HealthCheckCustomConfig</code>, you can optionally use
                *        <code>AWS_INIT_HEALTH_STATUS</code> to specify the initial status of the custom health check,
                *        <code>HEALTHY</code> or <code>UNHEALTHY</code>. If you don't specify a value for
                *        <code>AWS_INIT_HEALTH_STATUS</code>, the initial status is <code>HEALTHY</code>.</p>
                *             </dd>
                *             <dt>AWS_INSTANCE_CNAME</dt>
                *             <dd>
                *                <p>For a <code>CNAME</code> record, the domain name that Route 53 returns in response to DNS queries (for example,
                *        <code>example.com</code>).</p>
                *             </dd>
                *             <dt>AWS_INSTANCE_IPV4</dt>
                *             <dd>
                *                <p>For an <code>A</code> record, the IPv4 address that Route 53 returns in response to DNS queries (for example,
                *        <code>192.0.2.44</code>).</p>
                *             </dd>
                *             <dt>AWS_INSTANCE_IPV6</dt>
                *             <dd>
                *                <p>For an <code>AAAA</code> record, the IPv6 address that Route 53 returns in response to DNS queries (for example,
                *        <code>2001:0db8:85a3:0000:0000:abcd:0001:2345</code>).</p>
                *             </dd>
                *             <dt>AWS_INSTANCE_PORT</dt>
                *             <dd>
                *                <p>For an <code>SRV</code> record, the value that Route 53 returns for the port. In addition, if the service
                *       includes <code>HealthCheckConfig</code>, the port on the endpoint that Route 53 sends requests to.</p>
                *             </dd>
                *          </dl>
                */
            Attributes?: Record<string, string>;
    }
    export namespace InstanceSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InstanceSummary) => any;
    }
    export interface ListInstancesRequest {
            /**
                * <p>The ID of the service that you want to list instances for.</p>
                */
            ServiceId: string | undefined;
            /**
                * <p>For the first <code>ListInstances</code> request, omit this value.</p>
                *          <p>If more than <code>MaxResults</code> instances match the specified criteria, you can submit another
                *     <code>ListInstances</code> request to get the next group of results. Specify the value of <code>NextToken</code>
                *    from the previous response in the next request.</p>
                */
            NextToken?: string;
            /**
                * <p>The maximum number of instances that you want Cloud Map to return in the response to a
                *     <code>ListInstances</code> request. If you don't specify a value for <code>MaxResults</code>, Cloud Map returns up
                *    to 100 instances.</p>
                */
            MaxResults?: number;
    }
    export namespace ListInstancesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListInstancesRequest) => any;
    }
    export interface ListInstancesResponse {
            /**
                * <p>Summary information about the instances that are associated with the specified service.</p>
                */
            Instances?: InstanceSummary[];
            /**
                * <p>If more than <code>MaxResults</code> instances match the specified criteria, you can submit another
                *     <code>ListInstances</code> request to get the next group of results. Specify the value of <code>NextToken</code>
                *    from the previous response in the next request.</p>
                */
            NextToken?: string;
    }
    export namespace ListInstancesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListInstancesResponse) => any;
    }
    export enum NamespaceFilterName {
            TYPE = "TYPE"
    }
    /**
        * <p>A complex type that identifies the namespaces that you want to list. You can choose to list public or private
        *    namespaces.</p>
        */
    export interface NamespaceFilter {
            /**
                * <p>Specify <code>TYPE</code>.</p>
                */
            Name: NamespaceFilterName | string | undefined;
            /**
                * <p>If you specify <code>EQ</code> for <code>Condition</code>, specify either <code>DNS_PUBLIC</code> or
                *     <code>DNS_PRIVATE</code>.</p>
                *          <p>If you specify <code>IN</code> for <code>Condition</code>, you can specify <code>DNS_PUBLIC</code>,
                *     <code>DNS_PRIVATE</code>, or both.</p>
                */
            Values: string[] | undefined;
            /**
                * <p>The operator that you want to use to determine whether <code>ListNamespaces</code> returns a namespace. Valid
                *    values for <code>condition</code> include:</p>
                *          <dl>
                *             <dt>EQ</dt>
                *             <dd>
                *                <p>When you specify <code>EQ</code> for the condition, you can choose to list only public namespaces or private
                *       namespaces, but not both. <code>EQ</code> is the default condition and can be omitted.</p>
                *             </dd>
                *             <dt>IN</dt>
                *             <dd>
                *                <p>When you specify <code>IN</code> for the condition, you can choose to list public namespaces, private
                *       namespaces, or both. </p>
                *             </dd>
                *             <dt>BETWEEN</dt>
                *             <dd>
                *                <p> Not applicable</p>
                *             </dd>
                *          </dl>
                */
            Condition?: FilterCondition | string;
    }
    export namespace NamespaceFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: NamespaceFilter) => any;
    }
    export interface ListNamespacesRequest {
            /**
                * <p>For the first <code>ListNamespaces</code> request, omit this value.</p>
                *          <p>If the response contains <code>NextToken</code>, submit another <code>ListNamespaces</code> request to get the
                *    next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
                *    request.</p>
                *          <note>
                *             <p>Cloud Map gets <code>MaxResults</code> namespaces and then filters them based on the specified criteria. It's
                *     possible that no namespaces in the first <code>MaxResults</code> namespaces matched the specified criteria but that
                *     subsequent groups of <code>MaxResults</code> namespaces do contain namespaces that match the criteria.</p>
                *          </note>
                */
            NextToken?: string;
            /**
                * <p>The maximum number of namespaces that you want Cloud Map to return in the response to a
                *     <code>ListNamespaces</code> request. If you don't specify a value for <code>MaxResults</code>, Cloud Map returns up
                *    to 100 namespaces.</p>
                */
            MaxResults?: number;
            /**
                * <p>A complex type that contains specifications for the namespaces that you want to list.</p>
                *          <p>If you specify more than one filter, a namespace must match all filters to be returned by
                *     <code>ListNamespaces</code>.</p>
                */
            Filters?: NamespaceFilter[];
    }
    export namespace ListNamespacesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListNamespacesRequest) => any;
    }
    /**
        * <p>A complex type that contains information about a namespace.</p>
        */
    export interface NamespaceSummary {
            /**
                * <p>The ID of the namespace.</p>
                */
            Id?: string;
            /**
                * <p>The Amazon Resource Name (ARN) that Cloud Map assigns to the namespace when you create it.</p>
                */
            Arn?: string;
            /**
                * <p>The name of the namespace. When you create a namespace, Cloud Map automatically creates a Route 53 hosted zone
                *    that has the same name as the namespace.</p>
                */
            Name?: string;
            /**
                * <p>The type of the namespace, either public or private.</p>
                */
            Type?: NamespaceType | string;
            /**
                * <p>A description for the namespace.</p>
                */
            Description?: string;
            /**
                * <p>The number of services that were created using the namespace.</p>
                */
            ServiceCount?: number;
            /**
                * <p>The properties of the namespace.</p>
                */
            Properties?: NamespaceProperties;
            /**
                * <p>The date and time that the namespace was created.</p>
                */
            CreateDate?: Date;
    }
    export namespace NamespaceSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: NamespaceSummary) => any;
    }
    export interface ListNamespacesResponse {
            /**
                * <p>An array that contains one <code>NamespaceSummary</code> object for each namespace that matches the specified
                *    filter criteria.</p>
                */
            Namespaces?: NamespaceSummary[];
            /**
                * <p>If the response contains <code>NextToken</code>, submit another <code>ListNamespaces</code> request to get the
                *    next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
                *    request.</p>
                *          <note>
                *             <p>Cloud Map gets <code>MaxResults</code> namespaces and then filters them based on the specified criteria. It's
                *     possible that no namespaces in the first <code>MaxResults</code> namespaces matched the specified criteria but that
                *     subsequent groups of <code>MaxResults</code> namespaces do contain namespaces that match the criteria.</p>
                *          </note>
                */
            NextToken?: string;
    }
    export namespace ListNamespacesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListNamespacesResponse) => any;
    }
    export enum OperationFilterName {
            NAMESPACE_ID = "NAMESPACE_ID",
            SERVICE_ID = "SERVICE_ID",
            STATUS = "STATUS",
            TYPE = "TYPE",
            UPDATE_DATE = "UPDATE_DATE"
    }
    /**
        * <p>A complex type that lets you select the operations that you want to list.</p>
        */
    export interface OperationFilter {
            /**
                * <p>Specify the operations that you want to get:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <b>NAMESPACE_ID</b>: Gets operations related to specified namespaces.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>SERVICE_ID</b>: Gets operations related to specified services.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>STATUS</b>: Gets operations based on the status of the operations:
                *       <code>SUBMITTED</code>, <code>PENDING</code>, <code>SUCCEED</code>, or <code>FAIL</code>.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>TYPE</b>: Gets specified types of operation.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>UPDATE_DATE</b>: Gets operations that changed status during a specified date/time
                *      range. </p>
                *             </li>
                *          </ul>
                */
            Name: OperationFilterName | string | undefined;
            /**
                * <p>Specify values that are applicable to the value that you specify for <code>Name</code>: </p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <b>NAMESPACE_ID</b>: Specify one namespace ID.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>SERVICE_ID</b>: Specify one service ID.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>STATUS</b>: Specify one or more statuses: <code>SUBMITTED</code>,
                *       <code>PENDING</code>, <code>SUCCEED</code>, or <code>FAIL</code>.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>TYPE</b>: Specify one or more of the following types:
                *       <code>CREATE_NAMESPACE</code>, <code>DELETE_NAMESPACE</code>, <code>UPDATE_SERVICE</code>,
                *       <code>REGISTER_INSTANCE</code>, or <code>DEREGISTER_INSTANCE</code>.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>UPDATE_DATE</b>: Specify a start date and an end date in Unix date/time format
                *      and Coordinated Universal Time (UTC). The start date must be the first value.</p>
                *             </li>
                *          </ul>
                */
            Values: string[] | undefined;
            /**
                * <p>The operator that you want to use to determine whether an operation matches the specified value. Valid values
                *    for condition include:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>EQ</code>: When you specify <code>EQ</code> for the condition, you can specify only one value.
                *       <code>EQ</code> is supported for <code>NAMESPACE_ID</code>, <code>SERVICE_ID</code>, <code>STATUS</code>, and
                *       <code>TYPE</code>. <code>EQ</code> is the default condition and can be omitted.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>IN</code>: When you specify <code>IN</code> for the condition, you can specify a list of one or more
                *      values. <code>IN</code> is supported for <code>STATUS</code> and <code>TYPE</code>. An operation must match one of
                *      the specified values to be returned in the response.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>BETWEEN</code>: Specify a start date and an end date in Unix date/time format and Coordinated Universal
                *      Time (UTC). The start date must be the first value. <code>BETWEEN</code> is supported for <code>UPDATE_DATE</code>.
                *     </p>
                *             </li>
                *          </ul>
                */
            Condition?: FilterCondition | string;
    }
    export namespace OperationFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OperationFilter) => any;
    }
    export interface ListOperationsRequest {
            /**
                * <p>For the first <code>ListOperations</code> request, omit this value.</p>
                *          <p>If the response contains <code>NextToken</code>, submit another <code>ListOperations</code> request to get the
                *    next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
                *    request.</p>
                *          <note>
                *             <p>Cloud Map gets <code>MaxResults</code> operations and then filters them based on the specified criteria. It's
                *     possible that no operations in the first <code>MaxResults</code> operations matched the specified criteria but that
                *     subsequent groups of <code>MaxResults</code> operations do contain operations that match the criteria.</p>
                *          </note>
                */
            NextToken?: string;
            /**
                * <p>The maximum number of items that you want Cloud Map to return in the response to a <code>ListOperations</code>
                *    request. If you don't specify a value for <code>MaxResults</code>, Cloud Map returns up to 100 operations.</p>
                */
            MaxResults?: number;
            /**
                * <p>A complex type that contains specifications for the operations that you want to list, for example, operations
                *    that you started between a specified start date and end date.</p>
                *          <p>If you specify more than one filter, an operation must match all filters to be returned by
                *     <code>ListOperations</code>.</p>
                */
            Filters?: OperationFilter[];
    }
    export namespace ListOperationsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListOperationsRequest) => any;
    }
    /**
        * <p>A complex type that contains information about an operation that matches the criteria that you specified in a
        *     <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_ListOperations.html">ListOperations</a>
        *    request.</p>
        */
    export interface OperationSummary {
            /**
                * <p>The ID for an operation.</p>
                */
            Id?: string;
            /**
                * <p>The status of the operation. Values include the following:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <b>SUBMITTED</b>: This is the initial state immediately after you submit a
                *      request.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>PENDING</b>: Cloud Map is performing the operation.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>SUCCESS</b>: The operation succeeded.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>FAIL</b>: The operation failed. For the failure reason, see
                *       <code>ErrorMessage</code>.</p>
                *             </li>
                *          </ul>
                */
            Status?: OperationStatus | string;
    }
    export namespace OperationSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OperationSummary) => any;
    }
    export interface ListOperationsResponse {
            /**
                * <p>Summary information about the operations that match the specified criteria.</p>
                */
            Operations?: OperationSummary[];
            /**
                * <p>If the response contains <code>NextToken</code>, submit another <code>ListOperations</code> request to get the
                *    next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
                *    request.</p>
                *          <note>
                *             <p>Cloud Map gets <code>MaxResults</code> operations and then filters them based on the specified criteria. It's
                *     possible that no operations in the first <code>MaxResults</code> operations matched the specified criteria but that
                *     subsequent groups of <code>MaxResults</code> operations do contain operations that match the criteria.</p>
                *          </note>
                */
            NextToken?: string;
    }
    export namespace ListOperationsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListOperationsResponse) => any;
    }
    export enum ServiceFilterName {
            NAMESPACE_ID = "NAMESPACE_ID"
    }
    /**
        * <p>A complex type that lets you specify the namespaces that you want to list services for.</p>
        */
    export interface ServiceFilter {
            /**
                * <p>Specify <code>NAMESPACE_ID</code>.</p>
                */
            Name: ServiceFilterName | string | undefined;
            /**
                * <p>The values that are applicable to the value that you specify for <code>Condition</code> to filter the list of
                *    services.</p>
                */
            Values: string[] | undefined;
            /**
                * <p>The operator that you want to use to determine whether a service is returned by <code>ListServices</code>. Valid
                *    values for <code>Condition</code> include the following:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>EQ</code>: When you specify <code>EQ</code>, specify one namespace ID for <code>Values</code>.
                *       <code>EQ</code> is the default condition and can be omitted.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>IN</code>: When you specify <code>IN</code>, specify a list of the IDs for the namespaces that you want
                *       <code>ListServices</code> to return a list of services for.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>BETWEEN</code>: Not applicable.</p>
                *             </li>
                *          </ul>
                */
            Condition?: FilterCondition | string;
    }
    export namespace ServiceFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ServiceFilter) => any;
    }
    export interface ListServicesRequest {
            /**
                * <p>For the first <code>ListServices</code> request, omit this value.</p>
                *          <p>If the response contains <code>NextToken</code>, submit another <code>ListServices</code> request to get the
                *    next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
                *    request.</p>
                *          <note>
                *             <p>Cloud Map gets <code>MaxResults</code> services and then filters them based on the specified criteria. It's
                *     possible that no services in the first <code>MaxResults</code> services matched the specified criteria but that
                *     subsequent groups of <code>MaxResults</code> services do contain services that match the criteria.</p>
                *          </note>
                */
            NextToken?: string;
            /**
                * <p>The maximum number of services that you want Cloud Map to return in the response to a <code>ListServices</code>
                *    request. If you don't specify a value for <code>MaxResults</code>, Cloud Map returns up to 100 services.</p>
                */
            MaxResults?: number;
            /**
                * <p>A complex type that contains specifications for the namespaces that you want to list services for. </p>
                *          <p>If you specify more than one filter, an operation must match all filters to be returned by
                *     <code>ListServices</code>.</p>
                */
            Filters?: ServiceFilter[];
    }
    export namespace ListServicesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListServicesRequest) => any;
    }
    /**
        * <p>A complex type that contains information about a specified service.</p>
        */
    export interface ServiceSummary {
            /**
                * <p>The ID that Cloud Map assigned to the service when you created it.</p>
                */
            Id?: string;
            /**
                * <p>The Amazon Resource Name (ARN) that Cloud Map assigns to the service when you create it.</p>
                */
            Arn?: string;
            /**
                * <p>The name of the service.</p>
                */
            Name?: string;
            /**
                * <p>Describes the systems that can be used to discover the service instances.</p>
                *          <dl>
                *             <dt>DNS_HTTP</dt>
                *             <dd>
                *                <p>The service instances can be discovered using either DNS queries or the <code>DiscoverInstances</code> API
                *       operation.</p>
                *             </dd>
                *             <dt>HTTP</dt>
                *             <dd>
                *                <p>The service instances can only be discovered using the <code>DiscoverInstances</code> API operation.</p>
                *             </dd>
                *             <dt>DNS</dt>
                *             <dd>
                *                <p>Reserved.</p>
                *             </dd>
                *          </dl>
                */
            Type?: ServiceType | string;
            /**
                * <p>The description that you specify when you create the service.</p>
                */
            Description?: string;
            /**
                * <p>The number of instances that are currently associated with the service. Instances that were previously
                *    associated with the service but that are deleted aren't included in the count. The count might not reflect pending
                *    registrations and deregistrations.</p>
                */
            InstanceCount?: number;
            /**
                * <p>Information about the Route 53 DNS records that you want Cloud Map to create when you register an instance.</p>
                */
            DnsConfig?: DnsConfig;
            /**
                * <p>
                *             <i>Public DNS and HTTP namespaces only.</i> Settings for an optional health check. If you specify
                *    settings for a health check, Cloud Map associates the health check with the records that you specify in
                *     <code>DnsConfig</code>.</p>
                */
            HealthCheckConfig?: HealthCheckConfig;
            /**
                * <p>Information about an optional custom health check. A custom health check, which requires that you use a
                *    third-party health checker to evaluate the health of your resources, is useful in the following circumstances:</p>
                *          <ul>
                *             <li>
                *                <p>You can't use a health check that's defined by <code>HealthCheckConfig</code> because the resource isn't
                *      available over the internet. For example, you can use a custom health check when the instance is in an Amazon VPC.
                *      (To check the health of resources in a VPC, the health checker must also be in the VPC.)</p>
                *             </li>
                *             <li>
                *                <p>You want to use a third-party health checker regardless of where your resources are located.</p>
                *             </li>
                *          </ul>
                *          <important>
                *             <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
                *      <code>HealthCheckConfig</code> but not both.</p>
                *          </important>
                */
            HealthCheckCustomConfig?: HealthCheckCustomConfig;
            /**
                * <p>The date and time that the service was created.</p>
                */
            CreateDate?: Date;
    }
    export namespace ServiceSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ServiceSummary) => any;
    }
    export interface ListServicesResponse {
            /**
                * <p>An array that contains one <code>ServiceSummary</code> object for each service that matches the specified filter
                *    criteria.</p>
                */
            Services?: ServiceSummary[];
            /**
                * <p>If the response contains <code>NextToken</code>, submit another <code>ListServices</code> request to get the
                *    next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
                *    request.</p>
                *          <note>
                *             <p>Cloud Map gets <code>MaxResults</code> services and then filters them based on the specified criteria. It's
                *     possible that no services in the first <code>MaxResults</code> services matched the specified criteria but that
                *     subsequent groups of <code>MaxResults</code> services do contain services that match the criteria.</p>
                *          </note>
                */
            NextToken?: string;
    }
    export namespace ListServicesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListServicesResponse) => any;
    }
    export interface ListTagsForResourceRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.</p>
                */
            ResourceARN: string | undefined;
    }
    export namespace ListTagsForResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceRequest) => any;
    }
    export interface ListTagsForResourceResponse {
            /**
                * <p>The tags that are assigned to the resource.</p>
                */
            Tags?: Tag[];
    }
    export namespace ListTagsForResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceResponse) => any;
    }
    /**
        * <p>The operation can't be completed because the resource was not found.</p>
        */
    export class ResourceNotFoundException extends __BaseException {
            readonly name: "ResourceNotFoundException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>);
    }
    /**
        * <p>Updated Start of Authority (SOA)
        *    properties for a public or private DNS namespace.</p>
        */
    export interface SOAChange {
            /**
                * <p>The updated time to live (TTL) for
                *    purposes of negative caching.</p>
                */
            TTL: number | undefined;
    }
    export namespace SOAChange {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SOAChange) => any;
    }
    /**
        * <p>Updated DNS properties for the private
        *    DNS namespace.</p>
        */
    export interface PrivateDnsPropertiesMutableChange {
            /**
                * <p>Updated fields for the Start of Authority
                *    (SOA) record for the hosted zone for the private DNS namespace.</p>
                */
            SOA: SOAChange | undefined;
    }
    export namespace PrivateDnsPropertiesMutableChange {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PrivateDnsPropertiesMutableChange) => any;
    }
    /**
        * <p>Updated properties for the private DNS
        *    namespace.</p>
        */
    export interface PrivateDnsNamespacePropertiesChange {
            /**
                * <p>Updated DNS properties for the private
                *    DNS namespace.</p>
                */
            DnsProperties: PrivateDnsPropertiesMutableChange | undefined;
    }
    export namespace PrivateDnsNamespacePropertiesChange {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PrivateDnsNamespacePropertiesChange) => any;
    }
    /**
        * <p>Updated properties for the private DNS
        *    namespace.</p>
        */
    export interface PrivateDnsNamespaceChange {
            /**
                * <p>An updated description for the private
                *    DNS namespace.</p>
                */
            Description?: string;
            /**
                * <p>Properties to be updated in the private
                *    DNS namespace.</p>
                */
            Properties?: PrivateDnsNamespacePropertiesChange;
    }
    export namespace PrivateDnsNamespaceChange {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PrivateDnsNamespaceChange) => any;
    }
    /**
        * <p>Updated DNS properties for the public DNS
        *    namespace.</p>
        */
    export interface PublicDnsPropertiesMutableChange {
            /**
                * <p>Updated fields for the Start of Authority
                *    (SOA) record for the hosted zone for the public DNS namespace.</p>
                */
            SOA: SOAChange | undefined;
    }
    export namespace PublicDnsPropertiesMutableChange {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PublicDnsPropertiesMutableChange) => any;
    }
    /**
        * <p>Updated properties for the public DNS
        *    namespace.</p>
        */
    export interface PublicDnsNamespacePropertiesChange {
            /**
                * <p>Updated DNS properties for the hosted
                *    zone for the public DNS namespace.</p>
                */
            DnsProperties: PublicDnsPropertiesMutableChange | undefined;
    }
    export namespace PublicDnsNamespacePropertiesChange {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PublicDnsNamespacePropertiesChange) => any;
    }
    /**
        * <p>Updated properties for the public DNS
        *    namespace.</p>
        */
    export interface PublicDnsNamespaceChange {
            /**
                * <p>An updated description for the public DNS
                *    namespace.</p>
                */
            Description?: string;
            /**
                * <p>Properties to be updated in the public
                *    DNS namespace.</p>
                */
            Properties?: PublicDnsNamespacePropertiesChange;
    }
    export namespace PublicDnsNamespaceChange {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PublicDnsNamespaceChange) => any;
    }
    export interface RegisterInstanceRequest {
            /**
                * <p>The ID of the service that you want to use for settings for the instance.</p>
                */
            ServiceId: string | undefined;
            /**
                * <p>An identifier that you want to associate with the instance. Note the following:</p>
                *          <ul>
                *             <li>
                *                <p>If the service that's specified by <code>ServiceId</code> includes settings for an <code>SRV</code> record,
                *      the value of <code>InstanceId</code> is automatically included as part of the value for the <code>SRV</code>
                *      record. For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_DnsRecord.html#cloudmap-Type-DnsRecord-Type">DnsRecord > Type</a>.</p>
                *             </li>
                *             <li>
                *                <p>You can use this value to update an existing instance.</p>
                *             </li>
                *             <li>
                *                <p>To register a new instance, you must specify a value that's unique among instances that you register by using
                *      the same service. </p>
                *             </li>
                *             <li>
                *                <p>If you specify an existing <code>InstanceId</code> and <code>ServiceId</code>, Cloud Map updates the existing
                *      DNS records, if any. If there's also an existing health check, Cloud Map deletes the old health check and creates
                *      a new one. </p>
                *                <note>
                *                   <p>The health check isn't deleted immediately, so it will still appear for a while if you submit a
                *        <code>ListHealthChecks</code> request, for example.</p>
                *                </note>
                *             </li>
                *          </ul>
                */
            InstanceId: string | undefined;
            /**
                * <p>A unique string that identifies the request and that allows failed <code>RegisterInstance</code> requests to be
                *    retried without the risk of executing the operation twice. You must use a unique <code>CreatorRequestId</code> string
                *    every time you submit a <code>RegisterInstance</code> request if you're registering additional instances for the same
                *    namespace and service. <code>CreatorRequestId</code> can be any unique string (for example, a date/time
                *    stamp).</p>
                */
            CreatorRequestId?: string;
            /**
                * <p>A string map that contains the following information for the service that you specify in
                *    <code>ServiceId</code>:</p>
                *          <ul>
                *             <li>
                *                <p>The attributes that apply to the records that are defined in the service. </p>
                *             </li>
                *             <li>
                *                <p>For each attribute, the applicable value.</p>
                *             </li>
                *          </ul>
                *          <p>Supported attribute keys include the following:</p>
                *          <dl>
                *             <dt>AWS_ALIAS_DNS_NAME</dt>
                *             <dd>
                *                <p>If you want Cloud Map to create an Amazon Route 53 alias record that routes traffic to an Elastic Load Balancing load balancer,
                *       specify the DNS name that's associated with the load balancer. For information about how to get the DNS name, see
                *       "DNSName" in the topic <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_AliasTarget.html">AliasTarget</a> in the <i>Route 53 API Reference</i>.</p>
                *                <p>Note the following:</p>
                *                <ul>
                *                   <li>
                *                      <p>The configuration for the service that's specified by <code>ServiceId</code> must include settings for an
                *          <code>A</code> record, an <code>AAAA</code> record, or both.</p>
                *                   </li>
                *                   <li>
                *                      <p>In the service that's specified by <code>ServiceId</code>, the value of <code>RoutingPolicy</code> must be
                *          <code>WEIGHTED</code>.</p>
                *                   </li>
                *                   <li>
                *                      <p>If the service that's specified by <code>ServiceId</code> includes <code>HealthCheckConfig</code> settings,
                *         Cloud Map will create the Route 53 health check, but it doesn't associate the health check with the alias
                *         record.</p>
                *                   </li>
                *                   <li>
                *                      <p>Auto naming currently doesn't support creating alias records that route traffic to Amazon Web Services
                *         resources other than Elastic Load Balancing load balancers.</p>
                *                   </li>
                *                   <li>
                *                      <p>If you specify a value for <code>AWS_ALIAS_DNS_NAME</code>, don't specify values for any of the
                *          <code>AWS_INSTANCE</code> attributes.</p>
                *                   </li>
                *                </ul>
                *             </dd>
                *             <dt>AWS_EC2_INSTANCE_ID</dt>
                *             <dd>
                *                <p>
                *                   <i>HTTP namespaces only.</i> The Amazon EC2 instance ID for the instance. If the
                *        <code>AWS_EC2_INSTANCE_ID</code> attribute is specified, then the only other attribute that can be specified is
                *        <code>AWS_INIT_HEALTH_STATUS</code>. When the <code>AWS_EC2_INSTANCE_ID</code> attribute is specified, then the
                *        <code>AWS_INSTANCE_IPV4</code> attribute will be filled out with the primary private IPv4 address.</p>
                *             </dd>
                *             <dt>AWS_INIT_HEALTH_STATUS</dt>
                *             <dd>
                *                <p>If the service configuration includes <code>HealthCheckCustomConfig</code>, you can optionally use
                *        <code>AWS_INIT_HEALTH_STATUS</code> to specify the initial status of the custom health check,
                *        <code>HEALTHY</code> or <code>UNHEALTHY</code>. If you don't specify a value for
                *        <code>AWS_INIT_HEALTH_STATUS</code>, the initial status is <code>HEALTHY</code>.</p>
                *             </dd>
                *             <dt>AWS_INSTANCE_CNAME</dt>
                *             <dd>
                *                <p>If the service configuration includes a <code>CNAME</code> record, the domain name that you want Route 53 to
                *       return in response to DNS queries (for example, <code>example.com</code>).</p>
                *                <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
                *        <code>CNAME</code> record.</p>
                *             </dd>
                *             <dt>AWS_INSTANCE_IPV4</dt>
                *             <dd>
                *                <p>If the service configuration includes an <code>A</code> record, the IPv4 address that you want Route 53 to
                *       return in response to DNS queries (for example, <code>192.0.2.44</code>).</p>
                *                <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
                *        <code>A</code> record. If the service includes settings for an <code>SRV</code> record, you must specify a value
                *       for <code>AWS_INSTANCE_IPV4</code>, <code>AWS_INSTANCE_IPV6</code>, or both.</p>
                *             </dd>
                *             <dt>AWS_INSTANCE_IPV6</dt>
                *             <dd>
                *                <p>If the service configuration includes an <code>AAAA</code> record, the IPv6 address that you want Route 53 to
                *       return in response to DNS queries (for example, <code>2001:0db8:85a3:0000:0000:abcd:0001:2345</code>).</p>
                *                <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
                *        <code>AAAA</code> record. If the service includes settings for an <code>SRV</code> record, you must specify a
                *       value for <code>AWS_INSTANCE_IPV4</code>, <code>AWS_INSTANCE_IPV6</code>, or both.</p>
                *             </dd>
                *             <dt>AWS_INSTANCE_PORT</dt>
                *             <dd>
                *                <p>If the service includes an <code>SRV</code> record, the value that you want Route 53 to return for the
                *       port.</p>
                *                <p>If the service includes <code>HealthCheckConfig</code>, the port on the endpoint that you want Route 53 to send
                *       requests to. </p>
                *                <p>This value is required if you specified settings for an <code>SRV</code> record or a Route 53 health check when
                *       you created the service.</p>
                *             </dd>
                *             <dt>Custom attributes</dt>
                *             <dd>
                *                <p>You can add up to 30 custom attributes. For each key-value pair, the maximum length of the attribute name is
                *       255 characters, and the maximum length of the attribute value is 1,024 characters. The total size of all provided
                *       attributes (sum of all keys and values) must not exceed 5,000 characters.</p>
                *             </dd>
                *          </dl>
                */
            Attributes: Record<string, string> | undefined;
    }
    export namespace RegisterInstanceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RegisterInstanceRequest) => any;
    }
    export interface RegisterInstanceResponse {
            /**
                * <p>A value that you can use to determine whether the request completed successfully.
                *                                 To get the status of the operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
                */
            OperationId?: string;
    }
    export namespace RegisterInstanceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RegisterInstanceResponse) => any;
    }
    export interface TagResourceRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.</p>
                */
            ResourceARN: string | undefined;
            /**
                * <p>The tags to add to the specified resource. Specifying the tag key is required. You can set the value of a tag to
                *    an empty string, but you can't set the value of a tag to null.</p>
                */
            Tags: Tag[] | undefined;
    }
    export namespace TagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceRequest) => any;
    }
    export interface TagResourceResponse {
    }
    export namespace TagResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceResponse) => any;
    }
    export interface UntagResourceRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.</p>
                */
            ResourceARN: string | undefined;
            /**
                * <p>The tag keys to remove from the specified resource.</p>
                */
            TagKeys: string[] | undefined;
    }
    export namespace UntagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceRequest) => any;
    }
    export interface UntagResourceResponse {
    }
    export namespace UntagResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceResponse) => any;
    }
    export interface UpdateHttpNamespaceRequest {
            /**
                * <p>The ID of the namespace that you want to
                *    update.</p>
                */
            Id: string | undefined;
            /**
                * <p>A unique string that identifies the
                *    request and that allows failed <code>UpdateHttpNamespace</code> requests to be retried without the risk of running
                *    the operation twice. <code>UpdaterRequestId</code> can be any unique string (for example, a
                *    date/timestamp).</p>
                */
            UpdaterRequestId?: string;
            /**
                * <p>Updated properties for the the HTTP
                *    namespace.</p>
                */
            Namespace: HttpNamespaceChange | undefined;
    }
    export namespace UpdateHttpNamespaceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateHttpNamespaceRequest) => any;
    }
    export interface UpdateHttpNamespaceResponse {
            /**
                * <p>A value that you can use to determine whether the request completed successfully.
                *                                 To get the status of the operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
                */
            OperationId?: string;
    }
    export namespace UpdateHttpNamespaceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateHttpNamespaceResponse) => any;
    }
    export interface UpdateInstanceCustomHealthStatusRequest {
            /**
                * <p>The ID of the service that includes the configuration for the custom health check that you want to change the
                *    status for.</p>
                */
            ServiceId: string | undefined;
            /**
                * <p>The ID of the instance that you want to change the health status for.</p>
                */
            InstanceId: string | undefined;
            /**
                * <p>The new status of the instance, <code>HEALTHY</code> or <code>UNHEALTHY</code>.</p>
                */
            Status: CustomHealthStatus | string | undefined;
    }
    export namespace UpdateInstanceCustomHealthStatusRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateInstanceCustomHealthStatusRequest) => any;
    }
    export interface UpdatePrivateDnsNamespaceRequest {
            /**
                * <p>The ID of the namespace that you want to
                *    update.</p>
                */
            Id: string | undefined;
            /**
                * <p>A unique string that identifies the
                *    request and that allows failed <code>UpdatePrivateDnsNamespace</code> requests to be retried without the risk of
                *    running the operation twice. <code>UpdaterRequestId</code> can be any unique string (for example, a
                *    date/timestamp).</p>
                */
            UpdaterRequestId?: string;
            /**
                * <p>Updated properties for the private DNS
                *    namespace.</p>
                */
            Namespace: PrivateDnsNamespaceChange | undefined;
    }
    export namespace UpdatePrivateDnsNamespaceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdatePrivateDnsNamespaceRequest) => any;
    }
    export interface UpdatePrivateDnsNamespaceResponse {
            /**
                * <p>A value that you can use to determine whether the request completed successfully.
                *                                 To get the status of the operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
                */
            OperationId?: string;
    }
    export namespace UpdatePrivateDnsNamespaceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdatePrivateDnsNamespaceResponse) => any;
    }
    export interface UpdatePublicDnsNamespaceRequest {
            /**
                * <p>The ID of the namespace being
                *    updated.</p>
                */
            Id: string | undefined;
            /**
                * <p>A unique string that identifies the
                *    request and that allows failed <code>UpdatePublicDnsNamespace</code> requests to be retried without the risk of
                *    running the operation twice. <code>UpdaterRequestId</code> can be any unique string (for example, a
                *    date/timestamp).</p>
                */
            UpdaterRequestId?: string;
            /**
                * <p>Updated properties for the public DNS
                *    namespace.</p>
                */
            Namespace: PublicDnsNamespaceChange | undefined;
    }
    export namespace UpdatePublicDnsNamespaceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdatePublicDnsNamespaceRequest) => any;
    }
    export interface UpdatePublicDnsNamespaceResponse {
            /**
                * <p>A value that you can use to determine whether the request completed successfully.
                *                                 To get the status of the operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
                */
            OperationId?: string;
    }
    export namespace UpdatePublicDnsNamespaceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdatePublicDnsNamespaceResponse) => any;
    }
    /**
        * <p>A complex type that contains changes to an existing service.</p>
        */
    export interface ServiceChange {
            /**
                * <p>A description for the service.</p>
                */
            Description?: string;
            /**
                * <p>Information about the Route 53 DNS records that you want Cloud Map to create when you register an instance.</p>
                */
            DnsConfig?: DnsConfigChange;
            /**
                * <p>
                *             <i>Public DNS and HTTP namespaces only.</i> Settings for an optional health check. If you specify
                *    settings for a health check, Cloud Map associates the health check with the records that you specify in
                *     <code>DnsConfig</code>.</p>
                */
            HealthCheckConfig?: HealthCheckConfig;
    }
    export namespace ServiceChange {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ServiceChange) => any;
    }
    export interface UpdateServiceRequest {
            /**
                * <p>The ID of the service that you want to update.</p>
                */
            Id: string | undefined;
            /**
                * <p>A complex type that contains the new settings for the service.</p>
                */
            Service: ServiceChange | undefined;
    }
    export namespace UpdateServiceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateServiceRequest) => any;
    }
    export interface UpdateServiceResponse {
            /**
                * <p>A value that you can use to determine whether the request completed successfully.
                *                                 To get the status of the operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
                */
            OperationId?: string;
    }
    export namespace UpdateServiceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateServiceResponse) => any;
    }
}

declare module '@aws-sdk/client-servicediscovery/node_modules/@aws-sdk/client-servicediscovery/dist-types/models/ServiceDiscoveryServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from ServiceDiscovery service.
        */
    export class ServiceDiscoveryServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

