// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/smithy-client
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http

declare module '@aws-sdk/client-route53resolver' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { AssociateFirewallRuleGroupCommandInput, AssociateFirewallRuleGroupCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/AssociateFirewallRuleGroupCommand";
    import { AssociateResolverEndpointIpAddressCommandInput, AssociateResolverEndpointIpAddressCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/AssociateResolverEndpointIpAddressCommand";
    import { AssociateResolverQueryLogConfigCommandInput, AssociateResolverQueryLogConfigCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/AssociateResolverQueryLogConfigCommand";
    import { AssociateResolverRuleCommandInput, AssociateResolverRuleCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/AssociateResolverRuleCommand";
    import { CreateFirewallDomainListCommandInput, CreateFirewallDomainListCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/CreateFirewallDomainListCommand";
    import { CreateFirewallRuleCommandInput, CreateFirewallRuleCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/CreateFirewallRuleCommand";
    import { CreateFirewallRuleGroupCommandInput, CreateFirewallRuleGroupCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/CreateFirewallRuleGroupCommand";
    import { CreateResolverEndpointCommandInput, CreateResolverEndpointCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/CreateResolverEndpointCommand";
    import { CreateResolverQueryLogConfigCommandInput, CreateResolverQueryLogConfigCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/CreateResolverQueryLogConfigCommand";
    import { CreateResolverRuleCommandInput, CreateResolverRuleCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/CreateResolverRuleCommand";
    import { DeleteFirewallDomainListCommandInput, DeleteFirewallDomainListCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DeleteFirewallDomainListCommand";
    import { DeleteFirewallRuleCommandInput, DeleteFirewallRuleCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DeleteFirewallRuleCommand";
    import { DeleteFirewallRuleGroupCommandInput, DeleteFirewallRuleGroupCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DeleteFirewallRuleGroupCommand";
    import { DeleteResolverEndpointCommandInput, DeleteResolverEndpointCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DeleteResolverEndpointCommand";
    import { DeleteResolverQueryLogConfigCommandInput, DeleteResolverQueryLogConfigCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DeleteResolverQueryLogConfigCommand";
    import { DeleteResolverRuleCommandInput, DeleteResolverRuleCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DeleteResolverRuleCommand";
    import { DisassociateFirewallRuleGroupCommandInput, DisassociateFirewallRuleGroupCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DisassociateFirewallRuleGroupCommand";
    import { DisassociateResolverEndpointIpAddressCommandInput, DisassociateResolverEndpointIpAddressCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DisassociateResolverEndpointIpAddressCommand";
    import { DisassociateResolverQueryLogConfigCommandInput, DisassociateResolverQueryLogConfigCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DisassociateResolverQueryLogConfigCommand";
    import { DisassociateResolverRuleCommandInput, DisassociateResolverRuleCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DisassociateResolverRuleCommand";
    import { GetFirewallConfigCommandInput, GetFirewallConfigCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetFirewallConfigCommand";
    import { GetFirewallDomainListCommandInput, GetFirewallDomainListCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetFirewallDomainListCommand";
    import { GetFirewallRuleGroupAssociationCommandInput, GetFirewallRuleGroupAssociationCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetFirewallRuleGroupAssociationCommand";
    import { GetFirewallRuleGroupCommandInput, GetFirewallRuleGroupCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetFirewallRuleGroupCommand";
    import { GetFirewallRuleGroupPolicyCommandInput, GetFirewallRuleGroupPolicyCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetFirewallRuleGroupPolicyCommand";
    import { GetResolverConfigCommandInput, GetResolverConfigCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverConfigCommand";
    import { GetResolverDnssecConfigCommandInput, GetResolverDnssecConfigCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverDnssecConfigCommand";
    import { GetResolverEndpointCommandInput, GetResolverEndpointCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverEndpointCommand";
    import { GetResolverQueryLogConfigAssociationCommandInput, GetResolverQueryLogConfigAssociationCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverQueryLogConfigAssociationCommand";
    import { GetResolverQueryLogConfigCommandInput, GetResolverQueryLogConfigCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverQueryLogConfigCommand";
    import { GetResolverQueryLogConfigPolicyCommandInput, GetResolverQueryLogConfigPolicyCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverQueryLogConfigPolicyCommand";
    import { GetResolverRuleAssociationCommandInput, GetResolverRuleAssociationCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverRuleAssociationCommand";
    import { GetResolverRuleCommandInput, GetResolverRuleCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverRuleCommand";
    import { GetResolverRulePolicyCommandInput, GetResolverRulePolicyCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverRulePolicyCommand";
    import { ImportFirewallDomainsCommandInput, ImportFirewallDomainsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ImportFirewallDomainsCommand";
    import { ListFirewallConfigsCommandInput, ListFirewallConfigsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListFirewallConfigsCommand";
    import { ListFirewallDomainListsCommandInput, ListFirewallDomainListsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListFirewallDomainListsCommand";
    import { ListFirewallDomainsCommandInput, ListFirewallDomainsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListFirewallDomainsCommand";
    import { ListFirewallRuleGroupAssociationsCommandInput, ListFirewallRuleGroupAssociationsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListFirewallRuleGroupAssociationsCommand";
    import { ListFirewallRuleGroupsCommandInput, ListFirewallRuleGroupsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListFirewallRuleGroupsCommand";
    import { ListFirewallRulesCommandInput, ListFirewallRulesCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListFirewallRulesCommand";
    import { ListResolverConfigsCommandInput, ListResolverConfigsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverConfigsCommand";
    import { ListResolverDnssecConfigsCommandInput, ListResolverDnssecConfigsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverDnssecConfigsCommand";
    import { ListResolverEndpointIpAddressesCommandInput, ListResolverEndpointIpAddressesCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverEndpointIpAddressesCommand";
    import { ListResolverEndpointsCommandInput, ListResolverEndpointsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverEndpointsCommand";
    import { ListResolverQueryLogConfigAssociationsCommandInput, ListResolverQueryLogConfigAssociationsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverQueryLogConfigAssociationsCommand";
    import { ListResolverQueryLogConfigsCommandInput, ListResolverQueryLogConfigsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverQueryLogConfigsCommand";
    import { ListResolverRuleAssociationsCommandInput, ListResolverRuleAssociationsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverRuleAssociationsCommand";
    import { ListResolverRulesCommandInput, ListResolverRulesCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverRulesCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListTagsForResourceCommand";
    import { PutFirewallRuleGroupPolicyCommandInput, PutFirewallRuleGroupPolicyCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/PutFirewallRuleGroupPolicyCommand";
    import { PutResolverQueryLogConfigPolicyCommandInput, PutResolverQueryLogConfigPolicyCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/PutResolverQueryLogConfigPolicyCommand";
    import { PutResolverRulePolicyCommandInput, PutResolverRulePolicyCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/PutResolverRulePolicyCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UntagResourceCommand";
    import { UpdateFirewallConfigCommandInput, UpdateFirewallConfigCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateFirewallConfigCommand";
    import { UpdateFirewallDomainsCommandInput, UpdateFirewallDomainsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateFirewallDomainsCommand";
    import { UpdateFirewallRuleCommandInput, UpdateFirewallRuleCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateFirewallRuleCommand";
    import { UpdateFirewallRuleGroupAssociationCommandInput, UpdateFirewallRuleGroupAssociationCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateFirewallRuleGroupAssociationCommand";
    import { UpdateResolverConfigCommandInput, UpdateResolverConfigCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateResolverConfigCommand";
    import { UpdateResolverDnssecConfigCommandInput, UpdateResolverDnssecConfigCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateResolverDnssecConfigCommand";
    import { UpdateResolverEndpointCommandInput, UpdateResolverEndpointCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateResolverEndpointCommand";
    import { UpdateResolverRuleCommandInput, UpdateResolverRuleCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateResolverRuleCommand";
    import { Route53ResolverClient } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    /**
        * <p>When you create a VPC using Amazon VPC, you automatically get DNS resolution within the VPC
        * 			from Route 53 Resolver. By default, Resolver answers DNS queries for VPC domain names
        * 			such as domain names for EC2 instances or Elastic Load Balancing load balancers.
        * 			Resolver performs recursive lookups against public name servers for all other domain
        * 			names.</p>
        *
        * 		       <p>You can also configure DNS resolution between your VPC and your network over a Direct Connect or VPN connection:</p>
        *
        * 		       <p>
        *             <b>Forward DNS queries from resolvers on your network to Route 53 Resolver</b>
        *          </p>
        *
        * 		       <p>DNS resolvers on your network can forward DNS queries to Resolver in a specified VPC. This allows your DNS resolvers
        * 			to easily resolve domain names for Amazon Web Services resources such as EC2 instances or records in a Route 53 private hosted zone.
        * 			For more information, see
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resolver.html#resolver-overview-forward-network-to-vpc">How DNS Resolvers
        * 			on Your Network Forward DNS Queries to Route 53 Resolver</a> in the <i>Amazon Route 53 Developer Guide</i>.</p>
        *
        * 		       <p>
        *             <b>Conditionally forward queries from a VPC to resolvers on your network</b>
        *          </p>
        *
        * 		       <p>You can configure Resolver to forward queries that it receives from EC2 instances in your VPCs to DNS resolvers on your network.
        * 			To forward selected queries, you create Resolver rules that specify the domain names for the DNS queries that you want to forward
        * 			(such as example.com), and the IP addresses of the DNS resolvers on your network that you want to forward the queries to.
        * 			If a query matches multiple rules (example.com, acme.example.com), Resolver chooses the rule with the most specific match
        * 			(acme.example.com) and forwards the query to the IP addresses that you specified in that rule. For more information, see
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resolver.html#resolver-overview-forward-vpc-to-network">How Route 53 Resolver
        * 			Forwards DNS Queries from Your VPCs to Your Network</a> in the <i>Amazon Route 53 Developer Guide</i>.</p>
        *
        * 		       <p>Like Amazon VPC, Resolver is Regional. In each Region where you have VPCs, you can choose
        * 			whether to forward queries from your VPCs to your network (outbound queries), from your
        * 			network to your VPCs (inbound queries), or both.</p>
        */
    export class Route53Resolver extends Route53ResolverClient {
            /**
                * <p>Associates a <a>FirewallRuleGroup</a> with a VPC, to provide DNS filtering for the VPC. </p>
                */
            associateFirewallRuleGroup(args: AssociateFirewallRuleGroupCommandInput, options?: __HttpHandlerOptions): Promise<AssociateFirewallRuleGroupCommandOutput>;
            associateFirewallRuleGroup(args: AssociateFirewallRuleGroupCommandInput, cb: (err: any, data?: AssociateFirewallRuleGroupCommandOutput) => void): void;
            associateFirewallRuleGroup(args: AssociateFirewallRuleGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AssociateFirewallRuleGroupCommandOutput) => void): void;
            /**
                * <p>Adds IP addresses to an inbound or an outbound Resolver endpoint. If you want to add more than one IP address,
                * 			submit one <code>AssociateResolverEndpointIpAddress</code> request for each IP address.</p>
                * 		       <p>To remove an IP address from an endpoint, see
                * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverEndpointIpAddress.html">DisassociateResolverEndpointIpAddress</a>.
                * 		</p>
                */
            associateResolverEndpointIpAddress(args: AssociateResolverEndpointIpAddressCommandInput, options?: __HttpHandlerOptions): Promise<AssociateResolverEndpointIpAddressCommandOutput>;
            associateResolverEndpointIpAddress(args: AssociateResolverEndpointIpAddressCommandInput, cb: (err: any, data?: AssociateResolverEndpointIpAddressCommandOutput) => void): void;
            associateResolverEndpointIpAddress(args: AssociateResolverEndpointIpAddressCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AssociateResolverEndpointIpAddressCommandOutput) => void): void;
            /**
                * <p>Associates an Amazon VPC with a specified query logging configuration. Route 53 Resolver logs DNS queries that originate in all of the Amazon VPCs
                * 			that are associated with a specified query logging configuration. To associate more than one VPC with a configuration, submit one <code>AssociateResolverQueryLogConfig</code>
                * 			request for each VPC.</p>
                *
                * 		       <note>
                *             <p>The VPCs that you associate with a query logging configuration must be in the same Region as the configuration.</p>
                *          </note>
                *
                * 		       <p>To remove a VPC from a query logging configuration, see
                * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverQueryLogConfig.html">DisassociateResolverQueryLogConfig</a>.
                * 			</p>
                */
            associateResolverQueryLogConfig(args: AssociateResolverQueryLogConfigCommandInput, options?: __HttpHandlerOptions): Promise<AssociateResolverQueryLogConfigCommandOutput>;
            associateResolverQueryLogConfig(args: AssociateResolverQueryLogConfigCommandInput, cb: (err: any, data?: AssociateResolverQueryLogConfigCommandOutput) => void): void;
            associateResolverQueryLogConfig(args: AssociateResolverQueryLogConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AssociateResolverQueryLogConfigCommandOutput) => void): void;
            /**
                * <p>Associates a Resolver rule with a VPC. When you associate a rule with a VPC, Resolver forwards all DNS queries
                * 			for the domain name that is specified in the rule and that originate in the VPC. The queries are forwarded to the
                * 			IP addresses for the DNS resolvers that are specified in the rule. For more information about rules, see
                * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverRule.html">CreateResolverRule</a>. </p>
                */
            associateResolverRule(args: AssociateResolverRuleCommandInput, options?: __HttpHandlerOptions): Promise<AssociateResolverRuleCommandOutput>;
            associateResolverRule(args: AssociateResolverRuleCommandInput, cb: (err: any, data?: AssociateResolverRuleCommandOutput) => void): void;
            associateResolverRule(args: AssociateResolverRuleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AssociateResolverRuleCommandOutput) => void): void;
            /**
                * <p>Creates an empty firewall domain list for use in DNS Firewall rules. You can populate the domains for the new list with a file, using <a>ImportFirewallDomains</a>, or with domain strings, using <a>UpdateFirewallDomains</a>. </p>
                */
            createFirewallDomainList(args: CreateFirewallDomainListCommandInput, options?: __HttpHandlerOptions): Promise<CreateFirewallDomainListCommandOutput>;
            createFirewallDomainList(args: CreateFirewallDomainListCommandInput, cb: (err: any, data?: CreateFirewallDomainListCommandOutput) => void): void;
            createFirewallDomainList(args: CreateFirewallDomainListCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateFirewallDomainListCommandOutput) => void): void;
            /**
                * <p>Creates a single DNS Firewall rule in the specified rule group, using the specified domain list.</p>
                */
            createFirewallRule(args: CreateFirewallRuleCommandInput, options?: __HttpHandlerOptions): Promise<CreateFirewallRuleCommandOutput>;
            createFirewallRule(args: CreateFirewallRuleCommandInput, cb: (err: any, data?: CreateFirewallRuleCommandOutput) => void): void;
            createFirewallRule(args: CreateFirewallRuleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateFirewallRuleCommandOutput) => void): void;
            /**
                * <p>Creates an empty DNS Firewall rule group for filtering DNS network traffic in a VPC. You can add rules to the new rule group
                *            by calling <a>CreateFirewallRule</a>. </p>
                */
            createFirewallRuleGroup(args: CreateFirewallRuleGroupCommandInput, options?: __HttpHandlerOptions): Promise<CreateFirewallRuleGroupCommandOutput>;
            createFirewallRuleGroup(args: CreateFirewallRuleGroupCommandInput, cb: (err: any, data?: CreateFirewallRuleGroupCommandOutput) => void): void;
            createFirewallRuleGroup(args: CreateFirewallRuleGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateFirewallRuleGroupCommandOutput) => void): void;
            /**
                * <p>Creates a Resolver endpoint. There are two types of Resolver endpoints, inbound and outbound:</p>
                * 		       <ul>
                *             <li>
                *                <p>An <i>inbound Resolver endpoint</i> forwards DNS queries to the DNS service for a VPC
                * 				from your network.</p>
                *             </li>
                *             <li>
                *                <p>An <i>outbound Resolver endpoint</i> forwards DNS queries from the DNS service for a VPC
                * 				to your network.</p>
                *             </li>
                *          </ul>
                */
            createResolverEndpoint(args: CreateResolverEndpointCommandInput, options?: __HttpHandlerOptions): Promise<CreateResolverEndpointCommandOutput>;
            createResolverEndpoint(args: CreateResolverEndpointCommandInput, cb: (err: any, data?: CreateResolverEndpointCommandOutput) => void): void;
            createResolverEndpoint(args: CreateResolverEndpointCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateResolverEndpointCommandOutput) => void): void;
            /**
                * <p>Creates a Resolver query logging configuration, which defines where you want Resolver to save DNS query logs that originate in your VPCs.
                * 			Resolver can log queries only for VPCs that are in the same Region as the query logging configuration.</p>
                *
                * 		       <p>To specify which VPCs you want to log queries for, you use <code>AssociateResolverQueryLogConfig</code>. For more information, see
                * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverQueryLogConfig.html">AssociateResolverQueryLogConfig</a>. </p>
                *
                * 		       <p>You can optionally use Resource Access Manager (RAM) to share a query logging configuration with other Amazon Web Services accounts. The other accounts
                * 			can then associate VPCs with the configuration. The query logs that Resolver creates for a configuration include all DNS queries that originate in all
                * 			VPCs that are associated with the configuration.</p>
                */
            createResolverQueryLogConfig(args: CreateResolverQueryLogConfigCommandInput, options?: __HttpHandlerOptions): Promise<CreateResolverQueryLogConfigCommandOutput>;
            createResolverQueryLogConfig(args: CreateResolverQueryLogConfigCommandInput, cb: (err: any, data?: CreateResolverQueryLogConfigCommandOutput) => void): void;
            createResolverQueryLogConfig(args: CreateResolverQueryLogConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateResolverQueryLogConfigCommandOutput) => void): void;
            /**
                * <p>For DNS queries that originate in your VPCs, specifies which Resolver endpoint the queries pass through,
                * 			one domain name that you want to forward to your network, and the IP addresses of the DNS resolvers in your network.</p>
                */
            createResolverRule(args: CreateResolverRuleCommandInput, options?: __HttpHandlerOptions): Promise<CreateResolverRuleCommandOutput>;
            createResolverRule(args: CreateResolverRuleCommandInput, cb: (err: any, data?: CreateResolverRuleCommandOutput) => void): void;
            createResolverRule(args: CreateResolverRuleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateResolverRuleCommandOutput) => void): void;
            /**
                * <p>Deletes the specified domain list. </p>
                */
            deleteFirewallDomainList(args: DeleteFirewallDomainListCommandInput, options?: __HttpHandlerOptions): Promise<DeleteFirewallDomainListCommandOutput>;
            deleteFirewallDomainList(args: DeleteFirewallDomainListCommandInput, cb: (err: any, data?: DeleteFirewallDomainListCommandOutput) => void): void;
            deleteFirewallDomainList(args: DeleteFirewallDomainListCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteFirewallDomainListCommandOutput) => void): void;
            /**
                * <p>Deletes the specified firewall rule.</p>
                */
            deleteFirewallRule(args: DeleteFirewallRuleCommandInput, options?: __HttpHandlerOptions): Promise<DeleteFirewallRuleCommandOutput>;
            deleteFirewallRule(args: DeleteFirewallRuleCommandInput, cb: (err: any, data?: DeleteFirewallRuleCommandOutput) => void): void;
            deleteFirewallRule(args: DeleteFirewallRuleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteFirewallRuleCommandOutput) => void): void;
            /**
                * <p>Deletes the specified firewall rule group. </p>
                */
            deleteFirewallRuleGroup(args: DeleteFirewallRuleGroupCommandInput, options?: __HttpHandlerOptions): Promise<DeleteFirewallRuleGroupCommandOutput>;
            deleteFirewallRuleGroup(args: DeleteFirewallRuleGroupCommandInput, cb: (err: any, data?: DeleteFirewallRuleGroupCommandOutput) => void): void;
            deleteFirewallRuleGroup(args: DeleteFirewallRuleGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteFirewallRuleGroupCommandOutput) => void): void;
            /**
                * <p>Deletes a Resolver endpoint. The effect of deleting a Resolver endpoint depends on whether it's an inbound or an outbound
                * 			Resolver endpoint:</p>
                * 		       <ul>
                *             <li>
                *                <p>
                *                   <b>Inbound</b>: DNS queries from your network are no longer routed
                * 				to the DNS service for the specified VPC.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>Outbound</b>: DNS queries from a VPC are no longer routed to your network.</p>
                *             </li>
                *          </ul>
                */
            deleteResolverEndpoint(args: DeleteResolverEndpointCommandInput, options?: __HttpHandlerOptions): Promise<DeleteResolverEndpointCommandOutput>;
            deleteResolverEndpoint(args: DeleteResolverEndpointCommandInput, cb: (err: any, data?: DeleteResolverEndpointCommandOutput) => void): void;
            deleteResolverEndpoint(args: DeleteResolverEndpointCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteResolverEndpointCommandOutput) => void): void;
            /**
                * <p>Deletes a query logging configuration. When you delete a configuration, Resolver stops logging DNS queries for all of the Amazon VPCs that are
                * 			associated with the configuration. This also applies if the query logging configuration is shared with other Amazon Web Services accounts, and
                * 			the other accounts have associated VPCs with the shared configuration.</p>
                *
                * 		       <p>Before you can delete a query logging configuration, you must first disassociate all VPCs from the configuration. See
                * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverQueryLogConfig.html">DisassociateResolverQueryLogConfig</a>.</p>
                *
                * 		       <p>If you used Resource Access Manager (RAM) to share a query logging configuration with other accounts, you must stop sharing
                * 			the configuration before you can delete a configuration. The accounts that you shared the configuration with can first disassociate VPCs
                * 			that they associated with the configuration, but that's not necessary. If you stop sharing the configuration, those VPCs are automatically
                * 			disassociated from the configuration.</p>
                */
            deleteResolverQueryLogConfig(args: DeleteResolverQueryLogConfigCommandInput, options?: __HttpHandlerOptions): Promise<DeleteResolverQueryLogConfigCommandOutput>;
            deleteResolverQueryLogConfig(args: DeleteResolverQueryLogConfigCommandInput, cb: (err: any, data?: DeleteResolverQueryLogConfigCommandOutput) => void): void;
            deleteResolverQueryLogConfig(args: DeleteResolverQueryLogConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteResolverQueryLogConfigCommandOutput) => void): void;
            /**
                * <p>Deletes a Resolver rule. Before you can delete a Resolver rule, you must disassociate it from all the VPCs that you
                * 			associated the Resolver rule with. For more information, see
                * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverRule.html">DisassociateResolverRule</a>.</p>
                */
            deleteResolverRule(args: DeleteResolverRuleCommandInput, options?: __HttpHandlerOptions): Promise<DeleteResolverRuleCommandOutput>;
            deleteResolverRule(args: DeleteResolverRuleCommandInput, cb: (err: any, data?: DeleteResolverRuleCommandOutput) => void): void;
            deleteResolverRule(args: DeleteResolverRuleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteResolverRuleCommandOutput) => void): void;
            /**
                * <p>Disassociates a <a>FirewallRuleGroup</a> from a VPC, to remove DNS filtering from the VPC. </p>
                */
            disassociateFirewallRuleGroup(args: DisassociateFirewallRuleGroupCommandInput, options?: __HttpHandlerOptions): Promise<DisassociateFirewallRuleGroupCommandOutput>;
            disassociateFirewallRuleGroup(args: DisassociateFirewallRuleGroupCommandInput, cb: (err: any, data?: DisassociateFirewallRuleGroupCommandOutput) => void): void;
            disassociateFirewallRuleGroup(args: DisassociateFirewallRuleGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DisassociateFirewallRuleGroupCommandOutput) => void): void;
            /**
                * <p>Removes IP addresses from an inbound or an outbound Resolver endpoint. If you want to remove more than one IP address,
                * 			submit one <code>DisassociateResolverEndpointIpAddress</code> request for each IP address.</p>
                * 		       <p>To add an IP address to an endpoint, see
                * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverEndpointIpAddress.html">AssociateResolverEndpointIpAddress</a>.
                * 		</p>
                */
            disassociateResolverEndpointIpAddress(args: DisassociateResolverEndpointIpAddressCommandInput, options?: __HttpHandlerOptions): Promise<DisassociateResolverEndpointIpAddressCommandOutput>;
            disassociateResolverEndpointIpAddress(args: DisassociateResolverEndpointIpAddressCommandInput, cb: (err: any, data?: DisassociateResolverEndpointIpAddressCommandOutput) => void): void;
            disassociateResolverEndpointIpAddress(args: DisassociateResolverEndpointIpAddressCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DisassociateResolverEndpointIpAddressCommandOutput) => void): void;
            /**
                * <p>Disassociates a VPC from a query logging configuration.</p>
                *
                * 		       <note>
                * 			         <p>Before you can delete a query logging configuration, you must first disassociate all VPCs
                * 				from the configuration. If you used Resource Access Manager (RAM) to share a
                * 				query logging configuration with other accounts, VPCs can be disassociated from the
                * 				configuration in the following ways:</p>
                * 			         <ul>
                *                <li>
                *                   <p>The accounts that you shared the configuration with can disassociate VPCs from the configuration.</p>
                *                </li>
                *                <li>
                *                   <p>You can stop sharing the configuration.</p>
                *                </li>
                *             </ul>
                * 		       </note>
                */
            disassociateResolverQueryLogConfig(args: DisassociateResolverQueryLogConfigCommandInput, options?: __HttpHandlerOptions): Promise<DisassociateResolverQueryLogConfigCommandOutput>;
            disassociateResolverQueryLogConfig(args: DisassociateResolverQueryLogConfigCommandInput, cb: (err: any, data?: DisassociateResolverQueryLogConfigCommandOutput) => void): void;
            disassociateResolverQueryLogConfig(args: DisassociateResolverQueryLogConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DisassociateResolverQueryLogConfigCommandOutput) => void): void;
            /**
                * <p>Removes the association between a specified Resolver rule and a specified VPC.</p>
                * 		       <important>
                * 			         <p>If you disassociate a Resolver rule from a VPC, Resolver stops forwarding DNS queries for the
                * 				domain name that you specified in the Resolver rule. </p>
                * 		       </important>
                */
            disassociateResolverRule(args: DisassociateResolverRuleCommandInput, options?: __HttpHandlerOptions): Promise<DisassociateResolverRuleCommandOutput>;
            disassociateResolverRule(args: DisassociateResolverRuleCommandInput, cb: (err: any, data?: DisassociateResolverRuleCommandOutput) => void): void;
            disassociateResolverRule(args: DisassociateResolverRuleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DisassociateResolverRuleCommandOutput) => void): void;
            /**
                * <p>Retrieves the configuration of the firewall behavior provided by DNS Firewall for a
                * 			single VPC from Amazon Virtual Private Cloud (Amazon VPC). </p>
                */
            getFirewallConfig(args: GetFirewallConfigCommandInput, options?: __HttpHandlerOptions): Promise<GetFirewallConfigCommandOutput>;
            getFirewallConfig(args: GetFirewallConfigCommandInput, cb: (err: any, data?: GetFirewallConfigCommandOutput) => void): void;
            getFirewallConfig(args: GetFirewallConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetFirewallConfigCommandOutput) => void): void;
            /**
                * <p>Retrieves the specified firewall domain list.</p>
                */
            getFirewallDomainList(args: GetFirewallDomainListCommandInput, options?: __HttpHandlerOptions): Promise<GetFirewallDomainListCommandOutput>;
            getFirewallDomainList(args: GetFirewallDomainListCommandInput, cb: (err: any, data?: GetFirewallDomainListCommandOutput) => void): void;
            getFirewallDomainList(args: GetFirewallDomainListCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetFirewallDomainListCommandOutput) => void): void;
            /**
                * <p>Retrieves the specified firewall rule group. </p>
                */
            getFirewallRuleGroup(args: GetFirewallRuleGroupCommandInput, options?: __HttpHandlerOptions): Promise<GetFirewallRuleGroupCommandOutput>;
            getFirewallRuleGroup(args: GetFirewallRuleGroupCommandInput, cb: (err: any, data?: GetFirewallRuleGroupCommandOutput) => void): void;
            getFirewallRuleGroup(args: GetFirewallRuleGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetFirewallRuleGroupCommandOutput) => void): void;
            /**
                * <p>Retrieves a firewall rule group association, which enables DNS filtering for a VPC with one rule group. A VPC can have more than one firewall rule group association, and a rule group can be associated with more than one VPC.</p>
                */
            getFirewallRuleGroupAssociation(args: GetFirewallRuleGroupAssociationCommandInput, options?: __HttpHandlerOptions): Promise<GetFirewallRuleGroupAssociationCommandOutput>;
            getFirewallRuleGroupAssociation(args: GetFirewallRuleGroupAssociationCommandInput, cb: (err: any, data?: GetFirewallRuleGroupAssociationCommandOutput) => void): void;
            getFirewallRuleGroupAssociation(args: GetFirewallRuleGroupAssociationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetFirewallRuleGroupAssociationCommandOutput) => void): void;
            /**
                * <p>Returns the Identity and Access Management (Amazon Web Services IAM) policy for sharing the
                *        	specified rule group. You can use the policy to share the rule group using Resource Access Manager (RAM). </p>
                */
            getFirewallRuleGroupPolicy(args: GetFirewallRuleGroupPolicyCommandInput, options?: __HttpHandlerOptions): Promise<GetFirewallRuleGroupPolicyCommandOutput>;
            getFirewallRuleGroupPolicy(args: GetFirewallRuleGroupPolicyCommandInput, cb: (err: any, data?: GetFirewallRuleGroupPolicyCommandOutput) => void): void;
            getFirewallRuleGroupPolicy(args: GetFirewallRuleGroupPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetFirewallRuleGroupPolicyCommandOutput) => void): void;
            /**
                * <p>Retrieves the behavior configuration of Route 53 Resolver behavior for a single VPC from
                * 				Amazon Virtual Private Cloud.</p>
                */
            getResolverConfig(args: GetResolverConfigCommandInput, options?: __HttpHandlerOptions): Promise<GetResolverConfigCommandOutput>;
            getResolverConfig(args: GetResolverConfigCommandInput, cb: (err: any, data?: GetResolverConfigCommandOutput) => void): void;
            getResolverConfig(args: GetResolverConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetResolverConfigCommandOutput) => void): void;
            /**
                * <p>Gets DNSSEC validation information for a specified resource.</p>
                */
            getResolverDnssecConfig(args: GetResolverDnssecConfigCommandInput, options?: __HttpHandlerOptions): Promise<GetResolverDnssecConfigCommandOutput>;
            getResolverDnssecConfig(args: GetResolverDnssecConfigCommandInput, cb: (err: any, data?: GetResolverDnssecConfigCommandOutput) => void): void;
            getResolverDnssecConfig(args: GetResolverDnssecConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetResolverDnssecConfigCommandOutput) => void): void;
            /**
                * <p>Gets information about a specified Resolver endpoint, such as whether it's an inbound or an outbound Resolver endpoint, and the
                * 			current status of the endpoint.</p>
                */
            getResolverEndpoint(args: GetResolverEndpointCommandInput, options?: __HttpHandlerOptions): Promise<GetResolverEndpointCommandOutput>;
            getResolverEndpoint(args: GetResolverEndpointCommandInput, cb: (err: any, data?: GetResolverEndpointCommandOutput) => void): void;
            getResolverEndpoint(args: GetResolverEndpointCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetResolverEndpointCommandOutput) => void): void;
            /**
                * <p>Gets information about a specified Resolver query logging configuration, such as the number of VPCs that the configuration
                * 			is logging queries for and the location that logs are sent to. </p>
                */
            getResolverQueryLogConfig(args: GetResolverQueryLogConfigCommandInput, options?: __HttpHandlerOptions): Promise<GetResolverQueryLogConfigCommandOutput>;
            getResolverQueryLogConfig(args: GetResolverQueryLogConfigCommandInput, cb: (err: any, data?: GetResolverQueryLogConfigCommandOutput) => void): void;
            getResolverQueryLogConfig(args: GetResolverQueryLogConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetResolverQueryLogConfigCommandOutput) => void): void;
            /**
                * <p>Gets information about a specified association between a Resolver query logging configuration and an Amazon VPC. When you associate a VPC
                * 			with a query logging configuration, Resolver logs DNS queries that originate in that VPC.</p>
                */
            getResolverQueryLogConfigAssociation(args: GetResolverQueryLogConfigAssociationCommandInput, options?: __HttpHandlerOptions): Promise<GetResolverQueryLogConfigAssociationCommandOutput>;
            getResolverQueryLogConfigAssociation(args: GetResolverQueryLogConfigAssociationCommandInput, cb: (err: any, data?: GetResolverQueryLogConfigAssociationCommandOutput) => void): void;
            getResolverQueryLogConfigAssociation(args: GetResolverQueryLogConfigAssociationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetResolverQueryLogConfigAssociationCommandOutput) => void): void;
            /**
                * <p>Gets information about a query logging policy. A query logging policy specifies the Resolver query logging
                * 			operations and resources that you want to allow another Amazon Web Services account to be able to use.</p>
                */
            getResolverQueryLogConfigPolicy(args: GetResolverQueryLogConfigPolicyCommandInput, options?: __HttpHandlerOptions): Promise<GetResolverQueryLogConfigPolicyCommandOutput>;
            getResolverQueryLogConfigPolicy(args: GetResolverQueryLogConfigPolicyCommandInput, cb: (err: any, data?: GetResolverQueryLogConfigPolicyCommandOutput) => void): void;
            getResolverQueryLogConfigPolicy(args: GetResolverQueryLogConfigPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetResolverQueryLogConfigPolicyCommandOutput) => void): void;
            /**
                * <p>Gets information about a specified Resolver rule, such as the domain name that the rule forwards DNS queries for and the ID of the
                * 			outbound Resolver endpoint that the rule is associated with.</p>
                */
            getResolverRule(args: GetResolverRuleCommandInput, options?: __HttpHandlerOptions): Promise<GetResolverRuleCommandOutput>;
            getResolverRule(args: GetResolverRuleCommandInput, cb: (err: any, data?: GetResolverRuleCommandOutput) => void): void;
            getResolverRule(args: GetResolverRuleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetResolverRuleCommandOutput) => void): void;
            /**
                * <p>Gets information about an association between a specified Resolver rule and a VPC. You associate a Resolver rule and a VPC using
                * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverRule.html">AssociateResolverRule</a>. </p>
                */
            getResolverRuleAssociation(args: GetResolverRuleAssociationCommandInput, options?: __HttpHandlerOptions): Promise<GetResolverRuleAssociationCommandOutput>;
            getResolverRuleAssociation(args: GetResolverRuleAssociationCommandInput, cb: (err: any, data?: GetResolverRuleAssociationCommandOutput) => void): void;
            getResolverRuleAssociation(args: GetResolverRuleAssociationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetResolverRuleAssociationCommandOutput) => void): void;
            /**
                * <p>Gets information about the Resolver rule policy for a specified rule. A Resolver rule policy includes the rule that you want to share
                * 			with another account, the account that you want to share the rule with, and the Resolver operations that you want to allow the account to use. </p>
                */
            getResolverRulePolicy(args: GetResolverRulePolicyCommandInput, options?: __HttpHandlerOptions): Promise<GetResolverRulePolicyCommandOutput>;
            getResolverRulePolicy(args: GetResolverRulePolicyCommandInput, cb: (err: any, data?: GetResolverRulePolicyCommandOutput) => void): void;
            getResolverRulePolicy(args: GetResolverRulePolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetResolverRulePolicyCommandOutput) => void): void;
            /**
                * <p>Imports domain names from a file into a domain list, for use in a DNS firewall rule group. </p>
                *          <p>Each domain specification in your domain list must satisfy the following
                * 	requirements: </p>
                *          <ul>
                *             <li>
                *       	        <p>It can optionally start with <code>*</code> (asterisk).</p>
                *       	     </li>
                *             <li>
                *       	        <p>With the exception of the optional starting asterisk, it must only contain
                *       	   the following characters: <code>A-Z</code>, <code>a-z</code>,
                *       	   <code>0-9</code>, <code>-</code> (hyphen).</p>
                *       	     </li>
                *             <li>
                *       	        <p>It must be from 1-255 characters in length. </p>
                *       	     </li>
                *          </ul>
                */
            importFirewallDomains(args: ImportFirewallDomainsCommandInput, options?: __HttpHandlerOptions): Promise<ImportFirewallDomainsCommandOutput>;
            importFirewallDomains(args: ImportFirewallDomainsCommandInput, cb: (err: any, data?: ImportFirewallDomainsCommandOutput) => void): void;
            importFirewallDomains(args: ImportFirewallDomainsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ImportFirewallDomainsCommandOutput) => void): void;
            /**
                * <p>Retrieves the firewall configurations that you have defined. DNS Firewall uses the configurations to manage firewall behavior for your VPCs. </p>
                *          <p>A single call might return only a partial list of the configurations. For information, see <code>MaxResults</code>. </p>
                */
            listFirewallConfigs(args: ListFirewallConfigsCommandInput, options?: __HttpHandlerOptions): Promise<ListFirewallConfigsCommandOutput>;
            listFirewallConfigs(args: ListFirewallConfigsCommandInput, cb: (err: any, data?: ListFirewallConfigsCommandOutput) => void): void;
            listFirewallConfigs(args: ListFirewallConfigsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListFirewallConfigsCommandOutput) => void): void;
            /**
                * <p>Retrieves the firewall domain lists that you have defined. For each firewall domain list, you can retrieve the domains that are defined for a list by calling <a>ListFirewallDomains</a>. </p>
                *          <p>A single call to this list operation might return only a partial list of the domain lists. For information, see <code>MaxResults</code>. </p>
                */
            listFirewallDomainLists(args: ListFirewallDomainListsCommandInput, options?: __HttpHandlerOptions): Promise<ListFirewallDomainListsCommandOutput>;
            listFirewallDomainLists(args: ListFirewallDomainListsCommandInput, cb: (err: any, data?: ListFirewallDomainListsCommandOutput) => void): void;
            listFirewallDomainLists(args: ListFirewallDomainListsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListFirewallDomainListsCommandOutput) => void): void;
            /**
                * <p>Retrieves the domains that you have defined for the specified firewall domain list.  </p>
                *          <p>A single call might return only a partial list of the domains. For information, see <code>MaxResults</code>. </p>
                */
            listFirewallDomains(args: ListFirewallDomainsCommandInput, options?: __HttpHandlerOptions): Promise<ListFirewallDomainsCommandOutput>;
            listFirewallDomains(args: ListFirewallDomainsCommandInput, cb: (err: any, data?: ListFirewallDomainsCommandOutput) => void): void;
            listFirewallDomains(args: ListFirewallDomainsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListFirewallDomainsCommandOutput) => void): void;
            /**
                * <p>Retrieves the firewall rule group associations that you have defined. Each association enables DNS filtering for a VPC with one rule group. </p>
                *          <p>A single call might return only a partial list of the associations. For information, see <code>MaxResults</code>. </p>
                */
            listFirewallRuleGroupAssociations(args: ListFirewallRuleGroupAssociationsCommandInput, options?: __HttpHandlerOptions): Promise<ListFirewallRuleGroupAssociationsCommandOutput>;
            listFirewallRuleGroupAssociations(args: ListFirewallRuleGroupAssociationsCommandInput, cb: (err: any, data?: ListFirewallRuleGroupAssociationsCommandOutput) => void): void;
            listFirewallRuleGroupAssociations(args: ListFirewallRuleGroupAssociationsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListFirewallRuleGroupAssociationsCommandOutput) => void): void;
            /**
                * <p>Retrieves the minimal high-level information for the rule groups that you have defined.  </p>
                *          <p>A single call might return only a partial list of the rule groups. For information, see <code>MaxResults</code>. </p>
                */
            listFirewallRuleGroups(args: ListFirewallRuleGroupsCommandInput, options?: __HttpHandlerOptions): Promise<ListFirewallRuleGroupsCommandOutput>;
            listFirewallRuleGroups(args: ListFirewallRuleGroupsCommandInput, cb: (err: any, data?: ListFirewallRuleGroupsCommandOutput) => void): void;
            listFirewallRuleGroups(args: ListFirewallRuleGroupsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListFirewallRuleGroupsCommandOutput) => void): void;
            /**
                * <p>Retrieves the firewall rules that you have defined for the specified firewall rule group. DNS Firewall uses the rules in a rule group to filter DNS network traffic for a VPC. </p>
                *          <p>A single call might return only a partial list of the rules. For information, see <code>MaxResults</code>. </p>
                */
            listFirewallRules(args: ListFirewallRulesCommandInput, options?: __HttpHandlerOptions): Promise<ListFirewallRulesCommandOutput>;
            listFirewallRules(args: ListFirewallRulesCommandInput, cb: (err: any, data?: ListFirewallRulesCommandOutput) => void): void;
            listFirewallRules(args: ListFirewallRulesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListFirewallRulesCommandOutput) => void): void;
            /**
                * <p>Retrieves the Resolver configurations that you have defined.
                * 			Route 53 Resolver uses the configurations to manage DNS resolution behavior for your VPCs.</p>
                */
            listResolverConfigs(args: ListResolverConfigsCommandInput, options?: __HttpHandlerOptions): Promise<ListResolverConfigsCommandOutput>;
            listResolverConfigs(args: ListResolverConfigsCommandInput, cb: (err: any, data?: ListResolverConfigsCommandOutput) => void): void;
            listResolverConfigs(args: ListResolverConfigsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListResolverConfigsCommandOutput) => void): void;
            /**
                * <p>Lists the configurations for DNSSEC validation that are associated with the current Amazon Web Services account.</p>
                */
            listResolverDnssecConfigs(args: ListResolverDnssecConfigsCommandInput, options?: __HttpHandlerOptions): Promise<ListResolverDnssecConfigsCommandOutput>;
            listResolverDnssecConfigs(args: ListResolverDnssecConfigsCommandInput, cb: (err: any, data?: ListResolverDnssecConfigsCommandOutput) => void): void;
            listResolverDnssecConfigs(args: ListResolverDnssecConfigsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListResolverDnssecConfigsCommandOutput) => void): void;
            /**
                * <p>Gets the IP addresses for a specified Resolver endpoint.</p>
                */
            listResolverEndpointIpAddresses(args: ListResolverEndpointIpAddressesCommandInput, options?: __HttpHandlerOptions): Promise<ListResolverEndpointIpAddressesCommandOutput>;
            listResolverEndpointIpAddresses(args: ListResolverEndpointIpAddressesCommandInput, cb: (err: any, data?: ListResolverEndpointIpAddressesCommandOutput) => void): void;
            listResolverEndpointIpAddresses(args: ListResolverEndpointIpAddressesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListResolverEndpointIpAddressesCommandOutput) => void): void;
            /**
                * <p>Lists all the Resolver endpoints that were created using the current Amazon Web Services account.</p>
                */
            listResolverEndpoints(args: ListResolverEndpointsCommandInput, options?: __HttpHandlerOptions): Promise<ListResolverEndpointsCommandOutput>;
            listResolverEndpoints(args: ListResolverEndpointsCommandInput, cb: (err: any, data?: ListResolverEndpointsCommandOutput) => void): void;
            listResolverEndpoints(args: ListResolverEndpointsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListResolverEndpointsCommandOutput) => void): void;
            /**
                * <p>Lists information about associations between Amazon VPCs and query logging configurations.</p>
                */
            listResolverQueryLogConfigAssociations(args: ListResolverQueryLogConfigAssociationsCommandInput, options?: __HttpHandlerOptions): Promise<ListResolverQueryLogConfigAssociationsCommandOutput>;
            listResolverQueryLogConfigAssociations(args: ListResolverQueryLogConfigAssociationsCommandInput, cb: (err: any, data?: ListResolverQueryLogConfigAssociationsCommandOutput) => void): void;
            listResolverQueryLogConfigAssociations(args: ListResolverQueryLogConfigAssociationsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListResolverQueryLogConfigAssociationsCommandOutput) => void): void;
            /**
                * <p>Lists information about the specified query logging configurations. Each configuration defines where you want Resolver to save
                * 			DNS query logs and specifies the VPCs that you want to log queries for.</p>
                */
            listResolverQueryLogConfigs(args: ListResolverQueryLogConfigsCommandInput, options?: __HttpHandlerOptions): Promise<ListResolverQueryLogConfigsCommandOutput>;
            listResolverQueryLogConfigs(args: ListResolverQueryLogConfigsCommandInput, cb: (err: any, data?: ListResolverQueryLogConfigsCommandOutput) => void): void;
            listResolverQueryLogConfigs(args: ListResolverQueryLogConfigsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListResolverQueryLogConfigsCommandOutput) => void): void;
            /**
                * <p>Lists the associations that were created between Resolver rules and VPCs using the current Amazon Web Services account.</p>
                */
            listResolverRuleAssociations(args: ListResolverRuleAssociationsCommandInput, options?: __HttpHandlerOptions): Promise<ListResolverRuleAssociationsCommandOutput>;
            listResolverRuleAssociations(args: ListResolverRuleAssociationsCommandInput, cb: (err: any, data?: ListResolverRuleAssociationsCommandOutput) => void): void;
            listResolverRuleAssociations(args: ListResolverRuleAssociationsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListResolverRuleAssociationsCommandOutput) => void): void;
            /**
                * <p>Lists the Resolver rules that were created using the current Amazon Web Services account.</p>
                */
            listResolverRules(args: ListResolverRulesCommandInput, options?: __HttpHandlerOptions): Promise<ListResolverRulesCommandOutput>;
            listResolverRules(args: ListResolverRulesCommandInput, cb: (err: any, data?: ListResolverRulesCommandOutput) => void): void;
            listResolverRules(args: ListResolverRulesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListResolverRulesCommandOutput) => void): void;
            /**
                * <p>Lists the tags that you associated with the specified resource.</p>
                */
            listTagsForResource(args: ListTagsForResourceCommandInput, options?: __HttpHandlerOptions): Promise<ListTagsForResourceCommandOutput>;
            listTagsForResource(args: ListTagsForResourceCommandInput, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            listTagsForResource(args: ListTagsForResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            /**
                * <p>Attaches an Identity and Access Management (Amazon Web Services IAM) policy for sharing the rule
                * 			group. You can use the policy to share the rule group using Resource Access Manager
                * 			(RAM). </p>
                */
            putFirewallRuleGroupPolicy(args: PutFirewallRuleGroupPolicyCommandInput, options?: __HttpHandlerOptions): Promise<PutFirewallRuleGroupPolicyCommandOutput>;
            putFirewallRuleGroupPolicy(args: PutFirewallRuleGroupPolicyCommandInput, cb: (err: any, data?: PutFirewallRuleGroupPolicyCommandOutput) => void): void;
            putFirewallRuleGroupPolicy(args: PutFirewallRuleGroupPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutFirewallRuleGroupPolicyCommandOutput) => void): void;
            /**
                * <p>Specifies an Amazon Web Services account that you want to share a query logging configuration with, the query logging configuration that you want to share,
                * 			and the operations that you want the account to be able to perform on the configuration.</p>
                */
            putResolverQueryLogConfigPolicy(args: PutResolverQueryLogConfigPolicyCommandInput, options?: __HttpHandlerOptions): Promise<PutResolverQueryLogConfigPolicyCommandOutput>;
            putResolverQueryLogConfigPolicy(args: PutResolverQueryLogConfigPolicyCommandInput, cb: (err: any, data?: PutResolverQueryLogConfigPolicyCommandOutput) => void): void;
            putResolverQueryLogConfigPolicy(args: PutResolverQueryLogConfigPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutResolverQueryLogConfigPolicyCommandOutput) => void): void;
            /**
                * <p>Specifies an Amazon Web Services rule that you want to share with another account, the account that you want to share the rule with,
                * 			and the operations that you want the account to be able to perform on the rule.</p>
                */
            putResolverRulePolicy(args: PutResolverRulePolicyCommandInput, options?: __HttpHandlerOptions): Promise<PutResolverRulePolicyCommandOutput>;
            putResolverRulePolicy(args: PutResolverRulePolicyCommandInput, cb: (err: any, data?: PutResolverRulePolicyCommandOutput) => void): void;
            putResolverRulePolicy(args: PutResolverRulePolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutResolverRulePolicyCommandOutput) => void): void;
            /**
                * <p>Adds one or more tags to a specified resource.</p>
                */
            tagResource(args: TagResourceCommandInput, options?: __HttpHandlerOptions): Promise<TagResourceCommandOutput>;
            tagResource(args: TagResourceCommandInput, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            tagResource(args: TagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            /**
                * <p>Removes one or more tags from a specified resource.</p>
                */
            untagResource(args: UntagResourceCommandInput, options?: __HttpHandlerOptions): Promise<UntagResourceCommandOutput>;
            untagResource(args: UntagResourceCommandInput, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            untagResource(args: UntagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            /**
                * <p>Updates the configuration of the firewall behavior provided by DNS Firewall for a single
                * 			VPC from Amazon Virtual Private Cloud (Amazon VPC). </p>
                */
            updateFirewallConfig(args: UpdateFirewallConfigCommandInput, options?: __HttpHandlerOptions): Promise<UpdateFirewallConfigCommandOutput>;
            updateFirewallConfig(args: UpdateFirewallConfigCommandInput, cb: (err: any, data?: UpdateFirewallConfigCommandOutput) => void): void;
            updateFirewallConfig(args: UpdateFirewallConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateFirewallConfigCommandOutput) => void): void;
            /**
                * <p>Updates the firewall domain list from an array of domain specifications. </p>
                */
            updateFirewallDomains(args: UpdateFirewallDomainsCommandInput, options?: __HttpHandlerOptions): Promise<UpdateFirewallDomainsCommandOutput>;
            updateFirewallDomains(args: UpdateFirewallDomainsCommandInput, cb: (err: any, data?: UpdateFirewallDomainsCommandOutput) => void): void;
            updateFirewallDomains(args: UpdateFirewallDomainsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateFirewallDomainsCommandOutput) => void): void;
            /**
                * <p>Updates the specified firewall rule. </p>
                */
            updateFirewallRule(args: UpdateFirewallRuleCommandInput, options?: __HttpHandlerOptions): Promise<UpdateFirewallRuleCommandOutput>;
            updateFirewallRule(args: UpdateFirewallRuleCommandInput, cb: (err: any, data?: UpdateFirewallRuleCommandOutput) => void): void;
            updateFirewallRule(args: UpdateFirewallRuleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateFirewallRuleCommandOutput) => void): void;
            /**
                * <p>Changes the association of a <a>FirewallRuleGroup</a> with a VPC. The association enables DNS filtering for the VPC. </p>
                */
            updateFirewallRuleGroupAssociation(args: UpdateFirewallRuleGroupAssociationCommandInput, options?: __HttpHandlerOptions): Promise<UpdateFirewallRuleGroupAssociationCommandOutput>;
            updateFirewallRuleGroupAssociation(args: UpdateFirewallRuleGroupAssociationCommandInput, cb: (err: any, data?: UpdateFirewallRuleGroupAssociationCommandOutput) => void): void;
            updateFirewallRuleGroupAssociation(args: UpdateFirewallRuleGroupAssociationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateFirewallRuleGroupAssociationCommandOutput) => void): void;
            /**
                * <p>Updates the behavior configuration of Route 53 Resolver behavior for a single VPC from
                * 				Amazon Virtual Private Cloud.</p>
                */
            updateResolverConfig(args: UpdateResolverConfigCommandInput, options?: __HttpHandlerOptions): Promise<UpdateResolverConfigCommandOutput>;
            updateResolverConfig(args: UpdateResolverConfigCommandInput, cb: (err: any, data?: UpdateResolverConfigCommandOutput) => void): void;
            updateResolverConfig(args: UpdateResolverConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateResolverConfigCommandOutput) => void): void;
            /**
                * <p>Updates an existing DNSSEC validation configuration. If there is no existing DNSSEC validation configuration, one is created.</p>
                */
            updateResolverDnssecConfig(args: UpdateResolverDnssecConfigCommandInput, options?: __HttpHandlerOptions): Promise<UpdateResolverDnssecConfigCommandOutput>;
            updateResolverDnssecConfig(args: UpdateResolverDnssecConfigCommandInput, cb: (err: any, data?: UpdateResolverDnssecConfigCommandOutput) => void): void;
            updateResolverDnssecConfig(args: UpdateResolverDnssecConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateResolverDnssecConfigCommandOutput) => void): void;
            /**
                * <p>Updates the name of an inbound or an outbound Resolver endpoint.  </p>
                */
            updateResolverEndpoint(args: UpdateResolverEndpointCommandInput, options?: __HttpHandlerOptions): Promise<UpdateResolverEndpointCommandOutput>;
            updateResolverEndpoint(args: UpdateResolverEndpointCommandInput, cb: (err: any, data?: UpdateResolverEndpointCommandOutput) => void): void;
            updateResolverEndpoint(args: UpdateResolverEndpointCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateResolverEndpointCommandOutput) => void): void;
            /**
                * <p>Updates settings for a specified Resolver rule. <code>ResolverRuleId</code> is required, and all other parameters are optional.
                * 			If you don't specify a parameter, it retains its current value.</p>
                */
            updateResolverRule(args: UpdateResolverRuleCommandInput, options?: __HttpHandlerOptions): Promise<UpdateResolverRuleCommandOutput>;
            updateResolverRule(args: UpdateResolverRuleCommandInput, cb: (err: any, data?: UpdateResolverRuleCommandOutput) => void): void;
            updateResolverRule(args: UpdateResolverRuleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateResolverRuleCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/AssociateFirewallRuleGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { AssociateFirewallRuleGroupRequest, AssociateFirewallRuleGroupResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface AssociateFirewallRuleGroupCommandInput extends AssociateFirewallRuleGroupRequest {
    }
    export interface AssociateFirewallRuleGroupCommandOutput extends AssociateFirewallRuleGroupResponse, __MetadataBearer {
    }
    /**
        * <p>Associates a <a>FirewallRuleGroup</a> with a VPC, to provide DNS filtering for the VPC. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, AssociateFirewallRuleGroupCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, AssociateFirewallRuleGroupCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new AssociateFirewallRuleGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link AssociateFirewallRuleGroupCommandInput} for command's `input` shape.
        * @see {@link AssociateFirewallRuleGroupCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class AssociateFirewallRuleGroupCommand extends $Command<AssociateFirewallRuleGroupCommandInput, AssociateFirewallRuleGroupCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: AssociateFirewallRuleGroupCommandInput;
            constructor(input: AssociateFirewallRuleGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<AssociateFirewallRuleGroupCommandInput, AssociateFirewallRuleGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/AssociateResolverEndpointIpAddressCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { AssociateResolverEndpointIpAddressRequest, AssociateResolverEndpointIpAddressResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface AssociateResolverEndpointIpAddressCommandInput extends AssociateResolverEndpointIpAddressRequest {
    }
    export interface AssociateResolverEndpointIpAddressCommandOutput extends AssociateResolverEndpointIpAddressResponse, __MetadataBearer {
    }
    /**
        * <p>Adds IP addresses to an inbound or an outbound Resolver endpoint. If you want to add more than one IP address,
        * 			submit one <code>AssociateResolverEndpointIpAddress</code> request for each IP address.</p>
        * 		       <p>To remove an IP address from an endpoint, see
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverEndpointIpAddress.html">DisassociateResolverEndpointIpAddress</a>.
        * 		</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, AssociateResolverEndpointIpAddressCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, AssociateResolverEndpointIpAddressCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new AssociateResolverEndpointIpAddressCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link AssociateResolverEndpointIpAddressCommandInput} for command's `input` shape.
        * @see {@link AssociateResolverEndpointIpAddressCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class AssociateResolverEndpointIpAddressCommand extends $Command<AssociateResolverEndpointIpAddressCommandInput, AssociateResolverEndpointIpAddressCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: AssociateResolverEndpointIpAddressCommandInput;
            constructor(input: AssociateResolverEndpointIpAddressCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<AssociateResolverEndpointIpAddressCommandInput, AssociateResolverEndpointIpAddressCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/AssociateResolverQueryLogConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { AssociateResolverQueryLogConfigRequest, AssociateResolverQueryLogConfigResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface AssociateResolverQueryLogConfigCommandInput extends AssociateResolverQueryLogConfigRequest {
    }
    export interface AssociateResolverQueryLogConfigCommandOutput extends AssociateResolverQueryLogConfigResponse, __MetadataBearer {
    }
    /**
        * <p>Associates an Amazon VPC with a specified query logging configuration. Route 53 Resolver logs DNS queries that originate in all of the Amazon VPCs
        * 			that are associated with a specified query logging configuration. To associate more than one VPC with a configuration, submit one <code>AssociateResolverQueryLogConfig</code>
        * 			request for each VPC.</p>
        *
        * 		       <note>
        *             <p>The VPCs that you associate with a query logging configuration must be in the same Region as the configuration.</p>
        *          </note>
        *
        * 		       <p>To remove a VPC from a query logging configuration, see
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverQueryLogConfig.html">DisassociateResolverQueryLogConfig</a>.
        * 			</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, AssociateResolverQueryLogConfigCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, AssociateResolverQueryLogConfigCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new AssociateResolverQueryLogConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link AssociateResolverQueryLogConfigCommandInput} for command's `input` shape.
        * @see {@link AssociateResolverQueryLogConfigCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class AssociateResolverQueryLogConfigCommand extends $Command<AssociateResolverQueryLogConfigCommandInput, AssociateResolverQueryLogConfigCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: AssociateResolverQueryLogConfigCommandInput;
            constructor(input: AssociateResolverQueryLogConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<AssociateResolverQueryLogConfigCommandInput, AssociateResolverQueryLogConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/AssociateResolverRuleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { AssociateResolverRuleRequest, AssociateResolverRuleResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface AssociateResolverRuleCommandInput extends AssociateResolverRuleRequest {
    }
    export interface AssociateResolverRuleCommandOutput extends AssociateResolverRuleResponse, __MetadataBearer {
    }
    /**
        * <p>Associates a Resolver rule with a VPC. When you associate a rule with a VPC, Resolver forwards all DNS queries
        * 			for the domain name that is specified in the rule and that originate in the VPC. The queries are forwarded to the
        * 			IP addresses for the DNS resolvers that are specified in the rule. For more information about rules, see
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverRule.html">CreateResolverRule</a>. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, AssociateResolverRuleCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, AssociateResolverRuleCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new AssociateResolverRuleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link AssociateResolverRuleCommandInput} for command's `input` shape.
        * @see {@link AssociateResolverRuleCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class AssociateResolverRuleCommand extends $Command<AssociateResolverRuleCommandInput, AssociateResolverRuleCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: AssociateResolverRuleCommandInput;
            constructor(input: AssociateResolverRuleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<AssociateResolverRuleCommandInput, AssociateResolverRuleCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/CreateFirewallDomainListCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateFirewallDomainListRequest, CreateFirewallDomainListResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface CreateFirewallDomainListCommandInput extends CreateFirewallDomainListRequest {
    }
    export interface CreateFirewallDomainListCommandOutput extends CreateFirewallDomainListResponse, __MetadataBearer {
    }
    /**
        * <p>Creates an empty firewall domain list for use in DNS Firewall rules. You can populate the domains for the new list with a file, using <a>ImportFirewallDomains</a>, or with domain strings, using <a>UpdateFirewallDomains</a>. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, CreateFirewallDomainListCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, CreateFirewallDomainListCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new CreateFirewallDomainListCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateFirewallDomainListCommandInput} for command's `input` shape.
        * @see {@link CreateFirewallDomainListCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class CreateFirewallDomainListCommand extends $Command<CreateFirewallDomainListCommandInput, CreateFirewallDomainListCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: CreateFirewallDomainListCommandInput;
            constructor(input: CreateFirewallDomainListCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateFirewallDomainListCommandInput, CreateFirewallDomainListCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/CreateFirewallRuleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateFirewallRuleRequest, CreateFirewallRuleResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface CreateFirewallRuleCommandInput extends CreateFirewallRuleRequest {
    }
    export interface CreateFirewallRuleCommandOutput extends CreateFirewallRuleResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a single DNS Firewall rule in the specified rule group, using the specified domain list.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, CreateFirewallRuleCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, CreateFirewallRuleCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new CreateFirewallRuleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateFirewallRuleCommandInput} for command's `input` shape.
        * @see {@link CreateFirewallRuleCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class CreateFirewallRuleCommand extends $Command<CreateFirewallRuleCommandInput, CreateFirewallRuleCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: CreateFirewallRuleCommandInput;
            constructor(input: CreateFirewallRuleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateFirewallRuleCommandInput, CreateFirewallRuleCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/CreateFirewallRuleGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateFirewallRuleGroupRequest, CreateFirewallRuleGroupResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface CreateFirewallRuleGroupCommandInput extends CreateFirewallRuleGroupRequest {
    }
    export interface CreateFirewallRuleGroupCommandOutput extends CreateFirewallRuleGroupResponse, __MetadataBearer {
    }
    /**
        * <p>Creates an empty DNS Firewall rule group for filtering DNS network traffic in a VPC. You can add rules to the new rule group
        *            by calling <a>CreateFirewallRule</a>. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, CreateFirewallRuleGroupCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, CreateFirewallRuleGroupCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new CreateFirewallRuleGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateFirewallRuleGroupCommandInput} for command's `input` shape.
        * @see {@link CreateFirewallRuleGroupCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class CreateFirewallRuleGroupCommand extends $Command<CreateFirewallRuleGroupCommandInput, CreateFirewallRuleGroupCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: CreateFirewallRuleGroupCommandInput;
            constructor(input: CreateFirewallRuleGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateFirewallRuleGroupCommandInput, CreateFirewallRuleGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/CreateResolverEndpointCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateResolverEndpointRequest, CreateResolverEndpointResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface CreateResolverEndpointCommandInput extends CreateResolverEndpointRequest {
    }
    export interface CreateResolverEndpointCommandOutput extends CreateResolverEndpointResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a Resolver endpoint. There are two types of Resolver endpoints, inbound and outbound:</p>
        * 		       <ul>
        *             <li>
        *                <p>An <i>inbound Resolver endpoint</i> forwards DNS queries to the DNS service for a VPC
        * 				from your network.</p>
        *             </li>
        *             <li>
        *                <p>An <i>outbound Resolver endpoint</i> forwards DNS queries from the DNS service for a VPC
        * 				to your network.</p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, CreateResolverEndpointCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, CreateResolverEndpointCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new CreateResolverEndpointCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateResolverEndpointCommandInput} for command's `input` shape.
        * @see {@link CreateResolverEndpointCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class CreateResolverEndpointCommand extends $Command<CreateResolverEndpointCommandInput, CreateResolverEndpointCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: CreateResolverEndpointCommandInput;
            constructor(input: CreateResolverEndpointCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateResolverEndpointCommandInput, CreateResolverEndpointCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/CreateResolverQueryLogConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateResolverQueryLogConfigRequest, CreateResolverQueryLogConfigResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface CreateResolverQueryLogConfigCommandInput extends CreateResolverQueryLogConfigRequest {
    }
    export interface CreateResolverQueryLogConfigCommandOutput extends CreateResolverQueryLogConfigResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a Resolver query logging configuration, which defines where you want Resolver to save DNS query logs that originate in your VPCs.
        * 			Resolver can log queries only for VPCs that are in the same Region as the query logging configuration.</p>
        *
        * 		       <p>To specify which VPCs you want to log queries for, you use <code>AssociateResolverQueryLogConfig</code>. For more information, see
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverQueryLogConfig.html">AssociateResolverQueryLogConfig</a>. </p>
        *
        * 		       <p>You can optionally use Resource Access Manager (RAM) to share a query logging configuration with other Amazon Web Services accounts. The other accounts
        * 			can then associate VPCs with the configuration. The query logs that Resolver creates for a configuration include all DNS queries that originate in all
        * 			VPCs that are associated with the configuration.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, CreateResolverQueryLogConfigCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, CreateResolverQueryLogConfigCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new CreateResolverQueryLogConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateResolverQueryLogConfigCommandInput} for command's `input` shape.
        * @see {@link CreateResolverQueryLogConfigCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class CreateResolverQueryLogConfigCommand extends $Command<CreateResolverQueryLogConfigCommandInput, CreateResolverQueryLogConfigCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: CreateResolverQueryLogConfigCommandInput;
            constructor(input: CreateResolverQueryLogConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateResolverQueryLogConfigCommandInput, CreateResolverQueryLogConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/CreateResolverRuleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateResolverRuleRequest, CreateResolverRuleResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface CreateResolverRuleCommandInput extends CreateResolverRuleRequest {
    }
    export interface CreateResolverRuleCommandOutput extends CreateResolverRuleResponse, __MetadataBearer {
    }
    /**
        * <p>For DNS queries that originate in your VPCs, specifies which Resolver endpoint the queries pass through,
        * 			one domain name that you want to forward to your network, and the IP addresses of the DNS resolvers in your network.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, CreateResolverRuleCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, CreateResolverRuleCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new CreateResolverRuleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateResolverRuleCommandInput} for command's `input` shape.
        * @see {@link CreateResolverRuleCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class CreateResolverRuleCommand extends $Command<CreateResolverRuleCommandInput, CreateResolverRuleCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: CreateResolverRuleCommandInput;
            constructor(input: CreateResolverRuleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateResolverRuleCommandInput, CreateResolverRuleCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DeleteFirewallDomainListCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteFirewallDomainListRequest, DeleteFirewallDomainListResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface DeleteFirewallDomainListCommandInput extends DeleteFirewallDomainListRequest {
    }
    export interface DeleteFirewallDomainListCommandOutput extends DeleteFirewallDomainListResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes the specified domain list. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, DeleteFirewallDomainListCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, DeleteFirewallDomainListCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new DeleteFirewallDomainListCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteFirewallDomainListCommandInput} for command's `input` shape.
        * @see {@link DeleteFirewallDomainListCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class DeleteFirewallDomainListCommand extends $Command<DeleteFirewallDomainListCommandInput, DeleteFirewallDomainListCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: DeleteFirewallDomainListCommandInput;
            constructor(input: DeleteFirewallDomainListCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteFirewallDomainListCommandInput, DeleteFirewallDomainListCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DeleteFirewallRuleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteFirewallRuleRequest, DeleteFirewallRuleResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface DeleteFirewallRuleCommandInput extends DeleteFirewallRuleRequest {
    }
    export interface DeleteFirewallRuleCommandOutput extends DeleteFirewallRuleResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes the specified firewall rule.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, DeleteFirewallRuleCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, DeleteFirewallRuleCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new DeleteFirewallRuleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteFirewallRuleCommandInput} for command's `input` shape.
        * @see {@link DeleteFirewallRuleCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class DeleteFirewallRuleCommand extends $Command<DeleteFirewallRuleCommandInput, DeleteFirewallRuleCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: DeleteFirewallRuleCommandInput;
            constructor(input: DeleteFirewallRuleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteFirewallRuleCommandInput, DeleteFirewallRuleCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DeleteFirewallRuleGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteFirewallRuleGroupRequest, DeleteFirewallRuleGroupResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface DeleteFirewallRuleGroupCommandInput extends DeleteFirewallRuleGroupRequest {
    }
    export interface DeleteFirewallRuleGroupCommandOutput extends DeleteFirewallRuleGroupResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes the specified firewall rule group. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, DeleteFirewallRuleGroupCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, DeleteFirewallRuleGroupCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new DeleteFirewallRuleGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteFirewallRuleGroupCommandInput} for command's `input` shape.
        * @see {@link DeleteFirewallRuleGroupCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class DeleteFirewallRuleGroupCommand extends $Command<DeleteFirewallRuleGroupCommandInput, DeleteFirewallRuleGroupCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: DeleteFirewallRuleGroupCommandInput;
            constructor(input: DeleteFirewallRuleGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteFirewallRuleGroupCommandInput, DeleteFirewallRuleGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DeleteResolverEndpointCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteResolverEndpointRequest, DeleteResolverEndpointResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface DeleteResolverEndpointCommandInput extends DeleteResolverEndpointRequest {
    }
    export interface DeleteResolverEndpointCommandOutput extends DeleteResolverEndpointResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes a Resolver endpoint. The effect of deleting a Resolver endpoint depends on whether it's an inbound or an outbound
        * 			Resolver endpoint:</p>
        * 		       <ul>
        *             <li>
        *                <p>
        *                   <b>Inbound</b>: DNS queries from your network are no longer routed
        * 				to the DNS service for the specified VPC.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <b>Outbound</b>: DNS queries from a VPC are no longer routed to your network.</p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, DeleteResolverEndpointCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, DeleteResolverEndpointCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new DeleteResolverEndpointCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteResolverEndpointCommandInput} for command's `input` shape.
        * @see {@link DeleteResolverEndpointCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class DeleteResolverEndpointCommand extends $Command<DeleteResolverEndpointCommandInput, DeleteResolverEndpointCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: DeleteResolverEndpointCommandInput;
            constructor(input: DeleteResolverEndpointCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteResolverEndpointCommandInput, DeleteResolverEndpointCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DeleteResolverQueryLogConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteResolverQueryLogConfigRequest, DeleteResolverQueryLogConfigResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface DeleteResolverQueryLogConfigCommandInput extends DeleteResolverQueryLogConfigRequest {
    }
    export interface DeleteResolverQueryLogConfigCommandOutput extends DeleteResolverQueryLogConfigResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes a query logging configuration. When you delete a configuration, Resolver stops logging DNS queries for all of the Amazon VPCs that are
        * 			associated with the configuration. This also applies if the query logging configuration is shared with other Amazon Web Services accounts, and
        * 			the other accounts have associated VPCs with the shared configuration.</p>
        *
        * 		       <p>Before you can delete a query logging configuration, you must first disassociate all VPCs from the configuration. See
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverQueryLogConfig.html">DisassociateResolverQueryLogConfig</a>.</p>
        *
        * 		       <p>If you used Resource Access Manager (RAM) to share a query logging configuration with other accounts, you must stop sharing
        * 			the configuration before you can delete a configuration. The accounts that you shared the configuration with can first disassociate VPCs
        * 			that they associated with the configuration, but that's not necessary. If you stop sharing the configuration, those VPCs are automatically
        * 			disassociated from the configuration.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, DeleteResolverQueryLogConfigCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, DeleteResolverQueryLogConfigCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new DeleteResolverQueryLogConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteResolverQueryLogConfigCommandInput} for command's `input` shape.
        * @see {@link DeleteResolverQueryLogConfigCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class DeleteResolverQueryLogConfigCommand extends $Command<DeleteResolverQueryLogConfigCommandInput, DeleteResolverQueryLogConfigCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: DeleteResolverQueryLogConfigCommandInput;
            constructor(input: DeleteResolverQueryLogConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteResolverQueryLogConfigCommandInput, DeleteResolverQueryLogConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DeleteResolverRuleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteResolverRuleRequest, DeleteResolverRuleResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface DeleteResolverRuleCommandInput extends DeleteResolverRuleRequest {
    }
    export interface DeleteResolverRuleCommandOutput extends DeleteResolverRuleResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes a Resolver rule. Before you can delete a Resolver rule, you must disassociate it from all the VPCs that you
        * 			associated the Resolver rule with. For more information, see
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverRule.html">DisassociateResolverRule</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, DeleteResolverRuleCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, DeleteResolverRuleCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new DeleteResolverRuleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteResolverRuleCommandInput} for command's `input` shape.
        * @see {@link DeleteResolverRuleCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class DeleteResolverRuleCommand extends $Command<DeleteResolverRuleCommandInput, DeleteResolverRuleCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: DeleteResolverRuleCommandInput;
            constructor(input: DeleteResolverRuleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteResolverRuleCommandInput, DeleteResolverRuleCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DisassociateFirewallRuleGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DisassociateFirewallRuleGroupRequest, DisassociateFirewallRuleGroupResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface DisassociateFirewallRuleGroupCommandInput extends DisassociateFirewallRuleGroupRequest {
    }
    export interface DisassociateFirewallRuleGroupCommandOutput extends DisassociateFirewallRuleGroupResponse, __MetadataBearer {
    }
    /**
        * <p>Disassociates a <a>FirewallRuleGroup</a> from a VPC, to remove DNS filtering from the VPC. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, DisassociateFirewallRuleGroupCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, DisassociateFirewallRuleGroupCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new DisassociateFirewallRuleGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DisassociateFirewallRuleGroupCommandInput} for command's `input` shape.
        * @see {@link DisassociateFirewallRuleGroupCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class DisassociateFirewallRuleGroupCommand extends $Command<DisassociateFirewallRuleGroupCommandInput, DisassociateFirewallRuleGroupCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: DisassociateFirewallRuleGroupCommandInput;
            constructor(input: DisassociateFirewallRuleGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DisassociateFirewallRuleGroupCommandInput, DisassociateFirewallRuleGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DisassociateResolverEndpointIpAddressCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DisassociateResolverEndpointIpAddressRequest, DisassociateResolverEndpointIpAddressResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface DisassociateResolverEndpointIpAddressCommandInput extends DisassociateResolverEndpointIpAddressRequest {
    }
    export interface DisassociateResolverEndpointIpAddressCommandOutput extends DisassociateResolverEndpointIpAddressResponse, __MetadataBearer {
    }
    /**
        * <p>Removes IP addresses from an inbound or an outbound Resolver endpoint. If you want to remove more than one IP address,
        * 			submit one <code>DisassociateResolverEndpointIpAddress</code> request for each IP address.</p>
        * 		       <p>To add an IP address to an endpoint, see
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverEndpointIpAddress.html">AssociateResolverEndpointIpAddress</a>.
        * 		</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, DisassociateResolverEndpointIpAddressCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, DisassociateResolverEndpointIpAddressCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new DisassociateResolverEndpointIpAddressCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DisassociateResolverEndpointIpAddressCommandInput} for command's `input` shape.
        * @see {@link DisassociateResolverEndpointIpAddressCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class DisassociateResolverEndpointIpAddressCommand extends $Command<DisassociateResolverEndpointIpAddressCommandInput, DisassociateResolverEndpointIpAddressCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: DisassociateResolverEndpointIpAddressCommandInput;
            constructor(input: DisassociateResolverEndpointIpAddressCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DisassociateResolverEndpointIpAddressCommandInput, DisassociateResolverEndpointIpAddressCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DisassociateResolverQueryLogConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DisassociateResolverQueryLogConfigRequest, DisassociateResolverQueryLogConfigResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface DisassociateResolverQueryLogConfigCommandInput extends DisassociateResolverQueryLogConfigRequest {
    }
    export interface DisassociateResolverQueryLogConfigCommandOutput extends DisassociateResolverQueryLogConfigResponse, __MetadataBearer {
    }
    /**
        * <p>Disassociates a VPC from a query logging configuration.</p>
        *
        * 		       <note>
        * 			         <p>Before you can delete a query logging configuration, you must first disassociate all VPCs
        * 				from the configuration. If you used Resource Access Manager (RAM) to share a
        * 				query logging configuration with other accounts, VPCs can be disassociated from the
        * 				configuration in the following ways:</p>
        * 			         <ul>
        *                <li>
        *                   <p>The accounts that you shared the configuration with can disassociate VPCs from the configuration.</p>
        *                </li>
        *                <li>
        *                   <p>You can stop sharing the configuration.</p>
        *                </li>
        *             </ul>
        * 		       </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, DisassociateResolverQueryLogConfigCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, DisassociateResolverQueryLogConfigCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new DisassociateResolverQueryLogConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DisassociateResolverQueryLogConfigCommandInput} for command's `input` shape.
        * @see {@link DisassociateResolverQueryLogConfigCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class DisassociateResolverQueryLogConfigCommand extends $Command<DisassociateResolverQueryLogConfigCommandInput, DisassociateResolverQueryLogConfigCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: DisassociateResolverQueryLogConfigCommandInput;
            constructor(input: DisassociateResolverQueryLogConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DisassociateResolverQueryLogConfigCommandInput, DisassociateResolverQueryLogConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DisassociateResolverRuleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DisassociateResolverRuleRequest, DisassociateResolverRuleResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface DisassociateResolverRuleCommandInput extends DisassociateResolverRuleRequest {
    }
    export interface DisassociateResolverRuleCommandOutput extends DisassociateResolverRuleResponse, __MetadataBearer {
    }
    /**
        * <p>Removes the association between a specified Resolver rule and a specified VPC.</p>
        * 		       <important>
        * 			         <p>If you disassociate a Resolver rule from a VPC, Resolver stops forwarding DNS queries for the
        * 				domain name that you specified in the Resolver rule. </p>
        * 		       </important>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, DisassociateResolverRuleCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, DisassociateResolverRuleCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new DisassociateResolverRuleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DisassociateResolverRuleCommandInput} for command's `input` shape.
        * @see {@link DisassociateResolverRuleCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class DisassociateResolverRuleCommand extends $Command<DisassociateResolverRuleCommandInput, DisassociateResolverRuleCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: DisassociateResolverRuleCommandInput;
            constructor(input: DisassociateResolverRuleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DisassociateResolverRuleCommandInput, DisassociateResolverRuleCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetFirewallConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetFirewallConfigRequest, GetFirewallConfigResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface GetFirewallConfigCommandInput extends GetFirewallConfigRequest {
    }
    export interface GetFirewallConfigCommandOutput extends GetFirewallConfigResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves the configuration of the firewall behavior provided by DNS Firewall for a
        * 			single VPC from Amazon Virtual Private Cloud (Amazon VPC). </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, GetFirewallConfigCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, GetFirewallConfigCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new GetFirewallConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetFirewallConfigCommandInput} for command's `input` shape.
        * @see {@link GetFirewallConfigCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class GetFirewallConfigCommand extends $Command<GetFirewallConfigCommandInput, GetFirewallConfigCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: GetFirewallConfigCommandInput;
            constructor(input: GetFirewallConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetFirewallConfigCommandInput, GetFirewallConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetFirewallDomainListCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetFirewallDomainListRequest, GetFirewallDomainListResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface GetFirewallDomainListCommandInput extends GetFirewallDomainListRequest {
    }
    export interface GetFirewallDomainListCommandOutput extends GetFirewallDomainListResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves the specified firewall domain list.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, GetFirewallDomainListCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, GetFirewallDomainListCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new GetFirewallDomainListCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetFirewallDomainListCommandInput} for command's `input` shape.
        * @see {@link GetFirewallDomainListCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class GetFirewallDomainListCommand extends $Command<GetFirewallDomainListCommandInput, GetFirewallDomainListCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: GetFirewallDomainListCommandInput;
            constructor(input: GetFirewallDomainListCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetFirewallDomainListCommandInput, GetFirewallDomainListCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetFirewallRuleGroupAssociationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetFirewallRuleGroupAssociationRequest, GetFirewallRuleGroupAssociationResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface GetFirewallRuleGroupAssociationCommandInput extends GetFirewallRuleGroupAssociationRequest {
    }
    export interface GetFirewallRuleGroupAssociationCommandOutput extends GetFirewallRuleGroupAssociationResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves a firewall rule group association, which enables DNS filtering for a VPC with one rule group. A VPC can have more than one firewall rule group association, and a rule group can be associated with more than one VPC.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, GetFirewallRuleGroupAssociationCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, GetFirewallRuleGroupAssociationCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new GetFirewallRuleGroupAssociationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetFirewallRuleGroupAssociationCommandInput} for command's `input` shape.
        * @see {@link GetFirewallRuleGroupAssociationCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class GetFirewallRuleGroupAssociationCommand extends $Command<GetFirewallRuleGroupAssociationCommandInput, GetFirewallRuleGroupAssociationCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: GetFirewallRuleGroupAssociationCommandInput;
            constructor(input: GetFirewallRuleGroupAssociationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetFirewallRuleGroupAssociationCommandInput, GetFirewallRuleGroupAssociationCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetFirewallRuleGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetFirewallRuleGroupRequest, GetFirewallRuleGroupResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface GetFirewallRuleGroupCommandInput extends GetFirewallRuleGroupRequest {
    }
    export interface GetFirewallRuleGroupCommandOutput extends GetFirewallRuleGroupResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves the specified firewall rule group. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, GetFirewallRuleGroupCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, GetFirewallRuleGroupCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new GetFirewallRuleGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetFirewallRuleGroupCommandInput} for command's `input` shape.
        * @see {@link GetFirewallRuleGroupCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class GetFirewallRuleGroupCommand extends $Command<GetFirewallRuleGroupCommandInput, GetFirewallRuleGroupCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: GetFirewallRuleGroupCommandInput;
            constructor(input: GetFirewallRuleGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetFirewallRuleGroupCommandInput, GetFirewallRuleGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetFirewallRuleGroupPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetFirewallRuleGroupPolicyRequest, GetFirewallRuleGroupPolicyResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface GetFirewallRuleGroupPolicyCommandInput extends GetFirewallRuleGroupPolicyRequest {
    }
    export interface GetFirewallRuleGroupPolicyCommandOutput extends GetFirewallRuleGroupPolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Returns the Identity and Access Management (Amazon Web Services IAM) policy for sharing the
        *        	specified rule group. You can use the policy to share the rule group using Resource Access Manager (RAM). </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, GetFirewallRuleGroupPolicyCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, GetFirewallRuleGroupPolicyCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new GetFirewallRuleGroupPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetFirewallRuleGroupPolicyCommandInput} for command's `input` shape.
        * @see {@link GetFirewallRuleGroupPolicyCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class GetFirewallRuleGroupPolicyCommand extends $Command<GetFirewallRuleGroupPolicyCommandInput, GetFirewallRuleGroupPolicyCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: GetFirewallRuleGroupPolicyCommandInput;
            constructor(input: GetFirewallRuleGroupPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetFirewallRuleGroupPolicyCommandInput, GetFirewallRuleGroupPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetResolverConfigRequest, GetResolverConfigResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface GetResolverConfigCommandInput extends GetResolverConfigRequest {
    }
    export interface GetResolverConfigCommandOutput extends GetResolverConfigResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves the behavior configuration of Route 53 Resolver behavior for a single VPC from
        * 				Amazon Virtual Private Cloud.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, GetResolverConfigCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, GetResolverConfigCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new GetResolverConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetResolverConfigCommandInput} for command's `input` shape.
        * @see {@link GetResolverConfigCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class GetResolverConfigCommand extends $Command<GetResolverConfigCommandInput, GetResolverConfigCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: GetResolverConfigCommandInput;
            constructor(input: GetResolverConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetResolverConfigCommandInput, GetResolverConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverDnssecConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetResolverDnssecConfigRequest, GetResolverDnssecConfigResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface GetResolverDnssecConfigCommandInput extends GetResolverDnssecConfigRequest {
    }
    export interface GetResolverDnssecConfigCommandOutput extends GetResolverDnssecConfigResponse, __MetadataBearer {
    }
    /**
        * <p>Gets DNSSEC validation information for a specified resource.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, GetResolverDnssecConfigCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, GetResolverDnssecConfigCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new GetResolverDnssecConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetResolverDnssecConfigCommandInput} for command's `input` shape.
        * @see {@link GetResolverDnssecConfigCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class GetResolverDnssecConfigCommand extends $Command<GetResolverDnssecConfigCommandInput, GetResolverDnssecConfigCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: GetResolverDnssecConfigCommandInput;
            constructor(input: GetResolverDnssecConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetResolverDnssecConfigCommandInput, GetResolverDnssecConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverEndpointCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetResolverEndpointRequest, GetResolverEndpointResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface GetResolverEndpointCommandInput extends GetResolverEndpointRequest {
    }
    export interface GetResolverEndpointCommandOutput extends GetResolverEndpointResponse, __MetadataBearer {
    }
    /**
        * <p>Gets information about a specified Resolver endpoint, such as whether it's an inbound or an outbound Resolver endpoint, and the
        * 			current status of the endpoint.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, GetResolverEndpointCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, GetResolverEndpointCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new GetResolverEndpointCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetResolverEndpointCommandInput} for command's `input` shape.
        * @see {@link GetResolverEndpointCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class GetResolverEndpointCommand extends $Command<GetResolverEndpointCommandInput, GetResolverEndpointCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: GetResolverEndpointCommandInput;
            constructor(input: GetResolverEndpointCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetResolverEndpointCommandInput, GetResolverEndpointCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverQueryLogConfigAssociationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetResolverQueryLogConfigAssociationRequest, GetResolverQueryLogConfigAssociationResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface GetResolverQueryLogConfigAssociationCommandInput extends GetResolverQueryLogConfigAssociationRequest {
    }
    export interface GetResolverQueryLogConfigAssociationCommandOutput extends GetResolverQueryLogConfigAssociationResponse, __MetadataBearer {
    }
    /**
        * <p>Gets information about a specified association between a Resolver query logging configuration and an Amazon VPC. When you associate a VPC
        * 			with a query logging configuration, Resolver logs DNS queries that originate in that VPC.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, GetResolverQueryLogConfigAssociationCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, GetResolverQueryLogConfigAssociationCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new GetResolverQueryLogConfigAssociationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetResolverQueryLogConfigAssociationCommandInput} for command's `input` shape.
        * @see {@link GetResolverQueryLogConfigAssociationCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class GetResolverQueryLogConfigAssociationCommand extends $Command<GetResolverQueryLogConfigAssociationCommandInput, GetResolverQueryLogConfigAssociationCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: GetResolverQueryLogConfigAssociationCommandInput;
            constructor(input: GetResolverQueryLogConfigAssociationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetResolverQueryLogConfigAssociationCommandInput, GetResolverQueryLogConfigAssociationCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverQueryLogConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetResolverQueryLogConfigRequest, GetResolverQueryLogConfigResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface GetResolverQueryLogConfigCommandInput extends GetResolverQueryLogConfigRequest {
    }
    export interface GetResolverQueryLogConfigCommandOutput extends GetResolverQueryLogConfigResponse, __MetadataBearer {
    }
    /**
        * <p>Gets information about a specified Resolver query logging configuration, such as the number of VPCs that the configuration
        * 			is logging queries for and the location that logs are sent to. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, GetResolverQueryLogConfigCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, GetResolverQueryLogConfigCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new GetResolverQueryLogConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetResolverQueryLogConfigCommandInput} for command's `input` shape.
        * @see {@link GetResolverQueryLogConfigCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class GetResolverQueryLogConfigCommand extends $Command<GetResolverQueryLogConfigCommandInput, GetResolverQueryLogConfigCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: GetResolverQueryLogConfigCommandInput;
            constructor(input: GetResolverQueryLogConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetResolverQueryLogConfigCommandInput, GetResolverQueryLogConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverQueryLogConfigPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetResolverQueryLogConfigPolicyRequest, GetResolverQueryLogConfigPolicyResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface GetResolverQueryLogConfigPolicyCommandInput extends GetResolverQueryLogConfigPolicyRequest {
    }
    export interface GetResolverQueryLogConfigPolicyCommandOutput extends GetResolverQueryLogConfigPolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Gets information about a query logging policy. A query logging policy specifies the Resolver query logging
        * 			operations and resources that you want to allow another Amazon Web Services account to be able to use.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, GetResolverQueryLogConfigPolicyCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, GetResolverQueryLogConfigPolicyCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new GetResolverQueryLogConfigPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetResolverQueryLogConfigPolicyCommandInput} for command's `input` shape.
        * @see {@link GetResolverQueryLogConfigPolicyCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class GetResolverQueryLogConfigPolicyCommand extends $Command<GetResolverQueryLogConfigPolicyCommandInput, GetResolverQueryLogConfigPolicyCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: GetResolverQueryLogConfigPolicyCommandInput;
            constructor(input: GetResolverQueryLogConfigPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetResolverQueryLogConfigPolicyCommandInput, GetResolverQueryLogConfigPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverRuleAssociationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetResolverRuleAssociationRequest, GetResolverRuleAssociationResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface GetResolverRuleAssociationCommandInput extends GetResolverRuleAssociationRequest {
    }
    export interface GetResolverRuleAssociationCommandOutput extends GetResolverRuleAssociationResponse, __MetadataBearer {
    }
    /**
        * <p>Gets information about an association between a specified Resolver rule and a VPC. You associate a Resolver rule and a VPC using
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverRule.html">AssociateResolverRule</a>. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, GetResolverRuleAssociationCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, GetResolverRuleAssociationCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new GetResolverRuleAssociationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetResolverRuleAssociationCommandInput} for command's `input` shape.
        * @see {@link GetResolverRuleAssociationCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class GetResolverRuleAssociationCommand extends $Command<GetResolverRuleAssociationCommandInput, GetResolverRuleAssociationCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: GetResolverRuleAssociationCommandInput;
            constructor(input: GetResolverRuleAssociationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetResolverRuleAssociationCommandInput, GetResolverRuleAssociationCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverRuleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetResolverRuleRequest, GetResolverRuleResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface GetResolverRuleCommandInput extends GetResolverRuleRequest {
    }
    export interface GetResolverRuleCommandOutput extends GetResolverRuleResponse, __MetadataBearer {
    }
    /**
        * <p>Gets information about a specified Resolver rule, such as the domain name that the rule forwards DNS queries for and the ID of the
        * 			outbound Resolver endpoint that the rule is associated with.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, GetResolverRuleCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, GetResolverRuleCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new GetResolverRuleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetResolverRuleCommandInput} for command's `input` shape.
        * @see {@link GetResolverRuleCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class GetResolverRuleCommand extends $Command<GetResolverRuleCommandInput, GetResolverRuleCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: GetResolverRuleCommandInput;
            constructor(input: GetResolverRuleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetResolverRuleCommandInput, GetResolverRuleCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverRulePolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetResolverRulePolicyRequest, GetResolverRulePolicyResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface GetResolverRulePolicyCommandInput extends GetResolverRulePolicyRequest {
    }
    export interface GetResolverRulePolicyCommandOutput extends GetResolverRulePolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Gets information about the Resolver rule policy for a specified rule. A Resolver rule policy includes the rule that you want to share
        * 			with another account, the account that you want to share the rule with, and the Resolver operations that you want to allow the account to use. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, GetResolverRulePolicyCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, GetResolverRulePolicyCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new GetResolverRulePolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetResolverRulePolicyCommandInput} for command's `input` shape.
        * @see {@link GetResolverRulePolicyCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class GetResolverRulePolicyCommand extends $Command<GetResolverRulePolicyCommandInput, GetResolverRulePolicyCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: GetResolverRulePolicyCommandInput;
            constructor(input: GetResolverRulePolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetResolverRulePolicyCommandInput, GetResolverRulePolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ImportFirewallDomainsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ImportFirewallDomainsRequest, ImportFirewallDomainsResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface ImportFirewallDomainsCommandInput extends ImportFirewallDomainsRequest {
    }
    export interface ImportFirewallDomainsCommandOutput extends ImportFirewallDomainsResponse, __MetadataBearer {
    }
    /**
        * <p>Imports domain names from a file into a domain list, for use in a DNS firewall rule group. </p>
        *          <p>Each domain specification in your domain list must satisfy the following
        * 	requirements: </p>
        *          <ul>
        *             <li>
        *       	        <p>It can optionally start with <code>*</code> (asterisk).</p>
        *       	     </li>
        *             <li>
        *       	        <p>With the exception of the optional starting asterisk, it must only contain
        *       	   the following characters: <code>A-Z</code>, <code>a-z</code>,
        *       	   <code>0-9</code>, <code>-</code> (hyphen).</p>
        *       	     </li>
        *             <li>
        *       	        <p>It must be from 1-255 characters in length. </p>
        *       	     </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, ImportFirewallDomainsCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, ImportFirewallDomainsCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new ImportFirewallDomainsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ImportFirewallDomainsCommandInput} for command's `input` shape.
        * @see {@link ImportFirewallDomainsCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class ImportFirewallDomainsCommand extends $Command<ImportFirewallDomainsCommandInput, ImportFirewallDomainsCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: ImportFirewallDomainsCommandInput;
            constructor(input: ImportFirewallDomainsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ImportFirewallDomainsCommandInput, ImportFirewallDomainsCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListFirewallConfigsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListFirewallConfigsRequest, ListFirewallConfigsResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface ListFirewallConfigsCommandInput extends ListFirewallConfigsRequest {
    }
    export interface ListFirewallConfigsCommandOutput extends ListFirewallConfigsResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves the firewall configurations that you have defined. DNS Firewall uses the configurations to manage firewall behavior for your VPCs. </p>
        *          <p>A single call might return only a partial list of the configurations. For information, see <code>MaxResults</code>. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, ListFirewallConfigsCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, ListFirewallConfigsCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new ListFirewallConfigsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListFirewallConfigsCommandInput} for command's `input` shape.
        * @see {@link ListFirewallConfigsCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class ListFirewallConfigsCommand extends $Command<ListFirewallConfigsCommandInput, ListFirewallConfigsCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: ListFirewallConfigsCommandInput;
            constructor(input: ListFirewallConfigsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListFirewallConfigsCommandInput, ListFirewallConfigsCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListFirewallDomainListsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListFirewallDomainListsRequest, ListFirewallDomainListsResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface ListFirewallDomainListsCommandInput extends ListFirewallDomainListsRequest {
    }
    export interface ListFirewallDomainListsCommandOutput extends ListFirewallDomainListsResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves the firewall domain lists that you have defined. For each firewall domain list, you can retrieve the domains that are defined for a list by calling <a>ListFirewallDomains</a>. </p>
        *          <p>A single call to this list operation might return only a partial list of the domain lists. For information, see <code>MaxResults</code>. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, ListFirewallDomainListsCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, ListFirewallDomainListsCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new ListFirewallDomainListsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListFirewallDomainListsCommandInput} for command's `input` shape.
        * @see {@link ListFirewallDomainListsCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class ListFirewallDomainListsCommand extends $Command<ListFirewallDomainListsCommandInput, ListFirewallDomainListsCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: ListFirewallDomainListsCommandInput;
            constructor(input: ListFirewallDomainListsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListFirewallDomainListsCommandInput, ListFirewallDomainListsCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListFirewallDomainsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListFirewallDomainsRequest, ListFirewallDomainsResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface ListFirewallDomainsCommandInput extends ListFirewallDomainsRequest {
    }
    export interface ListFirewallDomainsCommandOutput extends ListFirewallDomainsResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves the domains that you have defined for the specified firewall domain list.  </p>
        *          <p>A single call might return only a partial list of the domains. For information, see <code>MaxResults</code>. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, ListFirewallDomainsCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, ListFirewallDomainsCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new ListFirewallDomainsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListFirewallDomainsCommandInput} for command's `input` shape.
        * @see {@link ListFirewallDomainsCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class ListFirewallDomainsCommand extends $Command<ListFirewallDomainsCommandInput, ListFirewallDomainsCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: ListFirewallDomainsCommandInput;
            constructor(input: ListFirewallDomainsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListFirewallDomainsCommandInput, ListFirewallDomainsCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListFirewallRuleGroupAssociationsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListFirewallRuleGroupAssociationsRequest, ListFirewallRuleGroupAssociationsResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface ListFirewallRuleGroupAssociationsCommandInput extends ListFirewallRuleGroupAssociationsRequest {
    }
    export interface ListFirewallRuleGroupAssociationsCommandOutput extends ListFirewallRuleGroupAssociationsResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves the firewall rule group associations that you have defined. Each association enables DNS filtering for a VPC with one rule group. </p>
        *          <p>A single call might return only a partial list of the associations. For information, see <code>MaxResults</code>. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, ListFirewallRuleGroupAssociationsCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, ListFirewallRuleGroupAssociationsCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new ListFirewallRuleGroupAssociationsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListFirewallRuleGroupAssociationsCommandInput} for command's `input` shape.
        * @see {@link ListFirewallRuleGroupAssociationsCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class ListFirewallRuleGroupAssociationsCommand extends $Command<ListFirewallRuleGroupAssociationsCommandInput, ListFirewallRuleGroupAssociationsCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: ListFirewallRuleGroupAssociationsCommandInput;
            constructor(input: ListFirewallRuleGroupAssociationsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListFirewallRuleGroupAssociationsCommandInput, ListFirewallRuleGroupAssociationsCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListFirewallRuleGroupsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListFirewallRuleGroupsRequest, ListFirewallRuleGroupsResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface ListFirewallRuleGroupsCommandInput extends ListFirewallRuleGroupsRequest {
    }
    export interface ListFirewallRuleGroupsCommandOutput extends ListFirewallRuleGroupsResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves the minimal high-level information for the rule groups that you have defined.  </p>
        *          <p>A single call might return only a partial list of the rule groups. For information, see <code>MaxResults</code>. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, ListFirewallRuleGroupsCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, ListFirewallRuleGroupsCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new ListFirewallRuleGroupsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListFirewallRuleGroupsCommandInput} for command's `input` shape.
        * @see {@link ListFirewallRuleGroupsCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class ListFirewallRuleGroupsCommand extends $Command<ListFirewallRuleGroupsCommandInput, ListFirewallRuleGroupsCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: ListFirewallRuleGroupsCommandInput;
            constructor(input: ListFirewallRuleGroupsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListFirewallRuleGroupsCommandInput, ListFirewallRuleGroupsCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListFirewallRulesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListFirewallRulesRequest, ListFirewallRulesResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface ListFirewallRulesCommandInput extends ListFirewallRulesRequest {
    }
    export interface ListFirewallRulesCommandOutput extends ListFirewallRulesResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves the firewall rules that you have defined for the specified firewall rule group. DNS Firewall uses the rules in a rule group to filter DNS network traffic for a VPC. </p>
        *          <p>A single call might return only a partial list of the rules. For information, see <code>MaxResults</code>. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, ListFirewallRulesCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, ListFirewallRulesCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new ListFirewallRulesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListFirewallRulesCommandInput} for command's `input` shape.
        * @see {@link ListFirewallRulesCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class ListFirewallRulesCommand extends $Command<ListFirewallRulesCommandInput, ListFirewallRulesCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: ListFirewallRulesCommandInput;
            constructor(input: ListFirewallRulesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListFirewallRulesCommandInput, ListFirewallRulesCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverConfigsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListResolverConfigsRequest, ListResolverConfigsResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface ListResolverConfigsCommandInput extends ListResolverConfigsRequest {
    }
    export interface ListResolverConfigsCommandOutput extends ListResolverConfigsResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves the Resolver configurations that you have defined.
        * 			Route 53 Resolver uses the configurations to manage DNS resolution behavior for your VPCs.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, ListResolverConfigsCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, ListResolverConfigsCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new ListResolverConfigsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListResolverConfigsCommandInput} for command's `input` shape.
        * @see {@link ListResolverConfigsCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class ListResolverConfigsCommand extends $Command<ListResolverConfigsCommandInput, ListResolverConfigsCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: ListResolverConfigsCommandInput;
            constructor(input: ListResolverConfigsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListResolverConfigsCommandInput, ListResolverConfigsCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverDnssecConfigsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListResolverDnssecConfigsRequest, ListResolverDnssecConfigsResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface ListResolverDnssecConfigsCommandInput extends ListResolverDnssecConfigsRequest {
    }
    export interface ListResolverDnssecConfigsCommandOutput extends ListResolverDnssecConfigsResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the configurations for DNSSEC validation that are associated with the current Amazon Web Services account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, ListResolverDnssecConfigsCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, ListResolverDnssecConfigsCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new ListResolverDnssecConfigsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListResolverDnssecConfigsCommandInput} for command's `input` shape.
        * @see {@link ListResolverDnssecConfigsCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class ListResolverDnssecConfigsCommand extends $Command<ListResolverDnssecConfigsCommandInput, ListResolverDnssecConfigsCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: ListResolverDnssecConfigsCommandInput;
            constructor(input: ListResolverDnssecConfigsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListResolverDnssecConfigsCommandInput, ListResolverDnssecConfigsCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverEndpointIpAddressesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListResolverEndpointIpAddressesRequest, ListResolverEndpointIpAddressesResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface ListResolverEndpointIpAddressesCommandInput extends ListResolverEndpointIpAddressesRequest {
    }
    export interface ListResolverEndpointIpAddressesCommandOutput extends ListResolverEndpointIpAddressesResponse, __MetadataBearer {
    }
    /**
        * <p>Gets the IP addresses for a specified Resolver endpoint.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, ListResolverEndpointIpAddressesCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, ListResolverEndpointIpAddressesCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new ListResolverEndpointIpAddressesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListResolverEndpointIpAddressesCommandInput} for command's `input` shape.
        * @see {@link ListResolverEndpointIpAddressesCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class ListResolverEndpointIpAddressesCommand extends $Command<ListResolverEndpointIpAddressesCommandInput, ListResolverEndpointIpAddressesCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: ListResolverEndpointIpAddressesCommandInput;
            constructor(input: ListResolverEndpointIpAddressesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListResolverEndpointIpAddressesCommandInput, ListResolverEndpointIpAddressesCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverEndpointsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListResolverEndpointsRequest, ListResolverEndpointsResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface ListResolverEndpointsCommandInput extends ListResolverEndpointsRequest {
    }
    export interface ListResolverEndpointsCommandOutput extends ListResolverEndpointsResponse, __MetadataBearer {
    }
    /**
        * <p>Lists all the Resolver endpoints that were created using the current Amazon Web Services account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, ListResolverEndpointsCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, ListResolverEndpointsCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new ListResolverEndpointsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListResolverEndpointsCommandInput} for command's `input` shape.
        * @see {@link ListResolverEndpointsCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class ListResolverEndpointsCommand extends $Command<ListResolverEndpointsCommandInput, ListResolverEndpointsCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: ListResolverEndpointsCommandInput;
            constructor(input: ListResolverEndpointsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListResolverEndpointsCommandInput, ListResolverEndpointsCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverQueryLogConfigAssociationsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListResolverQueryLogConfigAssociationsRequest, ListResolverQueryLogConfigAssociationsResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface ListResolverQueryLogConfigAssociationsCommandInput extends ListResolverQueryLogConfigAssociationsRequest {
    }
    export interface ListResolverQueryLogConfigAssociationsCommandOutput extends ListResolverQueryLogConfigAssociationsResponse, __MetadataBearer {
    }
    /**
        * <p>Lists information about associations between Amazon VPCs and query logging configurations.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, ListResolverQueryLogConfigAssociationsCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, ListResolverQueryLogConfigAssociationsCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new ListResolverQueryLogConfigAssociationsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListResolverQueryLogConfigAssociationsCommandInput} for command's `input` shape.
        * @see {@link ListResolverQueryLogConfigAssociationsCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class ListResolverQueryLogConfigAssociationsCommand extends $Command<ListResolverQueryLogConfigAssociationsCommandInput, ListResolverQueryLogConfigAssociationsCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: ListResolverQueryLogConfigAssociationsCommandInput;
            constructor(input: ListResolverQueryLogConfigAssociationsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListResolverQueryLogConfigAssociationsCommandInput, ListResolverQueryLogConfigAssociationsCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverQueryLogConfigsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListResolverQueryLogConfigsRequest, ListResolverQueryLogConfigsResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface ListResolverQueryLogConfigsCommandInput extends ListResolverQueryLogConfigsRequest {
    }
    export interface ListResolverQueryLogConfigsCommandOutput extends ListResolverQueryLogConfigsResponse, __MetadataBearer {
    }
    /**
        * <p>Lists information about the specified query logging configurations. Each configuration defines where you want Resolver to save
        * 			DNS query logs and specifies the VPCs that you want to log queries for.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, ListResolverQueryLogConfigsCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, ListResolverQueryLogConfigsCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new ListResolverQueryLogConfigsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListResolverQueryLogConfigsCommandInput} for command's `input` shape.
        * @see {@link ListResolverQueryLogConfigsCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class ListResolverQueryLogConfigsCommand extends $Command<ListResolverQueryLogConfigsCommandInput, ListResolverQueryLogConfigsCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: ListResolverQueryLogConfigsCommandInput;
            constructor(input: ListResolverQueryLogConfigsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListResolverQueryLogConfigsCommandInput, ListResolverQueryLogConfigsCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverRuleAssociationsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListResolverRuleAssociationsRequest, ListResolverRuleAssociationsResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface ListResolverRuleAssociationsCommandInput extends ListResolverRuleAssociationsRequest {
    }
    export interface ListResolverRuleAssociationsCommandOutput extends ListResolverRuleAssociationsResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the associations that were created between Resolver rules and VPCs using the current Amazon Web Services account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, ListResolverRuleAssociationsCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, ListResolverRuleAssociationsCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new ListResolverRuleAssociationsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListResolverRuleAssociationsCommandInput} for command's `input` shape.
        * @see {@link ListResolverRuleAssociationsCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class ListResolverRuleAssociationsCommand extends $Command<ListResolverRuleAssociationsCommandInput, ListResolverRuleAssociationsCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: ListResolverRuleAssociationsCommandInput;
            constructor(input: ListResolverRuleAssociationsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListResolverRuleAssociationsCommandInput, ListResolverRuleAssociationsCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverRulesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListResolverRulesRequest, ListResolverRulesResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface ListResolverRulesCommandInput extends ListResolverRulesRequest {
    }
    export interface ListResolverRulesCommandOutput extends ListResolverRulesResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the Resolver rules that were created using the current Amazon Web Services account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, ListResolverRulesCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, ListResolverRulesCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new ListResolverRulesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListResolverRulesCommandInput} for command's `input` shape.
        * @see {@link ListResolverRulesCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class ListResolverRulesCommand extends $Command<ListResolverRulesCommandInput, ListResolverRulesCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: ListResolverRulesCommandInput;
            constructor(input: ListResolverRulesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListResolverRulesCommandInput, ListResolverRulesCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListTagsForResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListTagsForResourceRequest, ListTagsForResourceResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface ListTagsForResourceCommandInput extends ListTagsForResourceRequest {
    }
    export interface ListTagsForResourceCommandOutput extends ListTagsForResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the tags that you associated with the specified resource.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, ListTagsForResourceCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, ListTagsForResourceCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new ListTagsForResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTagsForResourceCommandInput} for command's `input` shape.
        * @see {@link ListTagsForResourceCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class ListTagsForResourceCommand extends $Command<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: ListTagsForResourceCommandInput;
            constructor(input: ListTagsForResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/PutFirewallRuleGroupPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { PutFirewallRuleGroupPolicyRequest, PutFirewallRuleGroupPolicyResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface PutFirewallRuleGroupPolicyCommandInput extends PutFirewallRuleGroupPolicyRequest {
    }
    export interface PutFirewallRuleGroupPolicyCommandOutput extends PutFirewallRuleGroupPolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Attaches an Identity and Access Management (Amazon Web Services IAM) policy for sharing the rule
        * 			group. You can use the policy to share the rule group using Resource Access Manager
        * 			(RAM). </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, PutFirewallRuleGroupPolicyCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, PutFirewallRuleGroupPolicyCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new PutFirewallRuleGroupPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutFirewallRuleGroupPolicyCommandInput} for command's `input` shape.
        * @see {@link PutFirewallRuleGroupPolicyCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class PutFirewallRuleGroupPolicyCommand extends $Command<PutFirewallRuleGroupPolicyCommandInput, PutFirewallRuleGroupPolicyCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: PutFirewallRuleGroupPolicyCommandInput;
            constructor(input: PutFirewallRuleGroupPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutFirewallRuleGroupPolicyCommandInput, PutFirewallRuleGroupPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/PutResolverQueryLogConfigPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { PutResolverQueryLogConfigPolicyRequest, PutResolverQueryLogConfigPolicyResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface PutResolverQueryLogConfigPolicyCommandInput extends PutResolverQueryLogConfigPolicyRequest {
    }
    export interface PutResolverQueryLogConfigPolicyCommandOutput extends PutResolverQueryLogConfigPolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Specifies an Amazon Web Services account that you want to share a query logging configuration with, the query logging configuration that you want to share,
        * 			and the operations that you want the account to be able to perform on the configuration.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, PutResolverQueryLogConfigPolicyCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, PutResolverQueryLogConfigPolicyCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new PutResolverQueryLogConfigPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutResolverQueryLogConfigPolicyCommandInput} for command's `input` shape.
        * @see {@link PutResolverQueryLogConfigPolicyCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class PutResolverQueryLogConfigPolicyCommand extends $Command<PutResolverQueryLogConfigPolicyCommandInput, PutResolverQueryLogConfigPolicyCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: PutResolverQueryLogConfigPolicyCommandInput;
            constructor(input: PutResolverQueryLogConfigPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutResolverQueryLogConfigPolicyCommandInput, PutResolverQueryLogConfigPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/PutResolverRulePolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { PutResolverRulePolicyRequest, PutResolverRulePolicyResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface PutResolverRulePolicyCommandInput extends PutResolverRulePolicyRequest {
    }
    export interface PutResolverRulePolicyCommandOutput extends PutResolverRulePolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Specifies an Amazon Web Services rule that you want to share with another account, the account that you want to share the rule with,
        * 			and the operations that you want the account to be able to perform on the rule.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, PutResolverRulePolicyCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, PutResolverRulePolicyCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new PutResolverRulePolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutResolverRulePolicyCommandInput} for command's `input` shape.
        * @see {@link PutResolverRulePolicyCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class PutResolverRulePolicyCommand extends $Command<PutResolverRulePolicyCommandInput, PutResolverRulePolicyCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: PutResolverRulePolicyCommandInput;
            constructor(input: PutResolverRulePolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutResolverRulePolicyCommandInput, PutResolverRulePolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/TagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { TagResourceRequest, TagResourceResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface TagResourceCommandInput extends TagResourceRequest {
    }
    export interface TagResourceCommandOutput extends TagResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Adds one or more tags to a specified resource.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, TagResourceCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, TagResourceCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new TagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TagResourceCommandInput} for command's `input` shape.
        * @see {@link TagResourceCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class TagResourceCommand extends $Command<TagResourceCommandInput, TagResourceCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: TagResourceCommandInput;
            constructor(input: TagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TagResourceCommandInput, TagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UntagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UntagResourceRequest, UntagResourceResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface UntagResourceCommandInput extends UntagResourceRequest {
    }
    export interface UntagResourceCommandOutput extends UntagResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Removes one or more tags from a specified resource.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, UntagResourceCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, UntagResourceCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new UntagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UntagResourceCommandInput} for command's `input` shape.
        * @see {@link UntagResourceCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class UntagResourceCommand extends $Command<UntagResourceCommandInput, UntagResourceCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: UntagResourceCommandInput;
            constructor(input: UntagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UntagResourceCommandInput, UntagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateFirewallConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UpdateFirewallConfigRequest, UpdateFirewallConfigResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface UpdateFirewallConfigCommandInput extends UpdateFirewallConfigRequest {
    }
    export interface UpdateFirewallConfigCommandOutput extends UpdateFirewallConfigResponse, __MetadataBearer {
    }
    /**
        * <p>Updates the configuration of the firewall behavior provided by DNS Firewall for a single
        * 			VPC from Amazon Virtual Private Cloud (Amazon VPC). </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, UpdateFirewallConfigCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, UpdateFirewallConfigCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new UpdateFirewallConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateFirewallConfigCommandInput} for command's `input` shape.
        * @see {@link UpdateFirewallConfigCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class UpdateFirewallConfigCommand extends $Command<UpdateFirewallConfigCommandInput, UpdateFirewallConfigCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: UpdateFirewallConfigCommandInput;
            constructor(input: UpdateFirewallConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateFirewallConfigCommandInput, UpdateFirewallConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateFirewallDomainsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UpdateFirewallDomainsRequest, UpdateFirewallDomainsResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface UpdateFirewallDomainsCommandInput extends UpdateFirewallDomainsRequest {
    }
    export interface UpdateFirewallDomainsCommandOutput extends UpdateFirewallDomainsResponse, __MetadataBearer {
    }
    /**
        * <p>Updates the firewall domain list from an array of domain specifications. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, UpdateFirewallDomainsCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, UpdateFirewallDomainsCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new UpdateFirewallDomainsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateFirewallDomainsCommandInput} for command's `input` shape.
        * @see {@link UpdateFirewallDomainsCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class UpdateFirewallDomainsCommand extends $Command<UpdateFirewallDomainsCommandInput, UpdateFirewallDomainsCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: UpdateFirewallDomainsCommandInput;
            constructor(input: UpdateFirewallDomainsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateFirewallDomainsCommandInput, UpdateFirewallDomainsCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateFirewallRuleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UpdateFirewallRuleRequest, UpdateFirewallRuleResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface UpdateFirewallRuleCommandInput extends UpdateFirewallRuleRequest {
    }
    export interface UpdateFirewallRuleCommandOutput extends UpdateFirewallRuleResponse, __MetadataBearer {
    }
    /**
        * <p>Updates the specified firewall rule. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, UpdateFirewallRuleCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, UpdateFirewallRuleCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new UpdateFirewallRuleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateFirewallRuleCommandInput} for command's `input` shape.
        * @see {@link UpdateFirewallRuleCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class UpdateFirewallRuleCommand extends $Command<UpdateFirewallRuleCommandInput, UpdateFirewallRuleCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: UpdateFirewallRuleCommandInput;
            constructor(input: UpdateFirewallRuleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateFirewallRuleCommandInput, UpdateFirewallRuleCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateFirewallRuleGroupAssociationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UpdateFirewallRuleGroupAssociationRequest, UpdateFirewallRuleGroupAssociationResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface UpdateFirewallRuleGroupAssociationCommandInput extends UpdateFirewallRuleGroupAssociationRequest {
    }
    export interface UpdateFirewallRuleGroupAssociationCommandOutput extends UpdateFirewallRuleGroupAssociationResponse, __MetadataBearer {
    }
    /**
        * <p>Changes the association of a <a>FirewallRuleGroup</a> with a VPC. The association enables DNS filtering for the VPC. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, UpdateFirewallRuleGroupAssociationCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, UpdateFirewallRuleGroupAssociationCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new UpdateFirewallRuleGroupAssociationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateFirewallRuleGroupAssociationCommandInput} for command's `input` shape.
        * @see {@link UpdateFirewallRuleGroupAssociationCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class UpdateFirewallRuleGroupAssociationCommand extends $Command<UpdateFirewallRuleGroupAssociationCommandInput, UpdateFirewallRuleGroupAssociationCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: UpdateFirewallRuleGroupAssociationCommandInput;
            constructor(input: UpdateFirewallRuleGroupAssociationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateFirewallRuleGroupAssociationCommandInput, UpdateFirewallRuleGroupAssociationCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateResolverConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UpdateResolverConfigRequest, UpdateResolverConfigResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface UpdateResolverConfigCommandInput extends UpdateResolverConfigRequest {
    }
    export interface UpdateResolverConfigCommandOutput extends UpdateResolverConfigResponse, __MetadataBearer {
    }
    /**
        * <p>Updates the behavior configuration of Route 53 Resolver behavior for a single VPC from
        * 				Amazon Virtual Private Cloud.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, UpdateResolverConfigCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, UpdateResolverConfigCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new UpdateResolverConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateResolverConfigCommandInput} for command's `input` shape.
        * @see {@link UpdateResolverConfigCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class UpdateResolverConfigCommand extends $Command<UpdateResolverConfigCommandInput, UpdateResolverConfigCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: UpdateResolverConfigCommandInput;
            constructor(input: UpdateResolverConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateResolverConfigCommandInput, UpdateResolverConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateResolverDnssecConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UpdateResolverDnssecConfigRequest, UpdateResolverDnssecConfigResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface UpdateResolverDnssecConfigCommandInput extends UpdateResolverDnssecConfigRequest {
    }
    export interface UpdateResolverDnssecConfigCommandOutput extends UpdateResolverDnssecConfigResponse, __MetadataBearer {
    }
    /**
        * <p>Updates an existing DNSSEC validation configuration. If there is no existing DNSSEC validation configuration, one is created.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, UpdateResolverDnssecConfigCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, UpdateResolverDnssecConfigCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new UpdateResolverDnssecConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateResolverDnssecConfigCommandInput} for command's `input` shape.
        * @see {@link UpdateResolverDnssecConfigCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class UpdateResolverDnssecConfigCommand extends $Command<UpdateResolverDnssecConfigCommandInput, UpdateResolverDnssecConfigCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: UpdateResolverDnssecConfigCommandInput;
            constructor(input: UpdateResolverDnssecConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateResolverDnssecConfigCommandInput, UpdateResolverDnssecConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateResolverEndpointCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UpdateResolverEndpointRequest, UpdateResolverEndpointResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface UpdateResolverEndpointCommandInput extends UpdateResolverEndpointRequest {
    }
    export interface UpdateResolverEndpointCommandOutput extends UpdateResolverEndpointResponse, __MetadataBearer {
    }
    /**
        * <p>Updates the name of an inbound or an outbound Resolver endpoint.  </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, UpdateResolverEndpointCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, UpdateResolverEndpointCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new UpdateResolverEndpointCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateResolverEndpointCommandInput} for command's `input` shape.
        * @see {@link UpdateResolverEndpointCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class UpdateResolverEndpointCommand extends $Command<UpdateResolverEndpointCommandInput, UpdateResolverEndpointCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: UpdateResolverEndpointCommandInput;
            constructor(input: UpdateResolverEndpointCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateResolverEndpointCommandInput, UpdateResolverEndpointCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateResolverRuleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UpdateResolverRuleRequest, UpdateResolverRuleResponse } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0";
    import { Route53ResolverClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient";
    export interface UpdateResolverRuleCommandInput extends UpdateResolverRuleRequest {
    }
    export interface UpdateResolverRuleCommandOutput extends UpdateResolverRuleResponse, __MetadataBearer {
    }
    /**
        * <p>Updates settings for a specified Resolver rule. <code>ResolverRuleId</code> is required, and all other parameters are optional.
        * 			If you don't specify a parameter, it retains its current value.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { Route53ResolverClient, UpdateResolverRuleCommand } from "@aws-sdk/client-route53resolver"; // ES Modules import
        * // const { Route53ResolverClient, UpdateResolverRuleCommand } = require("@aws-sdk/client-route53resolver"); // CommonJS import
        * const client = new Route53ResolverClient(config);
        * const command = new UpdateResolverRuleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateResolverRuleCommandInput} for command's `input` shape.
        * @see {@link UpdateResolverRuleCommandOutput} for command's `response` shape.
        * @see {@link Route53ResolverClientResolvedConfig | config} for Route53ResolverClient's `config` shape.
        *
        */
    export class UpdateResolverRuleCommand extends $Command<UpdateResolverRuleCommandInput, UpdateResolverRuleCommandOutput, Route53ResolverClientResolvedConfig> {
            readonly input: UpdateResolverRuleCommandInput;
            constructor(input: UpdateResolverRuleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: Route53ResolverClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateResolverRuleCommandInput, UpdateResolverRuleCommandOutput>;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/Route53ResolverClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { AssociateFirewallRuleGroupCommandInput, AssociateFirewallRuleGroupCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/AssociateFirewallRuleGroupCommand";
    import { AssociateResolverEndpointIpAddressCommandInput, AssociateResolverEndpointIpAddressCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/AssociateResolverEndpointIpAddressCommand";
    import { AssociateResolverQueryLogConfigCommandInput, AssociateResolverQueryLogConfigCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/AssociateResolverQueryLogConfigCommand";
    import { AssociateResolverRuleCommandInput, AssociateResolverRuleCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/AssociateResolverRuleCommand";
    import { CreateFirewallDomainListCommandInput, CreateFirewallDomainListCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/CreateFirewallDomainListCommand";
    import { CreateFirewallRuleCommandInput, CreateFirewallRuleCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/CreateFirewallRuleCommand";
    import { CreateFirewallRuleGroupCommandInput, CreateFirewallRuleGroupCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/CreateFirewallRuleGroupCommand";
    import { CreateResolverEndpointCommandInput, CreateResolverEndpointCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/CreateResolverEndpointCommand";
    import { CreateResolverQueryLogConfigCommandInput, CreateResolverQueryLogConfigCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/CreateResolverQueryLogConfigCommand";
    import { CreateResolverRuleCommandInput, CreateResolverRuleCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/CreateResolverRuleCommand";
    import { DeleteFirewallDomainListCommandInput, DeleteFirewallDomainListCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DeleteFirewallDomainListCommand";
    import { DeleteFirewallRuleCommandInput, DeleteFirewallRuleCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DeleteFirewallRuleCommand";
    import { DeleteFirewallRuleGroupCommandInput, DeleteFirewallRuleGroupCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DeleteFirewallRuleGroupCommand";
    import { DeleteResolverEndpointCommandInput, DeleteResolverEndpointCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DeleteResolverEndpointCommand";
    import { DeleteResolverQueryLogConfigCommandInput, DeleteResolverQueryLogConfigCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DeleteResolverQueryLogConfigCommand";
    import { DeleteResolverRuleCommandInput, DeleteResolverRuleCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DeleteResolverRuleCommand";
    import { DisassociateFirewallRuleGroupCommandInput, DisassociateFirewallRuleGroupCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DisassociateFirewallRuleGroupCommand";
    import { DisassociateResolverEndpointIpAddressCommandInput, DisassociateResolverEndpointIpAddressCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DisassociateResolverEndpointIpAddressCommand";
    import { DisassociateResolverQueryLogConfigCommandInput, DisassociateResolverQueryLogConfigCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DisassociateResolverQueryLogConfigCommand";
    import { DisassociateResolverRuleCommandInput, DisassociateResolverRuleCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/DisassociateResolverRuleCommand";
    import { GetFirewallConfigCommandInput, GetFirewallConfigCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetFirewallConfigCommand";
    import { GetFirewallDomainListCommandInput, GetFirewallDomainListCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetFirewallDomainListCommand";
    import { GetFirewallRuleGroupAssociationCommandInput, GetFirewallRuleGroupAssociationCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetFirewallRuleGroupAssociationCommand";
    import { GetFirewallRuleGroupCommandInput, GetFirewallRuleGroupCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetFirewallRuleGroupCommand";
    import { GetFirewallRuleGroupPolicyCommandInput, GetFirewallRuleGroupPolicyCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetFirewallRuleGroupPolicyCommand";
    import { GetResolverConfigCommandInput, GetResolverConfigCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverConfigCommand";
    import { GetResolverDnssecConfigCommandInput, GetResolverDnssecConfigCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverDnssecConfigCommand";
    import { GetResolverEndpointCommandInput, GetResolverEndpointCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverEndpointCommand";
    import { GetResolverQueryLogConfigAssociationCommandInput, GetResolverQueryLogConfigAssociationCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverQueryLogConfigAssociationCommand";
    import { GetResolverQueryLogConfigCommandInput, GetResolverQueryLogConfigCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverQueryLogConfigCommand";
    import { GetResolverQueryLogConfigPolicyCommandInput, GetResolverQueryLogConfigPolicyCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverQueryLogConfigPolicyCommand";
    import { GetResolverRuleAssociationCommandInput, GetResolverRuleAssociationCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverRuleAssociationCommand";
    import { GetResolverRuleCommandInput, GetResolverRuleCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverRuleCommand";
    import { GetResolverRulePolicyCommandInput, GetResolverRulePolicyCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/GetResolverRulePolicyCommand";
    import { ImportFirewallDomainsCommandInput, ImportFirewallDomainsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ImportFirewallDomainsCommand";
    import { ListFirewallConfigsCommandInput, ListFirewallConfigsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListFirewallConfigsCommand";
    import { ListFirewallDomainListsCommandInput, ListFirewallDomainListsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListFirewallDomainListsCommand";
    import { ListFirewallDomainsCommandInput, ListFirewallDomainsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListFirewallDomainsCommand";
    import { ListFirewallRuleGroupAssociationsCommandInput, ListFirewallRuleGroupAssociationsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListFirewallRuleGroupAssociationsCommand";
    import { ListFirewallRuleGroupsCommandInput, ListFirewallRuleGroupsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListFirewallRuleGroupsCommand";
    import { ListFirewallRulesCommandInput, ListFirewallRulesCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListFirewallRulesCommand";
    import { ListResolverConfigsCommandInput, ListResolverConfigsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverConfigsCommand";
    import { ListResolverDnssecConfigsCommandInput, ListResolverDnssecConfigsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverDnssecConfigsCommand";
    import { ListResolverEndpointIpAddressesCommandInput, ListResolverEndpointIpAddressesCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverEndpointIpAddressesCommand";
    import { ListResolverEndpointsCommandInput, ListResolverEndpointsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverEndpointsCommand";
    import { ListResolverQueryLogConfigAssociationsCommandInput, ListResolverQueryLogConfigAssociationsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverQueryLogConfigAssociationsCommand";
    import { ListResolverQueryLogConfigsCommandInput, ListResolverQueryLogConfigsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverQueryLogConfigsCommand";
    import { ListResolverRuleAssociationsCommandInput, ListResolverRuleAssociationsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverRuleAssociationsCommand";
    import { ListResolverRulesCommandInput, ListResolverRulesCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListResolverRulesCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/ListTagsForResourceCommand";
    import { PutFirewallRuleGroupPolicyCommandInput, PutFirewallRuleGroupPolicyCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/PutFirewallRuleGroupPolicyCommand";
    import { PutResolverQueryLogConfigPolicyCommandInput, PutResolverQueryLogConfigPolicyCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/PutResolverQueryLogConfigPolicyCommand";
    import { PutResolverRulePolicyCommandInput, PutResolverRulePolicyCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/PutResolverRulePolicyCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UntagResourceCommand";
    import { UpdateFirewallConfigCommandInput, UpdateFirewallConfigCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateFirewallConfigCommand";
    import { UpdateFirewallDomainsCommandInput, UpdateFirewallDomainsCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateFirewallDomainsCommand";
    import { UpdateFirewallRuleCommandInput, UpdateFirewallRuleCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateFirewallRuleCommand";
    import { UpdateFirewallRuleGroupAssociationCommandInput, UpdateFirewallRuleGroupAssociationCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateFirewallRuleGroupAssociationCommand";
    import { UpdateResolverConfigCommandInput, UpdateResolverConfigCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateResolverConfigCommand";
    import { UpdateResolverDnssecConfigCommandInput, UpdateResolverDnssecConfigCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateResolverDnssecConfigCommand";
    import { UpdateResolverEndpointCommandInput, UpdateResolverEndpointCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateResolverEndpointCommand";
    import { UpdateResolverRuleCommandInput, UpdateResolverRuleCommandOutput } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/commands/UpdateResolverRuleCommand";
    export type ServiceInputTypes = AssociateFirewallRuleGroupCommandInput | AssociateResolverEndpointIpAddressCommandInput | AssociateResolverQueryLogConfigCommandInput | AssociateResolverRuleCommandInput | CreateFirewallDomainListCommandInput | CreateFirewallRuleCommandInput | CreateFirewallRuleGroupCommandInput | CreateResolverEndpointCommandInput | CreateResolverQueryLogConfigCommandInput | CreateResolverRuleCommandInput | DeleteFirewallDomainListCommandInput | DeleteFirewallRuleCommandInput | DeleteFirewallRuleGroupCommandInput | DeleteResolverEndpointCommandInput | DeleteResolverQueryLogConfigCommandInput | DeleteResolverRuleCommandInput | DisassociateFirewallRuleGroupCommandInput | DisassociateResolverEndpointIpAddressCommandInput | DisassociateResolverQueryLogConfigCommandInput | DisassociateResolverRuleCommandInput | GetFirewallConfigCommandInput | GetFirewallDomainListCommandInput | GetFirewallRuleGroupAssociationCommandInput | GetFirewallRuleGroupCommandInput | GetFirewallRuleGroupPolicyCommandInput | GetResolverConfigCommandInput | GetResolverDnssecConfigCommandInput | GetResolverEndpointCommandInput | GetResolverQueryLogConfigAssociationCommandInput | GetResolverQueryLogConfigCommandInput | GetResolverQueryLogConfigPolicyCommandInput | GetResolverRuleAssociationCommandInput | GetResolverRuleCommandInput | GetResolverRulePolicyCommandInput | ImportFirewallDomainsCommandInput | ListFirewallConfigsCommandInput | ListFirewallDomainListsCommandInput | ListFirewallDomainsCommandInput | ListFirewallRuleGroupAssociationsCommandInput | ListFirewallRuleGroupsCommandInput | ListFirewallRulesCommandInput | ListResolverConfigsCommandInput | ListResolverDnssecConfigsCommandInput | ListResolverEndpointIpAddressesCommandInput | ListResolverEndpointsCommandInput | ListResolverQueryLogConfigAssociationsCommandInput | ListResolverQueryLogConfigsCommandInput | ListResolverRuleAssociationsCommandInput | ListResolverRulesCommandInput | ListTagsForResourceCommandInput | PutFirewallRuleGroupPolicyCommandInput | PutResolverQueryLogConfigPolicyCommandInput | PutResolverRulePolicyCommandInput | TagResourceCommandInput | UntagResourceCommandInput | UpdateFirewallConfigCommandInput | UpdateFirewallDomainsCommandInput | UpdateFirewallRuleCommandInput | UpdateFirewallRuleGroupAssociationCommandInput | UpdateResolverConfigCommandInput | UpdateResolverDnssecConfigCommandInput | UpdateResolverEndpointCommandInput | UpdateResolverRuleCommandInput;
    export type ServiceOutputTypes = AssociateFirewallRuleGroupCommandOutput | AssociateResolverEndpointIpAddressCommandOutput | AssociateResolverQueryLogConfigCommandOutput | AssociateResolverRuleCommandOutput | CreateFirewallDomainListCommandOutput | CreateFirewallRuleCommandOutput | CreateFirewallRuleGroupCommandOutput | CreateResolverEndpointCommandOutput | CreateResolverQueryLogConfigCommandOutput | CreateResolverRuleCommandOutput | DeleteFirewallDomainListCommandOutput | DeleteFirewallRuleCommandOutput | DeleteFirewallRuleGroupCommandOutput | DeleteResolverEndpointCommandOutput | DeleteResolverQueryLogConfigCommandOutput | DeleteResolverRuleCommandOutput | DisassociateFirewallRuleGroupCommandOutput | DisassociateResolverEndpointIpAddressCommandOutput | DisassociateResolverQueryLogConfigCommandOutput | DisassociateResolverRuleCommandOutput | GetFirewallConfigCommandOutput | GetFirewallDomainListCommandOutput | GetFirewallRuleGroupAssociationCommandOutput | GetFirewallRuleGroupCommandOutput | GetFirewallRuleGroupPolicyCommandOutput | GetResolverConfigCommandOutput | GetResolverDnssecConfigCommandOutput | GetResolverEndpointCommandOutput | GetResolverQueryLogConfigAssociationCommandOutput | GetResolverQueryLogConfigCommandOutput | GetResolverQueryLogConfigPolicyCommandOutput | GetResolverRuleAssociationCommandOutput | GetResolverRuleCommandOutput | GetResolverRulePolicyCommandOutput | ImportFirewallDomainsCommandOutput | ListFirewallConfigsCommandOutput | ListFirewallDomainListsCommandOutput | ListFirewallDomainsCommandOutput | ListFirewallRuleGroupAssociationsCommandOutput | ListFirewallRuleGroupsCommandOutput | ListFirewallRulesCommandOutput | ListResolverConfigsCommandOutput | ListResolverDnssecConfigsCommandOutput | ListResolverEndpointIpAddressesCommandOutput | ListResolverEndpointsCommandOutput | ListResolverQueryLogConfigAssociationsCommandOutput | ListResolverQueryLogConfigsCommandOutput | ListResolverRuleAssociationsCommandOutput | ListResolverRulesCommandOutput | ListTagsForResourceCommandOutput | PutFirewallRuleGroupPolicyCommandOutput | PutResolverQueryLogConfigPolicyCommandOutput | PutResolverRulePolicyCommandOutput | TagResourceCommandOutput | UntagResourceCommandOutput | UpdateFirewallConfigCommandOutput | UpdateFirewallDomainsCommandOutput | UpdateFirewallRuleCommandOutput | UpdateFirewallRuleGroupAssociationCommandOutput | UpdateResolverConfigCommandOutput | UpdateResolverDnssecConfigCommandOutput | UpdateResolverEndpointCommandOutput | UpdateResolverRuleCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type Route53ResolverClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of Route53ResolverClient class constructor that set the region, credentials and other options.
        */
    export interface Route53ResolverClientConfig extends Route53ResolverClientConfigType {
    }
    type Route53ResolverClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of Route53ResolverClient class. This is resolved and normalized from the {@link Route53ResolverClientConfig | constructor configuration interface}.
        */
    export interface Route53ResolverClientResolvedConfig extends Route53ResolverClientResolvedConfigType {
    }
    /**
        * <p>When you create a VPC using Amazon VPC, you automatically get DNS resolution within the VPC
        * 			from Route 53 Resolver. By default, Resolver answers DNS queries for VPC domain names
        * 			such as domain names for EC2 instances or Elastic Load Balancing load balancers.
        * 			Resolver performs recursive lookups against public name servers for all other domain
        * 			names.</p>
        *
        * 		       <p>You can also configure DNS resolution between your VPC and your network over a Direct Connect or VPN connection:</p>
        *
        * 		       <p>
        *             <b>Forward DNS queries from resolvers on your network to Route 53 Resolver</b>
        *          </p>
        *
        * 		       <p>DNS resolvers on your network can forward DNS queries to Resolver in a specified VPC. This allows your DNS resolvers
        * 			to easily resolve domain names for Amazon Web Services resources such as EC2 instances or records in a Route 53 private hosted zone.
        * 			For more information, see
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resolver.html#resolver-overview-forward-network-to-vpc">How DNS Resolvers
        * 			on Your Network Forward DNS Queries to Route 53 Resolver</a> in the <i>Amazon Route 53 Developer Guide</i>.</p>
        *
        * 		       <p>
        *             <b>Conditionally forward queries from a VPC to resolvers on your network</b>
        *          </p>
        *
        * 		       <p>You can configure Resolver to forward queries that it receives from EC2 instances in your VPCs to DNS resolvers on your network.
        * 			To forward selected queries, you create Resolver rules that specify the domain names for the DNS queries that you want to forward
        * 			(such as example.com), and the IP addresses of the DNS resolvers on your network that you want to forward the queries to.
        * 			If a query matches multiple rules (example.com, acme.example.com), Resolver chooses the rule with the most specific match
        * 			(acme.example.com) and forwards the query to the IP addresses that you specified in that rule. For more information, see
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resolver.html#resolver-overview-forward-vpc-to-network">How Route 53 Resolver
        * 			Forwards DNS Queries from Your VPCs to Your Network</a> in the <i>Amazon Route 53 Developer Guide</i>.</p>
        *
        * 		       <p>Like Amazon VPC, Resolver is Regional. In each Region where you have VPCs, you can choose
        * 			whether to forward queries from your VPCs to your network (outbound queries), from your
        * 			network to your VPCs (inbound queries), or both.</p>
        */
    export class Route53ResolverClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, Route53ResolverClientResolvedConfig> {
            /**
                * The resolved configuration of Route53ResolverClient class. This is resolved and normalized from the {@link Route53ResolverClientConfig | constructor configuration interface}.
                */
            readonly config: Route53ResolverClientResolvedConfig;
            constructor(configuration: Route53ResolverClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { Route53ResolverServiceException as __BaseException } from "@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/Route53ResolverServiceException";
    /**
        * <p>The current account doesn't have the IAM permissions required to perform the specified Resolver operation.</p>
        */
    export class AccessDeniedException extends __BaseException {
            readonly name: "AccessDeniedException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AccessDeniedException, __BaseException>);
    }
    export enum Action {
            ALERT = "ALERT",
            ALLOW = "ALLOW",
            BLOCK = "BLOCK"
    }
    export enum MutationProtectionStatus {
            DISABLED = "DISABLED",
            ENABLED = "ENABLED"
    }
    /**
        * <p>One tag that you want to add to the specified resource. A tag consists of a <code>Key</code> (a name for the tag) and a <code>Value</code>.</p>
        */
    export interface Tag {
            /**
                * <p>The name for the tag. For example, if you want to associate Resolver resources with the account IDs of your customers for billing purposes,
                * 			the value of <code>Key</code> might be <code>account-id</code>.</p>
                */
            Key: string | undefined;
            /**
                * <p>The value for the tag. For example, if <code>Key</code> is <code>account-id</code>, then <code>Value</code> might be the ID of the
                * 			customer account that you're creating the resource for.</p>
                */
            Value: string | undefined;
    }
    export namespace Tag {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Tag) => any;
    }
    export interface AssociateFirewallRuleGroupRequest {
            /**
                * <p>A unique string that identifies the request and that allows failed requests to be
                * 			retried without the risk of running the operation twice. <code>CreatorRequestId</code>
                * 			can be any unique string, for example, a date/time stamp. </p>
                */
            CreatorRequestId?: string;
            /**
                * <p>The unique identifier of the firewall rule group. </p>
                */
            FirewallRuleGroupId: string | undefined;
            /**
                * <p>The unique identifier of the VPC that you want to associate with the rule group. </p>
                */
            VpcId: string | undefined;
            /**
                * <p>The setting that determines the processing order of the rule group among the rule
                * 			groups that you associate with the specified VPC. DNS Firewall filters VPC traffic
                * 			starting from the rule group with the lowest numeric priority setting. </p>
                *          <p>You must specify a unique priority for each rule group that you associate with a single VPC.
                *            To make it easier to insert rule groups later, leave space between the numbers, for example, use 101, 200, and so on. You
                *    can change the priority setting for a rule group association after you create it.</p>
                *    	     <p>The allowed values for <code>Priority</code> are between 100 and 9900.</p>
                */
            Priority: number | undefined;
            /**
                * <p>A name that lets you identify the association, to manage and use it.</p>
                */
            Name: string | undefined;
            /**
                * <p>If enabled, this setting disallows modification or removal of the association, to help prevent against accidentally altering DNS firewall protections.
                *        When you create the association, the default setting is <code>DISABLED</code>. </p>
                */
            MutationProtection?: MutationProtectionStatus | string;
            /**
                * <p>A list of the tag keys and values that you want to associate with the rule group association. </p>
                */
            Tags?: Tag[];
    }
    export namespace AssociateFirewallRuleGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AssociateFirewallRuleGroupRequest) => any;
    }
    export enum FirewallRuleGroupAssociationStatus {
            COMPLETE = "COMPLETE",
            DELETING = "DELETING",
            UPDATING = "UPDATING"
    }
    /**
        * <p>An association between a firewall rule group and a VPC, which enables DNS filtering for
        * 			the VPC. </p>
        */
    export interface FirewallRuleGroupAssociation {
            /**
                * <p>The identifier for the association.</p>
                */
            Id?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the firewall rule group association.</p>
                */
            Arn?: string;
            /**
                * <p>The unique identifier of the firewall rule group. </p>
                */
            FirewallRuleGroupId?: string;
            /**
                * <p>The unique identifier of the VPC that is associated with the rule group. </p>
                */
            VpcId?: string;
            /**
                * <p>The name of the association.</p>
                */
            Name?: string;
            /**
                * <p>The setting that determines the processing order of the rule group among the rule groups that are associated with a single VPC. DNS Firewall
                *            filters VPC traffic starting from rule group with the lowest numeric priority setting. </p>
                */
            Priority?: number;
            /**
                * <p>If enabled, this setting disallows modification or removal of the association, to help prevent against accidentally altering DNS firewall protections. </p>
                */
            MutationProtection?: MutationProtectionStatus | string;
            /**
                * <p>The owner of the association, used only for associations that are not managed by you. If you use Firewall Manager to
                *    manage your DNS Firewalls, then this reports Firewall Manager as the managed owner.</p>
                */
            ManagedOwnerName?: string;
            /**
                * <p>The current status of the association.</p>
                */
            Status?: FirewallRuleGroupAssociationStatus | string;
            /**
                * <p>Additional information about the status of the response, if available.</p>
                */
            StatusMessage?: string;
            /**
                * <p>A unique string defined by you to identify the request. This allows you to retry failed
                * 			requests without the risk of running the operation twice. This can be any unique string,
                * 			for example, a timestamp. </p>
                */
            CreatorRequestId?: string;
            /**
                * <p>The date and time that the association was created, in Unix time format and Coordinated Universal Time (UTC). </p>
                */
            CreationTime?: string;
            /**
                * <p>The date and time that the association was last modified, in Unix time format and Coordinated Universal Time (UTC).</p>
                */
            ModificationTime?: string;
    }
    export namespace FirewallRuleGroupAssociation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FirewallRuleGroupAssociation) => any;
    }
    export interface AssociateFirewallRuleGroupResponse {
            /**
                * <p>The association that you just created. The association has an ID that you can use to
                * 			identify it in other requests, like update and delete.</p>
                */
            FirewallRuleGroupAssociation?: FirewallRuleGroupAssociation;
    }
    export namespace AssociateFirewallRuleGroupResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AssociateFirewallRuleGroupResponse) => any;
    }
    /**
        * <p></p>
        */
    export class ConflictException extends __BaseException {
            readonly name: "ConflictException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ConflictException, __BaseException>);
    }
    /**
        * <p>We encountered an unknown error. Try again in a few minutes.</p>
        */
    export class InternalServiceErrorException extends __BaseException {
            readonly name: "InternalServiceErrorException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InternalServiceErrorException, __BaseException>);
    }
    /**
        * <p>The request caused one or more limits to be exceeded.</p>
        */
    export class LimitExceededException extends __BaseException {
            readonly name: "LimitExceededException";
            readonly $fault: "client";
            Message?: string;
            /**
                * <p>For a <code>LimitExceededException</code> error, the type of resource that exceeded the current limit.</p>
                */
            ResourceType?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<LimitExceededException, __BaseException>);
    }
    /**
        * <p>The specified resource doesn't exist.</p>
        */
    export class ResourceNotFoundException extends __BaseException {
            readonly name: "ResourceNotFoundException";
            readonly $fault: "client";
            Message?: string;
            /**
                * <p>For a <code>ResourceNotFoundException</code> error, the type of resource that doesn't exist.</p>
                */
            ResourceType?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>);
    }
    /**
        * <p>The request was throttled. Try again in a few minutes.</p>
        */
    export class ThrottlingException extends __BaseException {
            readonly name: "ThrottlingException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ThrottlingException, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class ValidationException extends __BaseException {
            readonly name: "ValidationException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ValidationException, __BaseException>);
    }
    /**
        * <p>In an
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverEndpoint.html">UpdateResolverEndpoint</a>
        * 			request, information about an IP address to update.</p>
        */
    export interface IpAddressUpdate {
            /**
                * <p>
                *             <i>Only when removing an IP address from a Resolver endpoint</i>: The ID of the IP address that you want to remove.
                * 			To get this ID, use
                * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html">GetResolverEndpoint</a>.</p>
                */
            IpId?: string;
            /**
                * <p>The ID of the subnet that includes the IP address that you want to update. To get this ID, use
                * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html">GetResolverEndpoint</a>.</p>
                */
            SubnetId?: string;
            /**
                * <p>The new IP address.</p>
                */
            Ip?: string;
    }
    export namespace IpAddressUpdate {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: IpAddressUpdate) => any;
    }
    export interface AssociateResolverEndpointIpAddressRequest {
            /**
                * <p>The ID of the Resolver endpoint that you want to associate IP addresses with.</p>
                */
            ResolverEndpointId: string | undefined;
            /**
                * <p>Either the IPv4 address that you want to add to a Resolver endpoint or a subnet ID. If you specify a subnet ID,
                * 			Resolver chooses an IP address for you from the available IPs in the specified subnet.</p>
                */
            IpAddress: IpAddressUpdate | undefined;
    }
    export namespace AssociateResolverEndpointIpAddressRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AssociateResolverEndpointIpAddressRequest) => any;
    }
    export enum ResolverEndpointDirection {
            Inbound = "INBOUND",
            Outbound = "OUTBOUND"
    }
    export enum ResolverEndpointStatus {
            ActionNeeded = "ACTION_NEEDED",
            AutoRecovering = "AUTO_RECOVERING",
            Creating = "CREATING",
            Deleting = "DELETING",
            Operational = "OPERATIONAL",
            Updating = "UPDATING"
    }
    /**
        * <p>In the response to a
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverEndpoint.html">CreateResolverEndpoint</a>,
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DeleteResolverEndpoint.html">DeleteResolverEndpoint</a>,
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html">GetResolverEndpoint</a>,
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html">ListResolverEndpoints</a>,
        * 			or
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverEndpoint.html">UpdateResolverEndpoint</a>
        * 			request, a complex type that contains settings for an existing inbound or outbound Resolver endpoint.</p>
        */
    export interface ResolverEndpoint {
            /**
                * <p>The ID of the Resolver endpoint.</p>
                */
            Id?: string;
            /**
                * <p>A unique string that identifies the request that created the Resolver endpoint. The
                * 				<code>CreatorRequestId</code> allows failed requests to be retried without the risk
                * 			of running the operation twice.</p>
                */
            CreatorRequestId?: string;
            /**
                * <p>The ARN (Amazon Resource Name) for the Resolver endpoint.</p>
                */
            Arn?: string;
            /**
                * <p>The name that you assigned to the Resolver endpoint when you submitted a
                * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverEndpoint.html">CreateResolverEndpoint</a>
                * 			request.</p>
                */
            Name?: string;
            /**
                * <p>The ID of one or more security groups that control access to this VPC. The security group must include one or more inbound rules
                * 			(for inbound endpoints) or outbound rules (for outbound endpoints). Inbound and outbound rules must allow TCP and UDP access.
                * 			For inbound access, open port 53. For outbound access, open the port that you're using for DNS queries on your network.</p>
                */
            SecurityGroupIds?: string[];
            /**
                * <p>Indicates whether the Resolver endpoint allows inbound or outbound DNS queries:</p>
                * 		       <ul>
                *             <li>
                *                <p>
                *                   <code>INBOUND</code>: allows DNS queries to your VPC from your network</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>OUTBOUND</code>: allows DNS queries from your VPC to your network</p>
                *             </li>
                *          </ul>
                */
            Direction?: ResolverEndpointDirection | string;
            /**
                * <p>The number of IP addresses that the Resolver endpoint can use for DNS queries.</p>
                */
            IpAddressCount?: number;
            /**
                * <p>The ID of the VPC that you want to create the Resolver endpoint in.</p>
                */
            HostVPCId?: string;
            /**
                * <p>A code that specifies the current status of the Resolver endpoint. Valid values include the following:</p>
                * 		       <ul>
                *             <li>
                *                <p>
                *                   <code>CREATING</code>: Resolver is creating and configuring one or more Amazon VPC network interfaces
                * 				for this endpoint.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>OPERATIONAL</code>: The Amazon VPC network interfaces for this endpoint are correctly configured and
                * 				able to pass inbound or outbound DNS queries between your network and Resolver.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>UPDATING</code>: Resolver is associating or disassociating one or more network interfaces
                * 				with this endpoint.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>AUTO_RECOVERING</code>: Resolver is trying to recover one or more of the network interfaces
                * 				that are associated with this endpoint. During the recovery process, the endpoint functions with limited capacity because of the
                * 				limit on the number of DNS queries per IP address (per network interface). For the current limit, see
                * 				<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html#limits-api-entities-resolver">Limits on Route 53 Resolver</a>.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ACTION_NEEDED</code>: This endpoint is unhealthy, and Resolver can't automatically recover it.
                * 				To resolve the problem, we recommend that you check each IP address that you associated with the endpoint. For each IP address
                * 				that isn't available, add another IP address and then delete the IP address that isn't available. (An endpoint must always include
                * 				at least two IP addresses.) A status of <code>ACTION_NEEDED</code> can have a variety of causes. Here are two common causes:</p>
                * 				           <ul>
                *                   <li>
                *                      <p>One or more of the network interfaces that are associated with the endpoint were deleted using Amazon VPC.</p>
                *                   </li>
                *                   <li>
                *                      <p>The network interface couldn't be created for some reason that's outside the control of Resolver.</p>
                *                   </li>
                *                </ul>
                * 			         </li>
                *             <li>
                *                <p>
                *                   <code>DELETING</code>: Resolver is deleting this endpoint and the associated network interfaces.</p>
                *             </li>
                *          </ul>
                */
            Status?: ResolverEndpointStatus | string;
            /**
                * <p>A detailed description of the status of the Resolver endpoint.</p>
                */
            StatusMessage?: string;
            /**
                * <p>The date and time that the endpoint was created, in Unix time format and Coordinated Universal Time (UTC).</p>
                */
            CreationTime?: string;
            /**
                * <p>The date and time that the endpoint was last modified, in Unix time format and Coordinated Universal Time (UTC).</p>
                */
            ModificationTime?: string;
    }
    export namespace ResolverEndpoint {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResolverEndpoint) => any;
    }
    export interface AssociateResolverEndpointIpAddressResponse {
            /**
                * <p>The response to an <code>AssociateResolverEndpointIpAddress</code> request.</p>
                */
            ResolverEndpoint?: ResolverEndpoint;
    }
    export namespace AssociateResolverEndpointIpAddressResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AssociateResolverEndpointIpAddressResponse) => any;
    }
    /**
        * <p>One or more parameters in this request are not valid.</p>
        */
    export class InvalidParameterException extends __BaseException {
            readonly name: "InvalidParameterException";
            readonly $fault: "client";
            Message: string | undefined;
            /**
                * <p>For an <code>InvalidParameterException</code> error, the name of the parameter that's invalid.</p>
                */
            FieldName?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidParameterException, __BaseException>);
    }
    /**
        * <p>The request is invalid.</p>
        */
    export class InvalidRequestException extends __BaseException {
            readonly name: "InvalidRequestException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidRequestException, __BaseException>);
    }
    /**
        * <p>The resource that you tried to create already exists.</p>
        */
    export class ResourceExistsException extends __BaseException {
            readonly name: "ResourceExistsException";
            readonly $fault: "client";
            Message?: string;
            /**
                * <p>For a <code>ResourceExistsException</code> error, the type of resource that the error applies to.</p>
                */
            ResourceType?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceExistsException, __BaseException>);
    }
    export interface AssociateResolverQueryLogConfigRequest {
            /**
                * <p>The ID of the query logging configuration that you want to associate a VPC with.</p>
                */
            ResolverQueryLogConfigId: string | undefined;
            /**
                * <p>The ID of an Amazon VPC that you want this query logging configuration to log queries for.</p>
                *
                * 		       <note>
                * 			         <p>The VPCs and the query logging configuration must be in the same Region.</p>
                * 		       </note>
                */
            ResourceId: string | undefined;
    }
    export namespace AssociateResolverQueryLogConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AssociateResolverQueryLogConfigRequest) => any;
    }
    export enum ResolverQueryLogConfigAssociationError {
            AccessDenied = "ACCESS_DENIED",
            DestinationNotFound = "DESTINATION_NOT_FOUND",
            InternalServiceError = "INTERNAL_SERVICE_ERROR",
            None = "NONE"
    }
    export enum ResolverQueryLogConfigAssociationStatus {
            ActionNeeded = "ACTION_NEEDED",
            Active = "ACTIVE",
            Creating = "CREATING",
            Deleting = "DELETING",
            Failed = "FAILED"
    }
    /**
        * <p>In the response to an
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverQueryLogConfig.html">AssociateResolverQueryLogConfig</a>,
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverQueryLogConfig.html">DisassociateResolverQueryLogConfig</a>,
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverQueryLogConfigAssociation.html">GetResolverQueryLogConfigAssociation</a>,
        * 			or
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigAssociations.html">ListResolverQueryLogConfigAssociations</a>,
        * 			request, a complex type that contains settings for a specified association between an Amazon VPC and a query logging configuration.</p>
        */
    export interface ResolverQueryLogConfigAssociation {
            /**
                * <p>The ID of the query logging association.</p>
                */
            Id?: string;
            /**
                * <p>The ID of the query logging configuration that a VPC is associated with.</p>
                */
            ResolverQueryLogConfigId?: string;
            /**
                * <p>The ID of the Amazon VPC that is associated with the query logging configuration.</p>
                */
            ResourceId?: string;
            /**
                * <p>The status of the specified query logging association. Valid values include the following:</p>
                * 		       <ul>
                *             <li>
                *                <p>
                *                   <code>CREATING</code>: Resolver is creating an association between an Amazon VPC and a query logging configuration.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>CREATED</code>: The association between an Amazon VPC and a query logging configuration
                * 				was successfully created. Resolver is logging queries that originate in the specified VPC.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>DELETING</code>: Resolver is deleting this query logging association.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>FAILED</code>: Resolver either couldn't create or couldn't delete the query logging association.</p>
                *             </li>
                *          </ul>
                */
            Status?: ResolverQueryLogConfigAssociationStatus | string;
            /**
                * <p>If the value of <code>Status</code> is <code>FAILED</code>, the value of <code>Error</code> indicates the cause:</p>
                * 		       <ul>
                *             <li>
                *                <p>
                *                   <code>DESTINATION_NOT_FOUND</code>: The specified destination (for example, an Amazon S3 bucket) was deleted.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ACCESS_DENIED</code>: Permissions don't allow sending logs to the destination.</p>
                *             </li>
                *          </ul>
                * 		       <p>If the value of <code>Status</code> is a value other than <code>FAILED</code>, <code>Error</code> is null. </p>
                */
            Error?: ResolverQueryLogConfigAssociationError | string;
            /**
                * <p>Contains additional information about the error. If the value or <code>Error</code> is null, the value of <code>ErrorMessage</code> also is null.</p>
                */
            ErrorMessage?: string;
            /**
                * <p>The date and time that the VPC was associated with the query logging configuration, in Unix time format and Coordinated Universal Time (UTC).</p>
                */
            CreationTime?: string;
    }
    export namespace ResolverQueryLogConfigAssociation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResolverQueryLogConfigAssociation) => any;
    }
    export interface AssociateResolverQueryLogConfigResponse {
            /**
                * <p>A complex type that contains settings for a specified association between an Amazon VPC and a query logging configuration.</p>
                */
            ResolverQueryLogConfigAssociation?: ResolverQueryLogConfigAssociation;
    }
    export namespace AssociateResolverQueryLogConfigResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AssociateResolverQueryLogConfigResponse) => any;
    }
    export interface AssociateResolverRuleRequest {
            /**
                * <p>The ID of the Resolver rule that you want to associate with the VPC. To list the existing Resolver rules, use
                * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html">ListResolverRules</a>.</p>
                */
            ResolverRuleId: string | undefined;
            /**
                * <p>A name for the association that you're creating between a Resolver rule and a VPC.</p>
                */
            Name?: string;
            /**
                * <p>The ID of the VPC that you want to associate the Resolver rule with.</p>
                */
            VPCId: string | undefined;
    }
    export namespace AssociateResolverRuleRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AssociateResolverRuleRequest) => any;
    }
    export enum ResolverRuleAssociationStatus {
            Complete = "COMPLETE",
            Creating = "CREATING",
            Deleting = "DELETING",
            Failed = "FAILED",
            Overridden = "OVERRIDDEN"
    }
    /**
        * <p>In the response to an
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverRule.html">AssociateResolverRule</a>,
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverRule.html">DisassociateResolverRule</a>,
        * 			or
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html">ListResolverRuleAssociations</a>
        * 			request, provides information about an association between a Resolver rule and a VPC.
        * 			The association determines which DNS queries that originate in the VPC are forwarded to your network. </p>
        */
    export interface ResolverRuleAssociation {
            /**
                * <p>The ID of the association between a Resolver rule and a VPC. Resolver assigns this value when you submit an
                * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverRule.html">AssociateResolverRule</a>
                * 			request.</p>
                */
            Id?: string;
            /**
                * <p>The ID of the Resolver rule that you associated with the VPC that is specified by <code>VPCId</code>.</p>
                */
            ResolverRuleId?: string;
            /**
                * <p>The name of an association between a Resolver rule and a VPC.</p>
                */
            Name?: string;
            /**
                * <p>The ID of the VPC that you associated the Resolver rule with.</p>
                */
            VPCId?: string;
            /**
                * <p>A code that specifies the current status of the association between a Resolver rule and a VPC.</p>
                */
            Status?: ResolverRuleAssociationStatus | string;
            /**
                * <p>A detailed description of the status of the association between a Resolver rule and a VPC.</p>
                */
            StatusMessage?: string;
    }
    export namespace ResolverRuleAssociation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResolverRuleAssociation) => any;
    }
    export interface AssociateResolverRuleResponse {
            /**
                * <p>Information about the <code>AssociateResolverRule</code> request, including the status of the request.</p>
                */
            ResolverRuleAssociation?: ResolverRuleAssociation;
    }
    export namespace AssociateResolverRuleResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AssociateResolverRuleResponse) => any;
    }
    /**
        * <p>The specified resource isn't available.</p>
        */
    export class ResourceUnavailableException extends __BaseException {
            readonly name: "ResourceUnavailableException";
            readonly $fault: "client";
            Message?: string;
            /**
                * <p>For a <code>ResourceUnavailableException</code> error, the type of resource that isn't available.</p>
                */
            ResourceType?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceUnavailableException, __BaseException>);
    }
    export enum AutodefinedReverseFlag {
            DISABLE = "DISABLE",
            ENABLE = "ENABLE"
    }
    export enum BlockOverrideDnsType {
            CNAME = "CNAME"
    }
    export enum BlockResponse {
            NODATA = "NODATA",
            NXDOMAIN = "NXDOMAIN",
            OVERRIDE = "OVERRIDE"
    }
    export interface CreateFirewallDomainListRequest {
            /**
                * <p>A unique string that identifies the request and that allows you to retry failed requests
                * 			without the risk of running the operation twice. <code>CreatorRequestId</code> can be
                * 			any unique string, for example, a date/time stamp. </p>
                */
            CreatorRequestId?: string;
            /**
                * <p>A name that lets you identify the domain list to manage and use it.</p>
                */
            Name: string | undefined;
            /**
                * <p>A list of the tag keys and values that you want to associate with the domain list. </p>
                */
            Tags?: Tag[];
    }
    export namespace CreateFirewallDomainListRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateFirewallDomainListRequest) => any;
    }
    export enum FirewallDomainListStatus {
            COMPLETE = "COMPLETE",
            COMPLETE_IMPORT_FAILED = "COMPLETE_IMPORT_FAILED",
            DELETING = "DELETING",
            IMPORTING = "IMPORTING",
            UPDATING = "UPDATING"
    }
    /**
        * <p>High-level information about a list of firewall domains for use in a <a>FirewallRule</a>. This is returned by <a>GetFirewallDomainList</a>.</p>
        *          <p>To retrieve the domains that are defined for this domain list, call <a>ListFirewallDomains</a>.</p>
        */
    export interface FirewallDomainList {
            /**
                * <p>The ID of the domain list. </p>
                */
            Id?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the firewall domain list.</p>
                */
            Arn?: string;
            /**
                * <p>The name of the domain list. </p>
                */
            Name?: string;
            /**
                * <p>The number of domain names that are specified in the domain list.</p>
                */
            DomainCount?: number;
            /**
                * <p>The status of the domain list.  </p>
                */
            Status?: FirewallDomainListStatus | string;
            /**
                * <p>Additional information about the status of the list, if available.</p>
                */
            StatusMessage?: string;
            /**
                * <p>The owner of the list, used only for lists that are not managed by you. For example, the managed domain list <code>AWSManagedDomainsMalwareDomainList</code> has the managed owner name <code>Route 53 Resolver DNS Firewall</code>.</p>
                */
            ManagedOwnerName?: string;
            /**
                * <p>A unique string defined by you to identify the request. This allows you to retry failed
                * 			requests without the risk of running the operation twice. This can be any unique string,
                * 			for example, a timestamp. </p>
                */
            CreatorRequestId?: string;
            /**
                * <p>The date and time that the domain list was created, in Unix time format and Coordinated Universal Time (UTC). </p>
                */
            CreationTime?: string;
            /**
                * <p>The date and time that the domain list was last modified, in Unix time format and Coordinated Universal Time (UTC). </p>
                */
            ModificationTime?: string;
    }
    export namespace FirewallDomainList {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FirewallDomainList) => any;
    }
    export interface CreateFirewallDomainListResponse {
            /**
                * <p>The
                * 			domain list that you just created.</p>
                */
            FirewallDomainList?: FirewallDomainList;
    }
    export namespace CreateFirewallDomainListResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateFirewallDomainListResponse) => any;
    }
    export interface CreateFirewallRuleRequest {
            /**
                * <p>A unique string that identifies the request and that allows you to retry failed requests
                * 			without the risk of running the operation twice. <code>CreatorRequestId</code> can be
                * 			any unique string, for example, a date/time stamp. </p>
                */
            CreatorRequestId?: string;
            /**
                * <p>The unique identifier of the firewall rule group where you want to create the rule. </p>
                */
            FirewallRuleGroupId: string | undefined;
            /**
                * <p>The ID of the domain list that you want to use in the rule. </p>
                */
            FirewallDomainListId: string | undefined;
            /**
                * <p>The setting that determines the processing order of the rule in the rule group. DNS Firewall
                *            processes the rules in a rule group by order of priority, starting from the lowest setting.</p>
                *          <p>You must specify a unique priority for each rule in a rule group.
                *            To make it easier to insert rules later, leave space between the numbers, for example, use 100, 200, and so on. You
                *    can change the priority setting for the rules in a rule group at any time.</p>
                */
            Priority: number | undefined;
            /**
                * <p>The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>ALLOW</code> - Permit the request to go through.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ALERT</code> - Permit the request and send metrics and logs to Cloud Watch.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>BLOCK</code> - Disallow the request. This option requires additional details in the rule's <code>BlockResponse</code>. </p>
                *             </li>
                *          </ul>
                */
            Action: Action | string | undefined;
            /**
                * <p>The way that you want DNS Firewall to block the request, used with the rule action
                * 			setting <code>BLOCK</code>. </p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>NODATA</code> - Respond indicating that the query was successful, but no response is available for it.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>NXDOMAIN</code> - Respond indicating that the domain name that's in the query doesn't exist.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>OVERRIDE</code> - Provide a custom override in the response. This option requires custom handling details in the rule's <code>BlockOverride*</code> settings. </p>
                *             </li>
                *          </ul>
                *          <p>This setting is required if the rule action setting is <code>BLOCK</code>.</p>
                */
            BlockResponse?: BlockResponse | string;
            /**
                * <p>The custom DNS record to send back in response to the query. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
                *          <p>This setting is required if the <code>BlockResponse</code> setting is <code>OVERRIDE</code>.</p>
                */
            BlockOverrideDomain?: string;
            /**
                * <p>The DNS record's type. This determines the format of the record value that you provided in <code>BlockOverrideDomain</code>. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
                *          <p>This setting is required if the <code>BlockResponse</code> setting is <code>OVERRIDE</code>.</p>
                */
            BlockOverrideDnsType?: BlockOverrideDnsType | string;
            /**
                * <p>The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
                *          <p>This setting is required if the <code>BlockResponse</code> setting is <code>OVERRIDE</code>.</p>
                */
            BlockOverrideTtl?: number;
            /**
                * <p>A name that lets you identify the rule in the rule group.</p>
                */
            Name: string | undefined;
    }
    export namespace CreateFirewallRuleRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateFirewallRuleRequest) => any;
    }
    /**
        * <p>A single firewall rule in a rule group.</p>
        */
    export interface FirewallRule {
            /**
                * <p>The unique identifier of the firewall rule group of the rule. </p>
                */
            FirewallRuleGroupId?: string;
            /**
                * <p>The ID of the domain list that's used in the rule. </p>
                */
            FirewallDomainListId?: string;
            /**
                * <p>The name of the rule. </p>
                */
            Name?: string;
            /**
                * <p>The priority of the rule in the rule group. This value must be unique within the rule group. DNS Firewall processes the rules in a rule group by order of priority, starting from the lowest setting.</p>
                */
            Priority?: number;
            /**
                * <p>The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>ALLOW</code> - Permit the request to go through.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ALERT</code> - Permit the request to go through but send an alert to the logs.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>BLOCK</code> - Disallow the request. If this is specified, additional handling details are provided in the rule's <code>BlockResponse</code> setting. </p>
                *             </li>
                *          </ul>
                */
            Action?: Action | string;
            /**
                * <p>The way that you want DNS Firewall to block the request. Used for the rule action setting <code>BLOCK</code>.</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>NODATA</code> - Respond indicating that the query was successful, but no response is available for it.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>NXDOMAIN</code> - Respond indicating that the domain name that's in the query doesn't exist.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>OVERRIDE</code> - Provide a custom override in the response. This option requires custom handling details in the rule's <code>BlockOverride*</code> settings. </p>
                *             </li>
                *          </ul>
                */
            BlockResponse?: BlockResponse | string;
            /**
                * <p>The custom DNS record to send back in response to the query. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
                */
            BlockOverrideDomain?: string;
            /**
                * <p>The DNS record's type. This determines the format of the record value that you provided in <code>BlockOverrideDomain</code>. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
                */
            BlockOverrideDnsType?: BlockOverrideDnsType | string;
            /**
                * <p>The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
                */
            BlockOverrideTtl?: number;
            /**
                * <p>A unique string defined by you to identify the request. This allows you to retry failed requests
                *            without the risk of executing the operation twice. This can be any unique string, for example, a timestamp. </p>
                */
            CreatorRequestId?: string;
            /**
                * <p>The date and time that the rule was created, in Unix time format and Coordinated Universal Time (UTC). </p>
                */
            CreationTime?: string;
            /**
                * <p>The date and time that the rule was last modified, in Unix time format and Coordinated Universal Time (UTC).</p>
                */
            ModificationTime?: string;
    }
    export namespace FirewallRule {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FirewallRule) => any;
    }
    export interface CreateFirewallRuleResponse {
            /**
                * <p>The
                * 			firewall rule that you just created. </p>
                */
            FirewallRule?: FirewallRule;
    }
    export namespace CreateFirewallRuleResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateFirewallRuleResponse) => any;
    }
    export interface CreateFirewallRuleGroupRequest {
            /**
                * <p>A unique string defined by you to identify the request. This allows you to retry failed
                * 			requests without the risk of running the operation twice. This can be any unique string,
                * 			for example, a timestamp. </p>
                */
            CreatorRequestId?: string;
            /**
                * <p>A name that lets you identify the rule group, to manage and use it.</p>
                */
            Name: string | undefined;
            /**
                * <p>A list of the tag keys and values that you want to associate with the rule group. </p>
                */
            Tags?: Tag[];
    }
    export namespace CreateFirewallRuleGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateFirewallRuleGroupRequest) => any;
    }
    export enum ShareStatus {
            NotShared = "NOT_SHARED",
            SharedByMe = "SHARED_BY_ME",
            SharedWithMe = "SHARED_WITH_ME"
    }
    export enum FirewallRuleGroupStatus {
            COMPLETE = "COMPLETE",
            DELETING = "DELETING",
            UPDATING = "UPDATING"
    }
    /**
        * <p>High-level information for a firewall rule group. A firewall rule group is a collection of rules that DNS Firewall uses to filter DNS network traffic for a VPC. To retrieve the rules for the rule group, call <a>ListFirewallRules</a>.</p>
        */
    export interface FirewallRuleGroup {
            /**
                * <p>The ID of the rule group. </p>
                */
            Id?: string;
            /**
                * <p>The ARN (Amazon Resource Name) of the rule group.</p>
                */
            Arn?: string;
            /**
                * <p>The name of the rule group.</p>
                */
            Name?: string;
            /**
                * <p>The number of rules in the rule group.</p>
                */
            RuleCount?: number;
            /**
                * <p>The status of the domain list.  </p>
                */
            Status?: FirewallRuleGroupStatus | string;
            /**
                * <p>Additional information about the status of the rule group, if available.</p>
                */
            StatusMessage?: string;
            /**
                * <p>The Amazon Web Services account ID for the account that created the rule group. When a rule group is shared with your account,
                *        this is the account that has shared the rule group with you.  </p>
                */
            OwnerId?: string;
            /**
                * <p>A unique string defined by you to identify the request. This allows you to retry failed
                * 			requests without the risk of running the operation twice. This can be any unique string,
                * 			for example, a timestamp. </p>
                */
            CreatorRequestId?: string;
            /**
                * <p>Whether the rule group is shared with other Amazon Web Services accounts, or was shared with the current account by another
                *               Amazon Web Services account. Sharing is configured through Resource Access Manager (RAM).</p>
                */
            ShareStatus?: ShareStatus | string;
            /**
                * <p>The date and time that the rule group was created, in Unix time format and Coordinated Universal Time (UTC). </p>
                */
            CreationTime?: string;
            /**
                * <p>The date and time that the rule group was last modified, in Unix time format and Coordinated Universal Time (UTC).</p>
                */
            ModificationTime?: string;
    }
    export namespace FirewallRuleGroup {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FirewallRuleGroup) => any;
    }
    export interface CreateFirewallRuleGroupResponse {
            /**
                * <p>A collection of rules used to filter DNS network traffic. </p>
                */
            FirewallRuleGroup?: FirewallRuleGroup;
    }
    export namespace CreateFirewallRuleGroupResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateFirewallRuleGroupResponse) => any;
    }
    /**
        * <p>In a
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverEndpoint.html">CreateResolverEndpoint</a>
        * 			request, the IP address that DNS queries originate from (for outbound endpoints) or that you forward DNS queries to (for inbound endpoints).
        * 			<code>IpAddressRequest</code> also includes the ID of the subnet that contains the IP address.</p>
        */
    export interface IpAddressRequest {
            /**
                * <p>The ID of the subnet that contains the IP address. </p>
                */
            SubnetId: string | undefined;
            /**
                * <p>The IP address that you want to use for DNS queries.</p>
                */
            Ip?: string;
    }
    export namespace IpAddressRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: IpAddressRequest) => any;
    }
    export interface CreateResolverEndpointRequest {
            /**
                * <p>A unique string that identifies the request and that allows failed requests to be retried
                * 			without the risk of running the operation twice. <code>CreatorRequestId</code> can be
                * 			any unique string, for example, a date/time stamp. </p>
                */
            CreatorRequestId: string | undefined;
            /**
                * <p>A friendly name that lets you easily find a configuration in the Resolver dashboard in the Route 53 console.</p>
                */
            Name?: string;
            /**
                * <p>The ID of one or more security groups that you want to use to control access to this VPC. The security group that you specify
                * 			must include one or more inbound rules (for inbound Resolver endpoints) or outbound rules (for outbound Resolver endpoints).
                * 			Inbound and outbound rules must allow TCP and UDP access. For inbound access, open port 53. For outbound access, open the port
                * 			that you're using for DNS queries on your network.</p>
                */
            SecurityGroupIds: string[] | undefined;
            /**
                * <p>Specify the applicable value:</p>
                * 		       <ul>
                *             <li>
                *                <p>
                *                   <code>INBOUND</code>: Resolver forwards DNS queries to the DNS service for a VPC from your network</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>OUTBOUND</code>: Resolver forwards DNS queries from the DNS service for a VPC to your network</p>
                *             </li>
                *          </ul>
                */
            Direction: ResolverEndpointDirection | string | undefined;
            /**
                * <p>The subnets and IP addresses in your VPC that DNS queries originate from (for outbound endpoints) or that you forward
                * 			DNS queries to (for inbound endpoints). The subnet ID uniquely identifies a VPC. </p>
                */
            IpAddresses: IpAddressRequest[] | undefined;
            /**
                * <p>A list of the tag keys and values that you want to associate with the endpoint.</p>
                */
            Tags?: Tag[];
    }
    export namespace CreateResolverEndpointRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateResolverEndpointRequest) => any;
    }
    export interface CreateResolverEndpointResponse {
            /**
                * <p>Information about the <code>CreateResolverEndpoint</code> request, including the status of the request.</p>
                */
            ResolverEndpoint?: ResolverEndpoint;
    }
    export namespace CreateResolverEndpointResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateResolverEndpointResponse) => any;
    }
    export interface CreateResolverQueryLogConfigRequest {
            /**
                * <p>The name that you want to give the query logging configuration.</p>
                */
            Name: string | undefined;
            /**
                * <p>The ARN of the resource that you want Resolver to send query logs. You can send query logs to an S3 bucket, a CloudWatch Logs log group,
                * 			or a Kinesis Data Firehose delivery stream. Examples of valid values include the following:</p>
                *
                * 		       <ul>
                *             <li>
                * 				           <p>
                *                   <b>S3 bucket</b>: </p>
                * 				           <p>
                *                   <code>arn:aws:s3:::examplebucket</code>
                *                </p>
                * 				           <p>You can optionally append a file prefix to the end of the ARN.</p>
                * 				           <p>
                *                   <code>arn:aws:s3:::examplebucket/development/</code>
                *                </p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <b>CloudWatch Logs log group</b>: </p>
                * 				           <p>
                *                   <code>arn:aws:logs:us-west-1:123456789012:log-group:/mystack-testgroup-12ABC1AB12A1:*</code>
                *                </p>
                * 			         </li>
                *             <li>
                * 				           <p>
                *                   <b>Kinesis Data Firehose delivery stream</b>:</p>
                * 				           <p>
                *                   <code>arn:aws:kinesis:us-east-2:0123456789:stream/my_stream_name</code>
                *                </p>
                * 			         </li>
                *          </ul>
                */
            DestinationArn: string | undefined;
            /**
                * <p>A unique string that identifies the request and that allows failed requests to be retried
                * 			without the risk of running the operation twice. <code>CreatorRequestId</code> can be
                * 			any unique string, for example, a date/time stamp. </p>
                */
            CreatorRequestId?: string;
            /**
                * <p>A list of the tag keys and values that you want to associate with the query logging configuration.</p>
                */
            Tags?: Tag[];
    }
    export namespace CreateResolverQueryLogConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateResolverQueryLogConfigRequest) => any;
    }
    export enum ResolverQueryLogConfigStatus {
            Created = "CREATED",
            Creating = "CREATING",
            Deleting = "DELETING",
            Failed = "FAILED"
    }
    /**
        * <p>In the response to a
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverQueryLogConfig.html">CreateResolverQueryLogConfig</a>,
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DeleteResolverQueryLogConfig.html">DeleteResolverQueryLogConfig</a>,
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverQueryLogConfig.html">GetResolverQueryLogConfig</a>,
        * 			or
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigs.html">ListResolverQueryLogConfigs</a>
        * 			request, a complex type that contains settings for one query logging configuration.</p>
        */
    export interface ResolverQueryLogConfig {
            /**
                * <p>The ID for the query logging configuration.</p>
                */
            Id?: string;
            /**
                * <p>The Amazon Web Services account ID for the account that created the query logging configuration. </p>
                */
            OwnerId?: string;
            /**
                * <p>The status of the specified query logging configuration. Valid values include the following:</p>
                * 		       <ul>
                *             <li>
                *                <p>
                *                   <code>CREATING</code>: Resolver is creating the query logging configuration.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>CREATED</code>: The query logging configuration was successfully created.
                * 				Resolver is logging queries that originate in the specified VPC.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>DELETING</code>: Resolver is deleting this query logging configuration.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>FAILED</code>: Resolver can't deliver logs to the location that is specified in the query logging configuration.
                * 				Here are two common causes:</p>
                * 				           <ul>
                *                   <li>
                *                      <p>The specified destination (for example, an Amazon S3 bucket) was deleted.</p>
                *                   </li>
                *                   <li>
                *                      <p>Permissions don't allow sending logs to the destination.</p>
                *                   </li>
                *                </ul>
                * 			         </li>
                *          </ul>
                */
            Status?: ResolverQueryLogConfigStatus | string;
            /**
                * <p>An indication of whether the query logging configuration is shared with other Amazon Web Services accounts, or was shared with the current account by another
                * 			Amazon Web Services account. Sharing is configured through Resource Access Manager (RAM).</p>
                */
            ShareStatus?: ShareStatus | string;
            /**
                * <p>The number of VPCs that are associated with the query logging configuration.</p>
                */
            AssociationCount?: number;
            /**
                * <p>The ARN for the query logging configuration.</p>
                */
            Arn?: string;
            /**
                * <p>The name of the query logging configuration. </p>
                */
            Name?: string;
            /**
                * <p>The ARN of the resource that you want Resolver to send query logs: an Amazon S3 bucket, a CloudWatch Logs log group, or
                * 			a Kinesis Data Firehose delivery stream.</p>
                */
            DestinationArn?: string;
            /**
                * <p>A unique string that identifies the request that created the query logging configuration.
                * 			The <code>CreatorRequestId</code> allows failed requests to be retried without the risk
                * 			of running the operation twice.</p>
                */
            CreatorRequestId?: string;
            /**
                * <p>The date and time that the query logging configuration was created, in Unix time format and Coordinated Universal Time (UTC).</p>
                */
            CreationTime?: string;
    }
    export namespace ResolverQueryLogConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResolverQueryLogConfig) => any;
    }
    export interface CreateResolverQueryLogConfigResponse {
            /**
                * <p>Information about the <code>CreateResolverQueryLogConfig</code> request, including the status of the request.</p>
                */
            ResolverQueryLogConfig?: ResolverQueryLogConfig;
    }
    export namespace CreateResolverQueryLogConfigResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateResolverQueryLogConfigResponse) => any;
    }
    export enum RuleTypeOption {
            Forward = "FORWARD",
            Recursive = "RECURSIVE",
            System = "SYSTEM"
    }
    /**
        * <p>In a
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverRule.html">CreateResolverRule</a>
        * 			request, an array of the IPs that you want to forward DNS queries to.</p>
        */
    export interface TargetAddress {
            /**
                * <p>One IP address that you want to forward DNS queries to. You can specify only IPv4 addresses.</p>
                */
            Ip: string | undefined;
            /**
                * <p>The port at <code>Ip</code> that you want to forward DNS queries to.</p>
                */
            Port?: number;
    }
    export namespace TargetAddress {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TargetAddress) => any;
    }
    export interface CreateResolverRuleRequest {
            /**
                * <p>A unique string that identifies the request and that allows failed requests to be retried
                * 			without the risk of running the operation twice. <code>CreatorRequestId</code> can be
                * 			any unique string, for example, a date/time stamp. </p>
                */
            CreatorRequestId: string | undefined;
            /**
                * <p>A friendly name that lets you easily find a rule in the Resolver dashboard in the Route 53 console.</p>
                */
            Name?: string;
            /**
                * <p>When you want to forward DNS queries for specified domain name to resolvers on your network, specify <code>FORWARD</code>.</p>
                * 		       <p>When you have a forwarding rule to forward DNS queries for a domain to your network and you want Resolver to process queries for
                * 			a subdomain of that domain, specify <code>SYSTEM</code>.</p>
                * 		       <p>For example, to forward DNS queries for example.com to resolvers on your network, you create a rule and specify <code>FORWARD</code>
                * 			for <code>RuleType</code>. To then have Resolver process queries for apex.example.com, you create a rule and specify
                * 			<code>SYSTEM</code> for <code>RuleType</code>.</p>
                * 		       <p>Currently, only Resolver can create rules that have a value of <code>RECURSIVE</code> for <code>RuleType</code>.</p>
                */
            RuleType: RuleTypeOption | string | undefined;
            /**
                * <p>DNS queries for this domain name are forwarded to the IP addresses that you specify in <code>TargetIps</code>. If a query matches
                * 			multiple Resolver rules (example.com and www.example.com), outbound DNS queries are routed using the Resolver rule that contains
                * 			the most specific domain name (www.example.com).</p>
                */
            DomainName: string | undefined;
            /**
                * <p>The IPs that you want Resolver to forward DNS queries to. You can specify only IPv4 addresses. Separate IP addresses with a space.</p>
                * 		       <p>
                *             <code>TargetIps</code> is available only when the value of <code>Rule type</code> is <code>FORWARD</code>.</p>
                */
            TargetIps?: TargetAddress[];
            /**
                * <p>The ID of the outbound Resolver endpoint that you want to use to route DNS queries to the IP addresses that you specify
                * 			in <code>TargetIps</code>.</p>
                */
            ResolverEndpointId?: string;
            /**
                * <p>A list of the tag keys and values that you want to associate with the endpoint.</p>
                */
            Tags?: Tag[];
    }
    export namespace CreateResolverRuleRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateResolverRuleRequest) => any;
    }
    export enum ResolverRuleStatus {
            Complete = "COMPLETE",
            Deleting = "DELETING",
            Failed = "FAILED",
            Updating = "UPDATING"
    }
    /**
        * <p>For queries that originate in your VPC, detailed information about a Resolver rule, which specifies how to route DNS queries
        * 			out of the VPC. The <code>ResolverRule</code> parameter appears in the response to a
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverRule.html">CreateResolverRule</a>,
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DeleteResolverRule.html">DeleteResolverRule</a>,
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRule.html">GetResolverRule</a>,
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html">ListResolverRules</a>,
        * 			or
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverRule.html">UpdateResolverRule</a> request.</p>
        */
    export interface ResolverRule {
            /**
                * <p>The ID that Resolver assigned to the Resolver rule when you created it.</p>
                */
            Id?: string;
            /**
                * <p>A unique string that you specified when you created the Resolver rule.
                * 				<code>CreatorRequestId</code> identifies the request and allows failed requests to
                * 			be retried without the risk of running the operation twice. </p>
                */
            CreatorRequestId?: string;
            /**
                * <p>The ARN (Amazon Resource Name) for the Resolver rule specified by <code>Id</code>.</p>
                */
            Arn?: string;
            /**
                * <p>DNS queries for this domain name are forwarded to the IP addresses that are specified in <code>TargetIps</code>. If a query matches
                * 			multiple Resolver rules (example.com and www.example.com), the query is routed using the Resolver rule that contains the most specific domain name
                * 			(www.example.com).</p>
                */
            DomainName?: string;
            /**
                * <p>A code that specifies the current status of the Resolver rule.</p>
                */
            Status?: ResolverRuleStatus | string;
            /**
                * <p>A detailed description of the status of a Resolver rule.</p>
                */
            StatusMessage?: string;
            /**
                * <p>When you want to forward DNS queries for specified domain name to resolvers on your network, specify <code>FORWARD</code>.</p>
                * 		       <p>When you have a forwarding rule to forward DNS queries for a domain to your network and you want Resolver to process queries for
                * 			a subdomain of that domain, specify <code>SYSTEM</code>.</p>
                * 		       <p>For example, to forward DNS queries for example.com to resolvers on your network, you create a rule and specify <code>FORWARD</code>
                * 			for <code>RuleType</code>. To then have Resolver process queries for apex.example.com, you create a rule and specify
                * 			<code>SYSTEM</code> for <code>RuleType</code>.</p>
                * 		       <p>Currently, only Resolver can create rules that have a value of <code>RECURSIVE</code> for <code>RuleType</code>.</p>
                */
            RuleType?: RuleTypeOption | string;
            /**
                * <p>The name for the Resolver rule, which you specified when you created the Resolver rule.</p>
                */
            Name?: string;
            /**
                * <p>An array that contains the IP addresses and ports that an outbound endpoint forwards DNS queries to. Typically,
                * 			these are the IP addresses of DNS resolvers on your network. Specify IPv4 addresses. IPv6 is not supported.</p>
                */
            TargetIps?: TargetAddress[];
            /**
                * <p>The ID of the endpoint that the rule is associated with.</p>
                */
            ResolverEndpointId?: string;
            /**
                * <p>When a rule is shared with another Amazon Web Services account, the account ID of the account that the rule is shared with.</p>
                */
            OwnerId?: string;
            /**
                * <p>Whether the rule is shared and, if so, whether the current account is sharing the rule with
                * 			another account, or another account is sharing the rule with the current account.</p>
                */
            ShareStatus?: ShareStatus | string;
            /**
                * <p>The date and time that the Resolver rule was created, in Unix time format and Coordinated Universal Time (UTC).</p>
                */
            CreationTime?: string;
            /**
                * <p>The date and time that the Resolver rule was last updated, in Unix time format and Coordinated Universal Time (UTC).</p>
                */
            ModificationTime?: string;
    }
    export namespace ResolverRule {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResolverRule) => any;
    }
    export interface CreateResolverRuleResponse {
            /**
                * <p>Information about the <code>CreateResolverRule</code> request, including the status of the request.</p>
                */
            ResolverRule?: ResolverRule;
    }
    export namespace CreateResolverRuleResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateResolverRuleResponse) => any;
    }
    export interface DeleteFirewallDomainListRequest {
            /**
                * <p>The ID of the domain list that you want to delete. </p>
                */
            FirewallDomainListId: string | undefined;
    }
    export namespace DeleteFirewallDomainListRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteFirewallDomainListRequest) => any;
    }
    export interface DeleteFirewallDomainListResponse {
            /**
                * <p>The domain list that you just deleted. </p>
                */
            FirewallDomainList?: FirewallDomainList;
    }
    export namespace DeleteFirewallDomainListResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteFirewallDomainListResponse) => any;
    }
    export interface DeleteFirewallRuleRequest {
            /**
                * <p>The unique identifier of the firewall rule group that you want to delete the rule from. </p>
                */
            FirewallRuleGroupId: string | undefined;
            /**
                * <p>The ID of the domain list that's used in the rule.  </p>
                */
            FirewallDomainListId: string | undefined;
    }
    export namespace DeleteFirewallRuleRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteFirewallRuleRequest) => any;
    }
    export interface DeleteFirewallRuleResponse {
            /**
                * <p>The specification for the firewall rule that you just deleted.</p>
                */
            FirewallRule?: FirewallRule;
    }
    export namespace DeleteFirewallRuleResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteFirewallRuleResponse) => any;
    }
    export interface DeleteFirewallRuleGroupRequest {
            /**
                * <p>The unique identifier of the firewall rule group that you want to delete. </p>
                */
            FirewallRuleGroupId: string | undefined;
    }
    export namespace DeleteFirewallRuleGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteFirewallRuleGroupRequest) => any;
    }
    export interface DeleteFirewallRuleGroupResponse {
            /**
                * <p>A collection of rules used to filter DNS network traffic. </p>
                */
            FirewallRuleGroup?: FirewallRuleGroup;
    }
    export namespace DeleteFirewallRuleGroupResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteFirewallRuleGroupResponse) => any;
    }
    export interface DeleteResolverEndpointRequest {
            /**
                * <p>The ID of the Resolver endpoint that you want to delete.</p>
                */
            ResolverEndpointId: string | undefined;
    }
    export namespace DeleteResolverEndpointRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteResolverEndpointRequest) => any;
    }
    export interface DeleteResolverEndpointResponse {
            /**
                * <p>Information about the <code>DeleteResolverEndpoint</code> request, including the status of the request.</p>
                */
            ResolverEndpoint?: ResolverEndpoint;
    }
    export namespace DeleteResolverEndpointResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteResolverEndpointResponse) => any;
    }
    export interface DeleteResolverQueryLogConfigRequest {
            /**
                * <p>The ID of the query logging configuration that you want to delete.</p>
                */
            ResolverQueryLogConfigId: string | undefined;
    }
    export namespace DeleteResolverQueryLogConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteResolverQueryLogConfigRequest) => any;
    }
    export interface DeleteResolverQueryLogConfigResponse {
            /**
                * <p>Information about the query logging configuration that you deleted, including the status of the request.</p>
                */
            ResolverQueryLogConfig?: ResolverQueryLogConfig;
    }
    export namespace DeleteResolverQueryLogConfigResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteResolverQueryLogConfigResponse) => any;
    }
    export interface DeleteResolverRuleRequest {
            /**
                * <p>The ID of the Resolver rule that you want to delete.</p>
                */
            ResolverRuleId: string | undefined;
    }
    export namespace DeleteResolverRuleRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteResolverRuleRequest) => any;
    }
    export interface DeleteResolverRuleResponse {
            /**
                * <p>Information about the <code>DeleteResolverRule</code> request, including the status of the request.</p>
                */
            ResolverRule?: ResolverRule;
    }
    export namespace DeleteResolverRuleResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteResolverRuleResponse) => any;
    }
    /**
        * <p>The resource that you tried to update or delete is currently in use.</p>
        */
    export class ResourceInUseException extends __BaseException {
            readonly name: "ResourceInUseException";
            readonly $fault: "client";
            Message?: string;
            /**
                * <p>For a <code>ResourceInUseException</code> error, the type of resource that is currently in use.</p>
                */
            ResourceType?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceInUseException, __BaseException>);
    }
    export interface DisassociateFirewallRuleGroupRequest {
            /**
                * <p>The identifier of the <a>FirewallRuleGroupAssociation</a>. </p>
                */
            FirewallRuleGroupAssociationId: string | undefined;
    }
    export namespace DisassociateFirewallRuleGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DisassociateFirewallRuleGroupRequest) => any;
    }
    export interface DisassociateFirewallRuleGroupResponse {
            /**
                * <p>The firewall rule group association that you just removed. </p>
                */
            FirewallRuleGroupAssociation?: FirewallRuleGroupAssociation;
    }
    export namespace DisassociateFirewallRuleGroupResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DisassociateFirewallRuleGroupResponse) => any;
    }
    export interface DisassociateResolverEndpointIpAddressRequest {
            /**
                * <p>The ID of the Resolver endpoint that you want to disassociate an IP address from.</p>
                */
            ResolverEndpointId: string | undefined;
            /**
                * <p>The IPv4 address that you want to remove from a Resolver endpoint.</p>
                */
            IpAddress: IpAddressUpdate | undefined;
    }
    export namespace DisassociateResolverEndpointIpAddressRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DisassociateResolverEndpointIpAddressRequest) => any;
    }
    export interface DisassociateResolverEndpointIpAddressResponse {
            /**
                * <p>The response to an <code>DisassociateResolverEndpointIpAddress</code> request.</p>
                */
            ResolverEndpoint?: ResolverEndpoint;
    }
    export namespace DisassociateResolverEndpointIpAddressResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DisassociateResolverEndpointIpAddressResponse) => any;
    }
    export interface DisassociateResolverQueryLogConfigRequest {
            /**
                * <p>The ID of the query logging configuration that you want to disassociate a specified VPC from.</p>
                */
            ResolverQueryLogConfigId: string | undefined;
            /**
                * <p>The ID of the Amazon VPC that you want to disassociate from a specified query logging configuration.</p>
                */
            ResourceId: string | undefined;
    }
    export namespace DisassociateResolverQueryLogConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DisassociateResolverQueryLogConfigRequest) => any;
    }
    export interface DisassociateResolverQueryLogConfigResponse {
            /**
                * <p>A complex type that contains settings for the association that you deleted between an Amazon VPC and a query logging configuration.</p>
                */
            ResolverQueryLogConfigAssociation?: ResolverQueryLogConfigAssociation;
    }
    export namespace DisassociateResolverQueryLogConfigResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DisassociateResolverQueryLogConfigResponse) => any;
    }
    export interface DisassociateResolverRuleRequest {
            /**
                * <p>The ID of the VPC that you want to disassociate the Resolver rule from.</p>
                */
            VPCId: string | undefined;
            /**
                * <p>The ID of the Resolver rule that you want to disassociate from the specified VPC.</p>
                */
            ResolverRuleId: string | undefined;
    }
    export namespace DisassociateResolverRuleRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DisassociateResolverRuleRequest) => any;
    }
    export interface DisassociateResolverRuleResponse {
            /**
                * <p>Information about the <code>DisassociateResolverRule</code> request, including the status of the request.</p>
                */
            ResolverRuleAssociation?: ResolverRuleAssociation;
    }
    export namespace DisassociateResolverRuleResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DisassociateResolverRuleResponse) => any;
    }
    /**
        * <p>For Resolver list operations
        * 			(<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html">ListResolverEndpoints</a>,
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html">ListResolverRules</a>,
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html">ListResolverRuleAssociations</a>,
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigs.html">ListResolverQueryLogConfigs</a>,
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigAssociations.html">ListResolverQueryLogConfigAssociations</a>),
        * 			and
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverDnssecConfigs.html">ListResolverDnssecConfigs</a>),
        * 			an optional specification to return a subset of objects.</p>
        * 		       <p>To filter objects, such as Resolver endpoints or Resolver rules, you specify <code>Name</code> and <code>Values</code>. For example,
        * 			to list only inbound Resolver endpoints, specify <code>Direction</code> for <code>Name</code> and specify <code>INBOUND</code> for <code>Values</code>. </p>
        */
    export interface Filter {
            /**
                * <p>The name of the parameter that you want to use to filter objects.</p>
                * 		       <p>The valid values for <code>Name</code> depend on the action that you're including the filter in,
                * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html">ListResolverEndpoints</a>,
                * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html">ListResolverRules</a>,
                * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html">ListResolverRuleAssociations</a>,
                * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigs.html">ListResolverQueryLogConfigs</a>,
                * 			or
                * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigAssociations.html">ListResolverQueryLogConfigAssociations</a>.</p>
                *
                * 		       <note>
                * 			         <p>In early versions of Resolver, values for <code>Name</code> were listed as uppercase, with underscore (_) delimiters. For example,
                * 				<code>CreatorRequestId</code> was originally listed as <code>CREATOR_REQUEST_ID</code>. Uppercase values for <code>Name</code> are still supported.</p>
                * 		       </note>
                *
                * 		       <p>
                *             <b>ListResolverEndpoints</b>
                *          </p>
                * 		       <p>Valid values for <code>Name</code> include the following:</p>
                * 		       <ul>
                *             <li>
                *                <p>
                *                   <code>CreatorRequestId</code>: The value that you specified when you created the Resolver endpoint.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>Direction</code>: Whether you want to return inbound or outbound Resolver endpoints. If you specify <code>DIRECTION</code>
                * 				for <code>Name</code>, specify <code>INBOUND</code> or <code>OUTBOUND</code> for <code>Values</code>.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>HostVPCId</code>: The ID of the VPC that inbound DNS queries pass through on the way from your network to your VPCs in a region, or
                * 				the VPC that outbound queries pass through on the way from your VPCs to your network. In a
                * 				<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverEndpoint.html">CreateResolverEndpoint</a>
                * 				request, <code>SubnetId</code> indirectly identifies the VPC. In a
                * 				<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html">GetResolverEndpoint</a>
                * 				request, the VPC ID for a Resolver endpoint
                * 				is returned in the <code>HostVPCId</code> element. </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>IpAddressCount</code>: The number of IP addresses that you have associated with the Resolver endpoint.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>Name</code>: The name of the Resolver endpoint.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>SecurityGroupIds</code>: The IDs of the VPC security groups that you specified when you created the
                * 				Resolver endpoint.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>Status</code>: The status of the Resolver endpoint. If you specify <code>Status</code> for <code>Name</code>,
                * 				specify one of the following status codes for <code>Values</code>: <code>CREATING</code>, <code>OPERATIONAL</code>, <code>UPDATING</code>,
                * 				<code>AUTO_RECOVERING</code>, <code>ACTION_NEEDED</code>, or <code>DELETING</code>. For more information, see <code>Status</code> in
                * 				<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ResolverEndpoint.html">ResolverEndpoint</a>.</p>
                *             </li>
                *          </ul>
                *
                * 		       <p>
                *             <b>ListResolverRules</b>
                *          </p>
                * 		       <p>Valid values for <code>Name</code> include the following:</p>
                * 		       <ul>
                *             <li>
                *                <p>
                *                   <code>CreatorRequestId</code>: The value that you specified when you created the Resolver rule.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>DomainName</code>: The domain name for which Resolver is forwarding DNS queries to your network. In the value that
                * 				you specify for <code>Values</code>, include a trailing dot (.) after the domain name. For example, if the domain name is example.com,
                * 				specify the following value. Note the "." after <code>com</code>:</p>
                * 				           <p>
                *                   <code>example.com.</code>
                *                </p>
                * 			         </li>
                *             <li>
                *                <p>
                *                   <code>Name</code>: The name of the Resolver rule.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ResolverEndpointId</code>: The ID of the Resolver endpoint that the Resolver rule is associated with.</p>
                * 				           <note>
                *                   <p>You can filter on the Resolver endpoint only for rules that have a value of <code>FORWARD</code> for
                * 					<code>RuleType</code>.</p>
                *                </note>
                * 			         </li>
                *             <li>
                *                <p>
                *                   <code>Status</code>: The status of the Resolver rule. If you specify <code>Status</code> for <code>Name</code>,
                * 				specify one of the following status codes for <code>Values</code>: <code>COMPLETE</code>, <code>DELETING</code>, <code>UPDATING</code>,
                * 				or <code>FAILED</code>.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>Type</code>: The type of the Resolver rule. If you specify <code>TYPE</code>
                * 				for <code>Name</code>, specify <code>FORWARD</code> or <code>SYSTEM</code> for <code>Values</code>.</p>
                *             </li>
                *          </ul>
                *
                * 		       <p>
                *             <b>ListResolverRuleAssociations</b>
                *          </p>
                * 		       <p>Valid values for <code>Name</code> include the following:</p>
                * 		       <ul>
                *             <li>
                *                <p>
                *                   <code>Name</code>: The name of the Resolver rule association.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ResolverRuleId</code>: The ID of the Resolver rule that is associated with one or more VPCs.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>Status</code>: The status of the Resolver rule association. If you specify <code>Status</code> for <code>Name</code>,
                * 				specify one of the following status codes for <code>Values</code>: <code>CREATING</code>, <code>COMPLETE</code>, <code>DELETING</code>, or
                * 				<code>FAILED</code>.</p>
                * 			         </li>
                *             <li>
                *                <p>
                *                   <code>VPCId</code>: The ID of the VPC that the Resolver rule is associated with.</p>
                *             </li>
                *          </ul>
                *
                * 		       <p>
                *             <b>ListResolverQueryLogConfigs</b>
                *          </p>
                * 		       <p>Valid values for <code>Name</code> include the following:</p>
                * 		       <ul>
                *             <li>
                *                <p>
                *                   <code>Arn</code>: The ARN for the query logging configuration.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>AssociationCount</code>: The number of VPCs that are associated with the query logging configuration.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>CreationTime</code>: The date and time that the query logging configuration was created, in Unix time format and
                * 				Coordinated Universal Time (UTC). </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>CreatorRequestId</code>: A unique string that identifies the request that created the query logging configuration.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>Destination</code>: The Amazon Web Services service that you want to forward query logs to. Valid values include the following:</p>
                * 				           <ul>
                *                   <li>
                *                      <p>
                *                         <code>S3</code>
                *                      </p>
                *                   </li>
                *                   <li>
                *                      <p>
                *                         <code>CloudWatchLogs</code>
                *                      </p>
                *                   </li>
                *                   <li>
                *                      <p>
                *                         <code>KinesisFirehose</code>
                *                      </p>
                *                   </li>
                *                </ul>
                * 			         </li>
                *             <li>
                *                <p>
                *                   <code>DestinationArn</code>: The ARN of the location that Resolver is sending query logs to. This value can be the ARN for an
                * 				S3 bucket, a CloudWatch Logs log group, or a Kinesis Data Firehose delivery stream.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>Id</code>: The ID of the query logging configuration</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>Name</code>: The name of the query logging configuration</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>OwnerId</code>: The Amazon Web Services account ID for the account that created the query logging configuration.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ShareStatus</code>: An indication of whether the query logging configuration is shared with other Amazon Web Services accounts,
                * 				or was shared with the current account by another Amazon Web Services account. Valid values include: <code>NOT_SHARED</code>, <code>SHARED_WITH_ME</code>,
                * 				or <code>SHARED_BY_ME</code>.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>Status</code>: The status of the query logging configuration. If you specify <code>Status</code> for <code>Name</code>,
                * 				specify the applicable status code for <code>Values</code>: <code>CREATING</code>, <code>CREATED</code>,
                * 				<code>DELETING</code>, or <code>FAILED</code>. For more information, see
                * 				<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ResolverQueryLogConfig.html#Route53Resolver-Type-route53resolver_ResolverQueryLogConfig-Status">Status</a>.
                * 				</p>
                * 			         </li>
                *          </ul>
                *
                * 		       <p>
                *             <b>ListResolverQueryLogConfigAssociations</b>
                *          </p>
                * 		       <p>Valid values for <code>Name</code> include the following:</p>
                * 		       <ul>
                *             <li>
                *                <p>
                *                   <code>CreationTime</code>: The date and time that the VPC was associated with the query logging configuration, in Unix time format and
                * 				Coordinated Universal Time (UTC).</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>Error</code>: If the value of <code>Status</code> is <code>FAILED</code>, specify the cause:
                * 				<code>DESTINATION_NOT_FOUND</code> or <code>ACCESS_DENIED</code>.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>Id</code>: The ID of the query logging association.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ResolverQueryLogConfigId</code>: The ID of the query logging configuration that a VPC is associated with.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ResourceId</code>: The ID of the Amazon VPC that is associated with the query logging configuration.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>Status</code>: The status of the query logging association. If you specify <code>Status</code> for <code>Name</code>,
                * 				specify the applicable status code for <code>Values</code>: <code>CREATING</code>, <code>CREATED</code>,
                * 				<code>DELETING</code>, or <code>FAILED</code>. For more information, see
                * 			    <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ResolverQueryLogConfigAssociation.html#Route53Resolver-Type-route53resolver_ResolverQueryLogConfigAssociation-Status">Status</a>.
                * 				</p>
                * 			         </li>
                *          </ul>
                */
            Name?: string;
            /**
                * <p>When you're using a <code>List</code> operation and you want the operation to return a subset of objects, such as Resolver endpoints or Resolver rules,
                * 			the value of the parameter that you want to use to filter objects. For example, to list only inbound Resolver endpoints, specify <code>Direction</code> for
                * 			<code>Name</code> and specify <code>INBOUND</code> for <code>Values</code>.</p>
                */
            Values?: string[];
    }
    export namespace Filter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Filter) => any;
    }
    export enum FirewallFailOpenStatus {
            DISABLED = "DISABLED",
            ENABLED = "ENABLED"
    }
    /**
        * <p>Configuration of the firewall behavior provided by DNS Firewall for a single VPC from
        * 			Amazon Virtual Private Cloud (Amazon VPC). </p>
        */
    export interface FirewallConfig {
            /**
                * <p>The ID of the firewall configuration.</p>
                */
            Id?: string;
            /**
                * <p>The ID of the VPC that this firewall configuration applies to.</p>
                */
            ResourceId?: string;
            /**
                * <p>The Amazon Web Services account ID of the owner of the VPC that this firewall configuration applies to.</p>
                */
            OwnerId?: string;
            /**
                * <p>Determines how DNS Firewall operates during failures, for example when all traffic that is sent to DNS Firewall fails to receive a reply. </p>
                *          <ul>
                *             <li>
                *                <p>By default, fail open is disabled, which means the failure mode is closed. This approach favors security over availability. DNS Firewall returns
                *            a failure error when it is unable to properly evaluate a query. </p>
                *             </li>
                *             <li>
                *                <p>If you enable this option, the failure mode is open. This approach favors availability over security. DNS Firewall allows queries to proceed if it
                *        is unable to properly evaluate them. </p>
                *             </li>
                *          </ul>
                *          <p>This behavior is only enforced for VPCs that have at least one DNS Firewall rule group association. </p>
                */
            FirewallFailOpen?: FirewallFailOpenStatus | string;
    }
    export namespace FirewallConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FirewallConfig) => any;
    }
    export enum FirewallDomainImportOperation {
            REPLACE = "REPLACE"
    }
    /**
        * <p>Minimal high-level information for a firewall domain list. The action <a>ListFirewallDomainLists</a> returns an array of these objects. </p>
        *          <p>To retrieve full information for a firewall domain list, call  <a>GetFirewallDomainList</a> and <a>ListFirewallDomains</a>.</p>
        */
    export interface FirewallDomainListMetadata {
            /**
                * <p>The ID of the domain list. </p>
                */
            Id?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the firewall domain list metadata.</p>
                */
            Arn?: string;
            /**
                * <p>The name of the domain list. </p>
                */
            Name?: string;
            /**
                * <p>A unique string defined by you to identify the request. This allows you to retry failed
                * 			requests without the risk of running the operation twice. This can be any unique string,
                * 			for example, a timestamp. </p>
                */
            CreatorRequestId?: string;
            /**
                * <p>The owner of the list, used only for lists that are not managed by you. For example, the managed domain list <code>AWSManagedDomainsMalwareDomainList</code> has the managed owner name <code>Route 53 Resolver DNS Firewall</code>.</p>
                */
            ManagedOwnerName?: string;
    }
    export namespace FirewallDomainListMetadata {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FirewallDomainListMetadata) => any;
    }
    export enum FirewallDomainUpdateOperation {
            ADD = "ADD",
            REMOVE = "REMOVE",
            REPLACE = "REPLACE"
    }
    /**
        * <p>Minimal high-level information for a firewall rule group. The action <a>ListFirewallRuleGroups</a> returns an array of these objects. </p>
        *          <p>To retrieve full information for a firewall rule group, call <a>GetFirewallRuleGroup</a> and <a>ListFirewallRules</a>.</p>
        */
    export interface FirewallRuleGroupMetadata {
            /**
                * <p>The ID of the rule group. </p>
                */
            Id?: string;
            /**
                * <p>The ARN (Amazon Resource Name) of the rule group.</p>
                */
            Arn?: string;
            /**
                * <p>The name of the rule group.</p>
                */
            Name?: string;
            /**
                * <p>The Amazon Web Services account ID for the account that created the rule group. When a rule group is shared with your account,
                *        this is the account that has shared the rule group with you.  </p>
                */
            OwnerId?: string;
            /**
                * <p>A unique string defined by you to identify the request. This allows you to retry failed
                * 			requests without the risk of running the operation twice. This can be any unique string,
                * 			for example, a timestamp. </p>
                */
            CreatorRequestId?: string;
            /**
                * <p>Whether the rule group is shared with other Amazon Web Services accounts, or was shared with the current account by another
                *               Amazon Web Services account. Sharing is configured through Resource Access Manager (RAM).</p>
                */
            ShareStatus?: ShareStatus | string;
    }
    export namespace FirewallRuleGroupMetadata {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FirewallRuleGroupMetadata) => any;
    }
    export interface GetFirewallConfigRequest {
            /**
                * <p>The ID of the VPC from Amazon VPC that the configuration is for.</p>
                */
            ResourceId: string | undefined;
    }
    export namespace GetFirewallConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetFirewallConfigRequest) => any;
    }
    export interface GetFirewallConfigResponse {
            /**
                * <p>Configuration of the firewall behavior provided by DNS Firewall for a single VPC from
                * 			AmazonVPC. </p>
                */
            FirewallConfig?: FirewallConfig;
    }
    export namespace GetFirewallConfigResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetFirewallConfigResponse) => any;
    }
    export interface GetFirewallDomainListRequest {
            /**
                * <p>The ID of the domain list.  </p>
                */
            FirewallDomainListId: string | undefined;
    }
    export namespace GetFirewallDomainListRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetFirewallDomainListRequest) => any;
    }
    export interface GetFirewallDomainListResponse {
            /**
                * <p>The domain list that you requested.  </p>
                */
            FirewallDomainList?: FirewallDomainList;
    }
    export namespace GetFirewallDomainListResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetFirewallDomainListResponse) => any;
    }
    export interface GetFirewallRuleGroupRequest {
            /**
                * <p>The unique identifier of the firewall rule group. </p>
                */
            FirewallRuleGroupId: string | undefined;
    }
    export namespace GetFirewallRuleGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetFirewallRuleGroupRequest) => any;
    }
    export interface GetFirewallRuleGroupResponse {
            /**
                * <p>A collection of rules used to filter DNS network traffic. </p>
                */
            FirewallRuleGroup?: FirewallRuleGroup;
    }
    export namespace GetFirewallRuleGroupResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetFirewallRuleGroupResponse) => any;
    }
    export interface GetFirewallRuleGroupAssociationRequest {
            /**
                * <p>The identifier of the <a>FirewallRuleGroupAssociation</a>. </p>
                */
            FirewallRuleGroupAssociationId: string | undefined;
    }
    export namespace GetFirewallRuleGroupAssociationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetFirewallRuleGroupAssociationRequest) => any;
    }
    export interface GetFirewallRuleGroupAssociationResponse {
            /**
                * <p>The association that you requested. </p>
                */
            FirewallRuleGroupAssociation?: FirewallRuleGroupAssociation;
    }
    export namespace GetFirewallRuleGroupAssociationResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetFirewallRuleGroupAssociationResponse) => any;
    }
    export interface GetFirewallRuleGroupPolicyRequest {
            /**
                * <p>The ARN (Amazon Resource Name) for the rule group.</p>
                */
            Arn: string | undefined;
    }
    export namespace GetFirewallRuleGroupPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetFirewallRuleGroupPolicyRequest) => any;
    }
    export interface GetFirewallRuleGroupPolicyResponse {
            /**
                * <p>The Identity and Access Management (Amazon Web Services IAM) policy for sharing the specified rule
                * 			group. You can use the policy to share the rule group using Resource Access Manager
                * 			(RAM). </p>
                */
            FirewallRuleGroupPolicy?: string;
    }
    export namespace GetFirewallRuleGroupPolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetFirewallRuleGroupPolicyResponse) => any;
    }
    export interface GetResolverConfigRequest {
            /**
                * <p>Resource ID of the Amazon VPC that you want to get information about.</p>
                */
            ResourceId: string | undefined;
    }
    export namespace GetResolverConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetResolverConfigRequest) => any;
    }
    export enum ResolverAutodefinedReverseStatus {
            Disabled = "DISABLED",
            Disabling = "DISABLING",
            Enabled = "ENABLED",
            Enabling = "ENABLING"
    }
    /**
        * <p>A complex type that contains information about a Resolver configuration for a VPC.</p>
        */
    export interface ResolverConfig {
            /**
                * <p>ID for the Resolver configuration.</p>
                */
            Id?: string;
            /**
                * <p>The ID of the Amazon Virtual Private Cloud VPC that you're configuring Resolver for.</p>
                */
            ResourceId?: string;
            /**
                * <p>The owner account ID of the Amazon Virtual Private Cloud VPC.</p>
                */
            OwnerId?: string;
            /**
                * <p> The status of whether or not the Resolver will create autodefined rules for reverse DNS
                * 			lookups. This is enabled by default. The status can be one of following:</p>
                * 		       <p> Status of the rules generated by VPCs based on CIDR/Region for reverse DNS resolution. The
                * 			status can be one of following:</p>
                *
                * 		       <ul>
                *             <li>
                *                <p>
                *                   <b>ENABLING:</b> Autodefined rules for reverse DNS lookups are being
                * 					enabled but are not complete.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>ENABLED:</b> Autodefined rules for reverse DNS lookups are
                * 					enabled.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>DISABLING:</b> Autodefined rules for reverse DNS lookups are
                * 					being disabled but are not complete.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>DISABLED:</b> Autodefined rules for reverse DNS lookups are
                * 					disabled.</p>
                *             </li>
                *          </ul>
                */
            AutodefinedReverse?: ResolverAutodefinedReverseStatus | string;
    }
    export namespace ResolverConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResolverConfig) => any;
    }
    export interface GetResolverConfigResponse {
            /**
                * <p>Information about the behavior configuration of Route 53 Resolver behavior for the VPC you
                * 			specified in the <code>GetResolverConfig</code> request.</p>
                */
            ResolverConfig?: ResolverConfig;
    }
    export namespace GetResolverConfigResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetResolverConfigResponse) => any;
    }
    export interface GetResolverDnssecConfigRequest {
            /**
                * <p>The ID of the virtual private cloud (VPC) for the DNSSEC validation status.</p>
                */
            ResourceId: string | undefined;
    }
    export namespace GetResolverDnssecConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetResolverDnssecConfigRequest) => any;
    }
    export enum ResolverDNSSECValidationStatus {
            Disabled = "DISABLED",
            Disabling = "DISABLING",
            Enabled = "ENABLED",
            Enabling = "ENABLING"
    }
    /**
        * <p>A complex type that contains information about a configuration for DNSSEC validation.</p>
        */
    export interface ResolverDnssecConfig {
            /**
                * <p>The ID for a configuration for DNSSEC validation.</p>
                */
            Id?: string;
            /**
                * <p>The owner account ID of the virtual private cloud (VPC) for a configuration for DNSSEC validation.</p>
                */
            OwnerId?: string;
            /**
                * <p>The ID of the virtual private cloud (VPC) that you're configuring the DNSSEC validation status for.</p>
                */
            ResourceId?: string;
            /**
                * <p>The validation status for a DNSSEC configuration. The status can be one of the following:</p>
                * 		       <ul>
                *             <li>
                *                <p>
                *                   <b>ENABLING:</b> DNSSEC validation is being enabled but is not complete.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>ENABLED:</b> DNSSEC validation is enabled.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>DISABLING:</b> DNSSEC validation is being disabled but is not complete.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <b>DISABLED</b> DNSSEC validation is disabled.</p>
                *             </li>
                *          </ul>
                */
            ValidationStatus?: ResolverDNSSECValidationStatus | string;
    }
    export namespace ResolverDnssecConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResolverDnssecConfig) => any;
    }
    export interface GetResolverDnssecConfigResponse {
            /**
                * <p>The information about a configuration for DNSSEC validation.</p>
                */
            ResolverDNSSECConfig?: ResolverDnssecConfig;
    }
    export namespace GetResolverDnssecConfigResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetResolverDnssecConfigResponse) => any;
    }
    export interface GetResolverEndpointRequest {
            /**
                * <p>The ID of the Resolver endpoint that you want to get information about.</p>
                */
            ResolverEndpointId: string | undefined;
    }
    export namespace GetResolverEndpointRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetResolverEndpointRequest) => any;
    }
    export interface GetResolverEndpointResponse {
            /**
                * <p>Information about the Resolver endpoint that you specified in a <code>GetResolverEndpoint</code> request.</p>
                */
            ResolverEndpoint?: ResolverEndpoint;
    }
    export namespace GetResolverEndpointResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetResolverEndpointResponse) => any;
    }
    export interface GetResolverQueryLogConfigRequest {
            /**
                * <p>The ID of the Resolver query logging configuration that you want to get information about.</p>
                */
            ResolverQueryLogConfigId: string | undefined;
    }
    export namespace GetResolverQueryLogConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetResolverQueryLogConfigRequest) => any;
    }
    export interface GetResolverQueryLogConfigResponse {
            /**
                * <p>Information about the Resolver query logging configuration that you specified in a <code>GetQueryLogConfig</code> request.</p>
                */
            ResolverQueryLogConfig?: ResolverQueryLogConfig;
    }
    export namespace GetResolverQueryLogConfigResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetResolverQueryLogConfigResponse) => any;
    }
    export interface GetResolverQueryLogConfigAssociationRequest {
            /**
                * <p>The ID of the Resolver query logging configuration association that you want to get information about.</p>
                */
            ResolverQueryLogConfigAssociationId: string | undefined;
    }
    export namespace GetResolverQueryLogConfigAssociationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetResolverQueryLogConfigAssociationRequest) => any;
    }
    export interface GetResolverQueryLogConfigAssociationResponse {
            /**
                * <p>Information about the Resolver query logging configuration association that you specified in a <code>GetQueryLogConfigAssociation</code> request.</p>
                */
            ResolverQueryLogConfigAssociation?: ResolverQueryLogConfigAssociation;
    }
    export namespace GetResolverQueryLogConfigAssociationResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetResolverQueryLogConfigAssociationResponse) => any;
    }
    export interface GetResolverQueryLogConfigPolicyRequest {
            /**
                * <p>The ARN of the query logging configuration that you want to get the query logging policy for.</p>
                */
            Arn: string | undefined;
    }
    export namespace GetResolverQueryLogConfigPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetResolverQueryLogConfigPolicyRequest) => any;
    }
    export interface GetResolverQueryLogConfigPolicyResponse {
            /**
                * <p>Information about the query logging policy for the query logging configuration that you specified in a
                * 			<code>GetResolverQueryLogConfigPolicy</code> request.</p>
                */
            ResolverQueryLogConfigPolicy?: string;
    }
    export namespace GetResolverQueryLogConfigPolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetResolverQueryLogConfigPolicyResponse) => any;
    }
    /**
        * <p>The specified resource doesn't exist.</p>
        */
    export class UnknownResourceException extends __BaseException {
            readonly name: "UnknownResourceException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UnknownResourceException, __BaseException>);
    }
    export interface GetResolverRuleRequest {
            /**
                * <p>The ID of the Resolver rule that you want to get information about.</p>
                */
            ResolverRuleId: string | undefined;
    }
    export namespace GetResolverRuleRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetResolverRuleRequest) => any;
    }
    export interface GetResolverRuleResponse {
            /**
                * <p>Information about the Resolver rule that you specified in a <code>GetResolverRule</code> request.</p>
                */
            ResolverRule?: ResolverRule;
    }
    export namespace GetResolverRuleResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetResolverRuleResponse) => any;
    }
    export interface GetResolverRuleAssociationRequest {
            /**
                * <p>The ID of the Resolver rule association that you want to get information about.</p>
                */
            ResolverRuleAssociationId: string | undefined;
    }
    export namespace GetResolverRuleAssociationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetResolverRuleAssociationRequest) => any;
    }
    export interface GetResolverRuleAssociationResponse {
            /**
                * <p>Information about the Resolver rule association that you specified in a <code>GetResolverRuleAssociation</code> request.</p>
                */
            ResolverRuleAssociation?: ResolverRuleAssociation;
    }
    export namespace GetResolverRuleAssociationResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetResolverRuleAssociationResponse) => any;
    }
    export interface GetResolverRulePolicyRequest {
            /**
                * <p>The ID of the Resolver rule that you want to get the Resolver rule policy for.</p>
                */
            Arn: string | undefined;
    }
    export namespace GetResolverRulePolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetResolverRulePolicyRequest) => any;
    }
    export interface GetResolverRulePolicyResponse {
            /**
                * <p>The Resolver rule policy for the rule that you specified in a <code>GetResolverRulePolicy</code> request.</p>
                */
            ResolverRulePolicy?: string;
    }
    export namespace GetResolverRulePolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetResolverRulePolicyResponse) => any;
    }
    export interface ImportFirewallDomainsRequest {
            /**
                * <p>The ID of the domain list that you want to modify with the import operation.</p>
                */
            FirewallDomainListId: string | undefined;
            /**
                * <p>What you want DNS Firewall to do with the domains that are listed in the file. This must be set to <code>REPLACE</code>, which updates the domain list to exactly match the list in the file. </p>
                */
            Operation: FirewallDomainImportOperation | string | undefined;
            /**
                * <p>The fully qualified URL or URI of the file stored in Amazon Simple Storage Service
                * 			(Amazon S3) that contains the list of domains to import.</p>
                *          <p>The file must be in an S3 bucket that's in the same Region
                *        as your DNS Firewall. The file must be a text file and must contain a single domain per line.</p>
                */
            DomainFileUrl: string | undefined;
    }
    export namespace ImportFirewallDomainsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImportFirewallDomainsRequest) => any;
    }
    export interface ImportFirewallDomainsResponse {
            /**
                * <p>The Id of the firewall domain list that DNS Firewall just updated.</p>
                */
            Id?: string;
            /**
                * <p>The name of the domain list. </p>
                */
            Name?: string;
            /**
                * <p> </p>
                */
            Status?: FirewallDomainListStatus | string;
            /**
                * <p>Additional information about the status of the list, if available.</p>
                */
            StatusMessage?: string;
    }
    export namespace ImportFirewallDomainsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImportFirewallDomainsResponse) => any;
    }
    /**
        * <p>The value that you specified for <code>NextToken</code> in a <code>List</code> request isn't valid.</p>
        */
    export class InvalidNextTokenException extends __BaseException {
            readonly name: "InvalidNextTokenException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidNextTokenException, __BaseException>);
    }
    /**
        * <p>The specified Resolver rule policy is invalid.</p>
        */
    export class InvalidPolicyDocument extends __BaseException {
            readonly name: "InvalidPolicyDocument";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidPolicyDocument, __BaseException>);
    }
    /**
        * <p>The specified tag is invalid.</p>
        */
    export class InvalidTagException extends __BaseException {
            readonly name: "InvalidTagException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidTagException, __BaseException>);
    }
    export enum IpAddressStatus {
            Attached = "ATTACHED",
            Attaching = "ATTACHING",
            Creating = "CREATING",
            DeleteFailedFasExpired = "DELETE_FAILED_FAS_EXPIRED",
            Deleting = "DELETING",
            Detaching = "DETACHING",
            FailedCreation = "FAILED_CREATION",
            FailedResourceGone = "FAILED_RESOURCE_GONE",
            RemapAttaching = "REMAP_ATTACHING",
            RemapDetaching = "REMAP_DETACHING"
    }
    /**
        * <p>In the response to a
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html">GetResolverEndpoint</a>
        * 			request, information about the IP addresses that the Resolver endpoint uses for DNS queries.</p>
        */
    export interface IpAddressResponse {
            /**
                * <p>The ID of one IP address.</p>
                */
            IpId?: string;
            /**
                * <p>The ID of one subnet.</p>
                */
            SubnetId?: string;
            /**
                * <p>One IP address that the Resolver endpoint uses for DNS queries.</p>
                */
            Ip?: string;
            /**
                * <p>A status code that gives the current status of the request.</p>
                */
            Status?: IpAddressStatus | string;
            /**
                * <p>A message that provides additional information about the status of the request.</p>
                */
            StatusMessage?: string;
            /**
                * <p>The date and time that the IP address was created, in Unix time format and Coordinated Universal Time (UTC).</p>
                */
            CreationTime?: string;
            /**
                * <p>The date and time that the IP address was last modified, in Unix time format and Coordinated Universal Time (UTC).</p>
                */
            ModificationTime?: string;
    }
    export namespace IpAddressResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: IpAddressResponse) => any;
    }
    export interface ListFirewallConfigsRequest {
            /**
                * <p>The maximum number of objects that you want Resolver to return for this request. If more
                *             objects are available, in the response, Resolver provides a
                *            <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
                *          <p>If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 objects. </p>
                */
            MaxResults?: number;
            /**
                * <p>For the first call to this list request, omit this value.</p>
                *          <p>When you request a list of objects, Resolver returns at most the number of objects
                *        specified in <code>MaxResults</code>. If more objects are available for retrieval,
                *            Resolver returns a <code>NextToken</code> value in the response. To retrieve the next
                *                batch of objects, use the token that was returned for the prior request in your next request.</p>
                */
            NextToken?: string;
    }
    export namespace ListFirewallConfigsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListFirewallConfigsRequest) => any;
    }
    export interface ListFirewallConfigsResponse {
            /**
                * <p>If objects are still available for retrieval, Resolver returns this token in the response.
                *            To retrieve the next batch of objects, provide this token in your next request.</p>
                */
            NextToken?: string;
            /**
                * <p>The configurations for the firewall behavior provided by DNS Firewall for VPCs from
                * 			Amazon Virtual Private Cloud (Amazon VPC). </p>
                */
            FirewallConfigs?: FirewallConfig[];
    }
    export namespace ListFirewallConfigsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListFirewallConfigsResponse) => any;
    }
    export interface ListFirewallDomainListsRequest {
            /**
                * <p>The maximum number of objects that you want Resolver to return for this request. If more
                *             objects are available, in the response, Resolver provides a
                *            <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
                *          <p>If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 objects. </p>
                */
            MaxResults?: number;
            /**
                * <p>For the first call to this list request, omit this value.</p>
                *          <p>When you request a list of objects, Resolver returns at most the number of objects
                *        specified in <code>MaxResults</code>. If more objects are available for retrieval,
                *            Resolver returns a <code>NextToken</code> value in the response. To retrieve the next
                *                batch of objects, use the token that was returned for the prior request in your next request.</p>
                */
            NextToken?: string;
    }
    export namespace ListFirewallDomainListsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListFirewallDomainListsRequest) => any;
    }
    export interface ListFirewallDomainListsResponse {
            /**
                * <p>If objects are still available for retrieval, Resolver returns this token in the response.
                *            To retrieve the next batch of objects, provide this token in your next request.</p>
                */
            NextToken?: string;
            /**
                * <p>A list of the domain lists that you have defined.   </p>
                *          <p>This might be a partial list of the domain lists that you've defined. For information,
                * 			see <code>MaxResults</code>. </p>
                */
            FirewallDomainLists?: FirewallDomainListMetadata[];
    }
    export namespace ListFirewallDomainListsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListFirewallDomainListsResponse) => any;
    }
    export interface ListFirewallDomainsRequest {
            /**
                * <p>The ID of the domain list whose domains you want to retrieve. </p>
                */
            FirewallDomainListId: string | undefined;
            /**
                * <p>The maximum number of objects that you want Resolver to return for this request. If more
                *             objects are available, in the response, Resolver provides a
                *            <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
                *          <p>If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 objects. </p>
                */
            MaxResults?: number;
            /**
                * <p>For the first call to this list request, omit this value.</p>
                *          <p>When you request a list of objects, Resolver returns at most the number of objects
                *        specified in <code>MaxResults</code>. If more objects are available for retrieval,
                *            Resolver returns a <code>NextToken</code> value in the response. To retrieve the next
                *                batch of objects, use the token that was returned for the prior request in your next request.</p>
                */
            NextToken?: string;
    }
    export namespace ListFirewallDomainsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListFirewallDomainsRequest) => any;
    }
    export interface ListFirewallDomainsResponse {
            /**
                * <p>If objects are still available for retrieval, Resolver returns this token in the response.
                *            To retrieve the next batch of objects, provide this token in your next request.</p>
                */
            NextToken?: string;
            /**
                * <p>A list of the domains in the firewall domain list.  </p>
                *          <p>This might be a partial list of the domains that you've defined in the domain list. For
                * 			information, see <code>MaxResults</code>. </p>
                */
            Domains?: string[];
    }
    export namespace ListFirewallDomainsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListFirewallDomainsResponse) => any;
    }
    export interface ListFirewallRuleGroupAssociationsRequest {
            /**
                * <p>The unique identifier of the firewall rule group that you want to retrieve the associations
                *            for. Leave this blank to retrieve associations for any rule group. </p>
                */
            FirewallRuleGroupId?: string;
            /**
                * <p>The unique identifier of the VPC that you want to retrieve the associations
                *            for. Leave this blank to retrieve associations for any VPC. </p>
                */
            VpcId?: string;
            /**
                * <p>The setting that determines the processing order of the rule group among the rule
                * 			groups that are associated with a single VPC. DNS Firewall filters VPC traffic starting
                * 			from the rule group with the lowest numeric priority setting. </p>
                */
            Priority?: number;
            /**
                * <p>The association <code>Status</code> setting that you want DNS Firewall to filter on for the list. If you don't specify this, then DNS Firewall returns all associations, regardless of status.</p>
                */
            Status?: FirewallRuleGroupAssociationStatus | string;
            /**
                * <p>The maximum number of objects that you want Resolver to return for this request. If more
                *             objects are available, in the response, Resolver provides a
                *            <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
                *          <p>If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 objects. </p>
                */
            MaxResults?: number;
            /**
                * <p>For the first call to this list request, omit this value.</p>
                *          <p>When you request a list of objects, Resolver returns at most the number of objects
                *        specified in <code>MaxResults</code>. If more objects are available for retrieval,
                *            Resolver returns a <code>NextToken</code> value in the response. To retrieve the next
                *                batch of objects, use the token that was returned for the prior request in your next request.</p>
                */
            NextToken?: string;
    }
    export namespace ListFirewallRuleGroupAssociationsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListFirewallRuleGroupAssociationsRequest) => any;
    }
    export interface ListFirewallRuleGroupAssociationsResponse {
            /**
                * <p>If objects are still available for retrieval, Resolver returns this token in the response.
                *            To retrieve the next batch of objects, provide this token in your next request.</p>
                */
            NextToken?: string;
            /**
                * <p>A list of your firewall rule group associations.</p>
                *          <p>This might be a partial list of the associations that you have defined. For information, see <code>MaxResults</code>. </p>
                */
            FirewallRuleGroupAssociations?: FirewallRuleGroupAssociation[];
    }
    export namespace ListFirewallRuleGroupAssociationsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListFirewallRuleGroupAssociationsResponse) => any;
    }
    export interface ListFirewallRuleGroupsRequest {
            /**
                * <p>The maximum number of objects that you want Resolver to return for this request. If more
                *             objects are available, in the response, Resolver provides a
                *            <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
                *          <p>If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 objects. </p>
                */
            MaxResults?: number;
            /**
                * <p>For the first call to this list request, omit this value.</p>
                *          <p>When you request a list of objects, Resolver returns at most the number of objects
                *        specified in <code>MaxResults</code>. If more objects are available for retrieval,
                *            Resolver returns a <code>NextToken</code> value in the response. To retrieve the next
                *                batch of objects, use the token that was returned for the prior request in your next request.</p>
                */
            NextToken?: string;
    }
    export namespace ListFirewallRuleGroupsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListFirewallRuleGroupsRequest) => any;
    }
    export interface ListFirewallRuleGroupsResponse {
            /**
                * <p>If objects are still available for retrieval, Resolver returns this token in the response.
                *            To retrieve the next batch of objects, provide this token in your next request.</p>
                */
            NextToken?: string;
            /**
                * <p>A list of your firewall rule groups.</p>
                *          <p>This might be a partial list of the rule groups that you have defined. For information, see <code>MaxResults</code>. </p>
                */
            FirewallRuleGroups?: FirewallRuleGroupMetadata[];
    }
    export namespace ListFirewallRuleGroupsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListFirewallRuleGroupsResponse) => any;
    }
    export interface ListFirewallRulesRequest {
            /**
                * <p>The unique identifier of the firewall rule group that you want to retrieve the rules for. </p>
                */
            FirewallRuleGroupId: string | undefined;
            /**
                * <p>Optional additional filter for the rules to retrieve.</p>
                *          <p>The setting that determines the processing order of the rules in a rule group. DNS Firewall
                *            processes the rules in a rule group by order of priority, starting from the lowest setting.</p>
                */
            Priority?: number;
            /**
                * <p>Optional additional filter for the rules to retrieve.</p>
                *          <p>The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>ALLOW</code> - Permit the request to go through.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ALERT</code> - Permit the request to go through but send an alert to the logs.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>BLOCK</code> - Disallow the request. If this is specified, additional handling details are provided in the rule's <code>BlockResponse</code> setting. </p>
                *             </li>
                *          </ul>
                */
            Action?: Action | string;
            /**
                * <p>The maximum number of objects that you want Resolver to return for this request. If more
                *             objects are available, in the response, Resolver provides a
                *            <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
                *          <p>If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 objects. </p>
                */
            MaxResults?: number;
            /**
                * <p>For the first call to this list request, omit this value.</p>
                *          <p>When you request a list of objects, Resolver returns at most the number of objects
                *        specified in <code>MaxResults</code>. If more objects are available for retrieval,
                *            Resolver returns a <code>NextToken</code> value in the response. To retrieve the next
                *                batch of objects, use the token that was returned for the prior request in your next request.</p>
                */
            NextToken?: string;
    }
    export namespace ListFirewallRulesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListFirewallRulesRequest) => any;
    }
    export interface ListFirewallRulesResponse {
            /**
                * <p>If objects are still available for retrieval, Resolver returns this token in the response.
                *            To retrieve the next batch of objects, provide this token in your next request.</p>
                */
            NextToken?: string;
            /**
                * <p>A list of the rules that you have defined.  </p>
                *          <p>This might be a partial list of the firewall rules that you've defined. For information,
                * 			see <code>MaxResults</code>. </p>
                */
            FirewallRules?: FirewallRule[];
    }
    export namespace ListFirewallRulesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListFirewallRulesResponse) => any;
    }
    export interface ListResolverConfigsRequest {
            /**
                * <p>The maximum number of Resolver configurations that you want to return in the response to
                * 			a <code>ListResolverConfigs</code> request. If you don't specify a value for <code>MaxResults</code>,
                * 			up to 100 Resolver configurations are returned.</p>
                */
            MaxResults?: number;
            /**
                * <p>(Optional) If the current Amazon Web Services account has more than <code>MaxResults</code> Resolver configurations, use
                * 			<code>NextToken</code> to get the second and subsequent pages of results.</p>
                * 		       <p>For the first <code>ListResolverConfigs</code> request, omit this value.</p>
                * 		       <p>For the second and subsequent requests, get the value of <code>NextToken</code> from the previous response and
                * 			specify that value for <code>NextToken</code> in the request.</p>
                */
            NextToken?: string;
    }
    export namespace ListResolverConfigsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListResolverConfigsRequest) => any;
    }
    export interface ListResolverConfigsResponse {
            /**
                * <p>If a response includes the last of the Resolver configurations that are associated with the current Amazon Web Services account,
                * 			<code>NextToken</code> doesn't appear in the response.</p>
                * 		       <p>If a response doesn't include the last of the configurations, you can get more configurations by submitting another
                * 			<code>ListResolverConfigs</code> request.
                * 			Get the value of <code>NextToken</code> that Amazon Route 53
                *              returned in the previous response and include it in
                * 			<code>NextToken</code> in the next request.</p>
                */
            NextToken?: string;
            /**
                * <p>An array that contains one <code>ResolverConfigs</code> element for each Resolver configuration that is associated
                * 			with the current Amazon Web Services account.</p>
                */
            ResolverConfigs?: ResolverConfig[];
    }
    export namespace ListResolverConfigsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListResolverConfigsResponse) => any;
    }
    export interface ListResolverDnssecConfigsRequest {
            /**
                * <p>
                *             <i>Optional</i>: An integer that specifies the maximum number of DNSSEC configuration results that you want Amazon Route 53 to return.
                * 			If you don't specify a value for <code>MaxResults</code>, Route 53 returns up to 100 configuration per page.</p>
                */
            MaxResults?: number;
            /**
                * <p>(Optional) If the current Amazon Web Services account has more than <code>MaxResults</code> DNSSEC configurations, use <code>NextToken</code>
                * 			to get the second and subsequent pages of results.</p>
                * 		       <p>For the first <code>ListResolverDnssecConfigs</code> request, omit this value.</p>
                * 		       <p>For the second and subsequent requests, get the value of <code>NextToken</code> from the previous response and specify that value
                * 			for <code>NextToken</code> in the request.</p>
                */
            NextToken?: string;
            /**
                * <p>An optional specification to return a subset of objects.</p>
                */
            Filters?: Filter[];
    }
    export namespace ListResolverDnssecConfigsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListResolverDnssecConfigsRequest) => any;
    }
    export interface ListResolverDnssecConfigsResponse {
            /**
                * <p>If a response includes the last of the DNSSEC configurations that are associated with the current Amazon Web Services account,
                * 			<code>NextToken</code> doesn't appear in the response.</p>
                * 		       <p>If a response doesn't include the last of the configurations, you can get more configurations by submitting another
                * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ListResolverDnssecConfigs.html">ListResolverDnssecConfigs</a>
                * 			request. Get the value of <code>NextToken</code> that Amazon Route 53 returned in the previous response and include it in
                * 			<code>NextToken</code> in the next request.</p>
                */
            NextToken?: string;
            /**
                * <p>An array that contains one
                * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ResolverDnssecConfig.html">ResolverDnssecConfig</a> element
                * 			for each configuration for DNSSEC validation that is associated with the current Amazon Web Services account.</p>
                */
            ResolverDnssecConfigs?: ResolverDnssecConfig[];
    }
    export namespace ListResolverDnssecConfigsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListResolverDnssecConfigsResponse) => any;
    }
    export interface ListResolverEndpointIpAddressesRequest {
            /**
                * <p>The ID of the Resolver endpoint that you want to get IP addresses for.</p>
                */
            ResolverEndpointId: string | undefined;
            /**
                * <p>The maximum number of IP addresses that you want to return in the response to a <code>ListResolverEndpointIpAddresses</code> request.
                * 			If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 IP addresses. </p>
                */
            MaxResults?: number;
            /**
                * <p>For the first <code>ListResolverEndpointIpAddresses</code> request, omit this value.</p>
                * 		       <p>If the specified Resolver endpoint has more than <code>MaxResults</code> IP addresses, you can submit another
                * 			<code>ListResolverEndpointIpAddresses</code> request to get the next group of IP addresses. In the next request, specify the value of
                * 			<code>NextToken</code> from the previous response. </p>
                */
            NextToken?: string;
    }
    export namespace ListResolverEndpointIpAddressesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListResolverEndpointIpAddressesRequest) => any;
    }
    export interface ListResolverEndpointIpAddressesResponse {
            /**
                * <p>If the specified endpoint has more than <code>MaxResults</code> IP addresses, you can submit another
                * 			<code>ListResolverEndpointIpAddresses</code> request to get the next group of IP addresses. In the next request,
                * 			specify the value of <code>NextToken</code> from the previous response. </p>
                */
            NextToken?: string;
            /**
                * <p>The value that you specified for <code>MaxResults</code> in the request.</p>
                */
            MaxResults?: number;
            /**
                * <p>Information about the IP addresses in your VPC that DNS queries originate from (for outbound endpoints) or that you forward
                * 			DNS queries to (for inbound endpoints).</p>
                */
            IpAddresses?: IpAddressResponse[];
    }
    export namespace ListResolverEndpointIpAddressesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListResolverEndpointIpAddressesResponse) => any;
    }
    export interface ListResolverEndpointsRequest {
            /**
                * <p>The maximum number of Resolver endpoints that you want to return in the response to a <code>ListResolverEndpoints</code> request.
                * 			If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 Resolver endpoints. </p>
                */
            MaxResults?: number;
            /**
                * <p>For the first <code>ListResolverEndpoints</code> request, omit this value.</p>
                * 		       <p>If you have more than <code>MaxResults</code> Resolver endpoints, you can submit another <code>ListResolverEndpoints</code> request
                * 			to get the next group of Resolver endpoints. In the next request, specify the value of <code>NextToken</code> from the previous response. </p>
                */
            NextToken?: string;
            /**
                * <p>An optional specification to return a subset of Resolver endpoints, such as all inbound Resolver endpoints.</p>
                * 		       <note>
                *             <p>If you submit a second or subsequent <code>ListResolverEndpoints</code> request and specify the <code>NextToken</code> parameter,
                * 			you must use the same values for <code>Filters</code>, if any, as in the previous request.</p>
                *          </note>
                */
            Filters?: Filter[];
    }
    export namespace ListResolverEndpointsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListResolverEndpointsRequest) => any;
    }
    export interface ListResolverEndpointsResponse {
            /**
                * <p>If more than <code>MaxResults</code> IP addresses match the specified criteria, you can submit another <code>ListResolverEndpoint</code> request
                * 			to get the next group of results. In the next request, specify the value of <code>NextToken</code> from the previous response. </p>
                */
            NextToken?: string;
            /**
                * <p>The value that you specified for <code>MaxResults</code> in the request.</p>
                */
            MaxResults?: number;
            /**
                * <p>The Resolver endpoints that were created by using the current Amazon Web Services account, and that match the specified filters, if any.</p>
                */
            ResolverEndpoints?: ResolverEndpoint[];
    }
    export namespace ListResolverEndpointsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListResolverEndpointsResponse) => any;
    }
    export enum SortOrder {
            Ascending = "ASCENDING",
            Descending = "DESCENDING"
    }
    export interface ListResolverQueryLogConfigAssociationsRequest {
            /**
                * <p>The maximum number of query logging associations that you want to return in the response to a <code>ListResolverQueryLogConfigAssociations</code> request.
                * 			If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 query logging associations. </p>
                */
            MaxResults?: number;
            /**
                * <p>For the first <code>ListResolverQueryLogConfigAssociations</code> request, omit this value.</p>
                * 		       <p>If there are more than <code>MaxResults</code> query logging associations that match the values that you specify for <code>Filters</code>,
                * 			you can submit another <code>ListResolverQueryLogConfigAssociations</code> request to get the next group of associations. In the next request, specify the value of
                * 			<code>NextToken</code> from the previous response. </p>
                */
            NextToken?: string;
            /**
                * <p>An optional specification to return a subset of query logging associations.</p>
                * 		       <note>
                * 			         <p>If you submit a second or subsequent <code>ListResolverQueryLogConfigAssociations</code> request and specify the <code>NextToken</code> parameter,
                * 				you must use the same values for <code>Filters</code>, if any, as in the previous request.</p>
                * 		       </note>
                */
            Filters?: Filter[];
            /**
                * <p>The element that you want Resolver to sort query logging associations by. </p>
                * 		       <note>
                * 			         <p>If you submit a second or subsequent <code>ListResolverQueryLogConfigAssociations</code> request and specify the <code>NextToken</code> parameter,
                * 				you must use the same value for <code>SortBy</code>, if any, as in the previous request.</p>
                * 		       </note>
                *
                * 		       <p>Valid values include the following elements:</p>
                * 		       <ul>
                *             <li>
                *                <p>
                *                   <code>CreationTime</code>: The ID of the query logging association.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>Error</code>: If the value of <code>Status</code> is <code>FAILED</code>, the value of <code>Error</code>
                * 				indicates the cause: </p>
                * 				           <ul>
                *                   <li>
                *                      <p>
                *                         <code>DESTINATION_NOT_FOUND</code>: The specified destination (for example, an Amazon S3 bucket) was deleted.</p>
                *                   </li>
                *                   <li>
                *                      <p>
                *                         <code>ACCESS_DENIED</code>: Permissions don't allow sending logs to the destination.</p>
                *                   </li>
                *                </ul>
                * 				           <p>If <code>Status</code> is a value other than <code>FAILED</code>, <code>ERROR</code> is null.</p>
                * 			         </li>
                *             <li>
                *                <p>
                *                   <code>Id</code>: The ID of the query logging association</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ResolverQueryLogConfigId</code>: The ID of the query logging configuration</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ResourceId</code>: The ID of the VPC that is associated with the query logging configuration</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>Status</code>: The current status of the configuration. Valid values include the following:</p>
                *
                * 				           <ul>
                *                   <li>
                *                      <p>
                *                         <code>CREATING</code>: Resolver is creating an association between an Amazon VPC and a query logging configuration.</p>
                *                   </li>
                *                   <li>
                *                      <p>
                *                         <code>CREATED</code>: The association between an Amazon VPC and a query logging configuration
                * 						was successfully created. Resolver is logging queries that originate in the specified VPC.</p>
                *                   </li>
                *                   <li>
                *                      <p>
                *                         <code>DELETING</code>: Resolver is deleting this query logging association.</p>
                *                   </li>
                *                   <li>
                *                      <p>
                *                         <code>FAILED</code>: Resolver either couldn't create or couldn't delete the query logging association.
                * 						Here are two common causes:</p>
                * 						               <ul>
                *                         <li>
                *                            <p>The specified destination (for example, an Amazon S3 bucket) was deleted.</p>
                *                         </li>
                *                         <li>
                *                            <p>Permissions don't allow sending logs to the destination.</p>
                *                         </li>
                *                      </ul>
                * 					             </li>
                *                </ul>
                * 			         </li>
                *          </ul>
                */
            SortBy?: string;
            /**
                * <p>If you specified a value for <code>SortBy</code>, the order that you want query logging associations to be listed in,
                * 			<code>ASCENDING</code> or <code>DESCENDING</code>.</p>
                * 		       <note>
                * 			         <p>If you submit a second or subsequent <code>ListResolverQueryLogConfigAssociations</code> request and specify the <code>NextToken</code> parameter,
                * 				you must use the same value for <code>SortOrder</code>, if any, as in the previous request.</p>
                * 		       </note>
                */
            SortOrder?: SortOrder | string;
    }
    export namespace ListResolverQueryLogConfigAssociationsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListResolverQueryLogConfigAssociationsRequest) => any;
    }
    export interface ListResolverQueryLogConfigAssociationsResponse {
            /**
                * <p>If there are more than <code>MaxResults</code> query logging associations, you can submit another <code>ListResolverQueryLogConfigAssociations</code> request
                * 			to get the next group of associations. In the next request, specify the value of <code>NextToken</code> from the previous response. </p>
                */
            NextToken?: string;
            /**
                * <p>The total number of query logging associations that were created by the current account in the specified Region. This count can differ from the
                * 			number of associations that are returned in a <code>ListResolverQueryLogConfigAssociations</code> response, depending on the values that you specify
                * 			in the request.</p>
                */
            TotalCount?: number;
            /**
                * <p>The total number of query logging associations that were created by the current account in the specified Region and that match the filters
                * 			that were specified in the <code>ListResolverQueryLogConfigAssociations</code> request. For the total number of associations that were created by the
                * 			current account in the specified Region, see <code>TotalCount</code>.</p>
                */
            TotalFilteredCount?: number;
            /**
                * <p>A list that contains one <code>ResolverQueryLogConfigAssociations</code> element for each query logging association that matches the
                * 			values that you specified for <code>Filter</code>.</p>
                */
            ResolverQueryLogConfigAssociations?: ResolverQueryLogConfigAssociation[];
    }
    export namespace ListResolverQueryLogConfigAssociationsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListResolverQueryLogConfigAssociationsResponse) => any;
    }
    export interface ListResolverQueryLogConfigsRequest {
            /**
                * <p>The maximum number of query logging configurations that you want to return in the response to a <code>ListResolverQueryLogConfigs</code> request.
                * 			If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 query logging configurations. </p>
                */
            MaxResults?: number;
            /**
                * <p>For the first <code>ListResolverQueryLogConfigs</code> request, omit this value.</p>
                * 		       <p>If there are more than <code>MaxResults</code> query logging configurations that match the values that you specify for <code>Filters</code>,
                * 			you can submit another <code>ListResolverQueryLogConfigs</code> request to get the next group of configurations. In the next request, specify the value of
                * 			<code>NextToken</code> from the previous response. </p>
                */
            NextToken?: string;
            /**
                * <p>An optional specification to return a subset of query logging configurations.</p>
                * 		       <note>
                * 			         <p>If you submit a second or subsequent <code>ListResolverQueryLogConfigs</code> request and specify the <code>NextToken</code> parameter,
                * 				you must use the same values for <code>Filters</code>, if any, as in the previous request.</p>
                * 		       </note>
                */
            Filters?: Filter[];
            /**
                * <p>The element that you want Resolver to sort query logging configurations by. </p>
                * 		       <note>
                * 			         <p>If you submit a second or subsequent <code>ListResolverQueryLogConfigs</code> request and specify the <code>NextToken</code> parameter,
                * 				you must use the same value for <code>SortBy</code>, if any, as in the previous request.</p>
                * 		       </note>
                *
                * 		       <p>Valid values include the following elements:</p>
                * 		       <ul>
                *             <li>
                *                <p>
                *                   <code>Arn</code>: The ARN of the query logging configuration</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>AssociationCount</code>: The number of VPCs that are associated with the specified configuration </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>CreationTime</code>: The date and time that Resolver returned when the configuration was created</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>CreatorRequestId</code>: The value that was specified for <code>CreatorRequestId</code> when the configuration was created</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>DestinationArn</code>: The location that logs are sent to</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>Id</code>: The ID of the configuration</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>Name</code>: The name of the configuration</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>OwnerId</code>: The Amazon Web Services account number of the account that created the configuration</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ShareStatus</code>: Whether the configuration is shared with other Amazon Web Services accounts or shared with the current account by
                * 				another Amazon Web Services account. Sharing is configured through Resource Access Manager (RAM).</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>Status</code>: The current status of the configuration. Valid values include the following:</p>
                *
                * 				           <ul>
                *                   <li>
                *                      <p>
                *                         <code>CREATING</code>: Resolver is creating the query logging configuration.</p>
                *                   </li>
                *                   <li>
                *                      <p>
                *                         <code>CREATED</code>: The query logging configuration was successfully created.
                * 						Resolver is logging queries that originate in the specified VPC.</p>
                *                   </li>
                *                   <li>
                *                      <p>
                *                         <code>DELETING</code>: Resolver is deleting this query logging configuration.</p>
                *                   </li>
                *                   <li>
                *                      <p>
                *                         <code>FAILED</code>: Resolver either couldn't create or couldn't delete the query logging configuration.
                * 						Here are two common causes:</p>
                * 						               <ul>
                *                         <li>
                *                            <p>The specified destination (for example, an Amazon S3 bucket) was deleted.</p>
                *                         </li>
                *                         <li>
                *                            <p>Permissions don't allow sending logs to the destination.</p>
                *                         </li>
                *                      </ul>
                * 					             </li>
                *                </ul>
                * 			         </li>
                *          </ul>
                */
            SortBy?: string;
            /**
                * <p>If you specified a value for <code>SortBy</code>, the order that you want query logging configurations to be listed in,
                * 			<code>ASCENDING</code> or <code>DESCENDING</code>.</p>
                * 		       <note>
                * 			         <p>If you submit a second or subsequent <code>ListResolverQueryLogConfigs</code> request and specify the <code>NextToken</code> parameter,
                * 				you must use the same value for <code>SortOrder</code>, if any, as in the previous request.</p>
                * 		       </note>
                */
            SortOrder?: SortOrder | string;
    }
    export namespace ListResolverQueryLogConfigsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListResolverQueryLogConfigsRequest) => any;
    }
    export interface ListResolverQueryLogConfigsResponse {
            /**
                * <p>If there are more than <code>MaxResults</code> query logging configurations, you can submit another <code>ListResolverQueryLogConfigs</code> request
                * 			to get the next group of configurations. In the next request, specify the value of <code>NextToken</code> from the previous response. </p>
                */
            NextToken?: string;
            /**
                * <p>The total number of query logging configurations that were created by the current account in the specified Region. This count can differ from the
                * 			number of query logging configurations that are returned in a <code>ListResolverQueryLogConfigs</code> response, depending on the values that you specify
                * 			in the request.</p>
                */
            TotalCount?: number;
            /**
                * <p>The total number of query logging configurations that were created by the current account in the specified Region and that match the filters
                * 			that were specified in the <code>ListResolverQueryLogConfigs</code> request. For the total number of query logging configurations that were created by the
                * 			current account in the specified Region, see <code>TotalCount</code>.</p>
                */
            TotalFilteredCount?: number;
            /**
                * <p>A list that contains one <code>ResolverQueryLogConfig</code> element for each query logging configuration that matches the
                * 			values that you specified for <code>Filter</code>.</p>
                */
            ResolverQueryLogConfigs?: ResolverQueryLogConfig[];
    }
    export namespace ListResolverQueryLogConfigsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListResolverQueryLogConfigsResponse) => any;
    }
    export interface ListResolverRuleAssociationsRequest {
            /**
                * <p>The maximum number of rule associations that you want to return in the response to a <code>ListResolverRuleAssociations</code> request.
                * 			If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 rule associations. </p>
                */
            MaxResults?: number;
            /**
                * <p>For the first <code>ListResolverRuleAssociation</code> request, omit this value.</p>
                * 		       <p>If you have more than <code>MaxResults</code> rule associations, you can submit another <code>ListResolverRuleAssociation</code> request
                * 			to get the next group of rule associations. In the next request, specify the value of <code>NextToken</code> from the previous response. </p>
                */
            NextToken?: string;
            /**
                * <p>An optional specification to return a subset of Resolver rules, such as Resolver rules that are associated with the same VPC ID.</p>
                * 		       <note>
                *             <p>If you submit a second or subsequent <code>ListResolverRuleAssociations</code> request and specify the <code>NextToken</code> parameter,
                * 			you must use the same values for <code>Filters</code>, if any, as in the previous request.</p>
                *          </note>
                */
            Filters?: Filter[];
    }
    export namespace ListResolverRuleAssociationsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListResolverRuleAssociationsRequest) => any;
    }
    export interface ListResolverRuleAssociationsResponse {
            /**
                * <p>If more than <code>MaxResults</code> rule associations match the specified criteria, you can submit another
                * 			<code>ListResolverRuleAssociation</code> request to get the next group of results. In the next request, specify the value of
                * 			<code>NextToken</code> from the previous response. </p>
                */
            NextToken?: string;
            /**
                * <p>The value that you specified for <code>MaxResults</code> in the request.</p>
                */
            MaxResults?: number;
            /**
                * <p>The associations that were created between Resolver rules and VPCs using the current Amazon Web Services account, and that match the
                * 			specified filters, if any.</p>
                */
            ResolverRuleAssociations?: ResolverRuleAssociation[];
    }
    export namespace ListResolverRuleAssociationsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListResolverRuleAssociationsResponse) => any;
    }
    export interface ListResolverRulesRequest {
            /**
                * <p>The maximum number of Resolver rules that you want to return in the response to a <code>ListResolverRules</code> request.
                * 			If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 Resolver rules.</p>
                */
            MaxResults?: number;
            /**
                * <p>For the first <code>ListResolverRules</code> request, omit this value.</p>
                * 		       <p>If you have more than <code>MaxResults</code> Resolver rules, you can submit another <code>ListResolverRules</code> request
                * 			to get the next group of Resolver rules. In the next request, specify the value of <code>NextToken</code> from the previous response. </p>
                */
            NextToken?: string;
            /**
                * <p>An optional specification to return a subset of Resolver rules, such as all Resolver rules that are associated with the same Resolver endpoint.</p>
                * 		       <note>
                *             <p>If you submit a second or subsequent <code>ListResolverRules</code> request and specify the <code>NextToken</code> parameter,
                * 			you must use the same values for <code>Filters</code>, if any, as in the previous request.</p>
                *          </note>
                */
            Filters?: Filter[];
    }
    export namespace ListResolverRulesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListResolverRulesRequest) => any;
    }
    export interface ListResolverRulesResponse {
            /**
                * <p>If more than <code>MaxResults</code> Resolver rules match the specified criteria, you can submit another
                * 			<code>ListResolverRules</code> request to get the next group of results. In the next request, specify the value of
                * 			<code>NextToken</code> from the previous response. </p>
                */
            NextToken?: string;
            /**
                * <p>The value that you specified for <code>MaxResults</code> in the request.</p>
                */
            MaxResults?: number;
            /**
                * <p>The Resolver rules that were created using the current Amazon Web Services account and that match the specified filters, if any.</p>
                */
            ResolverRules?: ResolverRule[];
    }
    export namespace ListResolverRulesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListResolverRulesResponse) => any;
    }
    export interface ListTagsForResourceRequest {
            /**
                * <p>The Amazon Resource Name (ARN) for the resource that you want to list tags for.</p>
                */
            ResourceArn: string | undefined;
            /**
                * <p>The maximum number of tags that you want to return in the response to a <code>ListTagsForResource</code> request.
                * 			If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 tags.</p>
                */
            MaxResults?: number;
            /**
                * <p>For the first <code>ListTagsForResource</code> request, omit this value.</p>
                * 		       <p>If you have more than <code>MaxResults</code> tags, you can submit another <code>ListTagsForResource</code> request
                * 			to get the next group of tags for the resource. In the next request, specify the value of <code>NextToken</code> from the previous response. </p>
                */
            NextToken?: string;
    }
    export namespace ListTagsForResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceRequest) => any;
    }
    export interface ListTagsForResourceResponse {
            /**
                * <p>The tags that are associated with the resource that you specified in the <code>ListTagsForResource</code> request.</p>
                */
            Tags?: Tag[];
            /**
                * <p>If more than <code>MaxResults</code> tags match the specified criteria, you can submit another
                * 			<code>ListTagsForResource</code> request to get the next group of results. In the next request, specify the value of
                * 			<code>NextToken</code> from the previous response. </p>
                */
            NextToken?: string;
    }
    export namespace ListTagsForResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceResponse) => any;
    }
    export interface PutFirewallRuleGroupPolicyRequest {
            /**
                * <p>The ARN (Amazon Resource Name) for the rule group that you want to share.</p>
                */
            Arn: string | undefined;
            /**
                * <p>The Identity and Access Management (Amazon Web Services IAM) policy to attach to the rule group.</p>
                */
            FirewallRuleGroupPolicy: string | undefined;
    }
    export namespace PutFirewallRuleGroupPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutFirewallRuleGroupPolicyRequest) => any;
    }
    export interface PutFirewallRuleGroupPolicyResponse {
            /**
                * <p></p>
                */
            ReturnValue?: boolean;
    }
    export namespace PutFirewallRuleGroupPolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutFirewallRuleGroupPolicyResponse) => any;
    }
    export interface PutResolverQueryLogConfigPolicyRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the account that you want to share rules with.</p>
                */
            Arn: string | undefined;
            /**
                * <p>An Identity and Access Management policy statement that lists the query logging configurations that you want to share with another Amazon Web Services account
                * 			and the operations that you want the account to be able to perform. You can specify the following operations in the <code>Actions</code> section
                * 			of the statement:</p>
                * 		       <ul>
                *             <li>
                *                <p>
                *                   <code>route53resolver:AssociateResolverQueryLogConfig</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>route53resolver:DisassociateResolverQueryLogConfig</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>route53resolver:ListResolverQueryLogConfigAssociations</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>route53resolver:ListResolverQueryLogConfigs</code>
                *                </p>
                *             </li>
                *          </ul>
                *
                * 		       <p>In the <code>Resource</code> section of the statement, you specify the ARNs for the query logging configurations that you want to share
                * 			with the account that you specified in <code>Arn</code>. </p>
                */
            ResolverQueryLogConfigPolicy: string | undefined;
    }
    export namespace PutResolverQueryLogConfigPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutResolverQueryLogConfigPolicyRequest) => any;
    }
    /**
        * <p>The response to a <code>PutResolverQueryLogConfigPolicy</code> request.</p>
        */
    export interface PutResolverQueryLogConfigPolicyResponse {
            /**
                * <p>Whether the <code>PutResolverQueryLogConfigPolicy</code> request was successful.</p>
                */
            ReturnValue?: boolean;
    }
    export namespace PutResolverQueryLogConfigPolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutResolverQueryLogConfigPolicyResponse) => any;
    }
    export interface PutResolverRulePolicyRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the rule that you want to share with another account.</p>
                */
            Arn: string | undefined;
            /**
                * <p>An Identity and Access Management policy statement that lists the rules that you want to share with another Amazon Web Services account and the operations that you want the account
                * 			to be able to perform. You can specify the following operations in the <code>Action</code> section of the statement:</p>
                * 			      <ul>
                *             <li>
                *                <p>
                *                   <code>route53resolver:GetResolverRule</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>route53resolver:AssociateResolverRule</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>route53resolver:DisassociateResolverRule</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>route53resolver:ListResolverRules</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>route53resolver:ListResolverRuleAssociations</code>
                *                </p>
                *             </li>
                *          </ul>
                *
                * 		       <p>In the <code>Resource</code> section of the statement, specify the ARN for the rule that you want to share with another account. Specify the same ARN
                * 			that you specified in <code>Arn</code>.</p>
                */
            ResolverRulePolicy: string | undefined;
    }
    export namespace PutResolverRulePolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutResolverRulePolicyRequest) => any;
    }
    /**
        * <p>The response to a <code>PutResolverRulePolicy</code> request.</p>
        */
    export interface PutResolverRulePolicyResponse {
            /**
                * <p>Whether the <code>PutResolverRulePolicy</code> request was successful.</p>
                */
            ReturnValue?: boolean;
    }
    export namespace PutResolverRulePolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutResolverRulePolicyResponse) => any;
    }
    /**
        * <p>In an
        * 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverRule.html">UpdateResolverRule</a>
        * 			request, information about the changes that you want to make.</p>
        */
    export interface ResolverRuleConfig {
            /**
                * <p>The new name for the Resolver rule. The name that you specify appears in the Resolver dashboard in the Route 53 console. </p>
                */
            Name?: string;
            /**
                * <p>For DNS queries that originate in your VPC, the new IP addresses that you want to route outbound DNS queries to.</p>
                */
            TargetIps?: TargetAddress[];
            /**
                * <p>The ID of the new outbound Resolver endpoint that you want to use to route DNS queries to the IP addresses that you specify in
                * 			<code>TargetIps</code>.</p>
                */
            ResolverEndpointId?: string;
    }
    export namespace ResolverRuleConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResolverRuleConfig) => any;
    }
    export interface TagResourceRequest {
            /**
                * <p>The Amazon Resource Name (ARN) for the resource that you want to add tags to. To get the ARN for a resource, use the applicable
                * 			<code>Get</code> or <code>List</code> command: </p>
                * 			      <ul>
                *             <li>
                * 					          <p>
                *                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html">GetResolverEndpoint</a>
                *                </p>
                * 				        </li>
                *             <li>
                * 					          <p>
                *                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRule.html">GetResolverRule</a>
                *                </p>
                * 				        </li>
                *             <li>
                * 					          <p>
                *                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRuleAssociation.html">GetResolverRuleAssociation</a>
                *                </p>
                * 				        </li>
                *             <li>
                * 					          <p>
                *                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html">ListResolverEndpoints</a>
                *                </p>
                * 				        </li>
                *             <li>
                * 					          <p>
                *                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html">ListResolverRuleAssociations</a>
                *                </p>
                * 				        </li>
                *             <li>
                * 					          <p>
                *                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html">ListResolverRules</a>
                *                </p>
                * 				        </li>
                *          </ul>
                */
            ResourceArn: string | undefined;
            /**
                * <p>The tags that you want to add to the specified resource.</p>
                */
            Tags: Tag[] | undefined;
    }
    export namespace TagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceRequest) => any;
    }
    export interface TagResourceResponse {
    }
    export namespace TagResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceResponse) => any;
    }
    export interface UntagResourceRequest {
            /**
                * <p>The Amazon Resource Name (ARN) for the resource that you want to remove tags from. To get the ARN for a resource, use the applicable
                * 			<code>Get</code> or <code>List</code> command: </p>
                * 			      <ul>
                *             <li>
                * 					          <p>
                *                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html">GetResolverEndpoint</a>
                *                </p>
                * 				        </li>
                *             <li>
                * 					          <p>
                *                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRule.html">GetResolverRule</a>
                *                </p>
                * 				        </li>
                *             <li>
                * 					          <p>
                *                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRuleAssociation.html">GetResolverRuleAssociation</a>
                *                </p>
                * 				        </li>
                *             <li>
                * 					          <p>
                *                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html">ListResolverEndpoints</a>
                *                </p>
                * 				        </li>
                *             <li>
                * 					          <p>
                *                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html">ListResolverRuleAssociations</a>
                *                </p>
                * 				        </li>
                *             <li>
                * 					          <p>
                *                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html">ListResolverRules</a>
                *                </p>
                * 				        </li>
                *          </ul>
                */
            ResourceArn: string | undefined;
            /**
                * <p>The tags that you want to remove to the specified resource.</p>
                */
            TagKeys: string[] | undefined;
    }
    export namespace UntagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceRequest) => any;
    }
    export interface UntagResourceResponse {
    }
    export namespace UntagResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceResponse) => any;
    }
    export interface UpdateFirewallConfigRequest {
            /**
                * <p>The ID of the VPC that the configuration is for.</p>
                */
            ResourceId: string | undefined;
            /**
                * <p>Determines how Route 53 Resolver handles queries during failures, for example when all traffic that is sent to DNS Firewall fails to receive a reply. </p>
                *          <ul>
                *             <li>
                *                <p>By default, fail open is disabled, which means the failure mode is closed. This approach favors security over availability.
                *        DNS Firewall blocks queries that it is unable to evaluate properly. </p>
                *             </li>
                *             <li>
                *                <p>If you enable this option, the failure mode is open. This approach favors availability over security. DNS Firewall allows queries to proceed if it
                *        is unable to properly evaluate them. </p>
                *             </li>
                *          </ul>
                *          <p>This behavior is only enforced for VPCs that have at least one DNS Firewall rule group association. </p>
                */
            FirewallFailOpen: FirewallFailOpenStatus | string | undefined;
    }
    export namespace UpdateFirewallConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateFirewallConfigRequest) => any;
    }
    export interface UpdateFirewallConfigResponse {
            /**
                * <p>Configuration of the firewall behavior provided by DNS Firewall for a single VPC. </p>
                */
            FirewallConfig?: FirewallConfig;
    }
    export namespace UpdateFirewallConfigResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateFirewallConfigResponse) => any;
    }
    export interface UpdateFirewallDomainsRequest {
            /**
                * <p>The ID of the domain list whose domains you want to update. </p>
                */
            FirewallDomainListId: string | undefined;
            /**
                * <p>What you want DNS Firewall to do with the domains that you are providing: </p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>ADD</code> - Add the domains to the ones that are already in the domain list. </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>REMOVE</code> - Search the domain list for the domains and remove them from the list.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>REPLACE</code> - Update the domain list to exactly match the list that you are providing. </p>
                *             </li>
                *          </ul>
                */
            Operation: FirewallDomainUpdateOperation | string | undefined;
            /**
                * <p>A list of domains to use in the update operation.</p>
                *          <p>Each domain specification in your domain list must satisfy the following
                * 	requirements: </p>
                *          <ul>
                *             <li>
                *       	        <p>It can optionally start with <code>*</code> (asterisk).</p>
                *       	     </li>
                *             <li>
                *       	        <p>With the exception of the optional starting asterisk, it must only contain
                *       	   the following characters: <code>A-Z</code>, <code>a-z</code>,
                *       	   <code>0-9</code>, <code>-</code> (hyphen).</p>
                *       	     </li>
                *             <li>
                *       	        <p>It must be from 1-255 characters in length. </p>
                *       	     </li>
                *          </ul>
                */
            Domains: string[] | undefined;
    }
    export namespace UpdateFirewallDomainsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateFirewallDomainsRequest) => any;
    }
    export interface UpdateFirewallDomainsResponse {
            /**
                * <p>The ID of the firewall domain list that DNS Firewall just updated.</p>
                */
            Id?: string;
            /**
                * <p>The name of the domain list. </p>
                */
            Name?: string;
            /**
                * <p> </p>
                */
            Status?: FirewallDomainListStatus | string;
            /**
                * <p>Additional information about the status of the list, if available.</p>
                */
            StatusMessage?: string;
    }
    export namespace UpdateFirewallDomainsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateFirewallDomainsResponse) => any;
    }
    export interface UpdateFirewallRuleRequest {
            /**
                * <p>The unique identifier of the firewall rule group for the rule. </p>
                */
            FirewallRuleGroupId: string | undefined;
            /**
                * <p>The ID of the domain list to use in the rule.  </p>
                */
            FirewallDomainListId: string | undefined;
            /**
                * <p>The setting that determines the processing order of the rule in the rule group. DNS Firewall
                *            processes the rules in a rule group by order of priority, starting from the lowest setting.</p>
                *          <p>You must specify a unique priority for each rule in a rule group.
                *            To make it easier to insert rules later, leave space between the numbers, for example, use 100, 200, and so on. You
                *    can change the priority setting for the rules in a rule group at any time.</p>
                */
            Priority?: number;
            /**
                * <p>The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>ALLOW</code> - Permit the request to go through.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ALERT</code> - Permit the request to go through but send an alert to the logs.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>BLOCK</code> - Disallow the request. This option requires additional details in the rule's <code>BlockResponse</code>. </p>
                *             </li>
                *          </ul>
                */
            Action?: Action | string;
            /**
                * <p>The way that you want DNS Firewall to block the request. Used for the rule action setting <code>BLOCK</code>.</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>NODATA</code> - Respond indicating that the query was successful, but no response is available for it.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>NXDOMAIN</code> - Respond indicating that the domain name that's in the query doesn't exist.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>OVERRIDE</code> - Provide a custom override in the response. This option requires custom handling details in the rule's <code>BlockOverride*</code> settings. </p>
                *             </li>
                *          </ul>
                */
            BlockResponse?: BlockResponse | string;
            /**
                * <p>The custom DNS record to send back in response to the query. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
                */
            BlockOverrideDomain?: string;
            /**
                * <p>The DNS record's type. This determines the format of the record value that you provided in <code>BlockOverrideDomain</code>. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
                */
            BlockOverrideDnsType?: BlockOverrideDnsType | string;
            /**
                * <p>The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
                */
            BlockOverrideTtl?: number;
            /**
                * <p>The name of the rule.</p>
                */
            Name?: string;
    }
    export namespace UpdateFirewallRuleRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateFirewallRuleRequest) => any;
    }
    export interface UpdateFirewallRuleResponse {
            /**
                * <p>The firewall rule that you just updated. </p>
                */
            FirewallRule?: FirewallRule;
    }
    export namespace UpdateFirewallRuleResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateFirewallRuleResponse) => any;
    }
    export interface UpdateFirewallRuleGroupAssociationRequest {
            /**
                * <p>The identifier of the <a>FirewallRuleGroupAssociation</a>. </p>
                */
            FirewallRuleGroupAssociationId: string | undefined;
            /**
                * <p>The setting that determines the processing order of the rule group among the rule
                * 			groups that you associate with the specified VPC. DNS Firewall filters VPC traffic
                * 			starting from the rule group with the lowest numeric priority setting. </p>
                *          <p>You must specify a unique priority for each rule group that you associate with a single VPC.
                *            To make it easier to insert rule groups later, leave space between the numbers, for example, use 100, 200, and so on. You
                *    can change the priority setting for a rule group association after you create it.</p>
                */
            Priority?: number;
            /**
                * <p>If enabled, this setting disallows modification or removal of the association, to help prevent against accidentally altering DNS firewall protections. </p>
                */
            MutationProtection?: MutationProtectionStatus | string;
            /**
                * <p>The name of the rule group association.</p>
                */
            Name?: string;
    }
    export namespace UpdateFirewallRuleGroupAssociationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateFirewallRuleGroupAssociationRequest) => any;
    }
    export interface UpdateFirewallRuleGroupAssociationResponse {
            /**
                * <p>The association that you just updated. </p>
                */
            FirewallRuleGroupAssociation?: FirewallRuleGroupAssociation;
    }
    export namespace UpdateFirewallRuleGroupAssociationResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateFirewallRuleGroupAssociationResponse) => any;
    }
    export interface UpdateResolverConfigRequest {
            /**
                * <p>Resource ID of the Amazon VPC that you want to update the Resolver configuration for.</p>
                */
            ResourceId: string | undefined;
            /**
                * <p>Indicates whether or not the Resolver will create autodefined rules for reverse DNS
                * 			lookups. This is enabled by default. Disabling this option will also affect EC2-Classic
                * 			instances using ClassicLink. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html">ClassicLink</a> in the
                * 					<i>Amazon EC2 guide</i>.</p>
                * 		       <note>
                *             <p>It can take some time for the status change to be completed.</p>
                *          </note>
                * 		       <p></p>
                */
            AutodefinedReverseFlag: AutodefinedReverseFlag | string | undefined;
    }
    export namespace UpdateResolverConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateResolverConfigRequest) => any;
    }
    export interface UpdateResolverConfigResponse {
            /**
                * <p>An array that contains settings for the specified Resolver configuration.</p>
                */
            ResolverConfig?: ResolverConfig;
    }
    export namespace UpdateResolverConfigResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateResolverConfigResponse) => any;
    }
    export enum Validation {
            DISABLE = "DISABLE",
            ENABLE = "ENABLE"
    }
    export interface UpdateResolverDnssecConfigRequest {
            /**
                * <p>The ID of the virtual private cloud (VPC) that you're updating the DNSSEC validation status for.</p>
                */
            ResourceId: string | undefined;
            /**
                * <p>The new value that you are specifying for DNSSEC validation for the VPC. The value can be <code>ENABLE</code>
                * 			or <code>DISABLE</code>. Be aware that it can take time for a validation status change to be completed.</p>
                */
            Validation: Validation | string | undefined;
    }
    export namespace UpdateResolverDnssecConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateResolverDnssecConfigRequest) => any;
    }
    export interface UpdateResolverDnssecConfigResponse {
            /**
                * <p>A complex type that contains settings for the specified DNSSEC configuration.</p>
                */
            ResolverDNSSECConfig?: ResolverDnssecConfig;
    }
    export namespace UpdateResolverDnssecConfigResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateResolverDnssecConfigResponse) => any;
    }
    export interface UpdateResolverEndpointRequest {
            /**
                * <p>The ID of the Resolver endpoint that you want to update.</p>
                */
            ResolverEndpointId: string | undefined;
            /**
                * <p>The name of the Resolver endpoint that you want to update.</p>
                */
            Name?: string;
    }
    export namespace UpdateResolverEndpointRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateResolverEndpointRequest) => any;
    }
    export interface UpdateResolverEndpointResponse {
            /**
                * <p>The response to an <code>UpdateResolverEndpoint</code> request.</p>
                */
            ResolverEndpoint?: ResolverEndpoint;
    }
    export namespace UpdateResolverEndpointResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateResolverEndpointResponse) => any;
    }
    export interface UpdateResolverRuleRequest {
            /**
                * <p>The ID of the Resolver rule that you want to update.</p>
                */
            ResolverRuleId: string | undefined;
            /**
                * <p>The new settings for the Resolver rule.</p>
                */
            Config: ResolverRuleConfig | undefined;
    }
    export namespace UpdateResolverRuleRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateResolverRuleRequest) => any;
    }
    export interface UpdateResolverRuleResponse {
            /**
                * <p>The response to an <code>UpdateResolverRule</code> request.</p>
                */
            ResolverRule?: ResolverRule;
    }
    export namespace UpdateResolverRuleResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateResolverRuleResponse) => any;
    }
}

declare module '@aws-sdk/client-route53resolver/node_modules/@aws-sdk/client-route53resolver/dist-types/models/Route53ResolverServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from Route53Resolver service.
        */
    export class Route53ResolverServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

