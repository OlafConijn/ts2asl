// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/smithy-client
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http

declare module '@aws-sdk/client-eks' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { AssociateEncryptionConfigCommandInput, AssociateEncryptionConfigCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/AssociateEncryptionConfigCommand";
    import { AssociateIdentityProviderConfigCommandInput, AssociateIdentityProviderConfigCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/AssociateIdentityProviderConfigCommand";
    import { CreateAddonCommandInput, CreateAddonCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/CreateAddonCommand";
    import { CreateClusterCommandInput, CreateClusterCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/CreateClusterCommand";
    import { CreateFargateProfileCommandInput, CreateFargateProfileCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/CreateFargateProfileCommand";
    import { CreateNodegroupCommandInput, CreateNodegroupCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/CreateNodegroupCommand";
    import { DeleteAddonCommandInput, DeleteAddonCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DeleteAddonCommand";
    import { DeleteClusterCommandInput, DeleteClusterCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DeleteClusterCommand";
    import { DeleteFargateProfileCommandInput, DeleteFargateProfileCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DeleteFargateProfileCommand";
    import { DeleteNodegroupCommandInput, DeleteNodegroupCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DeleteNodegroupCommand";
    import { DeregisterClusterCommandInput, DeregisterClusterCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DeregisterClusterCommand";
    import { DescribeAddonCommandInput, DescribeAddonCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DescribeAddonCommand";
    import { DescribeAddonVersionsCommandInput, DescribeAddonVersionsCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DescribeAddonVersionsCommand";
    import { DescribeClusterCommandInput, DescribeClusterCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DescribeClusterCommand";
    import { DescribeFargateProfileCommandInput, DescribeFargateProfileCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DescribeFargateProfileCommand";
    import { DescribeIdentityProviderConfigCommandInput, DescribeIdentityProviderConfigCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DescribeIdentityProviderConfigCommand";
    import { DescribeNodegroupCommandInput, DescribeNodegroupCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DescribeNodegroupCommand";
    import { DescribeUpdateCommandInput, DescribeUpdateCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DescribeUpdateCommand";
    import { DisassociateIdentityProviderConfigCommandInput, DisassociateIdentityProviderConfigCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DisassociateIdentityProviderConfigCommand";
    import { ListAddonsCommandInput, ListAddonsCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/ListAddonsCommand";
    import { ListClustersCommandInput, ListClustersCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/ListClustersCommand";
    import { ListFargateProfilesCommandInput, ListFargateProfilesCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/ListFargateProfilesCommand";
    import { ListIdentityProviderConfigsCommandInput, ListIdentityProviderConfigsCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/ListIdentityProviderConfigsCommand";
    import { ListNodegroupsCommandInput, ListNodegroupsCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/ListNodegroupsCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/ListTagsForResourceCommand";
    import { ListUpdatesCommandInput, ListUpdatesCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/ListUpdatesCommand";
    import { RegisterClusterCommandInput, RegisterClusterCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/RegisterClusterCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/UntagResourceCommand";
    import { UpdateAddonCommandInput, UpdateAddonCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/UpdateAddonCommand";
    import { UpdateClusterConfigCommandInput, UpdateClusterConfigCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/UpdateClusterConfigCommand";
    import { UpdateClusterVersionCommandInput, UpdateClusterVersionCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/UpdateClusterVersionCommand";
    import { UpdateNodegroupConfigCommandInput, UpdateNodegroupConfigCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/UpdateNodegroupConfigCommand";
    import { UpdateNodegroupVersionCommandInput, UpdateNodegroupVersionCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/UpdateNodegroupVersionCommand";
    import { EKSClient } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    /**
        * <p>Amazon Elastic Kubernetes Service (Amazon EKS) is a managed service that makes it easy
        *             for you to run Kubernetes on Amazon Web Services without needing to stand up or maintain
        *             your own Kubernetes control plane. Kubernetes is an open-source system for automating
        *             the deployment, scaling, and management of containerized applications. </p>
        *         <p>Amazon EKS runs up-to-date versions of the open-source Kubernetes software, so
        *             you can use all the existing plugins and tooling from the Kubernetes community.
        *             Applications running on Amazon EKS are fully compatible with applications
        *             running on any standard Kubernetes environment, whether running in on-premises data
        *             centers or public clouds. This means that you can easily migrate any standard Kubernetes
        *             application to Amazon EKS without any code modification required.</p>
        */
    export class EKS extends EKSClient {
            /**
                * <p>Associate encryption configuration to an existing cluster.</p>
                *         <p>You can use this API to enable encryption on existing clusters which do not have
                *             encryption already enabled. This allows you to implement a defense-in-depth security
                *             strategy without migrating applications to new Amazon EKS clusters.</p>
                */
            associateEncryptionConfig(args: AssociateEncryptionConfigCommandInput, options?: __HttpHandlerOptions): Promise<AssociateEncryptionConfigCommandOutput>;
            associateEncryptionConfig(args: AssociateEncryptionConfigCommandInput, cb: (err: any, data?: AssociateEncryptionConfigCommandOutput) => void): void;
            associateEncryptionConfig(args: AssociateEncryptionConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AssociateEncryptionConfigCommandOutput) => void): void;
            /**
                * <p>Associate an identity provider configuration to a cluster.</p>
                *         <p>If you want to authenticate identities using an identity provider, you can create an
                *             identity provider configuration and associate it to your cluster. After configuring
                *             authentication to your cluster you can create Kubernetes <code>roles</code> and
                *                 <code>clusterroles</code> to assign permissions to the roles, and then bind the
                *             roles to the identities using Kubernetes <code>rolebindings</code> and
                *                 <code>clusterrolebindings</code>. For more information see <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">Using RBAC
                *                 Authorization</a> in the Kubernetes documentation.</p>
                */
            associateIdentityProviderConfig(args: AssociateIdentityProviderConfigCommandInput, options?: __HttpHandlerOptions): Promise<AssociateIdentityProviderConfigCommandOutput>;
            associateIdentityProviderConfig(args: AssociateIdentityProviderConfigCommandInput, cb: (err: any, data?: AssociateIdentityProviderConfigCommandOutput) => void): void;
            associateIdentityProviderConfig(args: AssociateIdentityProviderConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AssociateIdentityProviderConfigCommandOutput) => void): void;
            /**
                * <p>Creates an Amazon EKS add-on.</p>
                *         <p>Amazon EKS add-ons help to automate the provisioning and lifecycle management
                *             of common operational software for Amazon EKS clusters. Amazon EKS
                *             add-ons require clusters running version 1.18 or later because Amazon EKS
                *             add-ons rely on the Server-side Apply Kubernetes feature, which is only available in
                *             Kubernetes 1.18 and later. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/eks-add-ons.html">Amazon EKS add-ons</a> in
                *             the <i>Amazon EKS User Guide</i>.</p>
                */
            createAddon(args: CreateAddonCommandInput, options?: __HttpHandlerOptions): Promise<CreateAddonCommandOutput>;
            createAddon(args: CreateAddonCommandInput, cb: (err: any, data?: CreateAddonCommandOutput) => void): void;
            createAddon(args: CreateAddonCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateAddonCommandOutput) => void): void;
            /**
                * <p>Creates an Amazon EKS control plane. </p>
                *         <p>The Amazon EKS control plane consists of control plane instances that run the Kubernetes
                *             software, such as <code>etcd</code> and the API server. The control plane runs in an
                *             account managed by Amazon Web Services, and the Kubernetes API is exposed by the Amazon EKS API server
                *             endpoint. Each Amazon EKS cluster control plane is single tenant and unique. It runs on its
                *             own set of Amazon EC2 instances.</p>
                *         <p>The cluster control plane is provisioned across multiple Availability Zones and
                *             fronted by an Elastic Load Balancing Network Load Balancer. Amazon EKS also provisions elastic network interfaces in your VPC
                *             subnets to provide connectivity from the control plane instances to the nodes (for
                *             example, to support <code>kubectl exec</code>, <code>logs</code>, and <code>proxy</code>
                *             data flows).</p>
                *         <p>Amazon EKS nodes run in your Amazon Web Services account and connect to your cluster's control plane over
                *             the Kubernetes API server endpoint and a certificate file that is created for your
                *             cluster.</p>
                *
                *         <p>In most cases, it takes several minutes to create a cluster. After you create an Amazon EKS cluster,
                *             you must configure your Kubernetes tooling to communicate with the API server and launch
                *             nodes into your cluster. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/managing-auth.html">Managing Cluster
                *                 Authentication</a> and <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-workers.html">Launching Amazon EKS nodes</a> in the
                *             <i>Amazon EKS User Guide</i>.</p>
                */
            createCluster(args: CreateClusterCommandInput, options?: __HttpHandlerOptions): Promise<CreateClusterCommandOutput>;
            createCluster(args: CreateClusterCommandInput, cb: (err: any, data?: CreateClusterCommandOutput) => void): void;
            createCluster(args: CreateClusterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateClusterCommandOutput) => void): void;
            /**
                * <p>Creates an Fargate profile for your Amazon EKS cluster. You
                *             must have at least one Fargate profile in a cluster to be able to run
                *             pods on Fargate.</p>
                *         <p>The Fargate profile allows an administrator to declare which pods run
                *             on Fargate and specify which pods run on which Fargate
                *             profile. This declaration is done through the profile’s selectors. Each profile can have
                *             up to five selectors that contain a namespace and labels. A namespace is required for
                *             every selector. The label field consists of multiple optional key-value pairs. Pods that
                *             match the selectors are scheduled on Fargate. If a to-be-scheduled pod
                *             matches any of the selectors in the Fargate profile, then that pod is run
                *             on Fargate.</p>
                *         <p>When you create a Fargate profile, you must specify a pod execution
                *             role to use with the pods that are scheduled with the profile. This role is added to the
                *             cluster's Kubernetes <a href="https://kubernetes.io/docs/admin/authorization/rbac/">Role Based Access Control</a> (RBAC) for authorization so that the
                *                 <code>kubelet</code> that is running on the Fargate infrastructure
                *             can register with your Amazon EKS cluster so that it can appear in your cluster
                *             as a node. The pod execution role also provides IAM permissions to the
                *                 Fargate infrastructure to allow read access to Amazon ECR
                *             image repositories. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/pod-execution-role.html">Pod
                *                 Execution Role</a> in the <i>Amazon EKS User Guide</i>.</p>
                *         <p>Fargate profiles are immutable. However, you can create a new updated
                *             profile to replace an existing profile and then delete the original after the updated
                *             profile has finished creating.</p>
                *         <p>If any Fargate profiles in a cluster are in the <code>DELETING</code>
                *             status, you must wait for that Fargate profile to finish deleting before
                *             you can create any other profiles in that cluster.</p>
                *         <p>For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/fargate-profile.html">Fargate Profile</a> in the
                *             <i>Amazon EKS User Guide</i>.</p>
                */
            createFargateProfile(args: CreateFargateProfileCommandInput, options?: __HttpHandlerOptions): Promise<CreateFargateProfileCommandOutput>;
            createFargateProfile(args: CreateFargateProfileCommandInput, cb: (err: any, data?: CreateFargateProfileCommandOutput) => void): void;
            createFargateProfile(args: CreateFargateProfileCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateFargateProfileCommandOutput) => void): void;
            /**
                * <p>Creates a managed node group for an Amazon EKS cluster. You can only create a
                *             node group for your cluster that is equal to the current Kubernetes version for the
                *             cluster. All node groups are created with the latest AMI release version for the
                *             respective minor Kubernetes version of the cluster, unless you deploy a custom AMI using
                *             a launch template. For more information about using launch templates, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch
                *                 template support</a>.</p>
                *         <p>An Amazon EKS managed node group is an Amazon EC2
                *             Auto Scaling group and associated Amazon EC2 instances that are managed by
                *                 Amazon Web Services for an Amazon EKS cluster. Each node group uses a version
                *             of the Amazon EKS optimized Amazon Linux 2 AMI. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html">Managed
                *                 Node Groups</a> in the <i>Amazon EKS User Guide</i>. </p>
                */
            createNodegroup(args: CreateNodegroupCommandInput, options?: __HttpHandlerOptions): Promise<CreateNodegroupCommandOutput>;
            createNodegroup(args: CreateNodegroupCommandInput, cb: (err: any, data?: CreateNodegroupCommandOutput) => void): void;
            createNodegroup(args: CreateNodegroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateNodegroupCommandOutput) => void): void;
            /**
                * <p>Delete an Amazon EKS add-on.</p>
                *         <p>When you remove the add-on, it will also be deleted from the cluster. You can always
                *             manually start an add-on on the cluster using the Kubernetes API.</p>
                */
            deleteAddon(args: DeleteAddonCommandInput, options?: __HttpHandlerOptions): Promise<DeleteAddonCommandOutput>;
            deleteAddon(args: DeleteAddonCommandInput, cb: (err: any, data?: DeleteAddonCommandOutput) => void): void;
            deleteAddon(args: DeleteAddonCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteAddonCommandOutput) => void): void;
            /**
                * <p>Deletes the Amazon EKS cluster control plane.</p>
                *         <p>If you have active services in your cluster that are associated with a load balancer,
                *             you must delete those services before deleting the cluster so that the load balancers
                *             are deleted properly. Otherwise, you can have orphaned resources in your VPC that
                *             prevent you from being able to delete the VPC. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/delete-cluster.html">Deleting a
                *                 Cluster</a> in the <i>Amazon EKS User Guide</i>.</p>
                *         <p>If you have managed node groups or Fargate profiles attached to the
                *             cluster, you must delete them first. For more information, see <a>DeleteNodegroup</a> and <a>DeleteFargateProfile</a>.</p>
                */
            deleteCluster(args: DeleteClusterCommandInput, options?: __HttpHandlerOptions): Promise<DeleteClusterCommandOutput>;
            deleteCluster(args: DeleteClusterCommandInput, cb: (err: any, data?: DeleteClusterCommandOutput) => void): void;
            deleteCluster(args: DeleteClusterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteClusterCommandOutput) => void): void;
            /**
                * <p>Deletes an Fargate profile.</p>
                *         <p>When you delete a Fargate profile, any pods running on Fargate that were created with the profile are deleted. If those pods match
                *             another Fargate profile, then they are scheduled on Fargate with that profile. If they no longer match any Fargate profiles, then
                *             they are not scheduled on Fargate and they may remain in a pending
                *             state.</p>
                *         <p>Only one Fargate profile in a cluster can be in the
                *                 <code>DELETING</code> status at a time. You must wait for a Fargate
                *             profile to finish deleting before you can delete any other profiles in that
                *             cluster.</p>
                */
            deleteFargateProfile(args: DeleteFargateProfileCommandInput, options?: __HttpHandlerOptions): Promise<DeleteFargateProfileCommandOutput>;
            deleteFargateProfile(args: DeleteFargateProfileCommandInput, cb: (err: any, data?: DeleteFargateProfileCommandOutput) => void): void;
            deleteFargateProfile(args: DeleteFargateProfileCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteFargateProfileCommandOutput) => void): void;
            /**
                * <p>Deletes an Amazon EKS node group for a cluster.</p>
                */
            deleteNodegroup(args: DeleteNodegroupCommandInput, options?: __HttpHandlerOptions): Promise<DeleteNodegroupCommandOutput>;
            deleteNodegroup(args: DeleteNodegroupCommandInput, cb: (err: any, data?: DeleteNodegroupCommandOutput) => void): void;
            deleteNodegroup(args: DeleteNodegroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteNodegroupCommandOutput) => void): void;
            /**
                * <p>Deregisters a connected cluster to remove it from the Amazon EKS control
                *             plane.</p>
                */
            deregisterCluster(args: DeregisterClusterCommandInput, options?: __HttpHandlerOptions): Promise<DeregisterClusterCommandOutput>;
            deregisterCluster(args: DeregisterClusterCommandInput, cb: (err: any, data?: DeregisterClusterCommandOutput) => void): void;
            deregisterCluster(args: DeregisterClusterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeregisterClusterCommandOutput) => void): void;
            /**
                * <p>Describes an Amazon EKS add-on.</p>
                */
            describeAddon(args: DescribeAddonCommandInput, options?: __HttpHandlerOptions): Promise<DescribeAddonCommandOutput>;
            describeAddon(args: DescribeAddonCommandInput, cb: (err: any, data?: DescribeAddonCommandOutput) => void): void;
            describeAddon(args: DescribeAddonCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeAddonCommandOutput) => void): void;
            /**
                * <p>Describes the Kubernetes versions that the add-on can be used with.</p>
                */
            describeAddonVersions(args: DescribeAddonVersionsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeAddonVersionsCommandOutput>;
            describeAddonVersions(args: DescribeAddonVersionsCommandInput, cb: (err: any, data?: DescribeAddonVersionsCommandOutput) => void): void;
            describeAddonVersions(args: DescribeAddonVersionsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeAddonVersionsCommandOutput) => void): void;
            /**
                * <p>Returns descriptive information about an Amazon EKS cluster.</p>
                *         <p>The API server endpoint and certificate authority data returned by this operation are
                *             required for <code>kubelet</code> and <code>kubectl</code> to communicate with your
                *             Kubernetes API server. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html">Create a
                *                 kubeconfig for Amazon EKS</a>.</p>
                *         <note>
                *             <p>The API server endpoint and certificate authority data aren't available until the
                *                 cluster reaches the <code>ACTIVE</code> state.</p>
                *         </note>
                */
            describeCluster(args: DescribeClusterCommandInput, options?: __HttpHandlerOptions): Promise<DescribeClusterCommandOutput>;
            describeCluster(args: DescribeClusterCommandInput, cb: (err: any, data?: DescribeClusterCommandOutput) => void): void;
            describeCluster(args: DescribeClusterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeClusterCommandOutput) => void): void;
            /**
                * <p>Returns descriptive information about an Fargate profile.</p>
                */
            describeFargateProfile(args: DescribeFargateProfileCommandInput, options?: __HttpHandlerOptions): Promise<DescribeFargateProfileCommandOutput>;
            describeFargateProfile(args: DescribeFargateProfileCommandInput, cb: (err: any, data?: DescribeFargateProfileCommandOutput) => void): void;
            describeFargateProfile(args: DescribeFargateProfileCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeFargateProfileCommandOutput) => void): void;
            /**
                * <p>Returns descriptive information about an identity provider configuration.</p>
                */
            describeIdentityProviderConfig(args: DescribeIdentityProviderConfigCommandInput, options?: __HttpHandlerOptions): Promise<DescribeIdentityProviderConfigCommandOutput>;
            describeIdentityProviderConfig(args: DescribeIdentityProviderConfigCommandInput, cb: (err: any, data?: DescribeIdentityProviderConfigCommandOutput) => void): void;
            describeIdentityProviderConfig(args: DescribeIdentityProviderConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeIdentityProviderConfigCommandOutput) => void): void;
            /**
                * <p>Returns descriptive information about an Amazon EKS node group.</p>
                */
            describeNodegroup(args: DescribeNodegroupCommandInput, options?: __HttpHandlerOptions): Promise<DescribeNodegroupCommandOutput>;
            describeNodegroup(args: DescribeNodegroupCommandInput, cb: (err: any, data?: DescribeNodegroupCommandOutput) => void): void;
            describeNodegroup(args: DescribeNodegroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeNodegroupCommandOutput) => void): void;
            /**
                * <p>Returns descriptive information about an update against your Amazon EKS
                *             cluster or associated managed node group or Amazon EKS add-on.</p>
                *         <p>When the status of the update is <code>Succeeded</code>, the update is complete. If an
                *             update fails, the status is <code>Failed</code>, and an error detail explains the reason
                *             for the failure.</p>
                */
            describeUpdate(args: DescribeUpdateCommandInput, options?: __HttpHandlerOptions): Promise<DescribeUpdateCommandOutput>;
            describeUpdate(args: DescribeUpdateCommandInput, cb: (err: any, data?: DescribeUpdateCommandOutput) => void): void;
            describeUpdate(args: DescribeUpdateCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeUpdateCommandOutput) => void): void;
            /**
                * <p>Disassociates an identity provider configuration from a cluster. If you disassociate
                *             an identity provider from your cluster, users included in the provider can no longer
                *             access the cluster. However, you can still access the cluster with Amazon Web Services
                *             IAM users.</p>
                */
            disassociateIdentityProviderConfig(args: DisassociateIdentityProviderConfigCommandInput, options?: __HttpHandlerOptions): Promise<DisassociateIdentityProviderConfigCommandOutput>;
            disassociateIdentityProviderConfig(args: DisassociateIdentityProviderConfigCommandInput, cb: (err: any, data?: DisassociateIdentityProviderConfigCommandOutput) => void): void;
            disassociateIdentityProviderConfig(args: DisassociateIdentityProviderConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DisassociateIdentityProviderConfigCommandOutput) => void): void;
            /**
                * <p>Lists the available add-ons.</p>
                */
            listAddons(args: ListAddonsCommandInput, options?: __HttpHandlerOptions): Promise<ListAddonsCommandOutput>;
            listAddons(args: ListAddonsCommandInput, cb: (err: any, data?: ListAddonsCommandOutput) => void): void;
            listAddons(args: ListAddonsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListAddonsCommandOutput) => void): void;
            /**
                * <p>Lists the Amazon EKS clusters in your Amazon Web Services account in the
                *             specified Region.</p>
                */
            listClusters(args: ListClustersCommandInput, options?: __HttpHandlerOptions): Promise<ListClustersCommandOutput>;
            listClusters(args: ListClustersCommandInput, cb: (err: any, data?: ListClustersCommandOutput) => void): void;
            listClusters(args: ListClustersCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListClustersCommandOutput) => void): void;
            /**
                * <p>Lists the Fargate profiles associated with the specified cluster in
                *             your Amazon Web Services account in the specified Region.</p>
                */
            listFargateProfiles(args: ListFargateProfilesCommandInput, options?: __HttpHandlerOptions): Promise<ListFargateProfilesCommandOutput>;
            listFargateProfiles(args: ListFargateProfilesCommandInput, cb: (err: any, data?: ListFargateProfilesCommandOutput) => void): void;
            listFargateProfiles(args: ListFargateProfilesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListFargateProfilesCommandOutput) => void): void;
            /**
                * <p>A list of identity provider configurations.</p>
                */
            listIdentityProviderConfigs(args: ListIdentityProviderConfigsCommandInput, options?: __HttpHandlerOptions): Promise<ListIdentityProviderConfigsCommandOutput>;
            listIdentityProviderConfigs(args: ListIdentityProviderConfigsCommandInput, cb: (err: any, data?: ListIdentityProviderConfigsCommandOutput) => void): void;
            listIdentityProviderConfigs(args: ListIdentityProviderConfigsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListIdentityProviderConfigsCommandOutput) => void): void;
            /**
                * <p>Lists the Amazon EKS managed node groups associated with the specified cluster
                *             in your Amazon Web Services account in the specified Region. Self-managed node groups are
                *             not listed.</p>
                */
            listNodegroups(args: ListNodegroupsCommandInput, options?: __HttpHandlerOptions): Promise<ListNodegroupsCommandOutput>;
            listNodegroups(args: ListNodegroupsCommandInput, cb: (err: any, data?: ListNodegroupsCommandOutput) => void): void;
            listNodegroups(args: ListNodegroupsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListNodegroupsCommandOutput) => void): void;
            /**
                * <p>List the tags for an Amazon EKS resource.</p>
                */
            listTagsForResource(args: ListTagsForResourceCommandInput, options?: __HttpHandlerOptions): Promise<ListTagsForResourceCommandOutput>;
            listTagsForResource(args: ListTagsForResourceCommandInput, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            listTagsForResource(args: ListTagsForResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            /**
                * <p>Lists the updates associated with an Amazon EKS cluster or managed node group
                *             in your Amazon Web Services account, in the specified Region.</p>
                */
            listUpdates(args: ListUpdatesCommandInput, options?: __HttpHandlerOptions): Promise<ListUpdatesCommandOutput>;
            listUpdates(args: ListUpdatesCommandInput, cb: (err: any, data?: ListUpdatesCommandOutput) => void): void;
            listUpdates(args: ListUpdatesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListUpdatesCommandOutput) => void): void;
            /**
                * <p>Connects a Kubernetes cluster to the Amazon EKS control plane. </p>
                *         <p>Any Kubernetes cluster can be connected to the Amazon EKS control plane to
                *             view current information about the cluster and its nodes. </p>
                *         <p>Cluster connection requires two steps. First, send a <code>
                *                <a>RegisterClusterRequest</a>
                *             </code> to add it to the Amazon EKS
                *             control plane.</p>
                *         <p>Second, a <a href="https://amazon-eks.s3.us-west-2.amazonaws.com/eks-connector/manifests/eks-connector/latest/eks-connector.yaml">Manifest</a> containing the <code>activationID</code> and
                *                 <code>activationCode</code> must be applied to the Kubernetes cluster through it's
                *             native provider to provide visibility.</p>
                *
                *         <p>After the Manifest is updated and applied, then the connected cluster is visible to
                *             the Amazon EKS control plane. If the Manifest is not applied within three days,
                *             then the connected cluster will no longer be visible and must be deregistered. See <a>DeregisterCluster</a>.</p>
                */
            registerCluster(args: RegisterClusterCommandInput, options?: __HttpHandlerOptions): Promise<RegisterClusterCommandOutput>;
            registerCluster(args: RegisterClusterCommandInput, cb: (err: any, data?: RegisterClusterCommandOutput) => void): void;
            registerCluster(args: RegisterClusterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RegisterClusterCommandOutput) => void): void;
            /**
                * <p>Associates the specified tags to a resource with the specified
                *                 <code>resourceArn</code>. If existing tags on a resource are not specified in the
                *             request parameters, they are not changed. When a resource is deleted, the tags
                *             associated with that resource are deleted as well. Tags that you create for Amazon EKS resources do not propagate to any other resources associated with the
                *             cluster. For example, if you tag a cluster with this operation, that tag does not
                *             automatically propagate to the subnets and nodes associated with the cluster.</p>
                */
            tagResource(args: TagResourceCommandInput, options?: __HttpHandlerOptions): Promise<TagResourceCommandOutput>;
            tagResource(args: TagResourceCommandInput, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            tagResource(args: TagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            /**
                * <p>Deletes specified tags from a resource.</p>
                */
            untagResource(args: UntagResourceCommandInput, options?: __HttpHandlerOptions): Promise<UntagResourceCommandOutput>;
            untagResource(args: UntagResourceCommandInput, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            untagResource(args: UntagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            /**
                * <p>Updates an Amazon EKS add-on.</p>
                */
            updateAddon(args: UpdateAddonCommandInput, options?: __HttpHandlerOptions): Promise<UpdateAddonCommandOutput>;
            updateAddon(args: UpdateAddonCommandInput, cb: (err: any, data?: UpdateAddonCommandOutput) => void): void;
            updateAddon(args: UpdateAddonCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateAddonCommandOutput) => void): void;
            /**
                * <p>Updates an Amazon EKS cluster configuration. Your cluster continues to
                *             function during the update. The response output includes an update ID that you can use
                *             to track the status of your cluster update with the <a>DescribeUpdate</a> API
                *             operation.</p>
                *         <p>You can use this API operation to enable or disable exporting the Kubernetes control
                *             plane logs for your cluster to CloudWatch Logs. By default, cluster control plane
                *             logs aren't exported to CloudWatch Logs. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/control-plane-logs.html">Amazon EKS Cluster Control Plane Logs</a> in the
                *                 <i>
                *                <i>Amazon EKS User Guide</i>
                *             </i>.</p>
                *         <note>
                *             <p>CloudWatch Logs ingestion, archive storage, and data scanning rates apply to
                *                 exported control plane logs. For more information, see <a href="http://aws.amazon.com/cloudwatch/pricing/">CloudWatch
                *                 Pricing</a>.</p>
                *         </note>
                *         <p>You can also use this API operation to enable or disable public and private access to
                *             your cluster's Kubernetes API server endpoint. By default, public access is enabled, and
                *             private access is disabled. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html">Amazon EKS cluster endpoint access control</a> in the
                *                 <i>
                *                <i>Amazon EKS User Guide</i>
                *             </i>. </p>
                *         <important>
                *             <p>You can't update the subnets or security group IDs for an existing cluster.</p>
                *         </important>
                *         <p>Cluster updates are asynchronous, and they should finish within a few minutes. During
                *             an update, the cluster status moves to <code>UPDATING</code> (this status transition is
                *             eventually consistent). When the update is complete (either <code>Failed</code> or
                *                 <code>Successful</code>), the cluster status moves to <code>Active</code>.</p>
                */
            updateClusterConfig(args: UpdateClusterConfigCommandInput, options?: __HttpHandlerOptions): Promise<UpdateClusterConfigCommandOutput>;
            updateClusterConfig(args: UpdateClusterConfigCommandInput, cb: (err: any, data?: UpdateClusterConfigCommandOutput) => void): void;
            updateClusterConfig(args: UpdateClusterConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateClusterConfigCommandOutput) => void): void;
            /**
                * <p>Updates an Amazon EKS cluster to the specified Kubernetes version. Your
                *             cluster continues to function during the update. The response output includes an update
                *             ID that you can use to track the status of your cluster update with the <a>DescribeUpdate</a> API operation.</p>
                *         <p>Cluster updates are asynchronous, and they should finish within a few minutes. During
                *             an update, the cluster status moves to <code>UPDATING</code> (this status transition is
                *             eventually consistent). When the update is complete (either <code>Failed</code> or
                *                 <code>Successful</code>), the cluster status moves to <code>Active</code>.</p>
                *         <p>If your cluster has managed node groups attached to it, all of your node groups’
                *             Kubernetes versions must match the cluster’s Kubernetes version in order to update the
                *             cluster to a new Kubernetes version.</p>
                */
            updateClusterVersion(args: UpdateClusterVersionCommandInput, options?: __HttpHandlerOptions): Promise<UpdateClusterVersionCommandOutput>;
            updateClusterVersion(args: UpdateClusterVersionCommandInput, cb: (err: any, data?: UpdateClusterVersionCommandOutput) => void): void;
            updateClusterVersion(args: UpdateClusterVersionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateClusterVersionCommandOutput) => void): void;
            /**
                * <p>Updates an Amazon EKS managed node group configuration. Your node group
                *             continues to function during the update. The response output includes an update ID that
                *             you can use to track the status of your node group update with the <a>DescribeUpdate</a> API operation. Currently you can update the Kubernetes
                *             labels for a node group or the scaling configuration.</p>
                */
            updateNodegroupConfig(args: UpdateNodegroupConfigCommandInput, options?: __HttpHandlerOptions): Promise<UpdateNodegroupConfigCommandOutput>;
            updateNodegroupConfig(args: UpdateNodegroupConfigCommandInput, cb: (err: any, data?: UpdateNodegroupConfigCommandOutput) => void): void;
            updateNodegroupConfig(args: UpdateNodegroupConfigCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateNodegroupConfigCommandOutput) => void): void;
            /**
                * <p>Updates the Kubernetes version or AMI version of an Amazon EKS managed node
                *             group.</p>
                *         <p>You can update a node group using a launch template only if the node group was
                *             originally deployed with a launch template. If you need to update a custom AMI in a node
                *             group that was deployed with a launch template, then update your custom AMI, specify the
                *             new ID in a new version of the launch template, and then update the node group to the
                *             new version of the launch template.</p>
                *         <p>If you update without a launch template, then you can update to the latest available
                *             AMI version of a node group's current Kubernetes version by not specifying a Kubernetes
                *             version in the request. You can update to the latest AMI version of your cluster's
                *             current Kubernetes version by specifying your cluster's Kubernetes version in the
                *             request. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html">Amazon EKS optimized Amazon Linux 2 AMI versions</a> in the <i>Amazon EKS User Guide</i>.</p>
                *         <p>You cannot roll back a node group to an earlier Kubernetes version or AMI
                *             version.</p>
                *         <p>When a node in a managed node group is terminated due to a scaling action or update,
                *             the pods in that node are drained first. Amazon EKS attempts to drain the nodes
                *             gracefully and will fail if it is unable to do so. You can <code>force</code> the update
                *             if Amazon EKS is unable to drain the nodes as a result of a pod disruption
                *             budget issue.</p>
                */
            updateNodegroupVersion(args: UpdateNodegroupVersionCommandInput, options?: __HttpHandlerOptions): Promise<UpdateNodegroupVersionCommandOutput>;
            updateNodegroupVersion(args: UpdateNodegroupVersionCommandInput, cb: (err: any, data?: UpdateNodegroupVersionCommandOutput) => void): void;
            updateNodegroupVersion(args: UpdateNodegroupVersionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateNodegroupVersionCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/AssociateEncryptionConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { AssociateEncryptionConfigRequest, AssociateEncryptionConfigResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface AssociateEncryptionConfigCommandInput extends AssociateEncryptionConfigRequest {
    }
    export interface AssociateEncryptionConfigCommandOutput extends AssociateEncryptionConfigResponse, __MetadataBearer {
    }
    /**
        * <p>Associate encryption configuration to an existing cluster.</p>
        *         <p>You can use this API to enable encryption on existing clusters which do not have
        *             encryption already enabled. This allows you to implement a defense-in-depth security
        *             strategy without migrating applications to new Amazon EKS clusters.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, AssociateEncryptionConfigCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, AssociateEncryptionConfigCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new AssociateEncryptionConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link AssociateEncryptionConfigCommandInput} for command's `input` shape.
        * @see {@link AssociateEncryptionConfigCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class AssociateEncryptionConfigCommand extends $Command<AssociateEncryptionConfigCommandInput, AssociateEncryptionConfigCommandOutput, EKSClientResolvedConfig> {
            readonly input: AssociateEncryptionConfigCommandInput;
            constructor(input: AssociateEncryptionConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<AssociateEncryptionConfigCommandInput, AssociateEncryptionConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/AssociateIdentityProviderConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { AssociateIdentityProviderConfigRequest, AssociateIdentityProviderConfigResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface AssociateIdentityProviderConfigCommandInput extends AssociateIdentityProviderConfigRequest {
    }
    export interface AssociateIdentityProviderConfigCommandOutput extends AssociateIdentityProviderConfigResponse, __MetadataBearer {
    }
    /**
        * <p>Associate an identity provider configuration to a cluster.</p>
        *         <p>If you want to authenticate identities using an identity provider, you can create an
        *             identity provider configuration and associate it to your cluster. After configuring
        *             authentication to your cluster you can create Kubernetes <code>roles</code> and
        *                 <code>clusterroles</code> to assign permissions to the roles, and then bind the
        *             roles to the identities using Kubernetes <code>rolebindings</code> and
        *                 <code>clusterrolebindings</code>. For more information see <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">Using RBAC
        *                 Authorization</a> in the Kubernetes documentation.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, AssociateIdentityProviderConfigCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, AssociateIdentityProviderConfigCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new AssociateIdentityProviderConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link AssociateIdentityProviderConfigCommandInput} for command's `input` shape.
        * @see {@link AssociateIdentityProviderConfigCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class AssociateIdentityProviderConfigCommand extends $Command<AssociateIdentityProviderConfigCommandInput, AssociateIdentityProviderConfigCommandOutput, EKSClientResolvedConfig> {
            readonly input: AssociateIdentityProviderConfigCommandInput;
            constructor(input: AssociateIdentityProviderConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<AssociateIdentityProviderConfigCommandInput, AssociateIdentityProviderConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/CreateAddonCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { CreateAddonRequest, CreateAddonResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface CreateAddonCommandInput extends CreateAddonRequest {
    }
    export interface CreateAddonCommandOutput extends CreateAddonResponse, __MetadataBearer {
    }
    /**
        * <p>Creates an Amazon EKS add-on.</p>
        *         <p>Amazon EKS add-ons help to automate the provisioning and lifecycle management
        *             of common operational software for Amazon EKS clusters. Amazon EKS
        *             add-ons require clusters running version 1.18 or later because Amazon EKS
        *             add-ons rely on the Server-side Apply Kubernetes feature, which is only available in
        *             Kubernetes 1.18 and later. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/eks-add-ons.html">Amazon EKS add-ons</a> in
        *             the <i>Amazon EKS User Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, CreateAddonCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, CreateAddonCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new CreateAddonCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateAddonCommandInput} for command's `input` shape.
        * @see {@link CreateAddonCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class CreateAddonCommand extends $Command<CreateAddonCommandInput, CreateAddonCommandOutput, EKSClientResolvedConfig> {
            readonly input: CreateAddonCommandInput;
            constructor(input: CreateAddonCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateAddonCommandInput, CreateAddonCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/CreateClusterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { CreateClusterRequest, CreateClusterResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface CreateClusterCommandInput extends CreateClusterRequest {
    }
    export interface CreateClusterCommandOutput extends CreateClusterResponse, __MetadataBearer {
    }
    /**
        * <p>Creates an Amazon EKS control plane. </p>
        *         <p>The Amazon EKS control plane consists of control plane instances that run the Kubernetes
        *             software, such as <code>etcd</code> and the API server. The control plane runs in an
        *             account managed by Amazon Web Services, and the Kubernetes API is exposed by the Amazon EKS API server
        *             endpoint. Each Amazon EKS cluster control plane is single tenant and unique. It runs on its
        *             own set of Amazon EC2 instances.</p>
        *         <p>The cluster control plane is provisioned across multiple Availability Zones and
        *             fronted by an Elastic Load Balancing Network Load Balancer. Amazon EKS also provisions elastic network interfaces in your VPC
        *             subnets to provide connectivity from the control plane instances to the nodes (for
        *             example, to support <code>kubectl exec</code>, <code>logs</code>, and <code>proxy</code>
        *             data flows).</p>
        *         <p>Amazon EKS nodes run in your Amazon Web Services account and connect to your cluster's control plane over
        *             the Kubernetes API server endpoint and a certificate file that is created for your
        *             cluster.</p>
        *
        *         <p>In most cases, it takes several minutes to create a cluster. After you create an Amazon EKS cluster,
        *             you must configure your Kubernetes tooling to communicate with the API server and launch
        *             nodes into your cluster. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/managing-auth.html">Managing Cluster
        *                 Authentication</a> and <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-workers.html">Launching Amazon EKS nodes</a> in the
        *             <i>Amazon EKS User Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, CreateClusterCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, CreateClusterCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new CreateClusterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateClusterCommandInput} for command's `input` shape.
        * @see {@link CreateClusterCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class CreateClusterCommand extends $Command<CreateClusterCommandInput, CreateClusterCommandOutput, EKSClientResolvedConfig> {
            readonly input: CreateClusterCommandInput;
            constructor(input: CreateClusterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateClusterCommandInput, CreateClusterCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/CreateFargateProfileCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { CreateFargateProfileRequest, CreateFargateProfileResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface CreateFargateProfileCommandInput extends CreateFargateProfileRequest {
    }
    export interface CreateFargateProfileCommandOutput extends CreateFargateProfileResponse, __MetadataBearer {
    }
    /**
        * <p>Creates an Fargate profile for your Amazon EKS cluster. You
        *             must have at least one Fargate profile in a cluster to be able to run
        *             pods on Fargate.</p>
        *         <p>The Fargate profile allows an administrator to declare which pods run
        *             on Fargate and specify which pods run on which Fargate
        *             profile. This declaration is done through the profile’s selectors. Each profile can have
        *             up to five selectors that contain a namespace and labels. A namespace is required for
        *             every selector. The label field consists of multiple optional key-value pairs. Pods that
        *             match the selectors are scheduled on Fargate. If a to-be-scheduled pod
        *             matches any of the selectors in the Fargate profile, then that pod is run
        *             on Fargate.</p>
        *         <p>When you create a Fargate profile, you must specify a pod execution
        *             role to use with the pods that are scheduled with the profile. This role is added to the
        *             cluster's Kubernetes <a href="https://kubernetes.io/docs/admin/authorization/rbac/">Role Based Access Control</a> (RBAC) for authorization so that the
        *                 <code>kubelet</code> that is running on the Fargate infrastructure
        *             can register with your Amazon EKS cluster so that it can appear in your cluster
        *             as a node. The pod execution role also provides IAM permissions to the
        *                 Fargate infrastructure to allow read access to Amazon ECR
        *             image repositories. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/pod-execution-role.html">Pod
        *                 Execution Role</a> in the <i>Amazon EKS User Guide</i>.</p>
        *         <p>Fargate profiles are immutable. However, you can create a new updated
        *             profile to replace an existing profile and then delete the original after the updated
        *             profile has finished creating.</p>
        *         <p>If any Fargate profiles in a cluster are in the <code>DELETING</code>
        *             status, you must wait for that Fargate profile to finish deleting before
        *             you can create any other profiles in that cluster.</p>
        *         <p>For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/fargate-profile.html">Fargate Profile</a> in the
        *             <i>Amazon EKS User Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, CreateFargateProfileCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, CreateFargateProfileCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new CreateFargateProfileCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateFargateProfileCommandInput} for command's `input` shape.
        * @see {@link CreateFargateProfileCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class CreateFargateProfileCommand extends $Command<CreateFargateProfileCommandInput, CreateFargateProfileCommandOutput, EKSClientResolvedConfig> {
            readonly input: CreateFargateProfileCommandInput;
            constructor(input: CreateFargateProfileCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateFargateProfileCommandInput, CreateFargateProfileCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/CreateNodegroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { CreateNodegroupRequest, CreateNodegroupResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface CreateNodegroupCommandInput extends CreateNodegroupRequest {
    }
    export interface CreateNodegroupCommandOutput extends CreateNodegroupResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a managed node group for an Amazon EKS cluster. You can only create a
        *             node group for your cluster that is equal to the current Kubernetes version for the
        *             cluster. All node groups are created with the latest AMI release version for the
        *             respective minor Kubernetes version of the cluster, unless you deploy a custom AMI using
        *             a launch template. For more information about using launch templates, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch
        *                 template support</a>.</p>
        *         <p>An Amazon EKS managed node group is an Amazon EC2
        *             Auto Scaling group and associated Amazon EC2 instances that are managed by
        *                 Amazon Web Services for an Amazon EKS cluster. Each node group uses a version
        *             of the Amazon EKS optimized Amazon Linux 2 AMI. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html">Managed
        *                 Node Groups</a> in the <i>Amazon EKS User Guide</i>. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, CreateNodegroupCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, CreateNodegroupCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new CreateNodegroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateNodegroupCommandInput} for command's `input` shape.
        * @see {@link CreateNodegroupCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class CreateNodegroupCommand extends $Command<CreateNodegroupCommandInput, CreateNodegroupCommandOutput, EKSClientResolvedConfig> {
            readonly input: CreateNodegroupCommandInput;
            constructor(input: CreateNodegroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateNodegroupCommandInput, CreateNodegroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DeleteAddonCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { DeleteAddonRequest, DeleteAddonResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface DeleteAddonCommandInput extends DeleteAddonRequest {
    }
    export interface DeleteAddonCommandOutput extends DeleteAddonResponse, __MetadataBearer {
    }
    /**
        * <p>Delete an Amazon EKS add-on.</p>
        *         <p>When you remove the add-on, it will also be deleted from the cluster. You can always
        *             manually start an add-on on the cluster using the Kubernetes API.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, DeleteAddonCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, DeleteAddonCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new DeleteAddonCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteAddonCommandInput} for command's `input` shape.
        * @see {@link DeleteAddonCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class DeleteAddonCommand extends $Command<DeleteAddonCommandInput, DeleteAddonCommandOutput, EKSClientResolvedConfig> {
            readonly input: DeleteAddonCommandInput;
            constructor(input: DeleteAddonCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteAddonCommandInput, DeleteAddonCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DeleteClusterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { DeleteClusterRequest, DeleteClusterResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface DeleteClusterCommandInput extends DeleteClusterRequest {
    }
    export interface DeleteClusterCommandOutput extends DeleteClusterResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes the Amazon EKS cluster control plane.</p>
        *         <p>If you have active services in your cluster that are associated with a load balancer,
        *             you must delete those services before deleting the cluster so that the load balancers
        *             are deleted properly. Otherwise, you can have orphaned resources in your VPC that
        *             prevent you from being able to delete the VPC. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/delete-cluster.html">Deleting a
        *                 Cluster</a> in the <i>Amazon EKS User Guide</i>.</p>
        *         <p>If you have managed node groups or Fargate profiles attached to the
        *             cluster, you must delete them first. For more information, see <a>DeleteNodegroup</a> and <a>DeleteFargateProfile</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, DeleteClusterCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, DeleteClusterCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new DeleteClusterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteClusterCommandInput} for command's `input` shape.
        * @see {@link DeleteClusterCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class DeleteClusterCommand extends $Command<DeleteClusterCommandInput, DeleteClusterCommandOutput, EKSClientResolvedConfig> {
            readonly input: DeleteClusterCommandInput;
            constructor(input: DeleteClusterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteClusterCommandInput, DeleteClusterCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DeleteFargateProfileCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { DeleteFargateProfileRequest, DeleteFargateProfileResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface DeleteFargateProfileCommandInput extends DeleteFargateProfileRequest {
    }
    export interface DeleteFargateProfileCommandOutput extends DeleteFargateProfileResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes an Fargate profile.</p>
        *         <p>When you delete a Fargate profile, any pods running on Fargate that were created with the profile are deleted. If those pods match
        *             another Fargate profile, then they are scheduled on Fargate with that profile. If they no longer match any Fargate profiles, then
        *             they are not scheduled on Fargate and they may remain in a pending
        *             state.</p>
        *         <p>Only one Fargate profile in a cluster can be in the
        *                 <code>DELETING</code> status at a time. You must wait for a Fargate
        *             profile to finish deleting before you can delete any other profiles in that
        *             cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, DeleteFargateProfileCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, DeleteFargateProfileCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new DeleteFargateProfileCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteFargateProfileCommandInput} for command's `input` shape.
        * @see {@link DeleteFargateProfileCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class DeleteFargateProfileCommand extends $Command<DeleteFargateProfileCommandInput, DeleteFargateProfileCommandOutput, EKSClientResolvedConfig> {
            readonly input: DeleteFargateProfileCommandInput;
            constructor(input: DeleteFargateProfileCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteFargateProfileCommandInput, DeleteFargateProfileCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DeleteNodegroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { DeleteNodegroupRequest, DeleteNodegroupResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface DeleteNodegroupCommandInput extends DeleteNodegroupRequest {
    }
    export interface DeleteNodegroupCommandOutput extends DeleteNodegroupResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes an Amazon EKS node group for a cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, DeleteNodegroupCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, DeleteNodegroupCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new DeleteNodegroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteNodegroupCommandInput} for command's `input` shape.
        * @see {@link DeleteNodegroupCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class DeleteNodegroupCommand extends $Command<DeleteNodegroupCommandInput, DeleteNodegroupCommandOutput, EKSClientResolvedConfig> {
            readonly input: DeleteNodegroupCommandInput;
            constructor(input: DeleteNodegroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteNodegroupCommandInput, DeleteNodegroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DeregisterClusterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { DeregisterClusterRequest, DeregisterClusterResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface DeregisterClusterCommandInput extends DeregisterClusterRequest {
    }
    export interface DeregisterClusterCommandOutput extends DeregisterClusterResponse, __MetadataBearer {
    }
    /**
        * <p>Deregisters a connected cluster to remove it from the Amazon EKS control
        *             plane.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, DeregisterClusterCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, DeregisterClusterCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new DeregisterClusterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeregisterClusterCommandInput} for command's `input` shape.
        * @see {@link DeregisterClusterCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class DeregisterClusterCommand extends $Command<DeregisterClusterCommandInput, DeregisterClusterCommandOutput, EKSClientResolvedConfig> {
            readonly input: DeregisterClusterCommandInput;
            constructor(input: DeregisterClusterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeregisterClusterCommandInput, DeregisterClusterCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DescribeAddonCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { DescribeAddonRequest, DescribeAddonResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface DescribeAddonCommandInput extends DescribeAddonRequest {
    }
    export interface DescribeAddonCommandOutput extends DescribeAddonResponse, __MetadataBearer {
    }
    /**
        * <p>Describes an Amazon EKS add-on.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, DescribeAddonCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, DescribeAddonCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new DescribeAddonCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeAddonCommandInput} for command's `input` shape.
        * @see {@link DescribeAddonCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class DescribeAddonCommand extends $Command<DescribeAddonCommandInput, DescribeAddonCommandOutput, EKSClientResolvedConfig> {
            readonly input: DescribeAddonCommandInput;
            constructor(input: DescribeAddonCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeAddonCommandInput, DescribeAddonCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DescribeAddonVersionsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { DescribeAddonVersionsRequest, DescribeAddonVersionsResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface DescribeAddonVersionsCommandInput extends DescribeAddonVersionsRequest {
    }
    export interface DescribeAddonVersionsCommandOutput extends DescribeAddonVersionsResponse, __MetadataBearer {
    }
    /**
        * <p>Describes the Kubernetes versions that the add-on can be used with.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, DescribeAddonVersionsCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, DescribeAddonVersionsCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new DescribeAddonVersionsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeAddonVersionsCommandInput} for command's `input` shape.
        * @see {@link DescribeAddonVersionsCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class DescribeAddonVersionsCommand extends $Command<DescribeAddonVersionsCommandInput, DescribeAddonVersionsCommandOutput, EKSClientResolvedConfig> {
            readonly input: DescribeAddonVersionsCommandInput;
            constructor(input: DescribeAddonVersionsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeAddonVersionsCommandInput, DescribeAddonVersionsCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DescribeClusterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { DescribeClusterRequest, DescribeClusterResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface DescribeClusterCommandInput extends DescribeClusterRequest {
    }
    export interface DescribeClusterCommandOutput extends DescribeClusterResponse, __MetadataBearer {
    }
    /**
        * <p>Returns descriptive information about an Amazon EKS cluster.</p>
        *         <p>The API server endpoint and certificate authority data returned by this operation are
        *             required for <code>kubelet</code> and <code>kubectl</code> to communicate with your
        *             Kubernetes API server. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html">Create a
        *                 kubeconfig for Amazon EKS</a>.</p>
        *         <note>
        *             <p>The API server endpoint and certificate authority data aren't available until the
        *                 cluster reaches the <code>ACTIVE</code> state.</p>
        *         </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, DescribeClusterCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, DescribeClusterCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new DescribeClusterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeClusterCommandInput} for command's `input` shape.
        * @see {@link DescribeClusterCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class DescribeClusterCommand extends $Command<DescribeClusterCommandInput, DescribeClusterCommandOutput, EKSClientResolvedConfig> {
            readonly input: DescribeClusterCommandInput;
            constructor(input: DescribeClusterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeClusterCommandInput, DescribeClusterCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DescribeFargateProfileCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { DescribeFargateProfileRequest, DescribeFargateProfileResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface DescribeFargateProfileCommandInput extends DescribeFargateProfileRequest {
    }
    export interface DescribeFargateProfileCommandOutput extends DescribeFargateProfileResponse, __MetadataBearer {
    }
    /**
        * <p>Returns descriptive information about an Fargate profile.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, DescribeFargateProfileCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, DescribeFargateProfileCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new DescribeFargateProfileCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeFargateProfileCommandInput} for command's `input` shape.
        * @see {@link DescribeFargateProfileCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class DescribeFargateProfileCommand extends $Command<DescribeFargateProfileCommandInput, DescribeFargateProfileCommandOutput, EKSClientResolvedConfig> {
            readonly input: DescribeFargateProfileCommandInput;
            constructor(input: DescribeFargateProfileCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeFargateProfileCommandInput, DescribeFargateProfileCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DescribeIdentityProviderConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { DescribeIdentityProviderConfigRequest, DescribeIdentityProviderConfigResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface DescribeIdentityProviderConfigCommandInput extends DescribeIdentityProviderConfigRequest {
    }
    export interface DescribeIdentityProviderConfigCommandOutput extends DescribeIdentityProviderConfigResponse, __MetadataBearer {
    }
    /**
        * <p>Returns descriptive information about an identity provider configuration.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, DescribeIdentityProviderConfigCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, DescribeIdentityProviderConfigCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new DescribeIdentityProviderConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeIdentityProviderConfigCommandInput} for command's `input` shape.
        * @see {@link DescribeIdentityProviderConfigCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class DescribeIdentityProviderConfigCommand extends $Command<DescribeIdentityProviderConfigCommandInput, DescribeIdentityProviderConfigCommandOutput, EKSClientResolvedConfig> {
            readonly input: DescribeIdentityProviderConfigCommandInput;
            constructor(input: DescribeIdentityProviderConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeIdentityProviderConfigCommandInput, DescribeIdentityProviderConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DescribeNodegroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { DescribeNodegroupRequest, DescribeNodegroupResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface DescribeNodegroupCommandInput extends DescribeNodegroupRequest {
    }
    export interface DescribeNodegroupCommandOutput extends DescribeNodegroupResponse, __MetadataBearer {
    }
    /**
        * <p>Returns descriptive information about an Amazon EKS node group.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, DescribeNodegroupCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, DescribeNodegroupCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new DescribeNodegroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeNodegroupCommandInput} for command's `input` shape.
        * @see {@link DescribeNodegroupCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class DescribeNodegroupCommand extends $Command<DescribeNodegroupCommandInput, DescribeNodegroupCommandOutput, EKSClientResolvedConfig> {
            readonly input: DescribeNodegroupCommandInput;
            constructor(input: DescribeNodegroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeNodegroupCommandInput, DescribeNodegroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DescribeUpdateCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { DescribeUpdateRequest, DescribeUpdateResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface DescribeUpdateCommandInput extends DescribeUpdateRequest {
    }
    export interface DescribeUpdateCommandOutput extends DescribeUpdateResponse, __MetadataBearer {
    }
    /**
        * <p>Returns descriptive information about an update against your Amazon EKS
        *             cluster or associated managed node group or Amazon EKS add-on.</p>
        *         <p>When the status of the update is <code>Succeeded</code>, the update is complete. If an
        *             update fails, the status is <code>Failed</code>, and an error detail explains the reason
        *             for the failure.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, DescribeUpdateCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, DescribeUpdateCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new DescribeUpdateCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeUpdateCommandInput} for command's `input` shape.
        * @see {@link DescribeUpdateCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class DescribeUpdateCommand extends $Command<DescribeUpdateCommandInput, DescribeUpdateCommandOutput, EKSClientResolvedConfig> {
            readonly input: DescribeUpdateCommandInput;
            constructor(input: DescribeUpdateCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeUpdateCommandInput, DescribeUpdateCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DisassociateIdentityProviderConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { DisassociateIdentityProviderConfigRequest, DisassociateIdentityProviderConfigResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface DisassociateIdentityProviderConfigCommandInput extends DisassociateIdentityProviderConfigRequest {
    }
    export interface DisassociateIdentityProviderConfigCommandOutput extends DisassociateIdentityProviderConfigResponse, __MetadataBearer {
    }
    /**
        * <p>Disassociates an identity provider configuration from a cluster. If you disassociate
        *             an identity provider from your cluster, users included in the provider can no longer
        *             access the cluster. However, you can still access the cluster with Amazon Web Services
        *             IAM users.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, DisassociateIdentityProviderConfigCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, DisassociateIdentityProviderConfigCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new DisassociateIdentityProviderConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DisassociateIdentityProviderConfigCommandInput} for command's `input` shape.
        * @see {@link DisassociateIdentityProviderConfigCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class DisassociateIdentityProviderConfigCommand extends $Command<DisassociateIdentityProviderConfigCommandInput, DisassociateIdentityProviderConfigCommandOutput, EKSClientResolvedConfig> {
            readonly input: DisassociateIdentityProviderConfigCommandInput;
            constructor(input: DisassociateIdentityProviderConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DisassociateIdentityProviderConfigCommandInput, DisassociateIdentityProviderConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/ListAddonsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { ListAddonsRequest, ListAddonsResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface ListAddonsCommandInput extends ListAddonsRequest {
    }
    export interface ListAddonsCommandOutput extends ListAddonsResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the available add-ons.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, ListAddonsCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, ListAddonsCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new ListAddonsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListAddonsCommandInput} for command's `input` shape.
        * @see {@link ListAddonsCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class ListAddonsCommand extends $Command<ListAddonsCommandInput, ListAddonsCommandOutput, EKSClientResolvedConfig> {
            readonly input: ListAddonsCommandInput;
            constructor(input: ListAddonsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListAddonsCommandInput, ListAddonsCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/ListClustersCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { ListClustersRequest, ListClustersResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface ListClustersCommandInput extends ListClustersRequest {
    }
    export interface ListClustersCommandOutput extends ListClustersResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the Amazon EKS clusters in your Amazon Web Services account in the
        *             specified Region.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, ListClustersCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, ListClustersCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new ListClustersCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListClustersCommandInput} for command's `input` shape.
        * @see {@link ListClustersCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class ListClustersCommand extends $Command<ListClustersCommandInput, ListClustersCommandOutput, EKSClientResolvedConfig> {
            readonly input: ListClustersCommandInput;
            constructor(input: ListClustersCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListClustersCommandInput, ListClustersCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/ListFargateProfilesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { ListFargateProfilesRequest, ListFargateProfilesResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface ListFargateProfilesCommandInput extends ListFargateProfilesRequest {
    }
    export interface ListFargateProfilesCommandOutput extends ListFargateProfilesResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the Fargate profiles associated with the specified cluster in
        *             your Amazon Web Services account in the specified Region.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, ListFargateProfilesCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, ListFargateProfilesCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new ListFargateProfilesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListFargateProfilesCommandInput} for command's `input` shape.
        * @see {@link ListFargateProfilesCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class ListFargateProfilesCommand extends $Command<ListFargateProfilesCommandInput, ListFargateProfilesCommandOutput, EKSClientResolvedConfig> {
            readonly input: ListFargateProfilesCommandInput;
            constructor(input: ListFargateProfilesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListFargateProfilesCommandInput, ListFargateProfilesCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/ListIdentityProviderConfigsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { ListIdentityProviderConfigsRequest, ListIdentityProviderConfigsResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface ListIdentityProviderConfigsCommandInput extends ListIdentityProviderConfigsRequest {
    }
    export interface ListIdentityProviderConfigsCommandOutput extends ListIdentityProviderConfigsResponse, __MetadataBearer {
    }
    /**
        * <p>A list of identity provider configurations.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, ListIdentityProviderConfigsCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, ListIdentityProviderConfigsCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new ListIdentityProviderConfigsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListIdentityProviderConfigsCommandInput} for command's `input` shape.
        * @see {@link ListIdentityProviderConfigsCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class ListIdentityProviderConfigsCommand extends $Command<ListIdentityProviderConfigsCommandInput, ListIdentityProviderConfigsCommandOutput, EKSClientResolvedConfig> {
            readonly input: ListIdentityProviderConfigsCommandInput;
            constructor(input: ListIdentityProviderConfigsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListIdentityProviderConfigsCommandInput, ListIdentityProviderConfigsCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/ListNodegroupsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { ListNodegroupsRequest, ListNodegroupsResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface ListNodegroupsCommandInput extends ListNodegroupsRequest {
    }
    export interface ListNodegroupsCommandOutput extends ListNodegroupsResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the Amazon EKS managed node groups associated with the specified cluster
        *             in your Amazon Web Services account in the specified Region. Self-managed node groups are
        *             not listed.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, ListNodegroupsCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, ListNodegroupsCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new ListNodegroupsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListNodegroupsCommandInput} for command's `input` shape.
        * @see {@link ListNodegroupsCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class ListNodegroupsCommand extends $Command<ListNodegroupsCommandInput, ListNodegroupsCommandOutput, EKSClientResolvedConfig> {
            readonly input: ListNodegroupsCommandInput;
            constructor(input: ListNodegroupsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListNodegroupsCommandInput, ListNodegroupsCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/ListTagsForResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { ListTagsForResourceRequest, ListTagsForResourceResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface ListTagsForResourceCommandInput extends ListTagsForResourceRequest {
    }
    export interface ListTagsForResourceCommandOutput extends ListTagsForResourceResponse, __MetadataBearer {
    }
    /**
        * <p>List the tags for an Amazon EKS resource.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, ListTagsForResourceCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, ListTagsForResourceCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new ListTagsForResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTagsForResourceCommandInput} for command's `input` shape.
        * @see {@link ListTagsForResourceCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class ListTagsForResourceCommand extends $Command<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput, EKSClientResolvedConfig> {
            readonly input: ListTagsForResourceCommandInput;
            constructor(input: ListTagsForResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/ListUpdatesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { ListUpdatesRequest, ListUpdatesResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface ListUpdatesCommandInput extends ListUpdatesRequest {
    }
    export interface ListUpdatesCommandOutput extends ListUpdatesResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the updates associated with an Amazon EKS cluster or managed node group
        *             in your Amazon Web Services account, in the specified Region.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, ListUpdatesCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, ListUpdatesCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new ListUpdatesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListUpdatesCommandInput} for command's `input` shape.
        * @see {@link ListUpdatesCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class ListUpdatesCommand extends $Command<ListUpdatesCommandInput, ListUpdatesCommandOutput, EKSClientResolvedConfig> {
            readonly input: ListUpdatesCommandInput;
            constructor(input: ListUpdatesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListUpdatesCommandInput, ListUpdatesCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/RegisterClusterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { RegisterClusterRequest, RegisterClusterResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface RegisterClusterCommandInput extends RegisterClusterRequest {
    }
    export interface RegisterClusterCommandOutput extends RegisterClusterResponse, __MetadataBearer {
    }
    /**
        * <p>Connects a Kubernetes cluster to the Amazon EKS control plane. </p>
        *         <p>Any Kubernetes cluster can be connected to the Amazon EKS control plane to
        *             view current information about the cluster and its nodes. </p>
        *         <p>Cluster connection requires two steps. First, send a <code>
        *                <a>RegisterClusterRequest</a>
        *             </code> to add it to the Amazon EKS
        *             control plane.</p>
        *         <p>Second, a <a href="https://amazon-eks.s3.us-west-2.amazonaws.com/eks-connector/manifests/eks-connector/latest/eks-connector.yaml">Manifest</a> containing the <code>activationID</code> and
        *                 <code>activationCode</code> must be applied to the Kubernetes cluster through it's
        *             native provider to provide visibility.</p>
        *
        *         <p>After the Manifest is updated and applied, then the connected cluster is visible to
        *             the Amazon EKS control plane. If the Manifest is not applied within three days,
        *             then the connected cluster will no longer be visible and must be deregistered. See <a>DeregisterCluster</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, RegisterClusterCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, RegisterClusterCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new RegisterClusterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RegisterClusterCommandInput} for command's `input` shape.
        * @see {@link RegisterClusterCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class RegisterClusterCommand extends $Command<RegisterClusterCommandInput, RegisterClusterCommandOutput, EKSClientResolvedConfig> {
            readonly input: RegisterClusterCommandInput;
            constructor(input: RegisterClusterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RegisterClusterCommandInput, RegisterClusterCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/TagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { TagResourceRequest, TagResourceResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface TagResourceCommandInput extends TagResourceRequest {
    }
    export interface TagResourceCommandOutput extends TagResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Associates the specified tags to a resource with the specified
        *                 <code>resourceArn</code>. If existing tags on a resource are not specified in the
        *             request parameters, they are not changed. When a resource is deleted, the tags
        *             associated with that resource are deleted as well. Tags that you create for Amazon EKS resources do not propagate to any other resources associated with the
        *             cluster. For example, if you tag a cluster with this operation, that tag does not
        *             automatically propagate to the subnets and nodes associated with the cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, TagResourceCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, TagResourceCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new TagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TagResourceCommandInput} for command's `input` shape.
        * @see {@link TagResourceCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class TagResourceCommand extends $Command<TagResourceCommandInput, TagResourceCommandOutput, EKSClientResolvedConfig> {
            readonly input: TagResourceCommandInput;
            constructor(input: TagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TagResourceCommandInput, TagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/UntagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { UntagResourceRequest, UntagResourceResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface UntagResourceCommandInput extends UntagResourceRequest {
    }
    export interface UntagResourceCommandOutput extends UntagResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes specified tags from a resource.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, UntagResourceCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, UntagResourceCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new UntagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UntagResourceCommandInput} for command's `input` shape.
        * @see {@link UntagResourceCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class UntagResourceCommand extends $Command<UntagResourceCommandInput, UntagResourceCommandOutput, EKSClientResolvedConfig> {
            readonly input: UntagResourceCommandInput;
            constructor(input: UntagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UntagResourceCommandInput, UntagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/UpdateAddonCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { UpdateAddonRequest, UpdateAddonResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface UpdateAddonCommandInput extends UpdateAddonRequest {
    }
    export interface UpdateAddonCommandOutput extends UpdateAddonResponse, __MetadataBearer {
    }
    /**
        * <p>Updates an Amazon EKS add-on.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, UpdateAddonCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, UpdateAddonCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new UpdateAddonCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateAddonCommandInput} for command's `input` shape.
        * @see {@link UpdateAddonCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class UpdateAddonCommand extends $Command<UpdateAddonCommandInput, UpdateAddonCommandOutput, EKSClientResolvedConfig> {
            readonly input: UpdateAddonCommandInput;
            constructor(input: UpdateAddonCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateAddonCommandInput, UpdateAddonCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/UpdateClusterConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { UpdateClusterConfigRequest, UpdateClusterConfigResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface UpdateClusterConfigCommandInput extends UpdateClusterConfigRequest {
    }
    export interface UpdateClusterConfigCommandOutput extends UpdateClusterConfigResponse, __MetadataBearer {
    }
    /**
        * <p>Updates an Amazon EKS cluster configuration. Your cluster continues to
        *             function during the update. The response output includes an update ID that you can use
        *             to track the status of your cluster update with the <a>DescribeUpdate</a> API
        *             operation.</p>
        *         <p>You can use this API operation to enable or disable exporting the Kubernetes control
        *             plane logs for your cluster to CloudWatch Logs. By default, cluster control plane
        *             logs aren't exported to CloudWatch Logs. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/control-plane-logs.html">Amazon EKS Cluster Control Plane Logs</a> in the
        *                 <i>
        *                <i>Amazon EKS User Guide</i>
        *             </i>.</p>
        *         <note>
        *             <p>CloudWatch Logs ingestion, archive storage, and data scanning rates apply to
        *                 exported control plane logs. For more information, see <a href="http://aws.amazon.com/cloudwatch/pricing/">CloudWatch
        *                 Pricing</a>.</p>
        *         </note>
        *         <p>You can also use this API operation to enable or disable public and private access to
        *             your cluster's Kubernetes API server endpoint. By default, public access is enabled, and
        *             private access is disabled. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html">Amazon EKS cluster endpoint access control</a> in the
        *                 <i>
        *                <i>Amazon EKS User Guide</i>
        *             </i>. </p>
        *         <important>
        *             <p>You can't update the subnets or security group IDs for an existing cluster.</p>
        *         </important>
        *         <p>Cluster updates are asynchronous, and they should finish within a few minutes. During
        *             an update, the cluster status moves to <code>UPDATING</code> (this status transition is
        *             eventually consistent). When the update is complete (either <code>Failed</code> or
        *                 <code>Successful</code>), the cluster status moves to <code>Active</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, UpdateClusterConfigCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, UpdateClusterConfigCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new UpdateClusterConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateClusterConfigCommandInput} for command's `input` shape.
        * @see {@link UpdateClusterConfigCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class UpdateClusterConfigCommand extends $Command<UpdateClusterConfigCommandInput, UpdateClusterConfigCommandOutput, EKSClientResolvedConfig> {
            readonly input: UpdateClusterConfigCommandInput;
            constructor(input: UpdateClusterConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateClusterConfigCommandInput, UpdateClusterConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/UpdateClusterVersionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { UpdateClusterVersionRequest, UpdateClusterVersionResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface UpdateClusterVersionCommandInput extends UpdateClusterVersionRequest {
    }
    export interface UpdateClusterVersionCommandOutput extends UpdateClusterVersionResponse, __MetadataBearer {
    }
    /**
        * <p>Updates an Amazon EKS cluster to the specified Kubernetes version. Your
        *             cluster continues to function during the update. The response output includes an update
        *             ID that you can use to track the status of your cluster update with the <a>DescribeUpdate</a> API operation.</p>
        *         <p>Cluster updates are asynchronous, and they should finish within a few minutes. During
        *             an update, the cluster status moves to <code>UPDATING</code> (this status transition is
        *             eventually consistent). When the update is complete (either <code>Failed</code> or
        *                 <code>Successful</code>), the cluster status moves to <code>Active</code>.</p>
        *         <p>If your cluster has managed node groups attached to it, all of your node groups’
        *             Kubernetes versions must match the cluster’s Kubernetes version in order to update the
        *             cluster to a new Kubernetes version.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, UpdateClusterVersionCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, UpdateClusterVersionCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new UpdateClusterVersionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateClusterVersionCommandInput} for command's `input` shape.
        * @see {@link UpdateClusterVersionCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class UpdateClusterVersionCommand extends $Command<UpdateClusterVersionCommandInput, UpdateClusterVersionCommandOutput, EKSClientResolvedConfig> {
            readonly input: UpdateClusterVersionCommandInput;
            constructor(input: UpdateClusterVersionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateClusterVersionCommandInput, UpdateClusterVersionCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/UpdateNodegroupConfigCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { UpdateNodegroupConfigRequest, UpdateNodegroupConfigResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface UpdateNodegroupConfigCommandInput extends UpdateNodegroupConfigRequest {
    }
    export interface UpdateNodegroupConfigCommandOutput extends UpdateNodegroupConfigResponse, __MetadataBearer {
    }
    /**
        * <p>Updates an Amazon EKS managed node group configuration. Your node group
        *             continues to function during the update. The response output includes an update ID that
        *             you can use to track the status of your node group update with the <a>DescribeUpdate</a> API operation. Currently you can update the Kubernetes
        *             labels for a node group or the scaling configuration.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, UpdateNodegroupConfigCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, UpdateNodegroupConfigCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new UpdateNodegroupConfigCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateNodegroupConfigCommandInput} for command's `input` shape.
        * @see {@link UpdateNodegroupConfigCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class UpdateNodegroupConfigCommand extends $Command<UpdateNodegroupConfigCommandInput, UpdateNodegroupConfigCommandOutput, EKSClientResolvedConfig> {
            readonly input: UpdateNodegroupConfigCommandInput;
            constructor(input: UpdateNodegroupConfigCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateNodegroupConfigCommandInput, UpdateNodegroupConfigCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/UpdateNodegroupVersionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { EKSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient";
    import { UpdateNodegroupVersionRequest, UpdateNodegroupVersionResponse } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0";
    export interface UpdateNodegroupVersionCommandInput extends UpdateNodegroupVersionRequest {
    }
    export interface UpdateNodegroupVersionCommandOutput extends UpdateNodegroupVersionResponse, __MetadataBearer {
    }
    /**
        * <p>Updates the Kubernetes version or AMI version of an Amazon EKS managed node
        *             group.</p>
        *         <p>You can update a node group using a launch template only if the node group was
        *             originally deployed with a launch template. If you need to update a custom AMI in a node
        *             group that was deployed with a launch template, then update your custom AMI, specify the
        *             new ID in a new version of the launch template, and then update the node group to the
        *             new version of the launch template.</p>
        *         <p>If you update without a launch template, then you can update to the latest available
        *             AMI version of a node group's current Kubernetes version by not specifying a Kubernetes
        *             version in the request. You can update to the latest AMI version of your cluster's
        *             current Kubernetes version by specifying your cluster's Kubernetes version in the
        *             request. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html">Amazon EKS optimized Amazon Linux 2 AMI versions</a> in the <i>Amazon EKS User Guide</i>.</p>
        *         <p>You cannot roll back a node group to an earlier Kubernetes version or AMI
        *             version.</p>
        *         <p>When a node in a managed node group is terminated due to a scaling action or update,
        *             the pods in that node are drained first. Amazon EKS attempts to drain the nodes
        *             gracefully and will fail if it is unable to do so. You can <code>force</code> the update
        *             if Amazon EKS is unable to drain the nodes as a result of a pod disruption
        *             budget issue.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { EKSClient, UpdateNodegroupVersionCommand } from "@aws-sdk/client-eks"; // ES Modules import
        * // const { EKSClient, UpdateNodegroupVersionCommand } = require("@aws-sdk/client-eks"); // CommonJS import
        * const client = new EKSClient(config);
        * const command = new UpdateNodegroupVersionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateNodegroupVersionCommandInput} for command's `input` shape.
        * @see {@link UpdateNodegroupVersionCommandOutput} for command's `response` shape.
        * @see {@link EKSClientResolvedConfig | config} for EKSClient's `config` shape.
        *
        */
    export class UpdateNodegroupVersionCommand extends $Command<UpdateNodegroupVersionCommandInput, UpdateNodegroupVersionCommandOutput, EKSClientResolvedConfig> {
            readonly input: UpdateNodegroupVersionCommandInput;
            constructor(input: UpdateNodegroupVersionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: EKSClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateNodegroupVersionCommandInput, UpdateNodegroupVersionCommandOutput>;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/EKSClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { AssociateEncryptionConfigCommandInput, AssociateEncryptionConfigCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/AssociateEncryptionConfigCommand";
    import { AssociateIdentityProviderConfigCommandInput, AssociateIdentityProviderConfigCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/AssociateIdentityProviderConfigCommand";
    import { CreateAddonCommandInput, CreateAddonCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/CreateAddonCommand";
    import { CreateClusterCommandInput, CreateClusterCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/CreateClusterCommand";
    import { CreateFargateProfileCommandInput, CreateFargateProfileCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/CreateFargateProfileCommand";
    import { CreateNodegroupCommandInput, CreateNodegroupCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/CreateNodegroupCommand";
    import { DeleteAddonCommandInput, DeleteAddonCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DeleteAddonCommand";
    import { DeleteClusterCommandInput, DeleteClusterCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DeleteClusterCommand";
    import { DeleteFargateProfileCommandInput, DeleteFargateProfileCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DeleteFargateProfileCommand";
    import { DeleteNodegroupCommandInput, DeleteNodegroupCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DeleteNodegroupCommand";
    import { DeregisterClusterCommandInput, DeregisterClusterCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DeregisterClusterCommand";
    import { DescribeAddonCommandInput, DescribeAddonCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DescribeAddonCommand";
    import { DescribeAddonVersionsCommandInput, DescribeAddonVersionsCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DescribeAddonVersionsCommand";
    import { DescribeClusterCommandInput, DescribeClusterCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DescribeClusterCommand";
    import { DescribeFargateProfileCommandInput, DescribeFargateProfileCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DescribeFargateProfileCommand";
    import { DescribeIdentityProviderConfigCommandInput, DescribeIdentityProviderConfigCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DescribeIdentityProviderConfigCommand";
    import { DescribeNodegroupCommandInput, DescribeNodegroupCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DescribeNodegroupCommand";
    import { DescribeUpdateCommandInput, DescribeUpdateCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DescribeUpdateCommand";
    import { DisassociateIdentityProviderConfigCommandInput, DisassociateIdentityProviderConfigCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/DisassociateIdentityProviderConfigCommand";
    import { ListAddonsCommandInput, ListAddonsCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/ListAddonsCommand";
    import { ListClustersCommandInput, ListClustersCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/ListClustersCommand";
    import { ListFargateProfilesCommandInput, ListFargateProfilesCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/ListFargateProfilesCommand";
    import { ListIdentityProviderConfigsCommandInput, ListIdentityProviderConfigsCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/ListIdentityProviderConfigsCommand";
    import { ListNodegroupsCommandInput, ListNodegroupsCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/ListNodegroupsCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/ListTagsForResourceCommand";
    import { ListUpdatesCommandInput, ListUpdatesCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/ListUpdatesCommand";
    import { RegisterClusterCommandInput, RegisterClusterCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/RegisterClusterCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/UntagResourceCommand";
    import { UpdateAddonCommandInput, UpdateAddonCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/UpdateAddonCommand";
    import { UpdateClusterConfigCommandInput, UpdateClusterConfigCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/UpdateClusterConfigCommand";
    import { UpdateClusterVersionCommandInput, UpdateClusterVersionCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/UpdateClusterVersionCommand";
    import { UpdateNodegroupConfigCommandInput, UpdateNodegroupConfigCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/UpdateNodegroupConfigCommand";
    import { UpdateNodegroupVersionCommandInput, UpdateNodegroupVersionCommandOutput } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/commands/UpdateNodegroupVersionCommand";
    export type ServiceInputTypes = AssociateEncryptionConfigCommandInput | AssociateIdentityProviderConfigCommandInput | CreateAddonCommandInput | CreateClusterCommandInput | CreateFargateProfileCommandInput | CreateNodegroupCommandInput | DeleteAddonCommandInput | DeleteClusterCommandInput | DeleteFargateProfileCommandInput | DeleteNodegroupCommandInput | DeregisterClusterCommandInput | DescribeAddonCommandInput | DescribeAddonVersionsCommandInput | DescribeClusterCommandInput | DescribeFargateProfileCommandInput | DescribeIdentityProviderConfigCommandInput | DescribeNodegroupCommandInput | DescribeUpdateCommandInput | DisassociateIdentityProviderConfigCommandInput | ListAddonsCommandInput | ListClustersCommandInput | ListFargateProfilesCommandInput | ListIdentityProviderConfigsCommandInput | ListNodegroupsCommandInput | ListTagsForResourceCommandInput | ListUpdatesCommandInput | RegisterClusterCommandInput | TagResourceCommandInput | UntagResourceCommandInput | UpdateAddonCommandInput | UpdateClusterConfigCommandInput | UpdateClusterVersionCommandInput | UpdateNodegroupConfigCommandInput | UpdateNodegroupVersionCommandInput;
    export type ServiceOutputTypes = AssociateEncryptionConfigCommandOutput | AssociateIdentityProviderConfigCommandOutput | CreateAddonCommandOutput | CreateClusterCommandOutput | CreateFargateProfileCommandOutput | CreateNodegroupCommandOutput | DeleteAddonCommandOutput | DeleteClusterCommandOutput | DeleteFargateProfileCommandOutput | DeleteNodegroupCommandOutput | DeregisterClusterCommandOutput | DescribeAddonCommandOutput | DescribeAddonVersionsCommandOutput | DescribeClusterCommandOutput | DescribeFargateProfileCommandOutput | DescribeIdentityProviderConfigCommandOutput | DescribeNodegroupCommandOutput | DescribeUpdateCommandOutput | DisassociateIdentityProviderConfigCommandOutput | ListAddonsCommandOutput | ListClustersCommandOutput | ListFargateProfilesCommandOutput | ListIdentityProviderConfigsCommandOutput | ListNodegroupsCommandOutput | ListTagsForResourceCommandOutput | ListUpdatesCommandOutput | RegisterClusterCommandOutput | TagResourceCommandOutput | UntagResourceCommandOutput | UpdateAddonCommandOutput | UpdateClusterConfigCommandOutput | UpdateClusterVersionCommandOutput | UpdateNodegroupConfigCommandOutput | UpdateNodegroupVersionCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type EKSClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of EKSClient class constructor that set the region, credentials and other options.
        */
    export interface EKSClientConfig extends EKSClientConfigType {
    }
    type EKSClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of EKSClient class. This is resolved and normalized from the {@link EKSClientConfig | constructor configuration interface}.
        */
    export interface EKSClientResolvedConfig extends EKSClientResolvedConfigType {
    }
    /**
        * <p>Amazon Elastic Kubernetes Service (Amazon EKS) is a managed service that makes it easy
        *             for you to run Kubernetes on Amazon Web Services without needing to stand up or maintain
        *             your own Kubernetes control plane. Kubernetes is an open-source system for automating
        *             the deployment, scaling, and management of containerized applications. </p>
        *         <p>Amazon EKS runs up-to-date versions of the open-source Kubernetes software, so
        *             you can use all the existing plugins and tooling from the Kubernetes community.
        *             Applications running on Amazon EKS are fully compatible with applications
        *             running on any standard Kubernetes environment, whether running in on-premises data
        *             centers or public clouds. This means that you can easily migrate any standard Kubernetes
        *             application to Amazon EKS without any code modification required.</p>
        */
    export class EKSClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, EKSClientResolvedConfig> {
            /**
                * The resolved configuration of EKSClient class. This is resolved and normalized from the {@link EKSClientConfig | constructor configuration interface}.
                */
            readonly config: EKSClientResolvedConfig;
            constructor(configuration: EKSClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { EKSServiceException as __BaseException } from "@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/EKSServiceException";
    /**
        * <p>You don't have permissions to perform the requested operation. The user or role that
        *             is making the request must have at least one IAM permissions policy
        *             attached that grants the required permissions. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access.html">Access
        *                 Management</a> in the <i>IAM User Guide</i>. </p>
        */
    export class AccessDeniedException extends __BaseException {
            readonly name: "AccessDeniedException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AccessDeniedException, __BaseException>);
    }
    export enum AddonIssueCode {
            ACCESS_DENIED = "AccessDenied",
            ADMISSION_REQUEST_DENIED = "AdmissionRequestDenied",
            CLUSTER_UNREACHABLE = "ClusterUnreachable",
            CONFIGURATION_CONFLICT = "ConfigurationConflict",
            INSUFFICIENT_NUMBER_OF_REPLICAS = "InsufficientNumberOfReplicas",
            INTERNAL_FAILURE = "InternalFailure",
            K8S_RESOURCE_NOT_FOUND = "K8sResourceNotFound",
            UNSUPPORTED_ADDON_MODIFICATION = "UnsupportedAddonModification"
    }
    /**
        * <p>An issue related to an add-on.</p>
        */
    export interface AddonIssue {
            /**
                * <p>A code that describes the type of issue.</p>
                */
            code?: AddonIssueCode | string;
            /**
                * <p>A message that provides details about the issue and what might cause it.</p>
                */
            message?: string;
            /**
                * <p>The resource IDs of the issue.</p>
                */
            resourceIds?: string[];
    }
    export namespace AddonIssue {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AddonIssue) => any;
    }
    /**
        * <p>The health of the add-on.</p>
        */
    export interface AddonHealth {
            /**
                * <p>An object that represents the add-on's health issues.</p>
                */
            issues?: AddonIssue[];
    }
    export namespace AddonHealth {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AddonHealth) => any;
    }
    export type AddonStatus = "ACTIVE" | "CREATE_FAILED" | "CREATING" | "DEGRADED" | "DELETE_FAILED" | "DELETING" | "UPDATING";
    /**
        * <p>An Amazon EKS add-on. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/eks-add-ons.html">Amazon EKS add-ons</a> in
        *             the <i>Amazon EKS User Guide</i>.</p>
        */
    export interface Addon {
            /**
                * <p>The name of the add-on.</p>
                */
            addonName?: string;
            /**
                * <p>The name of the cluster.</p>
                */
            clusterName?: string;
            /**
                * <p>The status of the add-on.</p>
                */
            status?: AddonStatus | string;
            /**
                * <p>The version of the add-on.</p>
                */
            addonVersion?: string;
            /**
                * <p>An object that represents the health of the add-on.</p>
                */
            health?: AddonHealth;
            /**
                * <p>The Amazon Resource Name (ARN) of the add-on.</p>
                */
            addonArn?: string;
            /**
                * <p>The date and time that the add-on was created.</p>
                */
            createdAt?: Date;
            /**
                * <p>The date and time that the add-on was last modified.</p>
                */
            modifiedAt?: Date;
            /**
                * <p>The Amazon Resource Name (ARN) of the IAM role that is bound to the Kubernetes service
                *             account used by the add-on.</p>
                */
            serviceAccountRoleArn?: string;
            /**
                * <p>The metadata that you apply to the add-on to assist with categorization and
                *             organization. Each tag consists of a key and an optional value. You define both.
                *             Add-on tags do not propagate to any other resources associated with the cluster.
                *         </p>
                */
            tags?: Record<string, string>;
    }
    export namespace Addon {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Addon) => any;
    }
    /**
        * <p>Compatibility information.</p>
        */
    export interface Compatibility {
            /**
                * <p>The supported Kubernetes version of the cluster.</p>
                */
            clusterVersion?: string;
            /**
                * <p>The supported compute platform.</p>
                */
            platformVersions?: string[];
            /**
                * <p>The supported default version.</p>
                */
            defaultVersion?: boolean;
    }
    export namespace Compatibility {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Compatibility) => any;
    }
    /**
        * <p>Information about an add-on version.</p>
        */
    export interface AddonVersionInfo {
            /**
                * <p>The version of the add-on.</p>
                */
            addonVersion?: string;
            /**
                * <p>The architectures that the version supports.</p>
                */
            architecture?: string[];
            /**
                * <p>An object that represents the compatibilities of a version.</p>
                */
            compatibilities?: Compatibility[];
    }
    export namespace AddonVersionInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AddonVersionInfo) => any;
    }
    /**
        * <p>Information about an add-on.</p>
        */
    export interface AddonInfo {
            /**
                * <p>The name of the add-on.</p>
                */
            addonName?: string;
            /**
                * <p>The type of the add-on.</p>
                */
            type?: string;
            /**
                * <p>An object that represents information about available add-on versions and compatible
                *             Kubernetes versions.</p>
                */
            addonVersions?: AddonVersionInfo[];
    }
    export namespace AddonInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AddonInfo) => any;
    }
    export type AMITypes = "AL2_ARM_64" | "AL2_x86_64" | "AL2_x86_64_GPU" | "BOTTLEROCKET_ARM_64" | "BOTTLEROCKET_ARM_64_NVIDIA" | "BOTTLEROCKET_x86_64" | "BOTTLEROCKET_x86_64_NVIDIA" | "CUSTOM";
    /**
        * <p>Identifies the Key Management Service (KMS) key used to encrypt the
        *             secrets.</p>
        */
    export interface Provider {
            /**
                * <p>Amazon Resource Name (ARN) or alias of the KMS key. The KMS key must be symmetric, created in the same
                *             region as the cluster, and if the KMS key was created in a different account, the user
                *             must have access to the KMS key. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policy-modifying-external-accounts.html">Allowing
                *                 Users in Other Accounts to Use a KMS key</a> in the <i>Key Management Service Developer Guide</i>.</p>
                */
            keyArn?: string;
    }
    export namespace Provider {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Provider) => any;
    }
    /**
        * <p>The encryption configuration for the cluster.</p>
        */
    export interface EncryptionConfig {
            /**
                * <p>Specifies the resources to be encrypted. The only supported value is "secrets".</p>
                */
            resources?: string[];
            /**
                * <p>Key Management Service (KMS) key. Either the ARN or the alias can be
                *             used.</p>
                */
            provider?: Provider;
    }
    export namespace EncryptionConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EncryptionConfig) => any;
    }
    export interface AssociateEncryptionConfigRequest {
            /**
                * <p>The name of the cluster that you are associating with encryption configuration.</p>
                */
            clusterName: string | undefined;
            /**
                * <p>The configuration you are using for encryption.</p>
                */
            encryptionConfig: EncryptionConfig[] | undefined;
            /**
                * <p>The client request token you are using with the encryption configuration.</p>
                */
            clientRequestToken?: string;
    }
    export namespace AssociateEncryptionConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AssociateEncryptionConfigRequest) => any;
    }
    export enum ErrorCode {
            ACCESS_DENIED = "AccessDenied",
            ADMISSION_REQUEST_DENIED = "AdmissionRequestDenied",
            CLUSTER_UNREACHABLE = "ClusterUnreachable",
            CONFIGURATION_CONFLICT = "ConfigurationConflict",
            ENI_LIMIT_REACHED = "EniLimitReached",
            INSUFFICIENT_FREE_ADDRESSES = "InsufficientFreeAddresses",
            INSUFFICIENT_NUMBER_OF_REPLICAS = "InsufficientNumberOfReplicas",
            IP_NOT_AVAILABLE = "IpNotAvailable",
            K8S_RESOURCE_NOT_FOUND = "K8sResourceNotFound",
            NODE_CREATION_FAILURE = "NodeCreationFailure",
            OPERATION_NOT_PERMITTED = "OperationNotPermitted",
            POD_EVICTION_FAILURE = "PodEvictionFailure",
            SECURITY_GROUP_NOT_FOUND = "SecurityGroupNotFound",
            SUBNET_NOT_FOUND = "SubnetNotFound",
            UNKNOWN = "Unknown",
            UNSUPPORTED_ADDON_MODIFICATION = "UnsupportedAddonModification",
            VPC_ID_NOT_FOUND = "VpcIdNotFound"
    }
    /**
        * <p>An object representing an error when an asynchronous operation fails.</p>
        */
    export interface ErrorDetail {
            /**
                * <p>A brief description of the error. </p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <b>SubnetNotFound</b>: We couldn't find one of the
                *                     subnets associated with the cluster.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <b>SecurityGroupNotFound</b>: We couldn't find one
                *                     of the security groups associated with the cluster.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <b>EniLimitReached</b>: You have reached the elastic
                *                     network interface limit for your account.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <b>IpNotAvailable</b>: A subnet associated with the
                *                     cluster doesn't have any free IP addresses.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <b>AccessDenied</b>: You don't have permissions to
                *                     perform the specified operation.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <b>OperationNotPermitted</b>: The service role
                *                     associated with the cluster doesn't have the required access permissions for
                *                         Amazon EKS.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <b>VpcIdNotFound</b>: We couldn't find the VPC
                *                     associated with the cluster.</p>
                *             </li>
                *          </ul>
                */
            errorCode?: ErrorCode | string;
            /**
                * <p>A more complete description of the error.</p>
                */
            errorMessage?: string;
            /**
                * <p>An optional field that contains the resource IDs associated with the error.</p>
                */
            resourceIds?: string[];
    }
    export namespace ErrorDetail {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ErrorDetail) => any;
    }
    export enum UpdateParamType {
            ADDON_VERSION = "AddonVersion",
            CLUSTER_LOGGING = "ClusterLogging",
            DESIRED_SIZE = "DesiredSize",
            ENCRYPTION_CONFIG = "EncryptionConfig",
            ENDPOINT_PRIVATE_ACCESS = "EndpointPrivateAccess",
            ENDPOINT_PUBLIC_ACCESS = "EndpointPublicAccess",
            IDENTITY_PROVIDER_CONFIG = "IdentityProviderConfig",
            LABELS_TO_ADD = "LabelsToAdd",
            LABELS_TO_REMOVE = "LabelsToRemove",
            LAUNCH_TEMPLATE_NAME = "LaunchTemplateName",
            LAUNCH_TEMPLATE_VERSION = "LaunchTemplateVersion",
            MAX_SIZE = "MaxSize",
            MAX_UNAVAILABLE = "MaxUnavailable",
            MAX_UNAVAILABLE_PERCENTAGE = "MaxUnavailablePercentage",
            MIN_SIZE = "MinSize",
            PLATFORM_VERSION = "PlatformVersion",
            PUBLIC_ACCESS_CIDRS = "PublicAccessCidrs",
            RELEASE_VERSION = "ReleaseVersion",
            RESOLVE_CONFLICTS = "ResolveConflicts",
            SERVICE_ACCOUNT_ROLE_ARN = "ServiceAccountRoleArn",
            TAINTS_TO_ADD = "TaintsToAdd",
            TAINTS_TO_REMOVE = "TaintsToRemove",
            VERSION = "Version"
    }
    /**
        * <p>An object representing the details of an update request.</p>
        */
    export interface UpdateParam {
            /**
                * <p>The keys associated with an update request.</p>
                */
            type?: UpdateParamType | string;
            /**
                * <p>The value of the keys submitted as part of an update request.</p>
                */
            value?: string;
    }
    export namespace UpdateParam {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateParam) => any;
    }
    export enum UpdateStatus {
            CANCELLED = "Cancelled",
            FAILED = "Failed",
            IN_PROGRESS = "InProgress",
            SUCCESSFUL = "Successful"
    }
    export enum UpdateType {
            ADDON_UPDATE = "AddonUpdate",
            ASSOCIATE_ENCRYPTION_CONFIG = "AssociateEncryptionConfig",
            ASSOCIATE_IDENTITY_PROVIDER_CONFIG = "AssociateIdentityProviderConfig",
            CONFIG_UPDATE = "ConfigUpdate",
            DISASSOCIATE_IDENTITY_PROVIDER_CONFIG = "DisassociateIdentityProviderConfig",
            ENDPOINT_ACCESS_UPDATE = "EndpointAccessUpdate",
            LOGGING_UPDATE = "LoggingUpdate",
            VERSION_UPDATE = "VersionUpdate"
    }
    /**
        * <p>An object representing an asynchronous update.</p>
        */
    export interface Update {
            /**
                * <p>A UUID that is used to track the update.</p>
                */
            id?: string;
            /**
                * <p>The current status of the update.</p>
                */
            status?: UpdateStatus | string;
            /**
                * <p>The type of the update.</p>
                */
            type?: UpdateType | string;
            /**
                * <p>A key-value map that contains the parameters associated with the update.</p>
                */
            params?: UpdateParam[];
            /**
                * <p>The Unix epoch timestamp in seconds for when the update was created.</p>
                */
            createdAt?: Date;
            /**
                * <p>Any errors associated with a <code>Failed</code> update.</p>
                */
            errors?: ErrorDetail[];
    }
    export namespace Update {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Update) => any;
    }
    export interface AssociateEncryptionConfigResponse {
            /**
                * <p>An object representing an asynchronous update.</p>
                */
            update?: Update;
    }
    export namespace AssociateEncryptionConfigResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AssociateEncryptionConfigResponse) => any;
    }
    /**
        * <p>These errors are usually caused by a client action. Actions can include using an
        *             action or resource on behalf of a user that doesn't have permissions to use the action
        *             or resource or specifying an identifier that is not valid.</p>
        */
    export class ClientException extends __BaseException {
            readonly name: "ClientException";
            readonly $fault: "client";
            /**
                * <p>The Amazon EKS cluster associated with the exception.</p>
                */
            clusterName?: string;
            /**
                * <p>The Amazon EKS managed node group associated with the exception.</p>
                */
            nodegroupName?: string;
            addonName?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClientException, __BaseException>);
    }
    /**
        * <p>The specified parameter is invalid. Review the available parameters for the API
        *             request.</p>
        */
    export class InvalidParameterException extends __BaseException {
            readonly name: "InvalidParameterException";
            readonly $fault: "client";
            /**
                * <p>The Amazon EKS cluster associated with the exception.</p>
                */
            clusterName?: string;
            /**
                * <p>The Amazon EKS managed node group associated with the exception.</p>
                */
            nodegroupName?: string;
            /**
                * <p>The Fargate profile associated with the exception.</p>
                */
            fargateProfileName?: string;
            addonName?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidParameterException, __BaseException>);
    }
    /**
        * <p>The request is invalid given the state of the cluster. Check the state of the cluster
        *             and the associated operations.</p>
        */
    export class InvalidRequestException extends __BaseException {
            readonly name: "InvalidRequestException";
            readonly $fault: "client";
            /**
                * <p>The Amazon EKS cluster associated with the exception.</p>
                */
            clusterName?: string;
            /**
                * <p>The Amazon EKS managed node group associated with the exception.</p>
                */
            nodegroupName?: string;
            addonName?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidRequestException, __BaseException>);
    }
    /**
        * <p>The specified resource is in use.</p>
        */
    export class ResourceInUseException extends __BaseException {
            readonly name: "ResourceInUseException";
            readonly $fault: "client";
            /**
                * <p>The Amazon EKS cluster associated with the exception.</p>
                */
            clusterName?: string;
            /**
                * <p>The Amazon EKS managed node group associated with the exception.</p>
                */
            nodegroupName?: string;
            addonName?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceInUseException, __BaseException>);
    }
    /**
        * <p>The specified resource could not be found. You can view your available clusters with
        *                 <a>ListClusters</a>. You can view your available managed node groups with
        *                 <a>ListNodegroups</a>. Amazon EKS clusters and node groups are
        *             Region-specific.</p>
        */
    export class ResourceNotFoundException extends __BaseException {
            readonly name: "ResourceNotFoundException";
            readonly $fault: "client";
            /**
                * <p>The Amazon EKS cluster associated with the exception.</p>
                */
            clusterName?: string;
            /**
                * <p>The Amazon EKS managed node group associated with the exception.</p>
                */
            nodegroupName?: string;
            /**
                * <p>The Fargate profile associated with the exception.</p>
                */
            fargateProfileName?: string;
            addonName?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>);
    }
    /**
        * <p>These errors are usually caused by a server-side issue.</p>
        */
    export class ServerException extends __BaseException {
            readonly name: "ServerException";
            readonly $fault: "server";
            /**
                * <p>The Amazon EKS cluster associated with the exception.</p>
                */
            clusterName?: string;
            /**
                * <p>The Amazon EKS managed node group associated with the exception.</p>
                */
            nodegroupName?: string;
            addonName?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ServerException, __BaseException>);
    }
    /**
        * <p>An object representing an OpenID Connect (OIDC) configuration. Before associating an
        *             OIDC identity provider to your cluster, review the considerations in <a href="https://docs.aws.amazon.com/eks/latest/userguide/authenticate-oidc-identity-provider.html">Authenticating
        *                 users for your cluster from an OpenID Connect identity provider</a> in the
        *             <i>Amazon EKS User Guide</i>.</p>
        */
    export interface OidcIdentityProviderConfigRequest {
            /**
                * <p>The name of the OIDC provider configuration.</p>
                */
            identityProviderConfigName: string | undefined;
            /**
                * <p>The URL of the OpenID identity provider that allows the API server to discover public
                *             signing keys for verifying tokens. The URL must begin with <code>https://</code> and
                *             should correspond to the <code>iss</code> claim in the provider's OIDC ID tokens. Per
                *             the OIDC standard, path components are allowed but query parameters are not. Typically
                *             the URL consists of only a hostname, like <code>https://server.example.org</code> or
                *                 <code>https://example.com</code>. This URL should point to the level below
                *                 <code>.well-known/openid-configuration</code> and must be publicly accessible over
                *             the internet.</p>
                */
            issuerUrl: string | undefined;
            /**
                * <p>This is also known as <i>audience</i>. The ID for the client application
                *             that makes authentication requests to the OpenID identity provider.</p>
                */
            clientId: string | undefined;
            /**
                * <p>The JSON Web Token (JWT) claim to use as the username. The default is
                *             <code>sub</code>, which is expected to be a unique identifier of the end user. You can
                *             choose other claims, such as <code>email</code> or <code>name</code>, depending on the
                *             OpenID identity provider. Claims other than <code>email</code> are prefixed with the
                *             issuer URL to prevent naming clashes with other plug-ins.</p>
                */
            usernameClaim?: string;
            /**
                * <p>The prefix that is prepended to username claims to prevent clashes with existing
                *             names. If you do not provide this field, and <code>username</code> is a value other than
                *                 <code>email</code>, the prefix defaults to <code>issuerurl#</code>. You can use the
                *             value <code>-</code> to disable all prefixing.</p>
                */
            usernamePrefix?: string;
            /**
                * <p>The JWT claim that the provider uses to return your groups.</p>
                */
            groupsClaim?: string;
            /**
                * <p>The prefix that is prepended to group claims to prevent clashes with existing names
                *             (such as <code>system:</code> groups). For example, the value<code> oidc:</code> will
                *             create group names like <code>oidc:engineering</code> and
                *             <code>oidc:infra</code>.</p>
                */
            groupsPrefix?: string;
            /**
                * <p>The key value pairs that describe required claims in the identity token. If set, each
                *             claim is verified to be present in the token with a matching value. For the maximum
                *             number of claims that you can require, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/service-quotas.html">Amazon EKS service
                *                 quotas</a> in the <i>Amazon EKS User Guide</i>.</p>
                */
            requiredClaims?: Record<string, string>;
    }
    export namespace OidcIdentityProviderConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OidcIdentityProviderConfigRequest) => any;
    }
    export interface AssociateIdentityProviderConfigRequest {
            /**
                * <p>The name of the cluster to associate the configuration to.</p>
                */
            clusterName: string | undefined;
            /**
                * <p>An object that represents an OpenID Connect (OIDC) identity provider
                *             configuration.</p>
                */
            oidc: OidcIdentityProviderConfigRequest | undefined;
            /**
                * <p>The metadata to apply to the configuration to assist with categorization and
                *             organization. Each tag consists of a key and an optional value. You define both.</p>
                */
            tags?: Record<string, string>;
            /**
                * <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
                *             request.</p>
                */
            clientRequestToken?: string;
    }
    export namespace AssociateIdentityProviderConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AssociateIdentityProviderConfigRequest) => any;
    }
    export interface AssociateIdentityProviderConfigResponse {
            /**
                * <p>An object representing an asynchronous update.</p>
                */
            update?: Update;
            /**
                * <p>The tags for the resource.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace AssociateIdentityProviderConfigResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AssociateIdentityProviderConfigResponse) => any;
    }
    /**
        * <p>An Auto Scaling group that is associated with an Amazon EKS managed node
        *             group.</p>
        */
    export interface AutoScalingGroup {
            /**
                * <p>The name of the Auto Scaling group associated with an Amazon EKS managed node
                *             group.</p>
                */
            name?: string;
    }
    export namespace AutoScalingGroup {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AutoScalingGroup) => any;
    }
    export type ResolveConflicts = "NONE" | "OVERWRITE";
    export interface CreateAddonRequest {
            /**
                * <p>The name of the cluster to create the add-on for.</p>
                */
            clusterName: string | undefined;
            /**
                * <p>The name of the add-on. The name must match one of the names returned by <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeAddonVersions.html">
                *                <code>DescribeAddonVersions</code>
                *             </a>.</p>
                */
            addonName: string | undefined;
            /**
                * <p>The version of the add-on. The version must match one of the versions returned by <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeAddonVersions.html">
                *                <code>DescribeAddonVersions</code>
                *             </a>.</p>
                */
            addonVersion?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of an existing IAM role to bind to the add-on's service account. The role must be assigned the IAM permissions required by the add-on. If you don't specify an existing IAM role, then the add-on uses the
                *      permissions assigned to the node IAM role. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html">Amazon EKS node IAM role</a> in the <i>Amazon EKS User Guide</i>.</p>
                *         <note>
                *             <p>To specify an existing IAM role, you must have an IAM OpenID Connect (OIDC) provider created for
                *                 your cluster. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html">Enabling
                *                     IAM roles for service accounts on your cluster</a> in the
                *                 <i>Amazon EKS User Guide</i>.</p>
                *          </note>
                */
            serviceAccountRoleArn?: string;
            /**
                * <p>How to resolve parameter value conflicts when migrating an existing add-on to an
                *                 Amazon EKS add-on.</p>
                */
            resolveConflicts?: ResolveConflicts | string;
            /**
                * <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the
                *             request.</p>
                */
            clientRequestToken?: string;
            /**
                * <p>The metadata to apply to the cluster to assist with categorization and organization.
                *             Each tag consists of a key and an optional value. You define both.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace CreateAddonRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateAddonRequest) => any;
    }
    export interface CreateAddonResponse {
            /**
                * <p>An Amazon EKS add-on. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/eks-add-ons.html">Amazon EKS add-ons</a> in
                *             the <i>Amazon EKS User Guide</i>.</p>
                */
            addon?: Addon;
    }
    export namespace CreateAddonResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateAddonResponse) => any;
    }
    export enum IpFamily {
            IPV4 = "ipv4",
            IPV6 = "ipv6"
    }
    /**
        * <p>The Kubernetes network configuration for the cluster.</p>
        */
    export interface KubernetesNetworkConfigRequest {
            /**
                * <p>Don't specify a value if you select <code>ipv6</code> for <b>ipFamily</b>. The CIDR block to assign Kubernetes service IP addresses from.
                *             If you don't specify a block, Kubernetes assigns addresses from either the 10.100.0.0/16
                *             or 172.20.0.0/16 CIDR blocks. We recommend that you specify a block that does not
                *             overlap with resources in other networks that are peered or connected to your VPC. The
                *             block must meet the following requirements:</p>
                *         <ul>
                *             <li>
                *                 <p>Within one of the following private IP address blocks: 10.0.0.0/8,
                *                     172.16.0.0/12, or 192.168.0.0/16.</p>
                *             </li>
                *             <li>
                *                 <p>Doesn't overlap with any CIDR block assigned to the VPC that you selected for
                *                     VPC.</p>
                *             </li>
                *             <li>
                *                 <p>Between /24 and /12.</p>
                *             </li>
                *          </ul>
                *         <important>
                *             <p>You can only specify a custom CIDR block when you create a cluster and can't
                *                 change this value once the cluster is created.</p>
                *         </important>
                */
            serviceIpv4Cidr?: string;
            /**
                * <p>Specify which IP family is used to assign Kubernetes pod and service IP addresses. If
                *             you don't specify a value, <code>ipv4</code> is used by default. You can only specify an
                *             IP family when you create a cluster and can't change this value once the cluster is
                *             created. If you specify <code>ipv6</code>, the VPC and subnets that you specify for
                *             cluster creation must have both IPv4 and IPv6 CIDR blocks assigned to them. You can't
                *             specify <code>ipv6</code> for clusters in China Regions.</p>
                *         <p>You can only specify <code>ipv6</code> for 1.21 and later clusters that use version
                *             1.10.1 or later of the Amazon VPC CNI add-on. If you specify <code>ipv6</code>, then ensure
                *             that your VPC meets the requirements listed in the considerations listed in <a href="https://docs.aws.amazon.com/eks/latest/userguide/cni-ipv6.html">Assigning IPv6
                *                 addresses to pods and services</a> in the Amazon EKS User Guide.
                *             Kubernetes assigns services IPv6 addresses from the unique local address range
                *             (fc00::/7). You can't specify a custom IPv6 CIDR block. Pod addresses are assigned from
                *             the subnet's IPv6 CIDR.</p>
                */
            ipFamily?: IpFamily | string;
    }
    export namespace KubernetesNetworkConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: KubernetesNetworkConfigRequest) => any;
    }
    export enum LogType {
            API = "api",
            AUDIT = "audit",
            AUTHENTICATOR = "authenticator",
            CONTROLLER_MANAGER = "controllerManager",
            SCHEDULER = "scheduler"
    }
    /**
        * <p>An object representing the enabled or disabled Kubernetes control plane logs for your
        *             cluster.</p>
        */
    export interface LogSetup {
            /**
                * <p>The available cluster control plane log types.</p>
                */
            types?: (LogType | string)[];
            /**
                * <p>If a log type is enabled, that log type exports its control plane logs to CloudWatch Logs. If a log type isn't enabled, that log type doesn't export its control
                *             plane logs. Each individual log type can be enabled or disabled independently.</p>
                */
            enabled?: boolean;
    }
    export namespace LogSetup {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LogSetup) => any;
    }
    /**
        * <p>An object representing the logging configuration for resources in your cluster.</p>
        */
    export interface Logging {
            /**
                * <p>The cluster control plane logging configuration for your cluster.</p>
                */
            clusterLogging?: LogSetup[];
    }
    export namespace Logging {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Logging) => any;
    }
    /**
        * <p>An object representing the VPC configuration to use for an Amazon EKS
        *             cluster.</p>
        */
    export interface VpcConfigRequest {
            /**
                * <p>Specify subnets for your Amazon EKS nodes. Amazon EKS creates
                *             cross-account elastic network interfaces in these subnets to allow communication between
                *             your nodes and the Kubernetes control plane.</p>
                */
            subnetIds?: string[];
            /**
                * <p>Specify one or more security groups for the cross-account elastic network interfaces
                *             that Amazon EKS creates to use that allow communication between your nodes and
                *             the Kubernetes control plane. If you don't specify any security groups, then familiarize
                *             yourself with the difference between Amazon EKS defaults for clusters deployed
                *             with Kubernetes:</p>
                *         <ul>
                *             <li>
                *                 <p>1.14 Amazon EKS platform version <code>eks.2</code> and earlier</p>
                *             </li>
                *             <li>
                *                 <p>1.14 Amazon EKS platform version <code>eks.3</code> and later </p>
                *             </li>
                *          </ul>
                *         <p>For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html">Amazon EKS security group
                *                 considerations</a> in the <i>
                *                <i>Amazon EKS User Guide</i>
                *             </i>.</p>
                */
            securityGroupIds?: string[];
            /**
                * <p>Set this value to <code>false</code> to disable public access to your cluster's
                *             Kubernetes API server endpoint. If you disable public access, your cluster's Kubernetes
                *             API server can only receive requests from within the cluster VPC. The default value for
                *             this parameter is <code>true</code>, which enables public access for your Kubernetes API
                *             server. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html">Amazon EKS cluster endpoint access control</a> in the
                *                 <i>
                *                <i>Amazon EKS User Guide</i>
                *             </i>.</p>
                */
            endpointPublicAccess?: boolean;
            /**
                * <p>Set this value to <code>true</code> to enable private access for your cluster's
                *             Kubernetes API server endpoint. If you enable private access, Kubernetes API requests
                *             from within your cluster's VPC use the private VPC endpoint. The default value for this
                *             parameter is <code>false</code>, which disables private access for your Kubernetes API
                *             server. If you disable private access and you have nodes or Fargate
                *             pods in the cluster, then ensure that <code>publicAccessCidrs</code> includes the
                *             necessary CIDR blocks for communication with the nodes or Fargate pods.
                *             For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html">Amazon EKS cluster endpoint access control</a> in
                *             the <i>
                *                <i>Amazon EKS User Guide</i>
                *             </i>.</p>
                */
            endpointPrivateAccess?: boolean;
            /**
                * <p>The CIDR blocks that are allowed access to your cluster's public Kubernetes API server
                *             endpoint. Communication to the endpoint from addresses outside of the CIDR blocks that
                *             you specify is denied. The default value is <code>0.0.0.0/0</code>. If you've disabled
                *             private endpoint access and you have nodes or Fargate pods in the
                *             cluster, then ensure that you specify the necessary CIDR blocks. For more information,
                *             see <a href="https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html">Amazon EKS cluster endpoint access control</a> in the
                *                 <i>
                *                <i>Amazon EKS User Guide</i>
                *             </i>.</p>
                */
            publicAccessCidrs?: string[];
    }
    export namespace VpcConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: VpcConfigRequest) => any;
    }
    export interface CreateClusterRequest {
            /**
                * <p>The unique name to give to your cluster.</p>
                */
            name: string | undefined;
            /**
                * <p>The desired Kubernetes version for your cluster. If you don't specify a value here,
                *             the latest version available in Amazon EKS is used.</p>
                */
            version?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the IAM role that provides permissions for the
                *             Kubernetes control plane to make calls to Amazon Web Services API operations on your
                *             behalf. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html">Amazon EKS Service IAM Role</a> in the <i>
                *                <i>Amazon EKS User Guide</i>
                *             </i>.</p>
                */
            roleArn: string | undefined;
            /**
                * <p>The VPC configuration that's used by the cluster control plane. Amazon EKS VPC resources have
                *             specific requirements to work properly with Kubernetes. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html">Cluster VPC
                *                 Considerations</a> and <a href="https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html">Cluster Security Group Considerations</a> in the
                *             <i>Amazon EKS User Guide</i>. You must specify at least two subnets. You can specify up to five
                *             security groups. However, we recommend that you use a dedicated security group for your
                *             cluster control plane.</p>
                */
            resourcesVpcConfig: VpcConfigRequest | undefined;
            /**
                * <p>The Kubernetes network configuration for the cluster.</p>
                */
            kubernetesNetworkConfig?: KubernetesNetworkConfigRequest;
            /**
                * <p>Enable or disable exporting the Kubernetes control plane logs for your cluster to
                *                 CloudWatch Logs. By default, cluster control plane logs aren't exported to
                *                 CloudWatch Logs. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/control-plane-logs.html">Amazon EKS Cluster control plane logs</a> in the
                *                 <i>
                *                <i>Amazon EKS User Guide</i>
                *             </i>.</p>
                *         <note>
                *             <p>CloudWatch Logs ingestion, archive storage, and data scanning rates apply to
                *                 exported control plane logs. For more information, see <a href="http://aws.amazon.com/cloudwatch/pricing/">CloudWatch
                *                 Pricing</a>.</p>
                *         </note>
                */
            logging?: Logging;
            /**
                * <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
                *             request.</p>
                */
            clientRequestToken?: string;
            /**
                * <p>The metadata to apply to the cluster to assist with categorization and organization.
                *             Each tag consists of a key and an optional value. You define both.</p>
                */
            tags?: Record<string, string>;
            /**
                * <p>The encryption configuration for the cluster.</p>
                */
            encryptionConfig?: EncryptionConfig[];
    }
    export namespace CreateClusterRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateClusterRequest) => any;
    }
    /**
        * <p>An object representing the <code>certificate-authority-data</code> for your
        *             cluster.</p>
        */
    export interface Certificate {
            /**
                * <p>The Base64-encoded certificate data required to communicate with your cluster. Add
                *             this to the <code>certificate-authority-data</code> section of the
                *                 <code>kubeconfig</code> file for your cluster.</p>
                */
            data?: string;
    }
    export namespace Certificate {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Certificate) => any;
    }
    /**
        * <p>The full description of your connected cluster.</p>
        */
    export interface ConnectorConfigResponse {
            /**
                * <p>A unique ID associated with the cluster for registration purposes.</p>
                */
            activationId?: string;
            /**
                * <p>A unique code associated with the cluster for registration purposes.</p>
                */
            activationCode?: string;
            /**
                * <p>The expiration time of the connected cluster. The cluster's YAML file must be applied
                *             through the native provider.</p>
                */
            activationExpiry?: Date;
            /**
                * <p>The cluster's cloud service provider.</p>
                */
            provider?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the role to communicate with services from the connected Kubernetes
                *             cluster.</p>
                */
            roleArn?: string;
    }
    export namespace ConnectorConfigResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ConnectorConfigResponse) => any;
    }
    /**
        * <p>An object representing the <a href="https://openid.net/connect/">OpenID
        *                 Connect</a> (OIDC) identity provider information for the cluster.</p>
        */
    export interface OIDC {
            /**
                * <p>The issuer URL for the OIDC identity provider.</p>
                */
            issuer?: string;
    }
    export namespace OIDC {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OIDC) => any;
    }
    /**
        * <p>An object representing an identity provider.</p>
        */
    export interface Identity {
            /**
                * <p>An object representing the <a href="https://openid.net/connect/">OpenID
                *                 Connect</a> identity provider information.</p>
                */
            oidc?: OIDC;
    }
    export namespace Identity {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Identity) => any;
    }
    /**
        * <p>The Kubernetes network configuration for the cluster. The response contains a value
        *             for <b>serviceIpv6Cidr</b> or <b>serviceIpv4Cidr</b>, but not both. </p>
        */
    export interface KubernetesNetworkConfigResponse {
            /**
                * <p>The CIDR block that Kubernetes pod and service IP addresses are assigned from.
                *             Kubernetes assigns addresses from an IPv4 CIDR block assigned to a subnet that the node
                *             is in. If you didn't specify a CIDR block when you created the cluster, then Kubernetes
                *             assigns addresses from either the 10.100.0.0/16 or 172.20.0.0/16 CIDR blocks. If this
                *             was specified, then it was specified when the cluster was created and it can't be
                *             changed.</p>
                */
            serviceIpv4Cidr?: string;
            /**
                * <p>The CIDR block that Kubernetes pod and service IP addresses are assigned from if you
                *             created a 1.21 or later cluster with version 1.10.1 or later of the Amazon VPC CNI add-on and
                *             specified <code>ipv6</code> for <b>ipFamily</b> when you
                *             created the cluster. Kubernetes assigns service addresses from the unique local address
                *             range (<code>fc00::/7</code>) because you can't specify a custom IPv6 CIDR block when
                *             you create the cluster.</p>
                */
            serviceIpv6Cidr?: string;
            /**
                * <p>The IP family used to assign Kubernetes pod and service IP addresses. The IP family is
                *             always <code>ipv4</code>, unless you have a <code>1.21</code> or later cluster running
                *             version 1.10.1 or later of the Amazon VPC CNI add-on and specified <code>ipv6</code> when you
                *             created the cluster. </p>
                */
            ipFamily?: IpFamily | string;
    }
    export namespace KubernetesNetworkConfigResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: KubernetesNetworkConfigResponse) => any;
    }
    /**
        * <p>An object representing an Amazon EKS cluster VPC configuration
        *             response.</p>
        */
    export interface VpcConfigResponse {
            /**
                * <p>The subnets associated with your cluster.</p>
                */
            subnetIds?: string[];
            /**
                * <p>The security groups associated with the cross-account elastic network interfaces that
                *             are used to allow communication between your nodes and the Kubernetes control
                *             plane.</p>
                */
            securityGroupIds?: string[];
            /**
                * <p>The cluster security group that was created by Amazon EKS for the cluster.
                *             Managed node groups use this security group for control-plane-to-data-plane
                *             communication.</p>
                */
            clusterSecurityGroupId?: string;
            /**
                * <p>The VPC associated with your cluster.</p>
                */
            vpcId?: string;
            /**
                * <p>This parameter indicates whether the Amazon EKS public API server endpoint is
                *             enabled. If the Amazon EKS public API server endpoint is disabled, your
                *             cluster's Kubernetes API server can only receive requests that originate from within the
                *             cluster VPC.</p>
                */
            endpointPublicAccess?: boolean;
            /**
                * <p>This parameter indicates whether the Amazon EKS private API server endpoint is
                *             enabled. If the Amazon EKS private API server endpoint is enabled, Kubernetes
                *             API requests that originate from within your cluster's VPC use the private VPC endpoint
                *             instead of traversing the internet. If this value is disabled and you have nodes or
                *                 Fargate pods in the cluster, then ensure that
                *                 <code>publicAccessCidrs</code> includes the necessary CIDR blocks for communication
                *             with the nodes or Fargate pods. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html">Amazon EKS cluster endpoint access control</a> in the
                *                 <i>
                *                <i>Amazon EKS User Guide</i>
                *             </i>.</p>
                */
            endpointPrivateAccess?: boolean;
            /**
                * <p>The CIDR blocks that are allowed access to your cluster's public Kubernetes API server
                *             endpoint. Communication to the endpoint from addresses outside of the listed CIDR blocks
                *             is denied. The default value is <code>0.0.0.0/0</code>. If you've disabled private
                *             endpoint access and you have nodes or Fargate pods in the cluster,
                *             then ensure that the necessary CIDR blocks are listed. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html">Amazon EKS cluster endpoint access control</a> in the
                *                 <i>
                *                <i>Amazon EKS User Guide</i>
                *             </i>.</p>
                */
            publicAccessCidrs?: string[];
    }
    export namespace VpcConfigResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: VpcConfigResponse) => any;
    }
    export type ClusterStatus = "ACTIVE" | "CREATING" | "DELETING" | "FAILED" | "PENDING" | "UPDATING";
    /**
        * <p>An object representing an Amazon EKS cluster.</p>
        */
    export interface Cluster {
            /**
                * <p>The name of the cluster.</p>
                */
            name?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the cluster.</p>
                */
            arn?: string;
            /**
                * <p>The Unix epoch timestamp in seconds for when the cluster was created.</p>
                */
            createdAt?: Date;
            /**
                * <p>The Kubernetes server version for the cluster.</p>
                */
            version?: string;
            /**
                * <p>The endpoint for your Kubernetes API server.</p>
                */
            endpoint?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the IAM role that provides permissions for the
                *             Kubernetes control plane to make calls to Amazon Web Services API operations on your
                *             behalf.</p>
                */
            roleArn?: string;
            /**
                * <p>The VPC configuration used by the cluster control plane. Amazon EKS VPC
                *             resources have specific requirements to work properly with Kubernetes. For more
                *             information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html">Cluster VPC Considerations</a> and <a href="https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html">Cluster Security
                *                 Group Considerations</a> in the <i>Amazon EKS User Guide</i>.</p>
                */
            resourcesVpcConfig?: VpcConfigResponse;
            /**
                * <p>The Kubernetes network configuration for the cluster.</p>
                */
            kubernetesNetworkConfig?: KubernetesNetworkConfigResponse;
            /**
                * <p>The logging configuration for your cluster.</p>
                */
            logging?: Logging;
            /**
                * <p>The identity provider information for the cluster.</p>
                */
            identity?: Identity;
            /**
                * <p>The current status of the cluster.</p>
                */
            status?: ClusterStatus | string;
            /**
                * <p>The <code>certificate-authority-data</code> for your cluster.</p>
                */
            certificateAuthority?: Certificate;
            /**
                * <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
                *             request.</p>
                */
            clientRequestToken?: string;
            /**
                * <p>The platform version of your Amazon EKS cluster. For more information, see
                *                 <a href="https://docs.aws.amazon.com/eks/latest/userguide/platform-versions.html">Platform Versions</a> in the <i>
                *                <i>Amazon EKS User Guide</i>
                *             </i>.</p>
                */
            platformVersion?: string;
            /**
                * <p>The metadata that you apply to the cluster to assist with categorization and
                *             organization. Each tag consists of a key and an optional value. You define both.
                *             Cluster tags do not propagate to any other resources associated with the
                *             cluster.</p>
                */
            tags?: Record<string, string>;
            /**
                * <p>The encryption configuration for the cluster.</p>
                */
            encryptionConfig?: EncryptionConfig[];
            /**
                * <p>The configuration used to connect to a cluster for registration.</p>
                */
            connectorConfig?: ConnectorConfigResponse;
    }
    export namespace Cluster {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Cluster) => any;
    }
    export interface CreateClusterResponse {
            /**
                * <p>The full description of your new cluster.</p>
                */
            cluster?: Cluster;
    }
    export namespace CreateClusterResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateClusterResponse) => any;
    }
    /**
        * <p>You have encountered a service limit on the specified resource.</p>
        */
    export class ResourceLimitExceededException extends __BaseException {
            readonly name: "ResourceLimitExceededException";
            readonly $fault: "client";
            /**
                * <p>The Amazon EKS cluster associated with the exception.</p>
                */
            clusterName?: string;
            /**
                * <p>The Amazon EKS managed node group associated with the exception.</p>
                */
            nodegroupName?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceLimitExceededException, __BaseException>);
    }
    /**
        * <p>The service is unavailable. Back off and retry the operation.</p>
        */
    export class ServiceUnavailableException extends __BaseException {
            readonly name: "ServiceUnavailableException";
            readonly $fault: "server";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ServiceUnavailableException, __BaseException>);
    }
    /**
        * <p>At least one of your specified cluster subnets is in an Availability Zone that does
        *             not support Amazon EKS. The exception output specifies the supported
        *             Availability Zones for your account, from which you can choose subnets for your
        *             cluster.</p>
        */
    export class UnsupportedAvailabilityZoneException extends __BaseException {
            readonly name: "UnsupportedAvailabilityZoneException";
            readonly $fault: "client";
            /**
                * <p>The Amazon EKS cluster associated with the exception.</p>
                */
            clusterName?: string;
            /**
                * <p>The Amazon EKS managed node group associated with the exception.</p>
                */
            nodegroupName?: string;
            /**
                * <p>The supported Availability Zones for your account. Choose subnets in these
                *             Availability Zones for your cluster.</p>
                */
            validZones?: string[];
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UnsupportedAvailabilityZoneException, __BaseException>);
    }
    /**
        * <p>An object representing an Fargate profile selector.</p>
        */
    export interface FargateProfileSelector {
            /**
                * <p>The Kubernetes namespace that the selector should match.</p>
                */
            namespace?: string;
            /**
                * <p>The Kubernetes labels that the selector should match. A pod must contain all of the
                *             labels that are specified in the selector for it to be considered a match.</p>
                */
            labels?: Record<string, string>;
    }
    export namespace FargateProfileSelector {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FargateProfileSelector) => any;
    }
    export interface CreateFargateProfileRequest {
            /**
                * <p>The name of the Fargate profile.</p>
                */
            fargateProfileName: string | undefined;
            /**
                * <p>The name of the Amazon EKS cluster to apply the Fargate profile
                *             to.</p>
                */
            clusterName: string | undefined;
            /**
                * <p>The Amazon Resource Name (ARN) of the pod execution role to use for pods that match the selectors in
                *             the Fargate profile. The pod execution role allows Fargate
                *             infrastructure to register with your cluster as a node, and it provides read access to
                *                 Amazon ECR image repositories. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/pod-execution-role.html">Pod
                *                 Execution Role</a> in the <i>Amazon EKS User Guide</i>.</p>
                */
            podExecutionRoleArn: string | undefined;
            /**
                * <p>The IDs of subnets to launch your pods into. At this time, pods running on Fargate are not assigned public IP addresses, so only private subnets (with
                *             no direct route to an Internet Gateway) are accepted for this parameter.</p>
                */
            subnets?: string[];
            /**
                * <p>The selectors to match for pods to use this Fargate profile. Each
                *             selector must have an associated namespace. Optionally, you can also specify labels for
                *             a namespace. You may specify up to five selectors in a Fargate
                *             profile.</p>
                */
            selectors?: FargateProfileSelector[];
            /**
                * <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
                *             request.</p>
                */
            clientRequestToken?: string;
            /**
                * <p>The metadata to apply to the Fargate profile to assist with categorization and
                *             organization. Each tag consists of a key and an optional value. You define both.
                *             Fargate profile tags do not propagate to any other resources associated with the
                *             Fargate profile, such as the pods that are scheduled with it.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace CreateFargateProfileRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateFargateProfileRequest) => any;
    }
    export type FargateProfileStatus = "ACTIVE" | "CREATE_FAILED" | "CREATING" | "DELETE_FAILED" | "DELETING";
    /**
        * <p>An object representing an Fargate profile.</p>
        */
    export interface FargateProfile {
            /**
                * <p>The name of the Fargate profile.</p>
                */
            fargateProfileName?: string;
            /**
                * <p>The full Amazon Resource Name (ARN) of the Fargate profile.</p>
                */
            fargateProfileArn?: string;
            /**
                * <p>The name of the Amazon EKS cluster that the Fargate profile
                *             belongs to.</p>
                */
            clusterName?: string;
            /**
                * <p>The Unix epoch timestamp in seconds for when the Fargate profile was
                *             created.</p>
                */
            createdAt?: Date;
            /**
                * <p>The Amazon Resource Name (ARN) of the pod execution role to use for pods that match the selectors in
                *             the Fargate profile. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/pod-execution-role.html">Pod
                *                 Execution Role</a> in the <i>Amazon EKS User Guide</i>.</p>
                */
            podExecutionRoleArn?: string;
            /**
                * <p>The IDs of subnets to launch pods into.</p>
                */
            subnets?: string[];
            /**
                * <p>The selectors to match for pods to use this Fargate profile.</p>
                */
            selectors?: FargateProfileSelector[];
            /**
                * <p>The current status of the Fargate profile.</p>
                */
            status?: FargateProfileStatus | string;
            /**
                * <p>The metadata applied to the Fargate profile to assist with categorization and
                *             organization. Each tag consists of a key and an optional value. You define both.
                *             Fargate profile tags do not propagate to any other resources associated with the
                *             Fargate profile, such as the pods that are scheduled with it.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace FargateProfile {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FargateProfile) => any;
    }
    export interface CreateFargateProfileResponse {
            /**
                * <p>The full description of your new Fargate profile.</p>
                */
            fargateProfile?: FargateProfile;
    }
    export namespace CreateFargateProfileResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateFargateProfileResponse) => any;
    }
    export type CapacityTypes = "ON_DEMAND" | "SPOT";
    /**
        * <p>An object representing a node group launch template specification. The launch template
        *             cannot include <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateNetworkInterface.html">
        *                <code>SubnetId</code>
        *             </a>, <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IamInstanceProfile.html">
        *                <code>IamInstanceProfile</code>
        *             </a>, <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotInstances.html">
        *                <code>RequestSpotInstances</code>
        *             </a>, <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_HibernationOptionsRequest.html">
        *                <code>HibernationOptions</code>
        *             </a>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TerminateInstances.html">
        *                <code>TerminateInstances</code>
        *             </a>, or the node group  deployment or
        *             update will fail. For more information about launch templates, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateLaunchTemplate.html">
        *                <code>CreateLaunchTemplate</code>
        *             </a> in the Amazon EC2 API
        *             Reference. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the <i>Amazon EKS User Guide</i>.</p>
        *         <p>Specify either <code>name</code> or <code>id</code>, but not both.</p>
        */
    export interface LaunchTemplateSpecification {
            /**
                * <p>The name of the launch template.</p>
                */
            name?: string;
            /**
                * <p>The version of the launch template to use. If no version is specified, then the
                *             template's default version is used.</p>
                */
            version?: string;
            /**
                * <p>The ID of the launch template.</p>
                */
            id?: string;
    }
    export namespace LaunchTemplateSpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LaunchTemplateSpecification) => any;
    }
    /**
        * <p>An object representing the remote access configuration for the managed node
        *             group.</p>
        */
    export interface RemoteAccessConfig {
            /**
                * <p>The Amazon EC2 SSH key that provides access for SSH communication with the
                *             nodes in the managed node group. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html">Amazon EC2 key pairs and Linux instances</a> in the <i>Amazon Elastic Compute Cloud User Guide for Linux Instances</i>.</p>
                */
            ec2SshKey?: string;
            /**
                * <p>The security groups that are allowed SSH access (port 22) to the nodes. If you specify
                *             an Amazon EC2 SSH key but do not specify a source security group when you create
                *             a managed node group, then port 22 on the nodes is opened to the internet (0.0.0.0/0).
                *             For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html">Security Groups for Your VPC</a> in the
                *             <i>Amazon Virtual Private Cloud User Guide</i>.</p>
                */
            sourceSecurityGroups?: string[];
    }
    export namespace RemoteAccessConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RemoteAccessConfig) => any;
    }
    /**
        * <p>An object representing the scaling configuration details for the Auto Scaling group
        *             that is associated with your node group. When creating a node group, you must specify
        *             all or none of the properties. When updating a node group, you can specify any or none
        *             of the properties.</p>
        */
    export interface NodegroupScalingConfig {
            /**
                * <p>The minimum number of nodes that the managed node group can scale in to.</p>
                */
            minSize?: number;
            /**
                * <p>The maximum number of nodes that the managed node group can scale out to. For
                *             information about the maximum number that you can specify, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/service-quotas.html">Amazon EKS service quotas</a> in the <i>Amazon EKS User Guide</i>.</p>
                */
            maxSize?: number;
            /**
                * <p>The current number of nodes that the managed node group should maintain.</p>
                *         <important>
                *             <p>If you use Cluster Autoscaler, you shouldn't change the desiredSize value
                *                 directly, as this can cause the Cluster Autoscaler to suddenly scale up or scale
                *                 down.</p>
                *         </important>
                *         <p>Whenever this parameter changes, the number of worker nodes in the node group is
                *             updated to the specified size. If this parameter is given a value that is smaller than
                *             the current number of running worker nodes, the necessary number of worker nodes are
                *             terminated to match the given value.
                *
                *             When using CloudFormation, no action occurs if you remove this parameter from your CFN
                *             template.</p>
                *         <p>This parameter can be different from minSize in some cases, such as when starting with
                *             extra hosts for testing. This parameter can also be different when you want to start
                *             with an estimated number of needed hosts, but let Cluster Autoscaler reduce the number
                *             if there are too many. When Cluster Autoscaler is used, the desiredSize parameter is
                *             altered by Cluster Autoscaler (but can be out-of-date for short periods of time).
                *             Cluster Autoscaler doesn't scale a managed node group lower than minSize or higher than
                *             maxSize.</p>
                */
            desiredSize?: number;
    }
    export namespace NodegroupScalingConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: NodegroupScalingConfig) => any;
    }
    export enum TaintEffect {
            NO_EXECUTE = "NO_EXECUTE",
            NO_SCHEDULE = "NO_SCHEDULE",
            PREFER_NO_SCHEDULE = "PREFER_NO_SCHEDULE"
    }
    /**
        * <p>A property that allows a node to repel a set of pods. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html">Node taints on managed node groups</a>.</p>
        */
    export interface Taint {
            /**
                * <p>The key of the taint.</p>
                */
            key?: string;
            /**
                * <p>The value of the taint.</p>
                */
            value?: string;
            /**
                * <p>The effect of the taint.</p>
                */
            effect?: TaintEffect | string;
    }
    export namespace Taint {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Taint) => any;
    }
    /**
        * <p>The node group update configuration.</p>
        */
    export interface NodegroupUpdateConfig {
            /**
                * <p>The maximum number of nodes unavailable at once during a version update. Nodes will be
                *             updated in parallel. This value or <code>maxUnavailablePercentage</code> is required to
                *             have a value.The maximum number is 100.</p>
                */
            maxUnavailable?: number;
            /**
                * <p>The maximum percentage of nodes unavailable during a version update. This percentage
                *             of nodes will be updated in parallel, up to 100 nodes at once. This value or
                *                 <code>maxUnavailable</code> is required to have a value.</p>
                */
            maxUnavailablePercentage?: number;
    }
    export namespace NodegroupUpdateConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: NodegroupUpdateConfig) => any;
    }
    export interface CreateNodegroupRequest {
            /**
                * <p>The name of the cluster to create the node group in.</p>
                */
            clusterName: string | undefined;
            /**
                * <p>The unique name to give your node group.</p>
                */
            nodegroupName: string | undefined;
            /**
                * <p>The scaling configuration details for the Auto Scaling group that is created for your
                *             node group.</p>
                */
            scalingConfig?: NodegroupScalingConfig;
            /**
                * <p>The root device disk size (in GiB) for your node group instances. The default disk
                *             size is 20 GiB. If you specify <code>launchTemplate</code>, then don't specify  <code>diskSize</code>,
                *             or the node group  deployment will fail. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the <i>Amazon EKS User Guide</i>.</p>
                */
            diskSize?: number;
            /**
                * <p>The subnets to use for the Auto Scaling group that is created for your node group.
                *             If you specify <code>launchTemplate</code>, then don't specify  <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateNetworkInterface.html">
                *                <code>SubnetId</code>
                *             </a> in your launch template, or the node group
                *             deployment will fail. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the <i>Amazon EKS User Guide</i>.</p>
                */
            subnets: string[] | undefined;
            /**
                * <p>Specify the instance types for a node group. If you specify a GPU instance type, be
                *             sure to specify <code>AL2_x86_64_GPU</code> with the <code>amiType</code> parameter. If
                *             you specify <code>launchTemplate</code>, then you can specify zero or one instance type
                *             in your launch template <i>or</i> you can specify 0-20 instance types for
                *                 <code>instanceTypes</code>. If however, you specify an instance type in your launch
                *             template <i>and</i> specify any <code>instanceTypes</code>, the node group
                *             deployment will fail. If you don't specify an instance type in a launch template or for
                *                 <code>instanceTypes</code>, then <code>t3.medium</code> is used, by default. If you
                *             specify <code>Spot</code> for <code>capacityType</code>, then we recommend specifying
                *             multiple values for <code>instanceTypes</code>. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html#managed-node-group-capacity-types">Managed node group capacity types</a> and <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in
                *             the <i>Amazon EKS User Guide</i>.</p>
                */
            instanceTypes?: string[];
            /**
                * <p>The AMI type for your node group. GPU instance types should use the
                *                 <code>AL2_x86_64_GPU</code> AMI type. Non-GPU instances should use the
                *                 <code>AL2_x86_64</code> AMI type. Arm instances should use the
                *                 <code>AL2_ARM_64</code> AMI type. All types use the Amazon EKS optimized
                *             Amazon Linux 2 AMI. If you specify <code>launchTemplate</code>, and your launch template uses a custom AMI,
                *                 then don't specify <code>amiType</code>, or the node group  deployment
                *             will fail. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the <i>Amazon EKS User Guide</i>.</p>
                */
            amiType?: AMITypes | string;
            /**
                * <p>The remote access (SSH) configuration to use with your node group. If you specify <code>launchTemplate</code>,
                *             then don't specify  <code>remoteAccess</code>, or the node group  deployment
                *             will fail. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the <i>Amazon EKS User Guide</i>.</p>
                */
            remoteAccess?: RemoteAccessConfig;
            /**
                * <p>The Amazon Resource Name (ARN) of the IAM role to associate with your node group. The
                *                 Amazon EKS worker node <code>kubelet</code> daemon makes calls to Amazon Web Services APIs on your behalf. Nodes receive permissions for these API calls
                *             through an IAM instance profile and associated policies. Before you can
                *             launch nodes and register them into a cluster, you must create an IAM
                *             role for those nodes to use when they are launched. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html">Amazon EKS node IAM role</a> in the
                *                 <i>
                *                <i>Amazon EKS User Guide</i>
                *             </i>. If you specify <code>launchTemplate</code>, then don't specify
                *                 <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IamInstanceProfile.html">
                *                <code>IamInstanceProfile</code>
                *             </a> in your launch template,
                *             or the node group  deployment will fail. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the <i>Amazon EKS User Guide</i>.</p>
                */
            nodeRole: string | undefined;
            /**
                * <p>The Kubernetes labels to be applied to the nodes in the node group when they are
                *             created.</p>
                */
            labels?: Record<string, string>;
            /**
                * <p>The Kubernetes taints to be applied to the nodes in the node group. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html">Node taints on managed node groups</a>.</p>
                */
            taints?: Taint[];
            /**
                * <p>The metadata to apply to the node group to assist with categorization and
                *             organization. Each tag consists of a key and an optional value. You
                *             define both. Node group tags do not propagate to any other resources associated with the node
                *             group, such as the Amazon EC2 instances or subnets.</p>
                */
            tags?: Record<string, string>;
            /**
                * <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
                *             request.</p>
                */
            clientRequestToken?: string;
            /**
                * <p>An object representing a node group's launch template specification. If specified,
                *             then do not specify <code>instanceTypes</code>, <code>diskSize</code>, or
                *                 <code>remoteAccess</code> and make sure that the launch template meets the
                *             requirements in <code>launchTemplateSpecification</code>.</p>
                */
            launchTemplate?: LaunchTemplateSpecification;
            /**
                * <p>The node group update configuration.</p>
                */
            updateConfig?: NodegroupUpdateConfig;
            /**
                * <p>The capacity type for your node group.</p>
                */
            capacityType?: CapacityTypes | string;
            /**
                * <p>The Kubernetes version to use for your managed nodes. By default, the Kubernetes
                *             version of the cluster is used, and this is the only accepted specified value.
                *             If you specify <code>launchTemplate</code>, and your launch template uses a custom AMI, then don't specify  <code>version</code>,
                *             or the node group  deployment will fail. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the <i>Amazon EKS User Guide</i>.</p>
                */
            version?: string;
            /**
                * <p>The AMI version of the Amazon EKS optimized AMI to use with your node group.
                *             By default, the latest available AMI version for the node group's current Kubernetes
                *             version is used. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html">Amazon EKS optimized Amazon Linux 2 AMI versions</a> in the <i>Amazon EKS User Guide</i>.
                *             If you specify <code>launchTemplate</code>, and your launch template uses a custom AMI, then don't specify  <code>releaseVersion</code>,
                *             or the node group  deployment will fail. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the <i>Amazon EKS User Guide</i>.</p>
                */
            releaseVersion?: string;
    }
    export namespace CreateNodegroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateNodegroupRequest) => any;
    }
    export enum NodegroupIssueCode {
            ACCESS_DENIED = "AccessDenied",
            ASG_INSTANCE_LAUNCH_FAILURES = "AsgInstanceLaunchFailures",
            AUTO_SCALING_GROUP_INVALID_CONFIGURATION = "AutoScalingGroupInvalidConfiguration",
            AUTO_SCALING_GROUP_NOT_FOUND = "AutoScalingGroupNotFound",
            CLUSTER_UNREACHABLE = "ClusterUnreachable",
            EC2_LAUNCH_TEMPLATE_NOT_FOUND = "Ec2LaunchTemplateNotFound",
            EC2_LAUNCH_TEMPLATE_VERSION_MISMATCH = "Ec2LaunchTemplateVersionMismatch",
            EC2_SECURITY_GROUP_DELETION_FAILURE = "Ec2SecurityGroupDeletionFailure",
            EC2_SECURITY_GROUP_NOT_FOUND = "Ec2SecurityGroupNotFound",
            EC2_SUBNET_INVALID_CONFIGURATION = "Ec2SubnetInvalidConfiguration",
            EC2_SUBNET_MISSING_IPV6_ASSIGNMENT = "Ec2SubnetMissingIpv6Assignment",
            EC2_SUBNET_NOT_FOUND = "Ec2SubnetNotFound",
            IAM_INSTANCE_PROFILE_NOT_FOUND = "IamInstanceProfileNotFound",
            IAM_LIMIT_EXCEEDED = "IamLimitExceeded",
            IAM_NODE_ROLE_NOT_FOUND = "IamNodeRoleNotFound",
            INSTANCE_LIMIT_EXCEEDED = "InstanceLimitExceeded",
            INSUFFICIENT_FREE_ADDRESSES = "InsufficientFreeAddresses",
            INTERNAL_FAILURE = "InternalFailure",
            NODE_CREATION_FAILURE = "NodeCreationFailure"
    }
    /**
        * <p>An object representing an issue with an Amazon EKS resource.</p>
        */
    export interface Issue {
            /**
                * <p>A brief description of the error.</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <b>AccessDenied</b>: Amazon EKS or one or
                *                     more of your managed nodes is failing to authenticate or authorize with your
                *                     Kubernetes cluster API server.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <b>AsgInstanceLaunchFailures</b>: Your Auto Scaling group is experiencing failures while attempting to launch
                *                     instances.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <b>AutoScalingGroupNotFound</b>: We couldn't find
                *                     the Auto Scaling group associated with the managed node group. You may be
                *                     able to recreate an Auto Scaling group with the same settings to
                *                     recover.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <b>ClusterUnreachable</b>: Amazon EKS or one
                *                     or more of your managed nodes is unable to to communicate with your Kubernetes
                *                     cluster API server. This can happen if there are network disruptions or if API
                *                     servers are timing out processing requests. </p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <b>Ec2LaunchTemplateNotFound</b>: We couldn't find
                *                     the Amazon EC2 launch template for your managed node group. You may be
                *                     able to recreate a launch template with the same settings to recover.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <b>Ec2LaunchTemplateVersionMismatch</b>: The Amazon EC2 launch template version for your managed node group does not
                *                     match the version that Amazon EKS created. You may be able to revert to
                *                     the version that Amazon EKS created to recover.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <b>Ec2SecurityGroupDeletionFailure</b>: We could not
                *                     delete the remote access security group for your managed node group. Remove any
                *                     dependencies from the security group.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <b>Ec2SecurityGroupNotFound</b>: We couldn't find
                *                     the cluster security group for the cluster. You must recreate your
                *                     cluster.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <b>Ec2SubnetInvalidConfiguration</b>: One or more
                *                         Amazon EC2 subnets specified for a node group do not automatically
                *                     assign public IP addresses to instances launched into it. If you want your
                *                     instances to be assigned a public IP address, then you need to enable the
                *                         <code>auto-assign public IP address</code> setting for the subnet. See
                *                         <a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-ip-addressing.html#subnet-public-ip">Modifying
                *                         the public IPv4 addressing attribute for your subnet</a> in the
                *                         <i>Amazon VPC User Guide</i>.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <b>IamInstanceProfileNotFound</b>: We couldn't find
                *                     the IAM instance profile for your managed node group. You may be
                *                     able to recreate an instance profile with the same settings to recover.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <b>IamNodeRoleNotFound</b>: We couldn't find the
                *                         IAM role for your managed node group. You may be able to
                *                     recreate an IAM role with the same settings to recover.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <b>InstanceLimitExceeded</b>: Your Amazon Web Services account is unable to launch any more instances of the specified instance
                *                     type. You may be able to request an Amazon EC2 instance limit increase
                *                     to recover.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <b>InsufficientFreeAddresses</b>: One or more of the
                *                     subnets associated with your managed node group does not have enough available
                *                     IP addresses for new nodes.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <b>InternalFailure</b>: These errors are usually
                *                     caused by an Amazon EKS server-side issue.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <b>NodeCreationFailure</b>: Your launched instances
                *                     are unable to register with your Amazon EKS cluster. Common causes of this failure
                *                     are insufficient <a href="https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html">node IAM role</a>
                *                     permissions or lack of outbound internet access for the nodes. </p>
                *             </li>
                *          </ul>
                */
            code?: NodegroupIssueCode | string;
            /**
                * <p>The error message associated with the issue.</p>
                */
            message?: string;
            /**
                * <p>The Amazon Web Services resources that are afflicted by this issue.</p>
                */
            resourceIds?: string[];
    }
    export namespace Issue {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Issue) => any;
    }
    /**
        * <p>An object representing the health status of the node group.</p>
        */
    export interface NodegroupHealth {
            /**
                * <p>Any issues that are associated with the node group. </p>
                */
            issues?: Issue[];
    }
    export namespace NodegroupHealth {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: NodegroupHealth) => any;
    }
    /**
        * <p>An object representing the resources associated with the node group, such as Auto
        *             Scaling groups and security groups for remote access.</p>
        */
    export interface NodegroupResources {
            /**
                * <p>The Auto Scaling groups associated with the node group.</p>
                */
            autoScalingGroups?: AutoScalingGroup[];
            /**
                * <p>The remote access security group associated with the node group. This security group
                *             controls SSH access to the nodes.</p>
                */
            remoteAccessSecurityGroup?: string;
    }
    export namespace NodegroupResources {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: NodegroupResources) => any;
    }
    export type NodegroupStatus = "ACTIVE" | "CREATE_FAILED" | "CREATING" | "DEGRADED" | "DELETE_FAILED" | "DELETING" | "UPDATING";
    /**
        * <p>An object representing an Amazon EKS managed node group.</p>
        */
    export interface Nodegroup {
            /**
                * <p>The name associated with an Amazon EKS managed node group.</p>
                */
            nodegroupName?: string;
            /**
                * <p>The Amazon Resource Name (ARN) associated with the managed node group.</p>
                */
            nodegroupArn?: string;
            /**
                * <p>The name of the cluster that the managed node group resides in.</p>
                */
            clusterName?: string;
            /**
                * <p>The Kubernetes version of the managed node group.</p>
                */
            version?: string;
            /**
                * <p>If the node group was deployed using a launch template with a custom AMI, then this is
                *             the AMI ID that was specified in the launch template. For node groups that weren't
                *             deployed using a launch template, this is the version of the Amazon EKS
                *             optimized AMI that the node group was deployed with.</p>
                */
            releaseVersion?: string;
            /**
                * <p>The Unix epoch timestamp in seconds for when the managed node group was
                *             created.</p>
                */
            createdAt?: Date;
            /**
                * <p>The Unix epoch timestamp in seconds for when the managed node group was last
                *             modified.</p>
                */
            modifiedAt?: Date;
            /**
                * <p>The current status of the managed node group.</p>
                */
            status?: NodegroupStatus | string;
            /**
                * <p>The capacity type of your managed node group.</p>
                */
            capacityType?: CapacityTypes | string;
            /**
                * <p>The scaling configuration details for the Auto Scaling group that is associated with
                *             your node group.</p>
                */
            scalingConfig?: NodegroupScalingConfig;
            /**
                * <p>If the node group wasn't deployed with a launch template, then this is the instance
                *             type that is associated with the node group. If the node group was deployed with a
                *             launch template, then this is <code>null</code>.</p>
                */
            instanceTypes?: string[];
            /**
                * <p>The subnets that were specified for the Auto Scaling group that is associated with
                *             your node group.</p>
                */
            subnets?: string[];
            /**
                * <p>If the node group wasn't deployed with a launch template, then this is the remote
                *             access configuration that is associated with the node group. If the node group was
                *             deployed with a launch template, then this is <code>null</code>.</p>
                */
            remoteAccess?: RemoteAccessConfig;
            /**
                * <p>If the node group was deployed using a launch template with a custom AMI, then this is
                *                 <code>CUSTOM</code>. For node groups that weren't deployed using a launch template,
                *             this is the AMI type that was specified in the node group configuration.</p>
                */
            amiType?: AMITypes | string;
            /**
                * <p>The IAM role associated with your node group. The Amazon EKS
                *             node <code>kubelet</code> daemon makes calls to Amazon Web Services APIs on your behalf.
                *             Nodes receive permissions for these API calls through an IAM instance
                *             profile and associated policies.</p>
                */
            nodeRole?: string;
            /**
                * <p>The Kubernetes labels applied to the nodes in the node group.</p>
                *         <note>
                *             <p>Only labels that are applied with the Amazon EKS API are shown here. There
                *                 may be other Kubernetes labels applied to the nodes in this group.</p>
                *         </note>
                */
            labels?: Record<string, string>;
            /**
                * <p>The Kubernetes taints to be applied to the nodes in the node group when they are
                *             created. Effect is one of <code>No_Schedule</code>, <code>Prefer_No_Schedule</code>, or
                *                 <code>No_Execute</code>. Kubernetes taints can be used together with tolerations to
                *             control how workloads are scheduled to your nodes. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html">Node taints on managed node groups</a>.</p>
                */
            taints?: Taint[];
            /**
                * <p>The resources associated with the node group, such as Auto Scaling groups and security
                *             groups for remote access.</p>
                */
            resources?: NodegroupResources;
            /**
                * <p>If the node group wasn't deployed with a launch template, then this is the disk size
                *             in the node group configuration. If the node group was deployed with a launch template,
                *             then this is <code>null</code>.</p>
                */
            diskSize?: number;
            /**
                * <p>The health status of the node group. If there are issues with your node group's
                *             health, they are listed here.</p>
                */
            health?: NodegroupHealth;
            /**
                * <p>The node group update configuration.</p>
                */
            updateConfig?: NodegroupUpdateConfig;
            /**
                * <p>If a launch template was used to create the node group, then this is the launch
                *             template that was used.</p>
                */
            launchTemplate?: LaunchTemplateSpecification;
            /**
                * <p>The metadata applied to the node group to assist with categorization and organization.
                *             Each tag consists of a key and an optional value. You define both. Node group
                *             tags do not propagate to any other resources associated with the node group, such as the
                *             Amazon EC2 instances or subnets. </p>
                */
            tags?: Record<string, string>;
    }
    export namespace Nodegroup {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Nodegroup) => any;
    }
    export interface CreateNodegroupResponse {
            /**
                * <p>The full description of your new node group.</p>
                */
            nodegroup?: Nodegroup;
    }
    export namespace CreateNodegroupResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateNodegroupResponse) => any;
    }
    export interface DeleteAddonRequest {
            /**
                * <p>The name of the cluster to delete the add-on from.</p>
                */
            clusterName: string | undefined;
            /**
                * <p>The name of the add-on. The name must match one of the names returned by <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_ListAddons.html">
                *                <code>ListAddons</code>
                *             </a>.</p>
                */
            addonName: string | undefined;
            /**
                * <p>Specifying this option preserves the add-on software on your cluster but Amazon EKS stops managing any settings for the add-on. If an IAM
                *             account is associated with the add-on, it is not removed.</p>
                */
            preserve?: boolean;
    }
    export namespace DeleteAddonRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteAddonRequest) => any;
    }
    export interface DeleteAddonResponse {
            /**
                * <p>An Amazon EKS add-on. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/eks-add-ons.html">Amazon EKS add-ons</a> in
                *             the <i>Amazon EKS User Guide</i>.</p>
                */
            addon?: Addon;
    }
    export namespace DeleteAddonResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteAddonResponse) => any;
    }
    export interface DeleteClusterRequest {
            /**
                * <p>The name of the cluster to delete.</p>
                */
            name: string | undefined;
    }
    export namespace DeleteClusterRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteClusterRequest) => any;
    }
    export interface DeleteClusterResponse {
            /**
                * <p>The full description of the cluster to delete.</p>
                */
            cluster?: Cluster;
    }
    export namespace DeleteClusterResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteClusterResponse) => any;
    }
    export interface DeleteFargateProfileRequest {
            /**
                * <p>The name of the Amazon EKS cluster associated with the Fargate
                *             profile to delete.</p>
                */
            clusterName: string | undefined;
            /**
                * <p>The name of the Fargate profile to delete.</p>
                */
            fargateProfileName: string | undefined;
    }
    export namespace DeleteFargateProfileRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteFargateProfileRequest) => any;
    }
    export interface DeleteFargateProfileResponse {
            /**
                * <p>The deleted Fargate profile.</p>
                */
            fargateProfile?: FargateProfile;
    }
    export namespace DeleteFargateProfileResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteFargateProfileResponse) => any;
    }
    export interface DeleteNodegroupRequest {
            /**
                * <p>The name of the Amazon EKS cluster that is associated with your node
                *             group.</p>
                */
            clusterName: string | undefined;
            /**
                * <p>The name of the node group to delete.</p>
                */
            nodegroupName: string | undefined;
    }
    export namespace DeleteNodegroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteNodegroupRequest) => any;
    }
    export interface DeleteNodegroupResponse {
            /**
                * <p>The full description of your deleted node group.</p>
                */
            nodegroup?: Nodegroup;
    }
    export namespace DeleteNodegroupResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteNodegroupResponse) => any;
    }
    export interface DeregisterClusterRequest {
            /**
                * <p>The name of the connected cluster to deregister.</p>
                */
            name: string | undefined;
    }
    export namespace DeregisterClusterRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeregisterClusterRequest) => any;
    }
    export interface DeregisterClusterResponse {
            /**
                * <p>An object representing an Amazon EKS cluster.</p>
                */
            cluster?: Cluster;
    }
    export namespace DeregisterClusterResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeregisterClusterResponse) => any;
    }
    export interface DescribeAddonRequest {
            /**
                * <p>The name of the cluster.</p>
                */
            clusterName: string | undefined;
            /**
                * <p>The name of the add-on. The name must match one of the names returned by <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_ListAddons.html">
                *                <code>ListAddons</code>
                *             </a>.</p>
                */
            addonName: string | undefined;
    }
    export namespace DescribeAddonRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeAddonRequest) => any;
    }
    export interface DescribeAddonResponse {
            /**
                * <p>An Amazon EKS add-on. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/eks-add-ons.html">Amazon EKS add-ons</a> in
                *             the <i>Amazon EKS User Guide</i>.</p>
                */
            addon?: Addon;
    }
    export namespace DescribeAddonResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeAddonResponse) => any;
    }
    export interface DescribeAddonVersionsRequest {
            /**
                * <p>The Kubernetes versions that the add-on can be used with.</p>
                */
            kubernetesVersion?: string;
            /**
                * <p>The maximum number of results to return.</p>
                */
            maxResults?: number;
            /**
                * <p>The <code>nextToken</code> value returned from a previous paginated
                *                 <code>DescribeAddonVersionsRequest</code> where <code>maxResults</code> was used and
                *             the results exceeded the value of that parameter. Pagination continues from the end of
                *             the previous results that returned the <code>nextToken</code> value.</p>
                *         <note>
                *             <p>This token should be treated as an opaque identifier that is used only to
                *                 retrieve the next items in a list and not for other programmatic purposes.</p>
                *         </note>
                */
            nextToken?: string;
            /**
                * <p>The name of the add-on. The name must match one of the names returned by <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_ListAddons.html">
                *                <code>ListAddons</code>
                *             </a>.</p>
                */
            addonName?: string;
    }
    export namespace DescribeAddonVersionsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeAddonVersionsRequest) => any;
    }
    export interface DescribeAddonVersionsResponse {
            /**
                * <p>The list of available versions with Kubernetes version compatibility.</p>
                */
            addons?: AddonInfo[];
            /**
                * <p>The <code>nextToken</code> value returned from a previous paginated
                *                 <code>DescribeAddonVersionsResponse</code> where <code>maxResults</code> was used
                *             and the results exceeded the value of that parameter. Pagination continues from the end
                *             of the previous results that returned the <code>nextToken</code> value.</p>
                *         <note>
                *             <p>This token should be treated as an opaque identifier that is used only to
                *                 retrieve the next items in a list and not for other programmatic purposes.</p>
                *         </note>
                */
            nextToken?: string;
    }
    export namespace DescribeAddonVersionsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeAddonVersionsResponse) => any;
    }
    export interface DescribeClusterRequest {
            /**
                * <p>The name of the cluster to describe.</p>
                */
            name: string | undefined;
    }
    export namespace DescribeClusterRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeClusterRequest) => any;
    }
    export interface DescribeClusterResponse {
            /**
                * <p>The full description of your specified cluster.</p>
                */
            cluster?: Cluster;
    }
    export namespace DescribeClusterResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeClusterResponse) => any;
    }
    export interface DescribeFargateProfileRequest {
            /**
                * <p>The name of the Amazon EKS cluster associated with the Fargate
                *             profile.</p>
                */
            clusterName: string | undefined;
            /**
                * <p>The name of the Fargate profile to describe.</p>
                */
            fargateProfileName: string | undefined;
    }
    export namespace DescribeFargateProfileRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeFargateProfileRequest) => any;
    }
    export interface DescribeFargateProfileResponse {
            /**
                * <p>The full description of your Fargate profile.</p>
                */
            fargateProfile?: FargateProfile;
    }
    export namespace DescribeFargateProfileResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeFargateProfileResponse) => any;
    }
    /**
        * <p>An object representing an identity provider configuration.</p>
        */
    export interface IdentityProviderConfig {
            /**
                * <p>The type of the identity provider configuration. The only type available is
                *                 <code>oidc</code>.</p>
                */
            type: string | undefined;
            /**
                * <p>The name of the identity provider configuration.</p>
                */
            name: string | undefined;
    }
    export namespace IdentityProviderConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: IdentityProviderConfig) => any;
    }
    export interface DescribeIdentityProviderConfigRequest {
            /**
                * <p>The cluster name that the identity provider configuration is associated to.</p>
                */
            clusterName: string | undefined;
            /**
                * <p>An object that represents an identity provider configuration.</p>
                */
            identityProviderConfig: IdentityProviderConfig | undefined;
    }
    export namespace DescribeIdentityProviderConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeIdentityProviderConfigRequest) => any;
    }
    export enum ConfigStatus {
            ACTIVE = "ACTIVE",
            CREATING = "CREATING",
            DELETING = "DELETING"
    }
    /**
        * <p>An object that represents the configuration for an OpenID Connect (OIDC) identity
        *             provider. </p>
        */
    export interface OidcIdentityProviderConfig {
            /**
                * <p>The name of the configuration.</p>
                */
            identityProviderConfigName?: string;
            /**
                * <p>The ARN of the configuration.</p>
                */
            identityProviderConfigArn?: string;
            /**
                * <p>The cluster that the configuration is associated to.</p>
                */
            clusterName?: string;
            /**
                * <p>The URL of the OIDC identity provider that allows the API server to discover public
                *             signing keys for verifying tokens.</p>
                */
            issuerUrl?: string;
            /**
                * <p>This is also known as <i>audience</i>. The ID of the client application
                *             that makes authentication requests to the OIDC identity provider.</p>
                */
            clientId?: string;
            /**
                * <p>The JSON Web token (JWT) claim that is used as the username.</p>
                */
            usernameClaim?: string;
            /**
                * <p>The prefix that is prepended to username claims to prevent clashes with existing
                *             names. The prefix can't contain <code>system:</code>
                *          </p>
                */
            usernamePrefix?: string;
            /**
                * <p>The JSON web token (JWT) claim that the provider uses to return your groups.</p>
                */
            groupsClaim?: string;
            /**
                * <p>The prefix that is prepended to group claims to prevent clashes with existing names
                *             (such as <code>system:</code> groups). For example, the value<code> oidc:</code> creates
                *             group names like <code>oidc:engineering</code> and <code>oidc:infra</code>. The prefix
                *             can't contain <code>system:</code>
                *          </p>
                */
            groupsPrefix?: string;
            /**
                * <p>The key-value pairs that describe required claims in the identity token. If set, each
                *             claim is verified to be present in the token with a matching value.</p>
                */
            requiredClaims?: Record<string, string>;
            /**
                * <p>The metadata to apply to the provider configuration to assist with categorization and
                *             organization. Each tag consists of a key and an optional value. You define both.</p>
                */
            tags?: Record<string, string>;
            /**
                * <p>The status of the OIDC identity provider.</p>
                */
            status?: ConfigStatus | string;
    }
    export namespace OidcIdentityProviderConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OidcIdentityProviderConfig) => any;
    }
    /**
        * <p>The full description of your identity configuration.</p>
        */
    export interface IdentityProviderConfigResponse {
            /**
                * <p>An object that represents an OpenID Connect (OIDC) identity provider
                *             configuration.</p>
                */
            oidc?: OidcIdentityProviderConfig;
    }
    export namespace IdentityProviderConfigResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: IdentityProviderConfigResponse) => any;
    }
    export interface DescribeIdentityProviderConfigResponse {
            /**
                * <p>The object that represents an OpenID Connect (OIDC) identity provider
                *             configuration.</p>
                */
            identityProviderConfig?: IdentityProviderConfigResponse;
    }
    export namespace DescribeIdentityProviderConfigResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeIdentityProviderConfigResponse) => any;
    }
    export interface DescribeNodegroupRequest {
            /**
                * <p>The name of the Amazon EKS cluster associated with the node group.</p>
                */
            clusterName: string | undefined;
            /**
                * <p>The name of the node group to describe.</p>
                */
            nodegroupName: string | undefined;
    }
    export namespace DescribeNodegroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeNodegroupRequest) => any;
    }
    export interface DescribeNodegroupResponse {
            /**
                * <p>The full description of your node group.</p>
                */
            nodegroup?: Nodegroup;
    }
    export namespace DescribeNodegroupResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeNodegroupResponse) => any;
    }
    export interface DescribeUpdateRequest {
            /**
                * <p>The name of the Amazon EKS cluster associated with the update.</p>
                */
            name: string | undefined;
            /**
                * <p>The ID of the update to describe.</p>
                */
            updateId: string | undefined;
            /**
                * <p>The name of the Amazon EKS node group associated with the update. This
                *             parameter is required if the update is a node group update.</p>
                */
            nodegroupName?: string;
            /**
                * <p>The name of the add-on. The name must match one of the names returned by <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_ListAddons.html">
                *                <code>ListAddons</code>
                *             </a>. This parameter is required if the update is an add-on update.</p>
                */
            addonName?: string;
    }
    export namespace DescribeUpdateRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeUpdateRequest) => any;
    }
    export interface DescribeUpdateResponse {
            /**
                * <p>The full description of the specified update.</p>
                */
            update?: Update;
    }
    export namespace DescribeUpdateResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeUpdateResponse) => any;
    }
    export interface DisassociateIdentityProviderConfigRequest {
            /**
                * <p>The name of the cluster to disassociate an identity provider from.</p>
                */
            clusterName: string | undefined;
            /**
                * <p>An object that represents an identity provider configuration.</p>
                */
            identityProviderConfig: IdentityProviderConfig | undefined;
            /**
                * <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the
                *             request.</p>
                */
            clientRequestToken?: string;
    }
    export namespace DisassociateIdentityProviderConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DisassociateIdentityProviderConfigRequest) => any;
    }
    export interface DisassociateIdentityProviderConfigResponse {
            /**
                * <p>An object representing an asynchronous update.</p>
                */
            update?: Update;
    }
    export namespace DisassociateIdentityProviderConfigResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DisassociateIdentityProviderConfigResponse) => any;
    }
    export interface ListAddonsRequest {
            /**
                * <p>The name of the cluster.</p>
                */
            clusterName: string | undefined;
            /**
                * <p>The maximum number of add-on results returned by <code>ListAddonsRequest</code> in
                *             paginated output. When you use this parameter, <code>ListAddonsRequest</code> returns
                *             only <code>maxResults</code> results in a single page along with a
                *                 <code>nextToken</code> response element. You can see the remaining results of the
                *             initial request by sending another <code>ListAddonsRequest</code> request with the
                *             returned <code>nextToken</code> value. This value can be between 1 and
                *             100. If you don't use this parameter, <code>ListAddonsRequest</code>
                *             returns up to 100 results and a <code>nextToken</code> value, if
                *             applicable.</p>
                */
            maxResults?: number;
            /**
                * <p>The <code>nextToken</code> value returned from a previous paginated
                *                 <code>ListAddonsRequest</code> where <code>maxResults</code> was used and the
                *             results exceeded the value of that parameter. Pagination continues from the end of the
                *             previous results that returned the <code>nextToken</code> value.</p>
                *         <note>
                *             <p>This token should be treated as an opaque identifier that is used only to
                *                 retrieve the next items in a list and not for other programmatic purposes.</p>
                *         </note>
                */
            nextToken?: string;
    }
    export namespace ListAddonsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListAddonsRequest) => any;
    }
    export interface ListAddonsResponse {
            /**
                * <p>A list of available add-ons.</p>
                */
            addons?: string[];
            /**
                * <p>The <code>nextToken</code> value returned from a previous paginated
                *                 <code>ListAddonsResponse</code> where <code>maxResults</code> was used and the
                *             results exceeded the value of that parameter. Pagination continues from the end of the
                *             previous results that returned the <code>nextToken</code> value.</p>
                *         <note>
                *             <p>This token should be treated as an opaque identifier that is used only to
                *                 retrieve the next items in a list and not for other programmatic purposes.</p>
                *         </note>
                */
            nextToken?: string;
    }
    export namespace ListAddonsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListAddonsResponse) => any;
    }
    export interface ListClustersRequest {
            /**
                * <p>The maximum number of cluster results returned by <code>ListClusters</code> in
                *             paginated output. When you use this parameter, <code>ListClusters</code> returns only
                *                 <code>maxResults</code> results in a single page along with a <code>nextToken</code>
                *             response element. You can see the remaining results of the initial request by sending
                *             another <code>ListClusters</code> request with the returned <code>nextToken</code>
                *             value. This value can be between 1 and 100. If you don't
                *             use this parameter, <code>ListClusters</code> returns up to 100
                *             results and a <code>nextToken</code> value if applicable.</p>
                */
            maxResults?: number;
            /**
                * <p>The <code>nextToken</code> value returned from a previous paginated
                *                 <code>ListClusters</code> request where <code>maxResults</code> was used and the
                *             results exceeded the value of that parameter. Pagination continues from the end of the
                *             previous results that returned the <code>nextToken</code> value.</p>
                *         <note>
                *             <p>This token should be treated as an opaque identifier that is used only to
                *                 retrieve the next items in a list and not for other programmatic purposes.</p>
                *         </note>
                */
            nextToken?: string;
            /**
                * <p>Indicates whether external clusters are included in the returned list. Use '<code>all</code>' to return connected clusters, or blank to return only Amazon EKS clusters. '<code>all</code>' must be in lowercase otherwise an error occurs.</p>
                */
            include?: string[];
    }
    export namespace ListClustersRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListClustersRequest) => any;
    }
    export interface ListClustersResponse {
            /**
                * <p>A list of all of the clusters for your account in the specified Region.</p>
                */
            clusters?: string[];
            /**
                * <p>The <code>nextToken</code> value to include in a future <code>ListClusters</code>
                *             request. When the results of a <code>ListClusters</code> request exceed
                *                 <code>maxResults</code>, you can use this value to retrieve the next page of
                *             results. This value is <code>null</code> when there are no more results to
                *             return.</p>
                */
            nextToken?: string;
    }
    export namespace ListClustersResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListClustersResponse) => any;
    }
    export interface ListFargateProfilesRequest {
            /**
                * <p>The name of the Amazon EKS cluster that you would like to list Fargate profiles in.</p>
                */
            clusterName: string | undefined;
            /**
                * <p>The maximum number of Fargate profile results returned by
                *                 <code>ListFargateProfiles</code> in paginated output. When you use this parameter,
                *                 <code>ListFargateProfiles</code> returns only <code>maxResults</code> results in a
                *             single page along with a <code>nextToken</code> response element. You can see the
                *             remaining results of the initial request by sending another
                *                 <code>ListFargateProfiles</code> request with the returned <code>nextToken</code>
                *             value. This value can be between 1 and 100. If you don't
                *             use this parameter, <code>ListFargateProfiles</code> returns up to 100
                *             results and a <code>nextToken</code> value if applicable.</p>
                */
            maxResults?: number;
            /**
                * <p>The <code>nextToken</code> value returned from a previous paginated
                *                 <code>ListFargateProfiles</code> request where <code>maxResults</code> was used and
                *             the results exceeded the value of that parameter. Pagination continues from the end of
                *             the previous results that returned the <code>nextToken</code> value.</p>
                */
            nextToken?: string;
    }
    export namespace ListFargateProfilesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListFargateProfilesRequest) => any;
    }
    export interface ListFargateProfilesResponse {
            /**
                * <p>A list of all of the Fargate profiles associated with the specified
                *             cluster.</p>
                */
            fargateProfileNames?: string[];
            /**
                * <p>The <code>nextToken</code> value to include in a future
                *                 <code>ListFargateProfiles</code> request. When the results of a
                *                 <code>ListFargateProfiles</code> request exceed <code>maxResults</code>, you can use
                *             this value to retrieve the next page of results. This value is <code>null</code> when
                *             there are no more results to return.</p>
                */
            nextToken?: string;
    }
    export namespace ListFargateProfilesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListFargateProfilesResponse) => any;
    }
    export interface ListIdentityProviderConfigsRequest {
            /**
                * <p>The cluster name that you want to list identity provider configurations for.</p>
                */
            clusterName: string | undefined;
            /**
                * <p>The maximum number of identity provider configurations returned by
                *                 <code>ListIdentityProviderConfigs</code> in paginated output. When you use this
                *             parameter, <code>ListIdentityProviderConfigs</code> returns only <code>maxResults</code>
                *             results in a single page along with a <code>nextToken</code> response element. You can
                *             see the remaining results of the initial request by sending another
                *                 <code>ListIdentityProviderConfigs</code> request with the returned
                *                 <code>nextToken</code> value. This value can be between 1 and
                *             100. If you don't use this parameter,
                *                 <code>ListIdentityProviderConfigs</code> returns up to 100 results
                *             and a <code>nextToken</code> value, if applicable.</p>
                */
            maxResults?: number;
            /**
                * <p>The <code>nextToken</code> value returned from a previous paginated
                *                 <code>IdentityProviderConfigsRequest</code> where <code>maxResults</code> was used
                *             and the results exceeded the value of that parameter. Pagination continues from the end
                *             of the previous results that returned the <code>nextToken</code> value.</p>
                */
            nextToken?: string;
    }
    export namespace ListIdentityProviderConfigsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListIdentityProviderConfigsRequest) => any;
    }
    export interface ListIdentityProviderConfigsResponse {
            /**
                * <p>The identity provider configurations for the cluster.</p>
                */
            identityProviderConfigs?: IdentityProviderConfig[];
            /**
                * <p>The <code>nextToken</code> value returned from a previous paginated
                *                 <code>ListIdentityProviderConfigsResponse</code> where <code>maxResults</code> was
                *             used and the results exceeded the value of that parameter. Pagination continues from the
                *             end of the previous results that returned the <code>nextToken</code> value.</p>
                */
            nextToken?: string;
    }
    export namespace ListIdentityProviderConfigsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListIdentityProviderConfigsResponse) => any;
    }
    export interface ListNodegroupsRequest {
            /**
                * <p>The name of the Amazon EKS cluster that you would like to list node groups
                *             in.</p>
                */
            clusterName: string | undefined;
            /**
                * <p>The maximum number of node group results returned by <code>ListNodegroups</code> in
                *             paginated output. When you use this parameter, <code>ListNodegroups</code> returns only
                *                 <code>maxResults</code> results in a single page along with a <code>nextToken</code>
                *             response element. You can see the remaining results of the initial request by sending
                *             another <code>ListNodegroups</code> request with the returned <code>nextToken</code>
                *             value. This value can be between 1 and 100. If you don't
                *             use this parameter, <code>ListNodegroups</code> returns up to 100
                *             results and a <code>nextToken</code> value if applicable.</p>
                */
            maxResults?: number;
            /**
                * <p>The <code>nextToken</code> value returned from a previous paginated
                *                 <code>ListNodegroups</code> request where <code>maxResults</code> was used and the
                *             results exceeded the value of that parameter. Pagination continues from the end of the
                *             previous results that returned the <code>nextToken</code> value.</p>
                */
            nextToken?: string;
    }
    export namespace ListNodegroupsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListNodegroupsRequest) => any;
    }
    export interface ListNodegroupsResponse {
            /**
                * <p>A list of all of the node groups associated with the specified cluster.</p>
                */
            nodegroups?: string[];
            /**
                * <p>The <code>nextToken</code> value to include in a future <code>ListNodegroups</code>
                *             request. When the results of a <code>ListNodegroups</code> request exceed
                *                 <code>maxResults</code>, you can use this value to retrieve the next page of
                *             results. This value is <code>null</code> when there are no more results to
                *             return.</p>
                */
            nextToken?: string;
    }
    export namespace ListNodegroupsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListNodegroupsResponse) => any;
    }
    /**
        * <p>This exception is thrown if the request contains a semantic error. The precise meaning
        *             will depend on the API, and will be documented in the error message.</p>
        */
    export class BadRequestException extends __BaseException {
            readonly name: "BadRequestException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<BadRequestException, __BaseException>);
    }
    export interface ListTagsForResourceRequest {
            /**
                * <p>The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the
                *             supported resources are Amazon EKS clusters and managed node groups.</p>
                */
            resourceArn: string | undefined;
    }
    export namespace ListTagsForResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceRequest) => any;
    }
    export interface ListTagsForResourceResponse {
            /**
                * <p>The tags for the resource.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace ListTagsForResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceResponse) => any;
    }
    /**
        * <p>A service resource associated with the request could not be found. Clients should not
        *             retry such requests.</p>
        */
    export class NotFoundException extends __BaseException {
            readonly name: "NotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NotFoundException, __BaseException>);
    }
    export interface ListUpdatesRequest {
            /**
                * <p>The name of the Amazon EKS cluster to list updates for.</p>
                */
            name: string | undefined;
            /**
                * <p>The name of the Amazon EKS managed node group to list updates for.</p>
                */
            nodegroupName?: string;
            /**
                * <p>The names of the installed add-ons that have available updates.</p>
                */
            addonName?: string;
            /**
                * <p>The <code>nextToken</code> value returned from a previous paginated
                *                 <code>ListUpdates</code> request where <code>maxResults</code> was used and the
                *             results exceeded the value of that parameter. Pagination continues from the end of the
                *             previous results that returned the <code>nextToken</code> value.</p>
                */
            nextToken?: string;
            /**
                * <p>The maximum number of update results returned by <code>ListUpdates</code> in paginated
                *             output. When you use this parameter, <code>ListUpdates</code> returns only
                *                 <code>maxResults</code> results in a single page along with a <code>nextToken</code>
                *             response element. You can see the remaining results of the initial request by sending
                *             another <code>ListUpdates</code> request with the returned <code>nextToken</code> value.
                *             This value can be between 1 and 100. If you don't use this
                *             parameter, <code>ListUpdates</code> returns up to 100 results and a
                *                 <code>nextToken</code> value if applicable.</p>
                */
            maxResults?: number;
    }
    export namespace ListUpdatesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListUpdatesRequest) => any;
    }
    export interface ListUpdatesResponse {
            /**
                * <p>A list of all the updates for the specified cluster and Region.</p>
                */
            updateIds?: string[];
            /**
                * <p>The <code>nextToken</code> value to include in a future <code>ListUpdates</code>
                *             request. When the results of a <code>ListUpdates</code> request exceed
                *                 <code>maxResults</code>, you can use this value to retrieve the next page of
                *             results. This value is <code>null</code> when there are no more results to
                *             return.</p>
                */
            nextToken?: string;
    }
    export namespace ListUpdatesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListUpdatesResponse) => any;
    }
    export enum ConnectorConfigProvider {
            AKS = "AKS",
            ANTHOS = "ANTHOS",
            EC2 = "EC2",
            EKS_ANYWHERE = "EKS_ANYWHERE",
            GKE = "GKE",
            OPENSHIFT = "OPENSHIFT",
            OTHER = "OTHER",
            RANCHER = "RANCHER",
            TANZU = "TANZU"
    }
    /**
        * <p>The configuration sent to a cluster for configuration.</p>
        */
    export interface ConnectorConfigRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the role that is authorized to request the connector
                *             configuration.</p>
                */
            roleArn: string | undefined;
            /**
                * <p>The cloud provider for the target cluster to connect.</p>
                */
            provider: ConnectorConfigProvider | string | undefined;
    }
    export namespace ConnectorConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ConnectorConfigRequest) => any;
    }
    export interface RegisterClusterRequest {
            /**
                * <p>Define a unique name for this cluster for your Region.</p>
                */
            name: string | undefined;
            /**
                * <p>The configuration settings required to connect the Kubernetes cluster to the Amazon EKS control plane.</p>
                */
            connectorConfig: ConnectorConfigRequest | undefined;
            /**
                * <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
                *             request.</p>
                */
            clientRequestToken?: string;
            /**
                * <p>The metadata that you apply to the cluster to assist with categorization and
                *             organization. Each tag consists of a key and an optional value, both of which you
                *             define. Cluster tags do not propagate to any other resources associated with the
                *             cluster.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace RegisterClusterRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RegisterClusterRequest) => any;
    }
    export interface RegisterClusterResponse {
            /**
                * <p>An object representing an Amazon EKS cluster.</p>
                */
            cluster?: Cluster;
    }
    export namespace RegisterClusterResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RegisterClusterResponse) => any;
    }
    /**
        * <p>Required resources (such as service-linked roles) were created and are still propagating. Retry later.</p>
        */
    export class ResourcePropagationDelayException extends __BaseException {
            readonly name: "ResourcePropagationDelayException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourcePropagationDelayException, __BaseException>);
    }
    export interface TagResourceRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the resource to which to add tags. Currently, the supported resources
                *             are Amazon EKS clusters and managed node groups.</p>
                */
            resourceArn: string | undefined;
            /**
                * <p>The tags to add to the resource. A tag is an array of key-value pairs.</p>
                */
            tags: Record<string, string> | undefined;
    }
    export namespace TagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceRequest) => any;
    }
    export interface TagResourceResponse {
    }
    export namespace TagResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceResponse) => any;
    }
    export interface UntagResourceRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the resource from which to delete tags. Currently, the supported
                *             resources are Amazon EKS clusters and managed node groups.</p>
                */
            resourceArn: string | undefined;
            /**
                * <p>The keys of the tags to be removed.</p>
                */
            tagKeys: string[] | undefined;
    }
    export namespace UntagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceRequest) => any;
    }
    export interface UntagResourceResponse {
    }
    export namespace UntagResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceResponse) => any;
    }
    export interface UpdateAddonRequest {
            /**
                * <p>The name of the cluster.</p>
                */
            clusterName: string | undefined;
            /**
                * <p>The name of the add-on. The name must match one of the names returned by <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_ListAddons.html">
                *                <code>ListAddons</code>
                *             </a>.</p>
                */
            addonName: string | undefined;
            /**
                * <p>The version of the add-on. The version must match one of the versions returned by <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeAddonVersions.html">
                *                <code>DescribeAddonVersions</code>
                *             </a>.</p>
                */
            addonVersion?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of an existing IAM role to bind to the add-on's service account. The role must be assigned the IAM permissions required by the add-on. If you don't specify an existing IAM role, then the add-on uses the
                *      permissions assigned to the node IAM role. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html">Amazon EKS node IAM role</a> in the <i>Amazon EKS User Guide</i>.</p>
                *         <note>
                *             <p>To specify an existing IAM role, you must have an IAM OpenID Connect (OIDC) provider created for
                *                 your cluster. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html">Enabling
                *                     IAM roles for service accounts on your cluster</a> in the
                *                 <i>Amazon EKS User Guide</i>.</p>
                *          </note>
                */
            serviceAccountRoleArn?: string;
            /**
                * <p>How to resolve parameter value conflicts when applying the new version of the add-on
                *             to the cluster.</p>
                */
            resolveConflicts?: ResolveConflicts | string;
            /**
                * <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
                *             request.</p>
                */
            clientRequestToken?: string;
    }
    export namespace UpdateAddonRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateAddonRequest) => any;
    }
    export interface UpdateAddonResponse {
            /**
                * <p>An object representing an asynchronous update.</p>
                */
            update?: Update;
    }
    export namespace UpdateAddonResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateAddonResponse) => any;
    }
    export interface UpdateClusterConfigRequest {
            /**
                * <p>The name of the Amazon EKS cluster to update.</p>
                */
            name: string | undefined;
            /**
                * <p>An object representing the VPC configuration to use for an Amazon EKS
                *             cluster.</p>
                */
            resourcesVpcConfig?: VpcConfigRequest;
            /**
                * <p>Enable or disable exporting the Kubernetes control plane logs for your cluster to
                *                 CloudWatch Logs. By default, cluster control plane logs aren't exported to
                *                 CloudWatch Logs. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/control-plane-logs.html">Amazon EKS cluster control plane logs</a> in the
                *                 <i>
                *                <i>Amazon EKS User Guide</i>
                *             </i>.</p>
                *         <note>
                *             <p>CloudWatch Logs ingestion, archive storage, and data scanning rates apply to
                *                 exported control plane logs. For more information, see <a href="http://aws.amazon.com/cloudwatch/pricing/">CloudWatch
                *                 Pricing</a>.</p>
                *         </note>
                */
            logging?: Logging;
            /**
                * <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
                *             request.</p>
                */
            clientRequestToken?: string;
    }
    export namespace UpdateClusterConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateClusterConfigRequest) => any;
    }
    export interface UpdateClusterConfigResponse {
            /**
                * <p>An object representing an asynchronous update.</p>
                */
            update?: Update;
    }
    export namespace UpdateClusterConfigResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateClusterConfigResponse) => any;
    }
    export interface UpdateClusterVersionRequest {
            /**
                * <p>The name of the Amazon EKS cluster to update.</p>
                */
            name: string | undefined;
            /**
                * <p>The desired Kubernetes version following a successful update.</p>
                */
            version: string | undefined;
            /**
                * <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
                *             request.</p>
                */
            clientRequestToken?: string;
    }
    export namespace UpdateClusterVersionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateClusterVersionRequest) => any;
    }
    export interface UpdateClusterVersionResponse {
            /**
                * <p>The full description of the specified update</p>
                */
            update?: Update;
    }
    export namespace UpdateClusterVersionResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateClusterVersionResponse) => any;
    }
    /**
        * <p>An object representing a Kubernetes label change for a managed node group.</p>
        */
    export interface UpdateLabelsPayload {
            /**
                * <p>Kubernetes labels to be added or updated.</p>
                */
            addOrUpdateLabels?: Record<string, string>;
            /**
                * <p>Kubernetes labels to be removed.</p>
                */
            removeLabels?: string[];
    }
    export namespace UpdateLabelsPayload {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateLabelsPayload) => any;
    }
    /**
        * <p>An object representing the details of an update to a taints payload. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html">Node taints on managed node groups</a>.</p>
        */
    export interface UpdateTaintsPayload {
            /**
                * <p>Kubernetes taints to be added or updated.</p>
                */
            addOrUpdateTaints?: Taint[];
            /**
                * <p>Kubernetes taints to be removed.</p>
                */
            removeTaints?: Taint[];
    }
    export namespace UpdateTaintsPayload {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateTaintsPayload) => any;
    }
    export interface UpdateNodegroupConfigRequest {
            /**
                * <p>The name of the Amazon EKS cluster that the managed node group resides
                *             in.</p>
                */
            clusterName: string | undefined;
            /**
                * <p>The name of the managed node group to update.</p>
                */
            nodegroupName: string | undefined;
            /**
                * <p>The Kubernetes labels to be applied to the nodes in the node group after the
                *             update.</p>
                */
            labels?: UpdateLabelsPayload;
            /**
                * <p>The Kubernetes taints to be applied to the nodes in the node group after the
                *             update. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html">Node taints on managed node groups</a>.</p>
                */
            taints?: UpdateTaintsPayload;
            /**
                * <p>The scaling configuration details for the Auto Scaling group after the update.</p>
                */
            scalingConfig?: NodegroupScalingConfig;
            /**
                * <p>The node group update configuration.</p>
                */
            updateConfig?: NodegroupUpdateConfig;
            /**
                * <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
                *             request.</p>
                */
            clientRequestToken?: string;
    }
    export namespace UpdateNodegroupConfigRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateNodegroupConfigRequest) => any;
    }
    export interface UpdateNodegroupConfigResponse {
            /**
                * <p>An object representing an asynchronous update.</p>
                */
            update?: Update;
    }
    export namespace UpdateNodegroupConfigResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateNodegroupConfigResponse) => any;
    }
    export interface UpdateNodegroupVersionRequest {
            /**
                * <p>The name of the Amazon EKS cluster that is associated with the managed node
                *             group to update.</p>
                */
            clusterName: string | undefined;
            /**
                * <p>The name of the managed node group to update.</p>
                */
            nodegroupName: string | undefined;
            /**
                * <p>The Kubernetes version to update to. If no version is specified, then the Kubernetes
                *             version of the node group does not change. You can specify the Kubernetes version of the
                *             cluster to update the node group to the latest AMI version of the cluster's Kubernetes
                *             version. If you specify <code>launchTemplate</code>, and your launch template uses a custom AMI, then don't specify
                *                 <code>version</code>, or the node group  update will fail.
                *             For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the <i>Amazon EKS User Guide</i>.</p>
                */
            version?: string;
            /**
                * <p>The AMI version of the Amazon EKS optimized AMI to use for the update. By
                *             default, the latest available AMI version for the node group's Kubernetes version is
                *             used. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html">Amazon EKS optimized Amazon Linux 2 AMI versions </a> in the <i>Amazon EKS User Guide</i>.
                *             If you specify <code>launchTemplate</code>, and your launch template uses a custom AMI, then don't specify  <code>releaseVersion</code>,
                *             or the node group  update will fail. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the <i>Amazon EKS User Guide</i>.</p>
                */
            releaseVersion?: string;
            /**
                * <p>An object representing a node group's launch template specification. You can only
                *             update a node group using a launch template if the node group was originally deployed
                *             with a launch template.</p>
                */
            launchTemplate?: LaunchTemplateSpecification;
            /**
                * <p>Force the update if the existing node group's pods are unable to be drained due to a
                *             pod disruption budget issue. If an update fails because pods could not be drained, you
                *             can force the update after it fails to terminate the old node whether or not any pods
                *             are running on the node.</p>
                */
            force?: boolean;
            /**
                * <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
                *             request.</p>
                */
            clientRequestToken?: string;
    }
    export namespace UpdateNodegroupVersionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateNodegroupVersionRequest) => any;
    }
    export interface UpdateNodegroupVersionResponse {
            /**
                * <p>An object representing an asynchronous update.</p>
                */
            update?: Update;
    }
    export namespace UpdateNodegroupVersionResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateNodegroupVersionResponse) => any;
    }
}

declare module '@aws-sdk/client-eks/node_modules/@aws-sdk/client-eks/dist-types/models/EKSServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from EKS service.
        */
    export class EKSServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

