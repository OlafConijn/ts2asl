// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/smithy-client
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http

declare module '@aws-sdk/client-memorydb' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { BatchUpdateClusterCommandInput, BatchUpdateClusterCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/BatchUpdateClusterCommand";
    import { CopySnapshotCommandInput, CopySnapshotCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/CopySnapshotCommand";
    import { CreateACLCommandInput, CreateACLCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/CreateACLCommand";
    import { CreateClusterCommandInput, CreateClusterCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/CreateClusterCommand";
    import { CreateParameterGroupCommandInput, CreateParameterGroupCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/CreateParameterGroupCommand";
    import { CreateSnapshotCommandInput, CreateSnapshotCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/CreateSnapshotCommand";
    import { CreateSubnetGroupCommandInput, CreateSubnetGroupCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/CreateSubnetGroupCommand";
    import { CreateUserCommandInput, CreateUserCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/CreateUserCommand";
    import { DeleteACLCommandInput, DeleteACLCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DeleteACLCommand";
    import { DeleteClusterCommandInput, DeleteClusterCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DeleteClusterCommand";
    import { DeleteParameterGroupCommandInput, DeleteParameterGroupCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DeleteParameterGroupCommand";
    import { DeleteSnapshotCommandInput, DeleteSnapshotCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DeleteSnapshotCommand";
    import { DeleteSubnetGroupCommandInput, DeleteSubnetGroupCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DeleteSubnetGroupCommand";
    import { DeleteUserCommandInput, DeleteUserCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DeleteUserCommand";
    import { DescribeACLsCommandInput, DescribeACLsCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeACLsCommand";
    import { DescribeClustersCommandInput, DescribeClustersCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeClustersCommand";
    import { DescribeEngineVersionsCommandInput, DescribeEngineVersionsCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeEngineVersionsCommand";
    import { DescribeEventsCommandInput, DescribeEventsCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeEventsCommand";
    import { DescribeParameterGroupsCommandInput, DescribeParameterGroupsCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeParameterGroupsCommand";
    import { DescribeParametersCommandInput, DescribeParametersCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeParametersCommand";
    import { DescribeServiceUpdatesCommandInput, DescribeServiceUpdatesCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeServiceUpdatesCommand";
    import { DescribeSnapshotsCommandInput, DescribeSnapshotsCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeSnapshotsCommand";
    import { DescribeSubnetGroupsCommandInput, DescribeSubnetGroupsCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeSubnetGroupsCommand";
    import { DescribeUsersCommandInput, DescribeUsersCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeUsersCommand";
    import { FailoverShardCommandInput, FailoverShardCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/FailoverShardCommand";
    import { ListAllowedNodeTypeUpdatesCommandInput, ListAllowedNodeTypeUpdatesCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/ListAllowedNodeTypeUpdatesCommand";
    import { ListTagsCommandInput, ListTagsCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/ListTagsCommand";
    import { ResetParameterGroupCommandInput, ResetParameterGroupCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/ResetParameterGroupCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/UntagResourceCommand";
    import { UpdateACLCommandInput, UpdateACLCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/UpdateACLCommand";
    import { UpdateClusterCommandInput, UpdateClusterCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/UpdateClusterCommand";
    import { UpdateParameterGroupCommandInput, UpdateParameterGroupCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/UpdateParameterGroupCommand";
    import { UpdateSubnetGroupCommandInput, UpdateSubnetGroupCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/UpdateSubnetGroupCommand";
    import { UpdateUserCommandInput, UpdateUserCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/UpdateUserCommand";
    import { MemoryDBClient } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    /**
        * <p>MemoryDB for Redis is a fully managed, Redis-compatible, in-memory database that delivers ultra-fast performance and Multi-AZ durability for modern applications built using microservices architectures.
        *
        *        MemoryDB stores the entire database in-memory, enabling low latency and high throughput data access. It is compatible with Redis, a popular open source data store, enabling you to leverage Redisâ€™ flexible and friendly data structures, APIs, and commands.</p>
        */
    export class MemoryDB extends MemoryDBClient {
            /**
                * <p>Apply the service update to a list of clusters supplied. For more information on service updates and applying them, see <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/managing-updates.html#applying-updates">Applying the service updates</a>.</p>
                */
            batchUpdateCluster(args: BatchUpdateClusterCommandInput, options?: __HttpHandlerOptions): Promise<BatchUpdateClusterCommandOutput>;
            batchUpdateCluster(args: BatchUpdateClusterCommandInput, cb: (err: any, data?: BatchUpdateClusterCommandOutput) => void): void;
            batchUpdateCluster(args: BatchUpdateClusterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchUpdateClusterCommandOutput) => void): void;
            /**
                * <p>Makes a copy of an existing snapshot.</p>
                */
            copySnapshot(args: CopySnapshotCommandInput, options?: __HttpHandlerOptions): Promise<CopySnapshotCommandOutput>;
            copySnapshot(args: CopySnapshotCommandInput, cb: (err: any, data?: CopySnapshotCommandOutput) => void): void;
            copySnapshot(args: CopySnapshotCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CopySnapshotCommandOutput) => void): void;
            /**
                * <p>Creates an Access Control List. For more information, see <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/clusters.acls.html">Authenticating users with Access Contol Lists (ACLs)</a>.</p>
                */
            createACL(args: CreateACLCommandInput, options?: __HttpHandlerOptions): Promise<CreateACLCommandOutput>;
            createACL(args: CreateACLCommandInput, cb: (err: any, data?: CreateACLCommandOutput) => void): void;
            createACL(args: CreateACLCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateACLCommandOutput) => void): void;
            /**
                * <p>Creates a cluster. All nodes in the cluster run the same protocol-compliant engine software.</p>
                */
            createCluster(args: CreateClusterCommandInput, options?: __HttpHandlerOptions): Promise<CreateClusterCommandOutput>;
            createCluster(args: CreateClusterCommandInput, cb: (err: any, data?: CreateClusterCommandOutput) => void): void;
            createCluster(args: CreateClusterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateClusterCommandOutput) => void): void;
            /**
                * <p>Creates a new MemoryDB parameter group. A parameter group is a collection of parameters and their values that are applied to all of the nodes in any cluster. For
                *          more information, see <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/parametergroups.html">Configuring engine parameters using parameter groups</a>.
                *
                *          </p>
                */
            createParameterGroup(args: CreateParameterGroupCommandInput, options?: __HttpHandlerOptions): Promise<CreateParameterGroupCommandOutput>;
            createParameterGroup(args: CreateParameterGroupCommandInput, cb: (err: any, data?: CreateParameterGroupCommandOutput) => void): void;
            createParameterGroup(args: CreateParameterGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateParameterGroupCommandOutput) => void): void;
            /**
                * <p>Creates a copy of an entire cluster at a specific moment in time.</p>
                */
            createSnapshot(args: CreateSnapshotCommandInput, options?: __HttpHandlerOptions): Promise<CreateSnapshotCommandOutput>;
            createSnapshot(args: CreateSnapshotCommandInput, cb: (err: any, data?: CreateSnapshotCommandOutput) => void): void;
            createSnapshot(args: CreateSnapshotCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateSnapshotCommandOutput) => void): void;
            /**
                * <p>Creates a subnet group. A subnet group is a collection of subnets (typically private) that you can designate for your clusters running in an Amazon Virtual Private Cloud (VPC) environment.
                *
                *          When you create a cluster in an Amazon VPC, you must specify a subnet group. MemoryDB uses that subnet group to choose a subnet and IP addresses within that subnet to associate with your nodes.
                *          For more information, see <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/subnetgroups.html">Subnets and subnet groups</a>.</p>
                */
            createSubnetGroup(args: CreateSubnetGroupCommandInput, options?: __HttpHandlerOptions): Promise<CreateSubnetGroupCommandOutput>;
            createSubnetGroup(args: CreateSubnetGroupCommandInput, cb: (err: any, data?: CreateSubnetGroupCommandOutput) => void): void;
            createSubnetGroup(args: CreateSubnetGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateSubnetGroupCommandOutput) => void): void;
            /**
                * <p>Creates a MemoryDB user. For more information, see <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/clusters.acls.html">Authenticating users with Access Contol Lists (ACLs)</a>.</p>
                */
            createUser(args: CreateUserCommandInput, options?: __HttpHandlerOptions): Promise<CreateUserCommandOutput>;
            createUser(args: CreateUserCommandInput, cb: (err: any, data?: CreateUserCommandOutput) => void): void;
            createUser(args: CreateUserCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateUserCommandOutput) => void): void;
            /**
                * <p>Deletes an Access Control List. The ACL must first be disassociated from the cluster before it can be deleted. For more information, see <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/clusters.acls.html">Authenticating users with Access Contol Lists (ACLs)</a>.</p>
                */
            deleteACL(args: DeleteACLCommandInput, options?: __HttpHandlerOptions): Promise<DeleteACLCommandOutput>;
            deleteACL(args: DeleteACLCommandInput, cb: (err: any, data?: DeleteACLCommandOutput) => void): void;
            deleteACL(args: DeleteACLCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteACLCommandOutput) => void): void;
            /**
                * <p>Deletes a cluster. It also deletes all associated nodes and node endpoints</p>
                */
            deleteCluster(args: DeleteClusterCommandInput, options?: __HttpHandlerOptions): Promise<DeleteClusterCommandOutput>;
            deleteCluster(args: DeleteClusterCommandInput, cb: (err: any, data?: DeleteClusterCommandOutput) => void): void;
            deleteCluster(args: DeleteClusterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteClusterCommandOutput) => void): void;
            /**
                * <p>Deletes the specified parameter group. You cannot delete a parameter group if it is associated with any clusters.
                *          You cannot delete the default parameter groups in your account.</p>
                */
            deleteParameterGroup(args: DeleteParameterGroupCommandInput, options?: __HttpHandlerOptions): Promise<DeleteParameterGroupCommandOutput>;
            deleteParameterGroup(args: DeleteParameterGroupCommandInput, cb: (err: any, data?: DeleteParameterGroupCommandOutput) => void): void;
            deleteParameterGroup(args: DeleteParameterGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteParameterGroupCommandOutput) => void): void;
            /**
                * <p>Deletes an existing snapshot. When you receive a successful response from this operation, MemoryDB immediately begins deleting the snapshot; you cannot cancel or revert this operation.</p>
                */
            deleteSnapshot(args: DeleteSnapshotCommandInput, options?: __HttpHandlerOptions): Promise<DeleteSnapshotCommandOutput>;
            deleteSnapshot(args: DeleteSnapshotCommandInput, cb: (err: any, data?: DeleteSnapshotCommandOutput) => void): void;
            deleteSnapshot(args: DeleteSnapshotCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteSnapshotCommandOutput) => void): void;
            /**
                * <p>Deletes a subnet group. You cannot delete a default subnet group or one that is associated with any clusters.</p>
                */
            deleteSubnetGroup(args: DeleteSubnetGroupCommandInput, options?: __HttpHandlerOptions): Promise<DeleteSubnetGroupCommandOutput>;
            deleteSubnetGroup(args: DeleteSubnetGroupCommandInput, cb: (err: any, data?: DeleteSubnetGroupCommandOutput) => void): void;
            deleteSubnetGroup(args: DeleteSubnetGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteSubnetGroupCommandOutput) => void): void;
            /**
                * <p>Deletes a user. The user will be removed from all ACLs and in turn removed from all clusters.</p>
                */
            deleteUser(args: DeleteUserCommandInput, options?: __HttpHandlerOptions): Promise<DeleteUserCommandOutput>;
            deleteUser(args: DeleteUserCommandInput, cb: (err: any, data?: DeleteUserCommandOutput) => void): void;
            deleteUser(args: DeleteUserCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteUserCommandOutput) => void): void;
            /**
                * <p>Returns a list of ACLs</p>
                */
            describeACLs(args: DescribeACLsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeACLsCommandOutput>;
            describeACLs(args: DescribeACLsCommandInput, cb: (err: any, data?: DescribeACLsCommandOutput) => void): void;
            describeACLs(args: DescribeACLsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeACLsCommandOutput) => void): void;
            /**
                * <p>Returns information about all provisioned clusters if no cluster identifier is specified, or about a specific cluster if a cluster name is supplied.</p>
                */
            describeClusters(args: DescribeClustersCommandInput, options?: __HttpHandlerOptions): Promise<DescribeClustersCommandOutput>;
            describeClusters(args: DescribeClustersCommandInput, cb: (err: any, data?: DescribeClustersCommandOutput) => void): void;
            describeClusters(args: DescribeClustersCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeClustersCommandOutput) => void): void;
            /**
                * <p>Returns a list of the available Redis engine versions.</p>
                */
            describeEngineVersions(args: DescribeEngineVersionsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeEngineVersionsCommandOutput>;
            describeEngineVersions(args: DescribeEngineVersionsCommandInput, cb: (err: any, data?: DescribeEngineVersionsCommandOutput) => void): void;
            describeEngineVersions(args: DescribeEngineVersionsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeEngineVersionsCommandOutput) => void): void;
            /**
                * <p>Returns events related to clusters, security groups, and parameter groups. You can obtain events specific to a particular cluster, security group, or parameter group by providing the name as a parameter.
                *
                *          By default, only the events occurring within the last hour are returned; however, you can retrieve up to 14 days' worth of events if necessary.</p>
                */
            describeEvents(args: DescribeEventsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeEventsCommandOutput>;
            describeEvents(args: DescribeEventsCommandInput, cb: (err: any, data?: DescribeEventsCommandOutput) => void): void;
            describeEvents(args: DescribeEventsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeEventsCommandOutput) => void): void;
            /**
                * <p>Returns a list of parameter group descriptions. If a parameter group name is specified, the list contains only the descriptions for that group.</p>
                */
            describeParameterGroups(args: DescribeParameterGroupsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeParameterGroupsCommandOutput>;
            describeParameterGroups(args: DescribeParameterGroupsCommandInput, cb: (err: any, data?: DescribeParameterGroupsCommandOutput) => void): void;
            describeParameterGroups(args: DescribeParameterGroupsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeParameterGroupsCommandOutput) => void): void;
            /**
                * <p>Returns the detailed parameter list for a particular parameter group.</p>
                */
            describeParameters(args: DescribeParametersCommandInput, options?: __HttpHandlerOptions): Promise<DescribeParametersCommandOutput>;
            describeParameters(args: DescribeParametersCommandInput, cb: (err: any, data?: DescribeParametersCommandOutput) => void): void;
            describeParameters(args: DescribeParametersCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeParametersCommandOutput) => void): void;
            /**
                * <p>Returns details of the service updates</p>
                */
            describeServiceUpdates(args: DescribeServiceUpdatesCommandInput, options?: __HttpHandlerOptions): Promise<DescribeServiceUpdatesCommandOutput>;
            describeServiceUpdates(args: DescribeServiceUpdatesCommandInput, cb: (err: any, data?: DescribeServiceUpdatesCommandOutput) => void): void;
            describeServiceUpdates(args: DescribeServiceUpdatesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeServiceUpdatesCommandOutput) => void): void;
            /**
                * <p>Returns information about cluster snapshots. By default, DescribeSnapshots lists all of your snapshots; it can optionally describe a single snapshot,
                *          or just the snapshots associated with a particular cluster.</p>
                */
            describeSnapshots(args: DescribeSnapshotsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeSnapshotsCommandOutput>;
            describeSnapshots(args: DescribeSnapshotsCommandInput, cb: (err: any, data?: DescribeSnapshotsCommandOutput) => void): void;
            describeSnapshots(args: DescribeSnapshotsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeSnapshotsCommandOutput) => void): void;
            /**
                * <p>Returns a list of subnet group descriptions. If a subnet group name is specified, the list contains only the description of that group.</p>
                */
            describeSubnetGroups(args: DescribeSubnetGroupsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeSubnetGroupsCommandOutput>;
            describeSubnetGroups(args: DescribeSubnetGroupsCommandInput, cb: (err: any, data?: DescribeSubnetGroupsCommandOutput) => void): void;
            describeSubnetGroups(args: DescribeSubnetGroupsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeSubnetGroupsCommandOutput) => void): void;
            /**
                * <p>Returns a list of users.</p>
                */
            describeUsers(args: DescribeUsersCommandInput, options?: __HttpHandlerOptions): Promise<DescribeUsersCommandOutput>;
            describeUsers(args: DescribeUsersCommandInput, cb: (err: any, data?: DescribeUsersCommandOutput) => void): void;
            describeUsers(args: DescribeUsersCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeUsersCommandOutput) => void): void;
            /**
                * <p>Used to failover a shard</p>
                */
            failoverShard(args: FailoverShardCommandInput, options?: __HttpHandlerOptions): Promise<FailoverShardCommandOutput>;
            failoverShard(args: FailoverShardCommandInput, cb: (err: any, data?: FailoverShardCommandOutput) => void): void;
            failoverShard(args: FailoverShardCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: FailoverShardCommandOutput) => void): void;
            /**
                * <p>Lists all available node types that you can scale to from your cluster's current node type.
                *
                *          When you use the UpdateCluster operation to scale your cluster, the value of the NodeType parameter must be one of the node types returned by this operation.</p>
                */
            listAllowedNodeTypeUpdates(args: ListAllowedNodeTypeUpdatesCommandInput, options?: __HttpHandlerOptions): Promise<ListAllowedNodeTypeUpdatesCommandOutput>;
            listAllowedNodeTypeUpdates(args: ListAllowedNodeTypeUpdatesCommandInput, cb: (err: any, data?: ListAllowedNodeTypeUpdatesCommandOutput) => void): void;
            listAllowedNodeTypeUpdates(args: ListAllowedNodeTypeUpdatesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListAllowedNodeTypeUpdatesCommandOutput) => void): void;
            /**
                * <p>Lists all tags currently on a named resource.
                *
                *          A tag is a key-value pair where the key and value are case-sensitive. You can use tags to categorize and track your MemoryDB resources.
                *          For more information, see <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/Tagging-Resources.html">Tagging your MemoryDB resources</a>
                *          </p>
                */
            listTags(args: ListTagsCommandInput, options?: __HttpHandlerOptions): Promise<ListTagsCommandOutput>;
            listTags(args: ListTagsCommandInput, cb: (err: any, data?: ListTagsCommandOutput) => void): void;
            listTags(args: ListTagsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTagsCommandOutput) => void): void;
            /**
                * <p>Modifies the parameters of a parameter group to the engine or system default value. You can reset specific parameters by submitting a list of parameter names. To reset the entire parameter group, specify the AllParameters and ParameterGroupName parameters.</p>
                */
            resetParameterGroup(args: ResetParameterGroupCommandInput, options?: __HttpHandlerOptions): Promise<ResetParameterGroupCommandOutput>;
            resetParameterGroup(args: ResetParameterGroupCommandInput, cb: (err: any, data?: ResetParameterGroupCommandOutput) => void): void;
            resetParameterGroup(args: ResetParameterGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ResetParameterGroupCommandOutput) => void): void;
            /**
                * <p>A tag is a key-value pair where the key and value are case-sensitive. You can use tags to categorize and track all your MemoryDB resources.
                *
                *          When you add or remove tags on clusters, those actions will be replicated to all nodes in the cluster. For more information, see
                *
                *          <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/iam.resourcelevelpermissions.html">Resource-level permissions</a>.</p>
                *
                *          <p>For example, you can use cost-allocation tags to your MemoryDB resources, Amazon generates a cost allocation report as a comma-separated value
                *           (CSV) file with your usage and costs aggregated by your tags. You can apply tags that represent business categories
                *           (such as cost centers, application names, or owners) to organize your costs across multiple services.
                *
                *          For more information, see <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/tagging.html">Using Cost Allocation Tags</a>.</p>
                */
            tagResource(args: TagResourceCommandInput, options?: __HttpHandlerOptions): Promise<TagResourceCommandOutput>;
            tagResource(args: TagResourceCommandInput, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            tagResource(args: TagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            /**
                * <p>Use this operation to remove tags on a resource</p>
                */
            untagResource(args: UntagResourceCommandInput, options?: __HttpHandlerOptions): Promise<UntagResourceCommandOutput>;
            untagResource(args: UntagResourceCommandInput, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            untagResource(args: UntagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            /**
                * <p>Changes the list of users that belong to the Access Control List.</p>
                */
            updateACL(args: UpdateACLCommandInput, options?: __HttpHandlerOptions): Promise<UpdateACLCommandOutput>;
            updateACL(args: UpdateACLCommandInput, cb: (err: any, data?: UpdateACLCommandOutput) => void): void;
            updateACL(args: UpdateACLCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateACLCommandOutput) => void): void;
            /**
                * <p>Modifies the settings for a cluster. You can use this operation to change one or more cluster configuration settings by specifying the settings and the new values.</p>
                */
            updateCluster(args: UpdateClusterCommandInput, options?: __HttpHandlerOptions): Promise<UpdateClusterCommandOutput>;
            updateCluster(args: UpdateClusterCommandInput, cb: (err: any, data?: UpdateClusterCommandOutput) => void): void;
            updateCluster(args: UpdateClusterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateClusterCommandOutput) => void): void;
            /**
                * <p>Updates the parameters of a parameter group. You can modify up to 20 parameters in a single request by submitting a list parameter name and value pairs.</p>
                */
            updateParameterGroup(args: UpdateParameterGroupCommandInput, options?: __HttpHandlerOptions): Promise<UpdateParameterGroupCommandOutput>;
            updateParameterGroup(args: UpdateParameterGroupCommandInput, cb: (err: any, data?: UpdateParameterGroupCommandOutput) => void): void;
            updateParameterGroup(args: UpdateParameterGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateParameterGroupCommandOutput) => void): void;
            /**
                * <p>Updates a subnet group. For more information, see <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/ubnetGroups.Modifying.html">Updating a subnet group</a>
                *          </p>
                */
            updateSubnetGroup(args: UpdateSubnetGroupCommandInput, options?: __HttpHandlerOptions): Promise<UpdateSubnetGroupCommandOutput>;
            updateSubnetGroup(args: UpdateSubnetGroupCommandInput, cb: (err: any, data?: UpdateSubnetGroupCommandOutput) => void): void;
            updateSubnetGroup(args: UpdateSubnetGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateSubnetGroupCommandOutput) => void): void;
            /**
                * <p>Changes user password(s) and/or access string.</p>
                */
            updateUser(args: UpdateUserCommandInput, options?: __HttpHandlerOptions): Promise<UpdateUserCommandOutput>;
            updateUser(args: UpdateUserCommandInput, cb: (err: any, data?: UpdateUserCommandOutput) => void): void;
            updateUser(args: UpdateUserCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateUserCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/BatchUpdateClusterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { BatchUpdateClusterRequest, BatchUpdateClusterResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface BatchUpdateClusterCommandInput extends BatchUpdateClusterRequest {
    }
    export interface BatchUpdateClusterCommandOutput extends BatchUpdateClusterResponse, __MetadataBearer {
    }
    /**
        * <p>Apply the service update to a list of clusters supplied. For more information on service updates and applying them, see <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/managing-updates.html#applying-updates">Applying the service updates</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, BatchUpdateClusterCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, BatchUpdateClusterCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new BatchUpdateClusterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchUpdateClusterCommandInput} for command's `input` shape.
        * @see {@link BatchUpdateClusterCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class BatchUpdateClusterCommand extends $Command<BatchUpdateClusterCommandInput, BatchUpdateClusterCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: BatchUpdateClusterCommandInput;
            constructor(input: BatchUpdateClusterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchUpdateClusterCommandInput, BatchUpdateClusterCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/CopySnapshotCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { CopySnapshotRequest, CopySnapshotResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface CopySnapshotCommandInput extends CopySnapshotRequest {
    }
    export interface CopySnapshotCommandOutput extends CopySnapshotResponse, __MetadataBearer {
    }
    /**
        * <p>Makes a copy of an existing snapshot.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, CopySnapshotCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, CopySnapshotCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new CopySnapshotCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CopySnapshotCommandInput} for command's `input` shape.
        * @see {@link CopySnapshotCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class CopySnapshotCommand extends $Command<CopySnapshotCommandInput, CopySnapshotCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: CopySnapshotCommandInput;
            constructor(input: CopySnapshotCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CopySnapshotCommandInput, CopySnapshotCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/CreateACLCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { CreateACLRequest, CreateACLResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface CreateACLCommandInput extends CreateACLRequest {
    }
    export interface CreateACLCommandOutput extends CreateACLResponse, __MetadataBearer {
    }
    /**
        * <p>Creates an Access Control List. For more information, see <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/clusters.acls.html">Authenticating users with Access Contol Lists (ACLs)</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, CreateACLCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, CreateACLCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new CreateACLCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateACLCommandInput} for command's `input` shape.
        * @see {@link CreateACLCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class CreateACLCommand extends $Command<CreateACLCommandInput, CreateACLCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: CreateACLCommandInput;
            constructor(input: CreateACLCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateACLCommandInput, CreateACLCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/CreateClusterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { CreateClusterRequest, CreateClusterResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface CreateClusterCommandInput extends CreateClusterRequest {
    }
    export interface CreateClusterCommandOutput extends CreateClusterResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a cluster. All nodes in the cluster run the same protocol-compliant engine software.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, CreateClusterCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, CreateClusterCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new CreateClusterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateClusterCommandInput} for command's `input` shape.
        * @see {@link CreateClusterCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class CreateClusterCommand extends $Command<CreateClusterCommandInput, CreateClusterCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: CreateClusterCommandInput;
            constructor(input: CreateClusterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateClusterCommandInput, CreateClusterCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/CreateParameterGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { CreateParameterGroupRequest, CreateParameterGroupResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface CreateParameterGroupCommandInput extends CreateParameterGroupRequest {
    }
    export interface CreateParameterGroupCommandOutput extends CreateParameterGroupResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a new MemoryDB parameter group. A parameter group is a collection of parameters and their values that are applied to all of the nodes in any cluster. For
        *          more information, see <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/parametergroups.html">Configuring engine parameters using parameter groups</a>.
        *
        *          </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, CreateParameterGroupCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, CreateParameterGroupCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new CreateParameterGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateParameterGroupCommandInput} for command's `input` shape.
        * @see {@link CreateParameterGroupCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class CreateParameterGroupCommand extends $Command<CreateParameterGroupCommandInput, CreateParameterGroupCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: CreateParameterGroupCommandInput;
            constructor(input: CreateParameterGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateParameterGroupCommandInput, CreateParameterGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/CreateSnapshotCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { CreateSnapshotRequest, CreateSnapshotResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface CreateSnapshotCommandInput extends CreateSnapshotRequest {
    }
    export interface CreateSnapshotCommandOutput extends CreateSnapshotResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a copy of an entire cluster at a specific moment in time.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, CreateSnapshotCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, CreateSnapshotCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new CreateSnapshotCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateSnapshotCommandInput} for command's `input` shape.
        * @see {@link CreateSnapshotCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class CreateSnapshotCommand extends $Command<CreateSnapshotCommandInput, CreateSnapshotCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: CreateSnapshotCommandInput;
            constructor(input: CreateSnapshotCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateSnapshotCommandInput, CreateSnapshotCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/CreateSubnetGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { CreateSubnetGroupRequest, CreateSubnetGroupResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface CreateSubnetGroupCommandInput extends CreateSubnetGroupRequest {
    }
    export interface CreateSubnetGroupCommandOutput extends CreateSubnetGroupResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a subnet group. A subnet group is a collection of subnets (typically private) that you can designate for your clusters running in an Amazon Virtual Private Cloud (VPC) environment.
        *
        *          When you create a cluster in an Amazon VPC, you must specify a subnet group. MemoryDB uses that subnet group to choose a subnet and IP addresses within that subnet to associate with your nodes.
        *          For more information, see <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/subnetgroups.html">Subnets and subnet groups</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, CreateSubnetGroupCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, CreateSubnetGroupCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new CreateSubnetGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateSubnetGroupCommandInput} for command's `input` shape.
        * @see {@link CreateSubnetGroupCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class CreateSubnetGroupCommand extends $Command<CreateSubnetGroupCommandInput, CreateSubnetGroupCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: CreateSubnetGroupCommandInput;
            constructor(input: CreateSubnetGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateSubnetGroupCommandInput, CreateSubnetGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/CreateUserCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { CreateUserRequest, CreateUserResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface CreateUserCommandInput extends CreateUserRequest {
    }
    export interface CreateUserCommandOutput extends CreateUserResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a MemoryDB user. For more information, see <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/clusters.acls.html">Authenticating users with Access Contol Lists (ACLs)</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, CreateUserCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, CreateUserCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new CreateUserCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateUserCommandInput} for command's `input` shape.
        * @see {@link CreateUserCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class CreateUserCommand extends $Command<CreateUserCommandInput, CreateUserCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: CreateUserCommandInput;
            constructor(input: CreateUserCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateUserCommandInput, CreateUserCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DeleteACLCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { DeleteACLRequest, DeleteACLResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface DeleteACLCommandInput extends DeleteACLRequest {
    }
    export interface DeleteACLCommandOutput extends DeleteACLResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes an Access Control List. The ACL must first be disassociated from the cluster before it can be deleted. For more information, see <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/clusters.acls.html">Authenticating users with Access Contol Lists (ACLs)</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, DeleteACLCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, DeleteACLCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new DeleteACLCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteACLCommandInput} for command's `input` shape.
        * @see {@link DeleteACLCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class DeleteACLCommand extends $Command<DeleteACLCommandInput, DeleteACLCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: DeleteACLCommandInput;
            constructor(input: DeleteACLCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteACLCommandInput, DeleteACLCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DeleteClusterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { DeleteClusterRequest, DeleteClusterResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface DeleteClusterCommandInput extends DeleteClusterRequest {
    }
    export interface DeleteClusterCommandOutput extends DeleteClusterResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes a cluster. It also deletes all associated nodes and node endpoints</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, DeleteClusterCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, DeleteClusterCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new DeleteClusterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteClusterCommandInput} for command's `input` shape.
        * @see {@link DeleteClusterCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class DeleteClusterCommand extends $Command<DeleteClusterCommandInput, DeleteClusterCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: DeleteClusterCommandInput;
            constructor(input: DeleteClusterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteClusterCommandInput, DeleteClusterCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DeleteParameterGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { DeleteParameterGroupRequest, DeleteParameterGroupResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface DeleteParameterGroupCommandInput extends DeleteParameterGroupRequest {
    }
    export interface DeleteParameterGroupCommandOutput extends DeleteParameterGroupResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes the specified parameter group. You cannot delete a parameter group if it is associated with any clusters.
        *          You cannot delete the default parameter groups in your account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, DeleteParameterGroupCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, DeleteParameterGroupCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new DeleteParameterGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteParameterGroupCommandInput} for command's `input` shape.
        * @see {@link DeleteParameterGroupCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class DeleteParameterGroupCommand extends $Command<DeleteParameterGroupCommandInput, DeleteParameterGroupCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: DeleteParameterGroupCommandInput;
            constructor(input: DeleteParameterGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteParameterGroupCommandInput, DeleteParameterGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DeleteSnapshotCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { DeleteSnapshotRequest, DeleteSnapshotResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface DeleteSnapshotCommandInput extends DeleteSnapshotRequest {
    }
    export interface DeleteSnapshotCommandOutput extends DeleteSnapshotResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes an existing snapshot. When you receive a successful response from this operation, MemoryDB immediately begins deleting the snapshot; you cannot cancel or revert this operation.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, DeleteSnapshotCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, DeleteSnapshotCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new DeleteSnapshotCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteSnapshotCommandInput} for command's `input` shape.
        * @see {@link DeleteSnapshotCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class DeleteSnapshotCommand extends $Command<DeleteSnapshotCommandInput, DeleteSnapshotCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: DeleteSnapshotCommandInput;
            constructor(input: DeleteSnapshotCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteSnapshotCommandInput, DeleteSnapshotCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DeleteSubnetGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { DeleteSubnetGroupRequest, DeleteSubnetGroupResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface DeleteSubnetGroupCommandInput extends DeleteSubnetGroupRequest {
    }
    export interface DeleteSubnetGroupCommandOutput extends DeleteSubnetGroupResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes a subnet group. You cannot delete a default subnet group or one that is associated with any clusters.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, DeleteSubnetGroupCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, DeleteSubnetGroupCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new DeleteSubnetGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteSubnetGroupCommandInput} for command's `input` shape.
        * @see {@link DeleteSubnetGroupCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class DeleteSubnetGroupCommand extends $Command<DeleteSubnetGroupCommandInput, DeleteSubnetGroupCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: DeleteSubnetGroupCommandInput;
            constructor(input: DeleteSubnetGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteSubnetGroupCommandInput, DeleteSubnetGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DeleteUserCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { DeleteUserRequest, DeleteUserResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface DeleteUserCommandInput extends DeleteUserRequest {
    }
    export interface DeleteUserCommandOutput extends DeleteUserResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes a user. The user will be removed from all ACLs and in turn removed from all clusters.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, DeleteUserCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, DeleteUserCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new DeleteUserCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteUserCommandInput} for command's `input` shape.
        * @see {@link DeleteUserCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class DeleteUserCommand extends $Command<DeleteUserCommandInput, DeleteUserCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: DeleteUserCommandInput;
            constructor(input: DeleteUserCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteUserCommandInput, DeleteUserCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeACLsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { DescribeACLsRequest, DescribeACLsResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface DescribeACLsCommandInput extends DescribeACLsRequest {
    }
    export interface DescribeACLsCommandOutput extends DescribeACLsResponse, __MetadataBearer {
    }
    /**
        * <p>Returns a list of ACLs</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, DescribeACLsCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, DescribeACLsCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new DescribeACLsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeACLsCommandInput} for command's `input` shape.
        * @see {@link DescribeACLsCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class DescribeACLsCommand extends $Command<DescribeACLsCommandInput, DescribeACLsCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: DescribeACLsCommandInput;
            constructor(input: DescribeACLsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeACLsCommandInput, DescribeACLsCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeClustersCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { DescribeClustersRequest, DescribeClustersResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface DescribeClustersCommandInput extends DescribeClustersRequest {
    }
    export interface DescribeClustersCommandOutput extends DescribeClustersResponse, __MetadataBearer {
    }
    /**
        * <p>Returns information about all provisioned clusters if no cluster identifier is specified, or about a specific cluster if a cluster name is supplied.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, DescribeClustersCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, DescribeClustersCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new DescribeClustersCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeClustersCommandInput} for command's `input` shape.
        * @see {@link DescribeClustersCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class DescribeClustersCommand extends $Command<DescribeClustersCommandInput, DescribeClustersCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: DescribeClustersCommandInput;
            constructor(input: DescribeClustersCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeClustersCommandInput, DescribeClustersCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeEngineVersionsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { DescribeEngineVersionsRequest, DescribeEngineVersionsResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface DescribeEngineVersionsCommandInput extends DescribeEngineVersionsRequest {
    }
    export interface DescribeEngineVersionsCommandOutput extends DescribeEngineVersionsResponse, __MetadataBearer {
    }
    /**
        * <p>Returns a list of the available Redis engine versions.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, DescribeEngineVersionsCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, DescribeEngineVersionsCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new DescribeEngineVersionsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeEngineVersionsCommandInput} for command's `input` shape.
        * @see {@link DescribeEngineVersionsCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class DescribeEngineVersionsCommand extends $Command<DescribeEngineVersionsCommandInput, DescribeEngineVersionsCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: DescribeEngineVersionsCommandInput;
            constructor(input: DescribeEngineVersionsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeEngineVersionsCommandInput, DescribeEngineVersionsCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeEventsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { DescribeEventsRequest, DescribeEventsResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface DescribeEventsCommandInput extends DescribeEventsRequest {
    }
    export interface DescribeEventsCommandOutput extends DescribeEventsResponse, __MetadataBearer {
    }
    /**
        * <p>Returns events related to clusters, security groups, and parameter groups. You can obtain events specific to a particular cluster, security group, or parameter group by providing the name as a parameter.
        *
        *          By default, only the events occurring within the last hour are returned; however, you can retrieve up to 14 days' worth of events if necessary.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, DescribeEventsCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, DescribeEventsCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new DescribeEventsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeEventsCommandInput} for command's `input` shape.
        * @see {@link DescribeEventsCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class DescribeEventsCommand extends $Command<DescribeEventsCommandInput, DescribeEventsCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: DescribeEventsCommandInput;
            constructor(input: DescribeEventsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeEventsCommandInput, DescribeEventsCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeParameterGroupsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { DescribeParameterGroupsRequest, DescribeParameterGroupsResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface DescribeParameterGroupsCommandInput extends DescribeParameterGroupsRequest {
    }
    export interface DescribeParameterGroupsCommandOutput extends DescribeParameterGroupsResponse, __MetadataBearer {
    }
    /**
        * <p>Returns a list of parameter group descriptions. If a parameter group name is specified, the list contains only the descriptions for that group.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, DescribeParameterGroupsCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, DescribeParameterGroupsCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new DescribeParameterGroupsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeParameterGroupsCommandInput} for command's `input` shape.
        * @see {@link DescribeParameterGroupsCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class DescribeParameterGroupsCommand extends $Command<DescribeParameterGroupsCommandInput, DescribeParameterGroupsCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: DescribeParameterGroupsCommandInput;
            constructor(input: DescribeParameterGroupsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeParameterGroupsCommandInput, DescribeParameterGroupsCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeParametersCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { DescribeParametersRequest, DescribeParametersResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface DescribeParametersCommandInput extends DescribeParametersRequest {
    }
    export interface DescribeParametersCommandOutput extends DescribeParametersResponse, __MetadataBearer {
    }
    /**
        * <p>Returns the detailed parameter list for a particular parameter group.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, DescribeParametersCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, DescribeParametersCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new DescribeParametersCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeParametersCommandInput} for command's `input` shape.
        * @see {@link DescribeParametersCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class DescribeParametersCommand extends $Command<DescribeParametersCommandInput, DescribeParametersCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: DescribeParametersCommandInput;
            constructor(input: DescribeParametersCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeParametersCommandInput, DescribeParametersCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeServiceUpdatesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { DescribeServiceUpdatesRequest, DescribeServiceUpdatesResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface DescribeServiceUpdatesCommandInput extends DescribeServiceUpdatesRequest {
    }
    export interface DescribeServiceUpdatesCommandOutput extends DescribeServiceUpdatesResponse, __MetadataBearer {
    }
    /**
        * <p>Returns details of the service updates</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, DescribeServiceUpdatesCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, DescribeServiceUpdatesCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new DescribeServiceUpdatesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeServiceUpdatesCommandInput} for command's `input` shape.
        * @see {@link DescribeServiceUpdatesCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class DescribeServiceUpdatesCommand extends $Command<DescribeServiceUpdatesCommandInput, DescribeServiceUpdatesCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: DescribeServiceUpdatesCommandInput;
            constructor(input: DescribeServiceUpdatesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeServiceUpdatesCommandInput, DescribeServiceUpdatesCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeSnapshotsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { DescribeSnapshotsRequest, DescribeSnapshotsResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface DescribeSnapshotsCommandInput extends DescribeSnapshotsRequest {
    }
    export interface DescribeSnapshotsCommandOutput extends DescribeSnapshotsResponse, __MetadataBearer {
    }
    /**
        * <p>Returns information about cluster snapshots. By default, DescribeSnapshots lists all of your snapshots; it can optionally describe a single snapshot,
        *          or just the snapshots associated with a particular cluster.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, DescribeSnapshotsCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, DescribeSnapshotsCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new DescribeSnapshotsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeSnapshotsCommandInput} for command's `input` shape.
        * @see {@link DescribeSnapshotsCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class DescribeSnapshotsCommand extends $Command<DescribeSnapshotsCommandInput, DescribeSnapshotsCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: DescribeSnapshotsCommandInput;
            constructor(input: DescribeSnapshotsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeSnapshotsCommandInput, DescribeSnapshotsCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeSubnetGroupsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { DescribeSubnetGroupsRequest, DescribeSubnetGroupsResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface DescribeSubnetGroupsCommandInput extends DescribeSubnetGroupsRequest {
    }
    export interface DescribeSubnetGroupsCommandOutput extends DescribeSubnetGroupsResponse, __MetadataBearer {
    }
    /**
        * <p>Returns a list of subnet group descriptions. If a subnet group name is specified, the list contains only the description of that group.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, DescribeSubnetGroupsCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, DescribeSubnetGroupsCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new DescribeSubnetGroupsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeSubnetGroupsCommandInput} for command's `input` shape.
        * @see {@link DescribeSubnetGroupsCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class DescribeSubnetGroupsCommand extends $Command<DescribeSubnetGroupsCommandInput, DescribeSubnetGroupsCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: DescribeSubnetGroupsCommandInput;
            constructor(input: DescribeSubnetGroupsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeSubnetGroupsCommandInput, DescribeSubnetGroupsCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeUsersCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { DescribeUsersRequest, DescribeUsersResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface DescribeUsersCommandInput extends DescribeUsersRequest {
    }
    export interface DescribeUsersCommandOutput extends DescribeUsersResponse, __MetadataBearer {
    }
    /**
        * <p>Returns a list of users.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, DescribeUsersCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, DescribeUsersCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new DescribeUsersCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeUsersCommandInput} for command's `input` shape.
        * @see {@link DescribeUsersCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class DescribeUsersCommand extends $Command<DescribeUsersCommandInput, DescribeUsersCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: DescribeUsersCommandInput;
            constructor(input: DescribeUsersCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeUsersCommandInput, DescribeUsersCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/FailoverShardCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { FailoverShardRequest, FailoverShardResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface FailoverShardCommandInput extends FailoverShardRequest {
    }
    export interface FailoverShardCommandOutput extends FailoverShardResponse, __MetadataBearer {
    }
    /**
        * <p>Used to failover a shard</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, FailoverShardCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, FailoverShardCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new FailoverShardCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link FailoverShardCommandInput} for command's `input` shape.
        * @see {@link FailoverShardCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class FailoverShardCommand extends $Command<FailoverShardCommandInput, FailoverShardCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: FailoverShardCommandInput;
            constructor(input: FailoverShardCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<FailoverShardCommandInput, FailoverShardCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/ListAllowedNodeTypeUpdatesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { ListAllowedNodeTypeUpdatesRequest, ListAllowedNodeTypeUpdatesResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface ListAllowedNodeTypeUpdatesCommandInput extends ListAllowedNodeTypeUpdatesRequest {
    }
    export interface ListAllowedNodeTypeUpdatesCommandOutput extends ListAllowedNodeTypeUpdatesResponse, __MetadataBearer {
    }
    /**
        * <p>Lists all available node types that you can scale to from your cluster's current node type.
        *
        *          When you use the UpdateCluster operation to scale your cluster, the value of the NodeType parameter must be one of the node types returned by this operation.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, ListAllowedNodeTypeUpdatesCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, ListAllowedNodeTypeUpdatesCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new ListAllowedNodeTypeUpdatesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListAllowedNodeTypeUpdatesCommandInput} for command's `input` shape.
        * @see {@link ListAllowedNodeTypeUpdatesCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class ListAllowedNodeTypeUpdatesCommand extends $Command<ListAllowedNodeTypeUpdatesCommandInput, ListAllowedNodeTypeUpdatesCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: ListAllowedNodeTypeUpdatesCommandInput;
            constructor(input: ListAllowedNodeTypeUpdatesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListAllowedNodeTypeUpdatesCommandInput, ListAllowedNodeTypeUpdatesCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/ListTagsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { ListTagsRequest, ListTagsResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface ListTagsCommandInput extends ListTagsRequest {
    }
    export interface ListTagsCommandOutput extends ListTagsResponse, __MetadataBearer {
    }
    /**
        * <p>Lists all tags currently on a named resource.
        *
        *          A tag is a key-value pair where the key and value are case-sensitive. You can use tags to categorize and track your MemoryDB resources.
        *          For more information, see <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/Tagging-Resources.html">Tagging your MemoryDB resources</a>
        *          </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, ListTagsCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, ListTagsCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new ListTagsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTagsCommandInput} for command's `input` shape.
        * @see {@link ListTagsCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class ListTagsCommand extends $Command<ListTagsCommandInput, ListTagsCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: ListTagsCommandInput;
            constructor(input: ListTagsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTagsCommandInput, ListTagsCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/ResetParameterGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { ResetParameterGroupRequest, ResetParameterGroupResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface ResetParameterGroupCommandInput extends ResetParameterGroupRequest {
    }
    export interface ResetParameterGroupCommandOutput extends ResetParameterGroupResponse, __MetadataBearer {
    }
    /**
        * <p>Modifies the parameters of a parameter group to the engine or system default value. You can reset specific parameters by submitting a list of parameter names. To reset the entire parameter group, specify the AllParameters and ParameterGroupName parameters.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, ResetParameterGroupCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, ResetParameterGroupCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new ResetParameterGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ResetParameterGroupCommandInput} for command's `input` shape.
        * @see {@link ResetParameterGroupCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class ResetParameterGroupCommand extends $Command<ResetParameterGroupCommandInput, ResetParameterGroupCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: ResetParameterGroupCommandInput;
            constructor(input: ResetParameterGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ResetParameterGroupCommandInput, ResetParameterGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/TagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { TagResourceRequest, TagResourceResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface TagResourceCommandInput extends TagResourceRequest {
    }
    export interface TagResourceCommandOutput extends TagResourceResponse, __MetadataBearer {
    }
    /**
        * <p>A tag is a key-value pair where the key and value are case-sensitive. You can use tags to categorize and track all your MemoryDB resources.
        *
        *          When you add or remove tags on clusters, those actions will be replicated to all nodes in the cluster. For more information, see
        *
        *          <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/iam.resourcelevelpermissions.html">Resource-level permissions</a>.</p>
        *
        *          <p>For example, you can use cost-allocation tags to your MemoryDB resources, Amazon generates a cost allocation report as a comma-separated value
        *           (CSV) file with your usage and costs aggregated by your tags. You can apply tags that represent business categories
        *           (such as cost centers, application names, or owners) to organize your costs across multiple services.
        *
        *          For more information, see <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/tagging.html">Using Cost Allocation Tags</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, TagResourceCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, TagResourceCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new TagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TagResourceCommandInput} for command's `input` shape.
        * @see {@link TagResourceCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class TagResourceCommand extends $Command<TagResourceCommandInput, TagResourceCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: TagResourceCommandInput;
            constructor(input: TagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TagResourceCommandInput, TagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/UntagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { UntagResourceRequest, UntagResourceResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface UntagResourceCommandInput extends UntagResourceRequest {
    }
    export interface UntagResourceCommandOutput extends UntagResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Use this operation to remove tags on a resource</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, UntagResourceCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, UntagResourceCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new UntagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UntagResourceCommandInput} for command's `input` shape.
        * @see {@link UntagResourceCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class UntagResourceCommand extends $Command<UntagResourceCommandInput, UntagResourceCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: UntagResourceCommandInput;
            constructor(input: UntagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UntagResourceCommandInput, UntagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/UpdateACLCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { UpdateACLRequest, UpdateACLResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface UpdateACLCommandInput extends UpdateACLRequest {
    }
    export interface UpdateACLCommandOutput extends UpdateACLResponse, __MetadataBearer {
    }
    /**
        * <p>Changes the list of users that belong to the Access Control List.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, UpdateACLCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, UpdateACLCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new UpdateACLCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateACLCommandInput} for command's `input` shape.
        * @see {@link UpdateACLCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class UpdateACLCommand extends $Command<UpdateACLCommandInput, UpdateACLCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: UpdateACLCommandInput;
            constructor(input: UpdateACLCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateACLCommandInput, UpdateACLCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/UpdateClusterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { UpdateClusterRequest, UpdateClusterResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface UpdateClusterCommandInput extends UpdateClusterRequest {
    }
    export interface UpdateClusterCommandOutput extends UpdateClusterResponse, __MetadataBearer {
    }
    /**
        * <p>Modifies the settings for a cluster. You can use this operation to change one or more cluster configuration settings by specifying the settings and the new values.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, UpdateClusterCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, UpdateClusterCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new UpdateClusterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateClusterCommandInput} for command's `input` shape.
        * @see {@link UpdateClusterCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class UpdateClusterCommand extends $Command<UpdateClusterCommandInput, UpdateClusterCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: UpdateClusterCommandInput;
            constructor(input: UpdateClusterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateClusterCommandInput, UpdateClusterCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/UpdateParameterGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { UpdateParameterGroupRequest, UpdateParameterGroupResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface UpdateParameterGroupCommandInput extends UpdateParameterGroupRequest {
    }
    export interface UpdateParameterGroupCommandOutput extends UpdateParameterGroupResponse, __MetadataBearer {
    }
    /**
        * <p>Updates the parameters of a parameter group. You can modify up to 20 parameters in a single request by submitting a list parameter name and value pairs.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, UpdateParameterGroupCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, UpdateParameterGroupCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new UpdateParameterGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateParameterGroupCommandInput} for command's `input` shape.
        * @see {@link UpdateParameterGroupCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class UpdateParameterGroupCommand extends $Command<UpdateParameterGroupCommandInput, UpdateParameterGroupCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: UpdateParameterGroupCommandInput;
            constructor(input: UpdateParameterGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateParameterGroupCommandInput, UpdateParameterGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/UpdateSubnetGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { UpdateSubnetGroupRequest, UpdateSubnetGroupResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface UpdateSubnetGroupCommandInput extends UpdateSubnetGroupRequest {
    }
    export interface UpdateSubnetGroupCommandOutput extends UpdateSubnetGroupResponse, __MetadataBearer {
    }
    /**
        * <p>Updates a subnet group. For more information, see <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/ubnetGroups.Modifying.html">Updating a subnet group</a>
        *          </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, UpdateSubnetGroupCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, UpdateSubnetGroupCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new UpdateSubnetGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateSubnetGroupCommandInput} for command's `input` shape.
        * @see {@link UpdateSubnetGroupCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class UpdateSubnetGroupCommand extends $Command<UpdateSubnetGroupCommandInput, UpdateSubnetGroupCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: UpdateSubnetGroupCommandInput;
            constructor(input: UpdateSubnetGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateSubnetGroupCommandInput, UpdateSubnetGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/UpdateUserCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { MemoryDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient";
    import { UpdateUserRequest, UpdateUserResponse } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0";
    export interface UpdateUserCommandInput extends UpdateUserRequest {
    }
    export interface UpdateUserCommandOutput extends UpdateUserResponse, __MetadataBearer {
    }
    /**
        * <p>Changes user password(s) and/or access string.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { MemoryDBClient, UpdateUserCommand } from "@aws-sdk/client-memorydb"; // ES Modules import
        * // const { MemoryDBClient, UpdateUserCommand } = require("@aws-sdk/client-memorydb"); // CommonJS import
        * const client = new MemoryDBClient(config);
        * const command = new UpdateUserCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateUserCommandInput} for command's `input` shape.
        * @see {@link UpdateUserCommandOutput} for command's `response` shape.
        * @see {@link MemoryDBClientResolvedConfig | config} for MemoryDBClient's `config` shape.
        *
        */
    export class UpdateUserCommand extends $Command<UpdateUserCommandInput, UpdateUserCommandOutput, MemoryDBClientResolvedConfig> {
            readonly input: UpdateUserCommandInput;
            constructor(input: UpdateUserCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: MemoryDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateUserCommandInput, UpdateUserCommandOutput>;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/MemoryDBClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { BatchUpdateClusterCommandInput, BatchUpdateClusterCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/BatchUpdateClusterCommand";
    import { CopySnapshotCommandInput, CopySnapshotCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/CopySnapshotCommand";
    import { CreateACLCommandInput, CreateACLCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/CreateACLCommand";
    import { CreateClusterCommandInput, CreateClusterCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/CreateClusterCommand";
    import { CreateParameterGroupCommandInput, CreateParameterGroupCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/CreateParameterGroupCommand";
    import { CreateSnapshotCommandInput, CreateSnapshotCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/CreateSnapshotCommand";
    import { CreateSubnetGroupCommandInput, CreateSubnetGroupCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/CreateSubnetGroupCommand";
    import { CreateUserCommandInput, CreateUserCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/CreateUserCommand";
    import { DeleteACLCommandInput, DeleteACLCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DeleteACLCommand";
    import { DeleteClusterCommandInput, DeleteClusterCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DeleteClusterCommand";
    import { DeleteParameterGroupCommandInput, DeleteParameterGroupCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DeleteParameterGroupCommand";
    import { DeleteSnapshotCommandInput, DeleteSnapshotCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DeleteSnapshotCommand";
    import { DeleteSubnetGroupCommandInput, DeleteSubnetGroupCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DeleteSubnetGroupCommand";
    import { DeleteUserCommandInput, DeleteUserCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DeleteUserCommand";
    import { DescribeACLsCommandInput, DescribeACLsCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeACLsCommand";
    import { DescribeClustersCommandInput, DescribeClustersCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeClustersCommand";
    import { DescribeEngineVersionsCommandInput, DescribeEngineVersionsCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeEngineVersionsCommand";
    import { DescribeEventsCommandInput, DescribeEventsCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeEventsCommand";
    import { DescribeParameterGroupsCommandInput, DescribeParameterGroupsCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeParameterGroupsCommand";
    import { DescribeParametersCommandInput, DescribeParametersCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeParametersCommand";
    import { DescribeServiceUpdatesCommandInput, DescribeServiceUpdatesCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeServiceUpdatesCommand";
    import { DescribeSnapshotsCommandInput, DescribeSnapshotsCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeSnapshotsCommand";
    import { DescribeSubnetGroupsCommandInput, DescribeSubnetGroupsCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeSubnetGroupsCommand";
    import { DescribeUsersCommandInput, DescribeUsersCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/DescribeUsersCommand";
    import { FailoverShardCommandInput, FailoverShardCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/FailoverShardCommand";
    import { ListAllowedNodeTypeUpdatesCommandInput, ListAllowedNodeTypeUpdatesCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/ListAllowedNodeTypeUpdatesCommand";
    import { ListTagsCommandInput, ListTagsCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/ListTagsCommand";
    import { ResetParameterGroupCommandInput, ResetParameterGroupCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/ResetParameterGroupCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/UntagResourceCommand";
    import { UpdateACLCommandInput, UpdateACLCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/UpdateACLCommand";
    import { UpdateClusterCommandInput, UpdateClusterCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/UpdateClusterCommand";
    import { UpdateParameterGroupCommandInput, UpdateParameterGroupCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/UpdateParameterGroupCommand";
    import { UpdateSubnetGroupCommandInput, UpdateSubnetGroupCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/UpdateSubnetGroupCommand";
    import { UpdateUserCommandInput, UpdateUserCommandOutput } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/commands/UpdateUserCommand";
    export type ServiceInputTypes = BatchUpdateClusterCommandInput | CopySnapshotCommandInput | CreateACLCommandInput | CreateClusterCommandInput | CreateParameterGroupCommandInput | CreateSnapshotCommandInput | CreateSubnetGroupCommandInput | CreateUserCommandInput | DeleteACLCommandInput | DeleteClusterCommandInput | DeleteParameterGroupCommandInput | DeleteSnapshotCommandInput | DeleteSubnetGroupCommandInput | DeleteUserCommandInput | DescribeACLsCommandInput | DescribeClustersCommandInput | DescribeEngineVersionsCommandInput | DescribeEventsCommandInput | DescribeParameterGroupsCommandInput | DescribeParametersCommandInput | DescribeServiceUpdatesCommandInput | DescribeSnapshotsCommandInput | DescribeSubnetGroupsCommandInput | DescribeUsersCommandInput | FailoverShardCommandInput | ListAllowedNodeTypeUpdatesCommandInput | ListTagsCommandInput | ResetParameterGroupCommandInput | TagResourceCommandInput | UntagResourceCommandInput | UpdateACLCommandInput | UpdateClusterCommandInput | UpdateParameterGroupCommandInput | UpdateSubnetGroupCommandInput | UpdateUserCommandInput;
    export type ServiceOutputTypes = BatchUpdateClusterCommandOutput | CopySnapshotCommandOutput | CreateACLCommandOutput | CreateClusterCommandOutput | CreateParameterGroupCommandOutput | CreateSnapshotCommandOutput | CreateSubnetGroupCommandOutput | CreateUserCommandOutput | DeleteACLCommandOutput | DeleteClusterCommandOutput | DeleteParameterGroupCommandOutput | DeleteSnapshotCommandOutput | DeleteSubnetGroupCommandOutput | DeleteUserCommandOutput | DescribeACLsCommandOutput | DescribeClustersCommandOutput | DescribeEngineVersionsCommandOutput | DescribeEventsCommandOutput | DescribeParameterGroupsCommandOutput | DescribeParametersCommandOutput | DescribeServiceUpdatesCommandOutput | DescribeSnapshotsCommandOutput | DescribeSubnetGroupsCommandOutput | DescribeUsersCommandOutput | FailoverShardCommandOutput | ListAllowedNodeTypeUpdatesCommandOutput | ListTagsCommandOutput | ResetParameterGroupCommandOutput | TagResourceCommandOutput | UntagResourceCommandOutput | UpdateACLCommandOutput | UpdateClusterCommandOutput | UpdateParameterGroupCommandOutput | UpdateSubnetGroupCommandOutput | UpdateUserCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type MemoryDBClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of MemoryDBClient class constructor that set the region, credentials and other options.
        */
    export interface MemoryDBClientConfig extends MemoryDBClientConfigType {
    }
    type MemoryDBClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of MemoryDBClient class. This is resolved and normalized from the {@link MemoryDBClientConfig | constructor configuration interface}.
        */
    export interface MemoryDBClientResolvedConfig extends MemoryDBClientResolvedConfigType {
    }
    /**
        * <p>MemoryDB for Redis is a fully managed, Redis-compatible, in-memory database that delivers ultra-fast performance and Multi-AZ durability for modern applications built using microservices architectures.
        *
        *        MemoryDB stores the entire database in-memory, enabling low latency and high throughput data access. It is compatible with Redis, a popular open source data store, enabling you to leverage Redisâ€™ flexible and friendly data structures, APIs, and commands.</p>
        */
    export class MemoryDBClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, MemoryDBClientResolvedConfig> {
            /**
                * The resolved configuration of MemoryDBClient class. This is resolved and normalized from the {@link MemoryDBClientConfig | constructor configuration interface}.
                */
            readonly config: MemoryDBClientResolvedConfig;
            constructor(configuration: MemoryDBClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { MemoryDBServiceException as __BaseException } from "@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/MemoryDBServiceException";
    /**
        * <p>Returns the updates being applied to the ACL.</p>
        */
    export interface ACLPendingChanges {
            /**
                * <p>A list of user names being removed from the ACL</p>
                */
            UserNamesToRemove?: string[];
            /**
                * <p>A list of users being added to the ACL</p>
                */
            UserNamesToAdd?: string[];
    }
    export namespace ACLPendingChanges {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ACLPendingChanges) => any;
    }
    /**
        * <p>An Access Control List. You can authenticate users with Access Contol Lists.
        *
        *          ACLs enable you to control cluster access by grouping users. These Access control lists are designed as a way to organize access to clusters.</p>
        */
    export interface ACL {
            /**
                * <p>The name of the Access Control List</p>
                */
            Name?: string;
            /**
                * <p>Indicates ACL status. Can be "creating", "active", "modifying", "deleting".</p>
                */
            Status?: string;
            /**
                * <p>The list of user names that belong to the ACL.</p>
                */
            UserNames?: string[];
            /**
                * <p>The minimum engine version supported for the ACL</p>
                */
            MinimumEngineVersion?: string;
            /**
                * <p>A list of updates being applied to the ACL.</p>
                */
            PendingChanges?: ACLPendingChanges;
            /**
                * <p>A list of clusters associated with the ACL.</p>
                */
            Clusters?: string[];
            /**
                * <p>The Amazon Resource Name (ARN) of the ACL</p>
                */
            ARN?: string;
    }
    export namespace ACL {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ACL) => any;
    }
    /**
        * <p></p>
        */
    export class ACLAlreadyExistsFault extends __BaseException {
            readonly name: "ACLAlreadyExistsFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ACLAlreadyExistsFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class ACLNotFoundFault extends __BaseException {
            readonly name: "ACLNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ACLNotFoundFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class ACLQuotaExceededFault extends __BaseException {
            readonly name: "ACLQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ACLQuotaExceededFault, __BaseException>);
    }
    /**
        * <p>The status of the ACL update</p>
        */
    export interface ACLsUpdateStatus {
            /**
                * <p>A list of ACLs pending to be applied.</p>
                */
            ACLToApply?: string;
    }
    export namespace ACLsUpdateStatus {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ACLsUpdateStatus) => any;
    }
    /**
        * <p>A request to apply a service update</p>
        */
    export interface ServiceUpdateRequest {
            /**
                * <p>The unique ID of the service update</p>
                */
            ServiceUpdateNameToApply?: string;
    }
    export namespace ServiceUpdateRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ServiceUpdateRequest) => any;
    }
    export interface BatchUpdateClusterRequest {
            /**
                * <p>The cluster names to apply the updates.</p>
                */
            ClusterNames: string[] | undefined;
            /**
                * <p>The unique ID of the service update</p>
                */
            ServiceUpdate?: ServiceUpdateRequest;
    }
    export namespace BatchUpdateClusterRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchUpdateClusterRequest) => any;
    }
    export enum AZStatus {
            MultiAZ = "multiaz",
            SingleAZ = "singleaz"
    }
    /**
        * <p>Represents the information required for client programs to connect to the cluster and its nodes.</p>
        */
    export interface Endpoint {
            /**
                * <p>The DNS hostname of the node.</p>
                */
            Address?: string;
            /**
                * <p>The port number that the engine is listening on.</p>
                */
            Port?: number;
    }
    export namespace Endpoint {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Endpoint) => any;
    }
    /**
        * <p>Represents the progress of an online resharding operation.</p>
        */
    export interface SlotMigration {
            /**
                * <p>The percentage of the slot migration that is complete.</p>
                */
            ProgressPercentage?: number;
    }
    export namespace SlotMigration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SlotMigration) => any;
    }
    /**
        * <p>The status of the online resharding</p>
        */
    export interface ReshardingStatus {
            /**
                * <p>The status of the online resharding slot migration</p>
                */
            SlotMigration?: SlotMigration;
    }
    export namespace ReshardingStatus {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReshardingStatus) => any;
    }
    export enum ServiceUpdateStatus {
            COMPLETE = "complete",
            IN_PROGRESS = "in-progress",
            NOT_APPLIED = "available",
            SCHEDULED = "scheduled"
    }
    /**
        * <p>Update action that has yet to be processed for the corresponding apply/stop request</p>
        */
    export interface PendingModifiedServiceUpdate {
            /**
                * <p>The unique ID of the service update</p>
                */
            ServiceUpdateName?: string;
            /**
                * <p>The status of the service update</p>
                */
            Status?: ServiceUpdateStatus | string;
    }
    export namespace PendingModifiedServiceUpdate {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PendingModifiedServiceUpdate) => any;
    }
    /**
        * <p>A list of updates being applied to the cluster</p>
        */
    export interface ClusterPendingUpdates {
            /**
                * <p>The status of an online resharding operation.</p>
                */
            Resharding?: ReshardingStatus;
            /**
                * <p>A list of ACLs associated with the cluster that are being updated</p>
                */
            ACLs?: ACLsUpdateStatus;
            /**
                * <p>A list of service updates being applied to the cluster</p>
                */
            ServiceUpdates?: PendingModifiedServiceUpdate[];
    }
    export namespace ClusterPendingUpdates {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterPendingUpdates) => any;
    }
    /**
        * <p>Represents a single security group and its status.</p>
        */
    export interface SecurityGroupMembership {
            /**
                * <p>The identifier of the security group.</p>
                */
            SecurityGroupId?: string;
            /**
                * <p>The status of the security group membership. The status changes whenever a security group is modified, or when the security groups assigned to a cluster are modified.</p>
                */
            Status?: string;
    }
    export namespace SecurityGroupMembership {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SecurityGroupMembership) => any;
    }
    /**
        * <p>Represents an individual node within a cluster. Each node runs its own instance of the cluster's protocol-compliant caching software.</p>
        */
    export interface Node {
            /**
                * <p>The  node identifier. A node name is a numeric identifier (0001, 0002, etc.). The combination of cluster name, shard name and node name uniquely identifies every node used in a customer's Amazon account.</p>
                */
            Name?: string;
            /**
                * <p>The status of the service update on the node</p>
                */
            Status?: string;
            /**
                * <p>The Availability Zone in which the node resides</p>
                */
            AvailabilityZone?: string;
            /**
                * <p>The date and time when the node was created.</p>
                */
            CreateTime?: Date;
            /**
                * <p>The hostname for connecting to this node.</p>
                */
            Endpoint?: Endpoint;
    }
    export namespace Node {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Node) => any;
    }
    /**
        * <p>Represents a collection of nodes in a cluster. One node in the node group is the read/write primary node. All the other nodes are read-only Replica nodes.</p>
        */
    export interface Shard {
            /**
                * <p>The name of the shard</p>
                */
            Name?: string;
            /**
                * <p>The current state of this replication group - creating, available, modifying, deleting.</p>
                */
            Status?: string;
            /**
                * <p>The keyspace for this shard.</p>
                */
            Slots?: string;
            /**
                * <p>A list containing information about individual nodes within the shard</p>
                */
            Nodes?: Node[];
            /**
                * <p>The number of nodes in the shard</p>
                */
            NumberOfNodes?: number;
    }
    export namespace Shard {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Shard) => any;
    }
    /**
        * <p>Contains all of the attributes of a specific cluster.</p>
        */
    export interface Cluster {
            /**
                * <p>The user-supplied name of the cluster. This identifier is a unique key that identifies a cluster.</p>
                */
            Name?: string;
            /**
                * <p>A description of the cluster</p>
                */
            Description?: string;
            /**
                * <p>The status of the cluster. For example, Available, Updating, Creating.</p>
                */
            Status?: string;
            /**
                * <p>A group of settings that are currently being applied.</p>
                */
            PendingUpdates?: ClusterPendingUpdates;
            /**
                * <p>The number of shards in the cluster</p>
                */
            NumberOfShards?: number;
            /**
                * <p>A list of shards that are members of the cluster.</p>
                */
            Shards?: Shard[];
            /**
                * <p>Indicates if the cluster has a Multi-AZ configuration (multiaz) or not (singleaz).</p>
                */
            AvailabilityMode?: AZStatus | string;
            /**
                * <p>The cluster's configuration endpoint</p>
                */
            ClusterEndpoint?: Endpoint;
            /**
                * <p>The cluster's node type</p>
                */
            NodeType?: string;
            /**
                * <p>The Redis engine version used by the cluster</p>
                */
            EngineVersion?: string;
            /**
                * <p>The Redis engine patch version used by the cluster</p>
                */
            EnginePatchVersion?: string;
            /**
                * <p>The name of the parameter group used by the cluster</p>
                */
            ParameterGroupName?: string;
            /**
                * <p>The status of the parameter group used by the cluster, for example 'active' or 'applying'.</p>
                */
            ParameterGroupStatus?: string;
            /**
                * <p>A list of security groups used by the cluster</p>
                */
            SecurityGroups?: SecurityGroupMembership[];
            /**
                * <p>The name of the subnet group used by the cluster</p>
                */
            SubnetGroupName?: string;
            /**
                * <p>A flag to indicate if In-transit encryption is enabled</p>
                */
            TLSEnabled?: boolean;
            /**
                * <p>The ID of the KMS key used to encrypt the cluster</p>
                */
            KmsKeyId?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the cluster.</p>
                */
            ARN?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the SNS notification topic</p>
                */
            SnsTopicArn?: string;
            /**
                * <p>The SNS topic must be in Active status to receive notifications</p>
                */
            SnsTopicStatus?: string;
            /**
                * <p>The number of days for which MemoryDB retains automatic snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot that was taken today is retained for 5 days before being deleted.</p>
                */
            SnapshotRetentionLimit?: number;
            /**
                * <p>Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period. </p>
                */
            MaintenanceWindow?: string;
            /**
                * <p>The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of your shard.
                *
                *          Example: 05:00-09:00
                *
                *          If you do not specify this parameter, MemoryDB automatically chooses an appropriate time range.</p>
                */
            SnapshotWindow?: string;
            /**
                * <p>The name of the Access Control List associated with this cluster.</p>
                */
            ACLName?: string;
            /**
                * <p>When set to true, the cluster will automatically receive minor engine version upgrades after launch.</p>
                */
            AutoMinorVersionUpgrade?: boolean;
    }
    export namespace Cluster {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Cluster) => any;
    }
    /**
        * <p>A cluster whose updates have failed</p>
        */
    export interface UnprocessedCluster {
            /**
                * <p>The name of the cluster</p>
                */
            ClusterName?: string;
            /**
                * <p>The error type associated with the update failure</p>
                */
            ErrorType?: string;
            /**
                * <p>The error message associated with the update failure</p>
                */
            ErrorMessage?: string;
    }
    export namespace UnprocessedCluster {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UnprocessedCluster) => any;
    }
    export interface BatchUpdateClusterResponse {
            /**
                * <p>The list of clusters that have been updated.</p>
                */
            ProcessedClusters?: Cluster[];
            /**
                * <p>The list of clusters where updates have not been applied.</p>
                */
            UnprocessedClusters?: UnprocessedCluster[];
    }
    export namespace BatchUpdateClusterResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchUpdateClusterResponse) => any;
    }
    /**
        * <p></p>
        */
    export class InvalidParameterValueException extends __BaseException {
            readonly name: "InvalidParameterValueException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidParameterValueException, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class ServiceUpdateNotFoundFault extends __BaseException {
            readonly name: "ServiceUpdateNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ServiceUpdateNotFoundFault, __BaseException>);
    }
    /**
        * <p>A tag that can be added to an MemoryDB resource. Tags are composed of a Key/Value pair. You can use tags to categorize and track all your MemoryDB resources.
        *          When you add or remove tags on clusters, those actions will be replicated to all nodes in the cluster. A tag with a null Value is permitted. For more information, see
        *          <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/tagging-resources.html">Tagging your MemoryDB resources</a>
        *          </p>
        */
    export interface Tag {
            /**
                * <p>The key for the tag. May not be null.</p>
                */
            Key?: string;
            /**
                * <p>The tag's value. May be null.</p>
                */
            Value?: string;
    }
    export namespace Tag {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Tag) => any;
    }
    export interface CopySnapshotRequest {
            /**
                * <p>The name of an existing snapshot from which to make a copy.</p>
                */
            SourceSnapshotName: string | undefined;
            /**
                * <p>A name for the snapshot copy. MemoryDB does not permit overwriting a snapshot, therefore this name must be unique within its context - MemoryDB or an Amazon S3 bucket if exporting.</p>
                */
            TargetSnapshotName: string | undefined;
            /**
                * <p>The Amazon S3 bucket to which the snapshot is exported. This parameter is used only when exporting a snapshot for external access.
                *
                *        When using this parameter to export a snapshot, be sure MemoryDB has the needed permissions to this S3 bucket. For more information, see
                *
                *        <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/snapshots-exporting.html">Step 2: Grant MemoryDB Access to Your Amazon S3 Bucket</a>.
                *
                *      </p>
                */
            TargetBucket?: string;
            /**
                * <p>The ID of the KMS key used to encrypt the target snapshot.</p>
                */
            KmsKeyId?: string;
            /**
                * <p>A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.</p>
                */
            Tags?: Tag[];
    }
    export namespace CopySnapshotRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CopySnapshotRequest) => any;
    }
    /**
        * <p>Shard configuration options. Each shard configuration has the following: Slots and ReplicaCount.</p>
        */
    export interface ShardConfiguration {
            /**
                * <p>A string that specifies the keyspace for a particular node group. Keyspaces range from 0 to 16,383. The string is in the format startkey-endkey.</p>
                */
            Slots?: string;
            /**
                * <p>The number of read replica nodes in this shard.</p>
                */
            ReplicaCount?: number;
    }
    export namespace ShardConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ShardConfiguration) => any;
    }
    /**
        * <p>Provides details of a shard in a snapshot</p>
        */
    export interface ShardDetail {
            /**
                * <p>The name of the shard</p>
                */
            Name?: string;
            /**
                * <p>The configuration details of the shard</p>
                */
            Configuration?: ShardConfiguration;
            /**
                * <p>The size of the shard's snapshot</p>
                */
            Size?: string;
            /**
                * <p>The date and time that the shard's snapshot was created</p>
                */
            SnapshotCreationTime?: Date;
    }
    export namespace ShardDetail {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ShardDetail) => any;
    }
    /**
        * <p>A list of cluster configuration options. </p>
        */
    export interface ClusterConfiguration {
            /**
                * <p>The name of the cluster</p>
                */
            Name?: string;
            /**
                * <p>The description of the cluster configuration</p>
                */
            Description?: string;
            /**
                * <p>The node type used for the cluster</p>
                */
            NodeType?: string;
            /**
                * <p>The Redis engine version used by the cluster</p>
                */
            EngineVersion?: string;
            /**
                * <p>The specified maintenance window for the cluster</p>
                */
            MaintenanceWindow?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the SNS notification topic for the cluster</p>
                */
            TopicArn?: string;
            /**
                * <p>The port used by the cluster</p>
                */
            Port?: number;
            /**
                * <p>The name of parameter group used by the cluster</p>
                */
            ParameterGroupName?: string;
            /**
                * <p>The name of the subnet group used by the cluster</p>
                */
            SubnetGroupName?: string;
            /**
                * <p>The ID of the VPC the cluster belongs to</p>
                */
            VpcId?: string;
            /**
                * <p>The snapshot retention limit set by the cluster</p>
                */
            SnapshotRetentionLimit?: number;
            /**
                * <p>The snapshot window set by the cluster</p>
                */
            SnapshotWindow?: string;
            /**
                * <p>The number of shards in the cluster</p>
                */
            NumShards?: number;
            /**
                * <p>The list of shards in the cluster</p>
                */
            Shards?: ShardDetail[];
    }
    export namespace ClusterConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ClusterConfiguration) => any;
    }
    /**
        * <p>Represents a copy of an entire cluster as of the time when the snapshot was taken.</p>
        */
    export interface Snapshot {
            /**
                * <p>The name of the snapshot</p>
                */
            Name?: string;
            /**
                * <p>The status of the snapshot. Valid values: creating | available | restoring | copying | deleting.</p>
                */
            Status?: string;
            /**
                * <p>Indicates whether the snapshot is from an automatic backup (automated) or was created manually (manual).</p>
                */
            Source?: string;
            /**
                * <p>The ID of the KMS key used to encrypt the snapshot.</p>
                */
            KmsKeyId?: string;
            /**
                * <p>The ARN (Amazon Resource Name) of the snapshot.</p>
                */
            ARN?: string;
            /**
                * <p>The configuration of the cluster from which the snapshot was taken</p>
                */
            ClusterConfiguration?: ClusterConfiguration;
    }
    export namespace Snapshot {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Snapshot) => any;
    }
    export interface CopySnapshotResponse {
            /**
                * <p>Represents a copy of an entire cluster as of the time when the snapshot was taken.</p>
                */
            Snapshot?: Snapshot;
    }
    export namespace CopySnapshotResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CopySnapshotResponse) => any;
    }
    /**
        * <p></p>
        */
    export class InvalidParameterCombinationException extends __BaseException {
            readonly name: "InvalidParameterCombinationException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidParameterCombinationException, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class InvalidSnapshotStateFault extends __BaseException {
            readonly name: "InvalidSnapshotStateFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidSnapshotStateFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class ServiceLinkedRoleNotFoundFault extends __BaseException {
            readonly name: "ServiceLinkedRoleNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ServiceLinkedRoleNotFoundFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class SnapshotAlreadyExistsFault extends __BaseException {
            readonly name: "SnapshotAlreadyExistsFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SnapshotAlreadyExistsFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class SnapshotNotFoundFault extends __BaseException {
            readonly name: "SnapshotNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SnapshotNotFoundFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class SnapshotQuotaExceededFault extends __BaseException {
            readonly name: "SnapshotQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SnapshotQuotaExceededFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class TagQuotaPerResourceExceeded extends __BaseException {
            readonly name: "TagQuotaPerResourceExceeded";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TagQuotaPerResourceExceeded, __BaseException>);
    }
    export interface CreateACLRequest {
            /**
                * <p>The name of the Access Control List.</p>
                */
            ACLName: string | undefined;
            /**
                * <p>The list of users that belong to the Access Control List.</p>
                */
            UserNames?: string[];
            /**
                * <p>A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.</p>
                */
            Tags?: Tag[];
    }
    export namespace CreateACLRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateACLRequest) => any;
    }
    export interface CreateACLResponse {
            /**
                * <p>The newly-created Access Control List.</p>
                */
            ACL?: ACL;
    }
    export namespace CreateACLResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateACLResponse) => any;
    }
    /**
        * <p></p>
        */
    export class DefaultUserRequired extends __BaseException {
            readonly name: "DefaultUserRequired";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DefaultUserRequired, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class DuplicateUserNameFault extends __BaseException {
            readonly name: "DuplicateUserNameFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DuplicateUserNameFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class UserNotFoundFault extends __BaseException {
            readonly name: "UserNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UserNotFoundFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class ClusterAlreadyExistsFault extends __BaseException {
            readonly name: "ClusterAlreadyExistsFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClusterAlreadyExistsFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class ClusterQuotaForCustomerExceededFault extends __BaseException {
            readonly name: "ClusterQuotaForCustomerExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClusterQuotaForCustomerExceededFault, __BaseException>);
    }
    export interface CreateClusterRequest {
            /**
                * <p>The name of the cluster. This value must be unique as it also serves as the cluster identifier.</p>
                */
            ClusterName: string | undefined;
            /**
                * <p>The compute and memory capacity of the nodes in the cluster.</p>
                */
            NodeType: string | undefined;
            /**
                * <p>The name of the parameter group associated with the cluster.</p>
                */
            ParameterGroupName?: string;
            /**
                * <p>An optional description of the cluster.</p>
                */
            Description?: string;
            /**
                * <p>The number of shards the cluster will contain. The default value is 1. </p>
                */
            NumShards?: number;
            /**
                * <p>The number of replicas to apply to each shard. The default value is 1. The maximum is 5. </p>
                */
            NumReplicasPerShard?: number;
            /**
                * <p>The name of the subnet group to be used for the cluster.</p>
                */
            SubnetGroupName?: string;
            /**
                * <p>A list of security group names to associate with this cluster.</p>
                */
            SecurityGroupIds?: string[];
            /**
                * <p>Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format <code>ddd:hh24:mi-ddd:hh24:mi</code> (24H Clock UTC). The minimum maintenance window is a 60 minute period.</p>
                */
            MaintenanceWindow?: string;
            /**
                * <p>The port number on which each of the nodes accepts connections.</p>
                */
            Port?: number;
            /**
                * <p>The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (SNS) topic to which notifications are sent.</p>
                */
            SnsTopicArn?: string;
            /**
                * <p>A flag to enable in-transit encryption on the cluster.</p>
                */
            TLSEnabled?: boolean;
            /**
                * <p>The ID of the KMS key used to encrypt the cluster.</p>
                */
            KmsKeyId?: string;
            /**
                * <p>A list of Amazon Resource Names (ARN) that uniquely identify the RDB snapshot files stored in Amazon S3. The snapshot files are used to populate the new cluster. The Amazon S3 object name in the ARN cannot contain any commas.</p>
                */
            SnapshotArns?: string[];
            /**
                * <p>The name of a snapshot from which to restore data into the new cluster. The snapshot status changes to restoring while the new cluster is being created.</p>
                */
            SnapshotName?: string;
            /**
                * <p>The number of days for which MemoryDB retains automatic snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot that was taken today is retained for 5 days before being deleted.</p>
                */
            SnapshotRetentionLimit?: number;
            /**
                * <p>A list of tags to be added to this resource. Tags are comma-separated key,value pairs (e.g. Key=myKey, Value=myKeyValue. You can include multiple tags as shown following: Key=myKey, Value=myKeyValue Key=mySecondKey, Value=mySecondKeyValue.</p>
                */
            Tags?: Tag[];
            /**
                * <p>The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of your shard.</p>
                *
                *          <p>    Example: 05:00-09:00</p>
                *
                *          <p>    If you do not specify this parameter, MemoryDB automatically chooses an appropriate time range.</p>
                */
            SnapshotWindow?: string;
            /**
                * <p>The name of the Access Control List to associate with the cluster.</p>
                */
            ACLName: string | undefined;
            /**
                * <p>The version number of the Redis engine to be used for the cluster.</p>
                */
            EngineVersion?: string;
            /**
                * <p>When set to true, the cluster will automatically receive minor engine version upgrades after launch.</p>
                */
            AutoMinorVersionUpgrade?: boolean;
    }
    export namespace CreateClusterRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateClusterRequest) => any;
    }
    export interface CreateClusterResponse {
            /**
                * <p>The newly-created cluster.</p>
                */
            Cluster?: Cluster;
    }
    export namespace CreateClusterResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateClusterResponse) => any;
    }
    /**
        * <p></p>
        */
    export class InsufficientClusterCapacityFault extends __BaseException {
            readonly name: "InsufficientClusterCapacityFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InsufficientClusterCapacityFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class InvalidACLStateFault extends __BaseException {
            readonly name: "InvalidACLStateFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidACLStateFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class InvalidCredentialsException extends __BaseException {
            readonly name: "InvalidCredentialsException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidCredentialsException, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class InvalidVPCNetworkStateFault extends __BaseException {
            readonly name: "InvalidVPCNetworkStateFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidVPCNetworkStateFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class NodeQuotaForClusterExceededFault extends __BaseException {
            readonly name: "NodeQuotaForClusterExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NodeQuotaForClusterExceededFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class NodeQuotaForCustomerExceededFault extends __BaseException {
            readonly name: "NodeQuotaForCustomerExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NodeQuotaForCustomerExceededFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class ParameterGroupNotFoundFault extends __BaseException {
            readonly name: "ParameterGroupNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ParameterGroupNotFoundFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class ShardsPerClusterQuotaExceededFault extends __BaseException {
            readonly name: "ShardsPerClusterQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ShardsPerClusterQuotaExceededFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class SubnetGroupNotFoundFault extends __BaseException {
            readonly name: "SubnetGroupNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SubnetGroupNotFoundFault, __BaseException>);
    }
    export interface CreateParameterGroupRequest {
            /**
                * <p>The name of the parameter group.</p>
                */
            ParameterGroupName: string | undefined;
            /**
                * <p>The name of the parameter group family that the parameter group can be used with.</p>
                */
            Family: string | undefined;
            /**
                * <p>An optional description of the parameter group.</p>
                */
            Description?: string;
            /**
                * <p>A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.</p>
                */
            Tags?: Tag[];
    }
    export namespace CreateParameterGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateParameterGroupRequest) => any;
    }
    /**
        * <p>Represents the output of a CreateParameterGroup operation. A parameter group represents a combination of specific values for the parameters that are passed to the engine software during startup.</p>
        */
    export interface ParameterGroup {
            /**
                * <p>The name of the parameter group</p>
                */
            Name?: string;
            /**
                * <p>The name of the parameter group family that this  parameter group is compatible with.</p>
                */
            Family?: string;
            /**
                * <p>A description of the parameter group</p>
                */
            Description?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the parameter group</p>
                */
            ARN?: string;
    }
    export namespace ParameterGroup {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ParameterGroup) => any;
    }
    export interface CreateParameterGroupResponse {
            /**
                * <p>The newly-created parameter group.</p>
                */
            ParameterGroup?: ParameterGroup;
    }
    export namespace CreateParameterGroupResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateParameterGroupResponse) => any;
    }
    /**
        * <p></p>
        */
    export class InvalidParameterGroupStateFault extends __BaseException {
            readonly name: "InvalidParameterGroupStateFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidParameterGroupStateFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class ParameterGroupAlreadyExistsFault extends __BaseException {
            readonly name: "ParameterGroupAlreadyExistsFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ParameterGroupAlreadyExistsFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class ParameterGroupQuotaExceededFault extends __BaseException {
            readonly name: "ParameterGroupQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ParameterGroupQuotaExceededFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class ClusterNotFoundFault extends __BaseException {
            readonly name: "ClusterNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ClusterNotFoundFault, __BaseException>);
    }
    export interface CreateSnapshotRequest {
            /**
                * <p>The snapshot is created from this cluster.</p>
                */
            ClusterName: string | undefined;
            /**
                * <p>A name for the snapshot being created.</p>
                */
            SnapshotName: string | undefined;
            /**
                * <p>The ID of the KMS key used to encrypt the snapshot.</p>
                */
            KmsKeyId?: string;
            /**
                * <p>A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.</p>
                */
            Tags?: Tag[];
    }
    export namespace CreateSnapshotRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateSnapshotRequest) => any;
    }
    export interface CreateSnapshotResponse {
            /**
                * <p>The newly-created snapshot.</p>
                */
            Snapshot?: Snapshot;
    }
    export namespace CreateSnapshotResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateSnapshotResponse) => any;
    }
    /**
        * <p></p>
        */
    export class InvalidClusterStateFault extends __BaseException {
            readonly name: "InvalidClusterStateFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidClusterStateFault, __BaseException>);
    }
    export interface CreateSubnetGroupRequest {
            /**
                * <p>The name of the subnet group.</p>
                */
            SubnetGroupName: string | undefined;
            /**
                * <p>A description for the subnet group.</p>
                */
            Description?: string;
            /**
                * <p>A list of VPC subnet IDs for the subnet group.</p>
                */
            SubnetIds: string[] | undefined;
            /**
                * <p>A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.</p>
                */
            Tags?: Tag[];
    }
    export namespace CreateSubnetGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateSubnetGroupRequest) => any;
    }
    /**
        * <p>Indicates if the cluster has a Multi-AZ configuration (multiaz) or not (singleaz).</p>
        */
    export interface AvailabilityZone {
            /**
                * <p>The name of the Availability Zone.</p>
                */
            Name?: string;
    }
    export namespace AvailabilityZone {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AvailabilityZone) => any;
    }
    /**
        * <p>Represents the subnet associated with a cluster. This parameter refers to subnets defined in Amazon Virtual Private Cloud (Amazon VPC) and used with MemoryDB.</p>
        */
    export interface Subnet {
            /**
                * <p>The unique identifier for the subnet.</p>
                */
            Identifier?: string;
            /**
                * <p>The Availability Zone where the subnet resides</p>
                */
            AvailabilityZone?: AvailabilityZone;
    }
    export namespace Subnet {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Subnet) => any;
    }
    /**
        * <p>Represents the output of one of the following operations:</p>
        *          <ul>
        *             <li>
        *                <p>CreateSubnetGroup</p>
        *             </li>
        *             <li>
        *                <p>UpdateSubnetGroup</p>
        *             </li>
        *          </ul>
        *          <p>A subnet group is a collection of subnets (typically private) that you can designate for your clusters running in an Amazon Virtual Private Cloud (VPC) environment.</p>
        */
    export interface SubnetGroup {
            /**
                * <p>The name of the subnet group</p>
                */
            Name?: string;
            /**
                * <p>A description of the subnet group</p>
                */
            Description?: string;
            /**
                * <p>The Amazon Virtual Private Cloud identifier (VPC ID) of the subnet group.</p>
                */
            VpcId?: string;
            /**
                * <p>A list of subnets associated with the subnet group.</p>
                */
            Subnets?: Subnet[];
            /**
                * <p>The ARN (Amazon Resource Name) of the subnet group.</p>
                */
            ARN?: string;
    }
    export namespace SubnetGroup {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SubnetGroup) => any;
    }
    export interface CreateSubnetGroupResponse {
            /**
                * <p>The newly-created subnet group</p>
                */
            SubnetGroup?: SubnetGroup;
    }
    export namespace CreateSubnetGroupResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateSubnetGroupResponse) => any;
    }
    /**
        * <p></p>
        */
    export class InvalidSubnet extends __BaseException {
            readonly name: "InvalidSubnet";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidSubnet, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class SubnetGroupAlreadyExistsFault extends __BaseException {
            readonly name: "SubnetGroupAlreadyExistsFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SubnetGroupAlreadyExistsFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class SubnetGroupQuotaExceededFault extends __BaseException {
            readonly name: "SubnetGroupQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SubnetGroupQuotaExceededFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class SubnetNotAllowedFault extends __BaseException {
            readonly name: "SubnetNotAllowedFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SubnetNotAllowedFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class SubnetQuotaExceededFault extends __BaseException {
            readonly name: "SubnetQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SubnetQuotaExceededFault, __BaseException>);
    }
    export enum InputAuthenticationType {
            PASSWORD = "password"
    }
    /**
        * <p>Denotes the user's authentication properties, such as whether it requires a password to authenticate. Used in output responses.</p>
        */
    export interface AuthenticationMode {
            /**
                * <p>Indicates whether the user requires a password to authenticate. All newly-created users require a password.</p>
                */
            Type?: InputAuthenticationType | string;
            /**
                * <p>The password(s) used for authentication</p>
                */
            Passwords?: string[];
    }
    export namespace AuthenticationMode {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AuthenticationMode) => any;
    }
    export interface CreateUserRequest {
            /**
                * <p>The name of the user. This value must be unique as it also serves as the user identifier.</p>
                */
            UserName: string | undefined;
            /**
                * <p>Denotes the user's authentication properties, such as whether it requires a password to authenticate.</p>
                */
            AuthenticationMode: AuthenticationMode | undefined;
            /**
                * <p>Access permissions string used for this user.</p>
                */
            AccessString: string | undefined;
            /**
                * <p>A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.</p>
                */
            Tags?: Tag[];
    }
    export namespace CreateUserRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateUserRequest) => any;
    }
    export enum AuthenticationType {
            NO_PASSWORD = "no-password",
            PASSWORD = "password"
    }
    /**
        * <p>Denotes the user's authentication properties, such as whether it requires a password to authenticate. Used in output responses.</p>
        */
    export interface Authentication {
            /**
                * <p>Indicates whether the user requires a password to authenticate.</p>
                */
            Type?: AuthenticationType | string;
            /**
                * <p>The number of passwords belonging to the user. The maximum is two.</p>
                */
            PasswordCount?: number;
    }
    export namespace Authentication {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Authentication) => any;
    }
    /**
        * <p>You create users and assign them specific permissions by using an access string. You assign the users to Access Control Lists aligned with a specific role (administrators, human resources) that are then deployed to one or more MemoryDB clusters.</p>
        */
    export interface User {
            /**
                * <p>The name of the user</p>
                */
            Name?: string;
            /**
                * <p>Indicates the user status. Can be "active", "modifying" or "deleting".</p>
                */
            Status?: string;
            /**
                * <p>Access permissions string used for this user.</p>
                */
            AccessString?: string;
            /**
                * <p>The names of the Access Control Lists to which the user belongs</p>
                */
            ACLNames?: string[];
            /**
                * <p>The minimum engine version supported for the user</p>
                */
            MinimumEngineVersion?: string;
            /**
                * <p>Denotes whether the user requires a password to authenticate.</p>
                */
            Authentication?: Authentication;
            /**
                * <p>The Amazon Resource Name (ARN) of the user.
                *
                *       </p>
                */
            ARN?: string;
    }
    export namespace User {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: User) => any;
    }
    export interface CreateUserResponse {
            /**
                * <p>The newly-created user.</p>
                */
            User?: User;
    }
    export namespace CreateUserResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateUserResponse) => any;
    }
    /**
        * <p></p>
        */
    export class UserAlreadyExistsFault extends __BaseException {
            readonly name: "UserAlreadyExistsFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UserAlreadyExistsFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class UserQuotaExceededFault extends __BaseException {
            readonly name: "UserQuotaExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UserQuotaExceededFault, __BaseException>);
    }
    export interface DeleteACLRequest {
            /**
                * <p>The name of the Access Control List to delete</p>
                */
            ACLName: string | undefined;
    }
    export namespace DeleteACLRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteACLRequest) => any;
    }
    export interface DeleteACLResponse {
            /**
                * <p>The Access Control List object that has been deleted.</p>
                */
            ACL?: ACL;
    }
    export namespace DeleteACLResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteACLResponse) => any;
    }
    export interface DeleteClusterRequest {
            /**
                * <p>The name of the cluster to be deleted</p>
                */
            ClusterName: string | undefined;
            /**
                * <p>The user-supplied name of a final cluster snapshot. This is the unique name that identifies the snapshot. MemoryDB creates the snapshot, and then deletes the cluster immediately afterward.</p>
                */
            FinalSnapshotName?: string;
    }
    export namespace DeleteClusterRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteClusterRequest) => any;
    }
    export interface DeleteClusterResponse {
            /**
                * <p>The cluster object that has been deleted</p>
                */
            Cluster?: Cluster;
    }
    export namespace DeleteClusterResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteClusterResponse) => any;
    }
    export interface DeleteParameterGroupRequest {
            /**
                * <p>The name of the parameter group to delete.</p>
                */
            ParameterGroupName: string | undefined;
    }
    export namespace DeleteParameterGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteParameterGroupRequest) => any;
    }
    export interface DeleteParameterGroupResponse {
            /**
                * <p>The parameter group that has been deleted.</p>
                */
            ParameterGroup?: ParameterGroup;
    }
    export namespace DeleteParameterGroupResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteParameterGroupResponse) => any;
    }
    export interface DeleteSnapshotRequest {
            /**
                * <p>The name of the snapshot to delete</p>
                */
            SnapshotName: string | undefined;
    }
    export namespace DeleteSnapshotRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteSnapshotRequest) => any;
    }
    export interface DeleteSnapshotResponse {
            /**
                * <p>The snapshot object that has been deleted.</p>
                */
            Snapshot?: Snapshot;
    }
    export namespace DeleteSnapshotResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteSnapshotResponse) => any;
    }
    export interface DeleteSubnetGroupRequest {
            /**
                * <p>The name of the subnet group to delete</p>
                */
            SubnetGroupName: string | undefined;
    }
    export namespace DeleteSubnetGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteSubnetGroupRequest) => any;
    }
    export interface DeleteSubnetGroupResponse {
            /**
                * <p>The subnet group object that has been deleted.</p>
                */
            SubnetGroup?: SubnetGroup;
    }
    export namespace DeleteSubnetGroupResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteSubnetGroupResponse) => any;
    }
    /**
        * <p></p>
        */
    export class SubnetGroupInUseFault extends __BaseException {
            readonly name: "SubnetGroupInUseFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SubnetGroupInUseFault, __BaseException>);
    }
    export interface DeleteUserRequest {
            /**
                * <p>The name of the user to delete</p>
                */
            UserName: string | undefined;
    }
    export namespace DeleteUserRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteUserRequest) => any;
    }
    export interface DeleteUserResponse {
            /**
                * <p>The user object that has been deleted.</p>
                */
            User?: User;
    }
    export namespace DeleteUserResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteUserResponse) => any;
    }
    /**
        * <p></p>
        */
    export class InvalidUserStateFault extends __BaseException {
            readonly name: "InvalidUserStateFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidUserStateFault, __BaseException>);
    }
    export interface DescribeACLsRequest {
            /**
                * <p>The name of the ACL</p>
                */
            ACLName?: string;
            /**
                * <p>The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.</p>
                */
            MaxResults?: number;
            /**
                * <p>An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. </p>
                */
            NextToken?: string;
    }
    export namespace DescribeACLsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeACLsRequest) => any;
    }
    export interface DescribeACLsResponse {
            /**
                * <p>The list of ACLs</p>
                */
            ACLs?: ACL[];
            /**
                * <p>If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. </p>
                */
            NextToken?: string;
    }
    export namespace DescribeACLsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeACLsResponse) => any;
    }
    export interface DescribeClustersRequest {
            /**
                * <p>The name of the cluster</p>
                */
            ClusterName?: string;
            /**
                * <p>The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.</p>
                */
            MaxResults?: number;
            /**
                * <p>An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. </p>
                */
            NextToken?: string;
            /**
                * <p>An optional flag that can be included in the request to retrieve information about the individual shard(s).</p>
                */
            ShowShardDetails?: boolean;
    }
    export namespace DescribeClustersRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeClustersRequest) => any;
    }
    export interface DescribeClustersResponse {
            /**
                * <p>An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. </p>
                */
            NextToken?: string;
            /**
                * <p>A list of clusters</p>
                */
            Clusters?: Cluster[];
    }
    export namespace DescribeClustersResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeClustersResponse) => any;
    }
    export interface DescribeEngineVersionsRequest {
            /**
                * <p>The Redis engine version</p>
                */
            EngineVersion?: string;
            /**
                * <p>The name of a specific parameter group family to return details for.</p>
                */
            ParameterGroupFamily?: string;
            /**
                * <p>The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.</p>
                */
            MaxResults?: number;
            /**
                * <p>An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. </p>
                */
            NextToken?: string;
            /**
                * <p>If true, specifies that only the default version of the specified engine or engine and major version combination is to be returned.</p>
                */
            DefaultOnly?: boolean;
    }
    export namespace DescribeEngineVersionsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeEngineVersionsRequest) => any;
    }
    /**
        * <p>Provides details of the Redis engine version</p>
        */
    export interface EngineVersionInfo {
            /**
                * <p>The engine version</p>
                */
            EngineVersion?: string;
            /**
                * <p>The patched engine version</p>
                */
            EnginePatchVersion?: string;
            /**
                * <p>Specifies the name of the parameter group family to which the engine default parameters apply.</p>
                */
            ParameterGroupFamily?: string;
    }
    export namespace EngineVersionInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EngineVersionInfo) => any;
    }
    export interface DescribeEngineVersionsResponse {
            /**
                * <p>An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. </p>
                */
            NextToken?: string;
            /**
                * <p>A list of engine version details. Each element in the list contains detailed information about one engine version.</p>
                */
            EngineVersions?: EngineVersionInfo[];
    }
    export namespace DescribeEngineVersionsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeEngineVersionsResponse) => any;
    }
    export enum SourceType {
            acl = "acl",
            cluster = "cluster",
            node = "node",
            parameter_group = "parameter-group",
            subnet_group = "subnet-group",
            user = "user"
    }
    export interface DescribeEventsRequest {
            /**
                * <p>The identifier of the event source for which events are returned. If not specified, all sources are included in the response.</p>
                */
            SourceName?: string;
            /**
                * <p>The event source to retrieve events for. If no value is specified, all events are returned.</p>
                */
            SourceType?: SourceType | string;
            /**
                * <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format.
                *
                *          Example: 2017-03-30T07:03:49.555Z</p>
                */
            StartTime?: Date;
            /**
                * <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format.
                *
                *          Example: 2017-03-30T07:03:49.555Z</p>
                */
            EndTime?: Date;
            /**
                * <p>The number of minutes worth of events to retrieve.</p>
                */
            Duration?: number;
            /**
                * <p>The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.</p>
                */
            MaxResults?: number;
            /**
                * <p>An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. </p>
                */
            NextToken?: string;
    }
    export namespace DescribeEventsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeEventsRequest) => any;
    }
    /**
        * <p>Represents a single occurrence of something interesting within the system. Some examples of events are creating a cluster or adding or removing a
        *          node.</p>
        */
    export interface Event {
            /**
                * <p>The name for the source of the event. For example, if the event occurred at the cluster level, the identifier would be the name of the cluster.</p>
                */
            SourceName?: string;
            /**
                * <p>Specifies the origin of this event - a cluster, a parameter group, a security group, etc.</p>
                */
            SourceType?: SourceType | string;
            /**
                * <p>The text of the event.</p>
                */
            Message?: string;
            /**
                * <p>The date and time when the event occurred.</p>
                */
            Date?: Date;
    }
    export namespace Event {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Event) => any;
    }
    export interface DescribeEventsResponse {
            /**
                * <p>An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. </p>
                */
            NextToken?: string;
            /**
                * <p>A list of events. Each element in the list contains detailed information about one event.</p>
                */
            Events?: Event[];
    }
    export namespace DescribeEventsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeEventsResponse) => any;
    }
    export interface DescribeParameterGroupsRequest {
            /**
                * <p>The name of a specific  parameter group to return details for.</p>
                */
            ParameterGroupName?: string;
            /**
                * <p>The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.</p>
                */
            MaxResults?: number;
            /**
                * <p>An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. </p>
                */
            NextToken?: string;
    }
    export namespace DescribeParameterGroupsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeParameterGroupsRequest) => any;
    }
    export interface DescribeParameterGroupsResponse {
            /**
                * <p>An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. </p>
                */
            NextToken?: string;
            /**
                * <p>A list of parameter groups. Each element in the list contains detailed information about one parameter group.</p>
                */
            ParameterGroups?: ParameterGroup[];
    }
    export namespace DescribeParameterGroupsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeParameterGroupsResponse) => any;
    }
    export interface DescribeParametersRequest {
            /**
                * <p>he name of a specific  parameter group to return details for.</p>
                */
            ParameterGroupName: string | undefined;
            /**
                * <p>The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.</p>
                */
            MaxResults?: number;
            /**
                * <p>An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. </p>
                */
            NextToken?: string;
    }
    export namespace DescribeParametersRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeParametersRequest) => any;
    }
    /**
        * <p>Describes an individual setting that controls some aspect of MemoryDB behavior.</p>
        */
    export interface Parameter {
            /**
                * <p>The name of the parameter</p>
                */
            Name?: string;
            /**
                * <p>The value of the parameter</p>
                */
            Value?: string;
            /**
                * <p>A description of the parameter</p>
                */
            Description?: string;
            /**
                * <p>The parameter's data type</p>
                */
            DataType?: string;
            /**
                * <p>The valid range of values for the parameter.</p>
                */
            AllowedValues?: string;
            /**
                * <p>The earliest engine version to which the parameter can apply.</p>
                */
            MinimumEngineVersion?: string;
    }
    export namespace Parameter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Parameter) => any;
    }
    export interface DescribeParametersResponse {
            /**
                * <p>An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. </p>
                */
            NextToken?: string;
            /**
                * <p>A list of parameters specific to a particular parameter group. Each element in the list contains detailed information about one parameter.</p>
                */
            Parameters?: Parameter[];
    }
    export namespace DescribeParametersResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeParametersResponse) => any;
    }
    export interface DescribeServiceUpdatesRequest {
            /**
                * <p>The unique ID of the service update to describe.</p>
                */
            ServiceUpdateName?: string;
            /**
                * <p>The list of cluster names to identify service updates to apply</p>
                */
            ClusterNames?: string[];
            /**
                * <p>The status(es) of the service updates to filter on</p>
                */
            Status?: (ServiceUpdateStatus | string)[];
            /**
                * <p>The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.</p>
                */
            MaxResults?: number;
            /**
                * <p>An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. </p>
                */
            NextToken?: string;
    }
    export namespace DescribeServiceUpdatesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeServiceUpdatesRequest) => any;
    }
    export enum ServiceUpdateType {
            SECURITY_UPDATE = "security-update"
    }
    /**
        * <p>An update that you can apply to your MemoryDB clusters.</p>
        */
    export interface ServiceUpdate {
            /**
                * <p>The name of the cluster to which the service update applies</p>
                */
            ClusterName?: string;
            /**
                * <p>The unique ID of the service update</p>
                */
            ServiceUpdateName?: string;
            /**
                * <p>The date when the service update is initially available</p>
                */
            ReleaseDate?: Date;
            /**
                * <p>Provides details of the service update</p>
                */
            Description?: string;
            /**
                * <p>The status of the service update</p>
                */
            Status?: ServiceUpdateStatus | string;
            /**
                * <p>Reflects the nature of the service update</p>
                */
            Type?: ServiceUpdateType | string;
            /**
                * <p>A list of nodes updated by the service update</p>
                */
            NodesUpdated?: string;
            /**
                * <p>The date at which the service update will be automatically applied</p>
                */
            AutoUpdateStartDate?: Date;
    }
    export namespace ServiceUpdate {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ServiceUpdate) => any;
    }
    export interface DescribeServiceUpdatesResponse {
            /**
                * <p>An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. </p>
                */
            NextToken?: string;
            /**
                * <p>A list of service updates</p>
                */
            ServiceUpdates?: ServiceUpdate[];
    }
    export namespace DescribeServiceUpdatesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeServiceUpdatesResponse) => any;
    }
    export interface DescribeSnapshotsRequest {
            /**
                * <p>A user-supplied cluster identifier. If this parameter is specified, only snapshots associated with that specific cluster are described.</p>
                */
            ClusterName?: string;
            /**
                * <p>A user-supplied name of the snapshot. If this parameter is specified, only this named snapshot is described.</p>
                */
            SnapshotName?: string;
            /**
                * <p>If set to system, the output shows snapshots that were automatically created by MemoryDB. If set to user the output shows snapshots that were manually created. If omitted, the output shows both automatically and manually created snapshots.</p>
                */
            Source?: string;
            /**
                * <p>An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. </p>
                */
            NextToken?: string;
            /**
                * <p>The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.</p>
                */
            MaxResults?: number;
            /**
                * <p>A Boolean value which if true, the shard configuration is included in the snapshot description.</p>
                */
            ShowDetail?: boolean;
    }
    export namespace DescribeSnapshotsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeSnapshotsRequest) => any;
    }
    export interface DescribeSnapshotsResponse {
            /**
                * <p>An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. </p>
                */
            NextToken?: string;
            /**
                * <p>A list of snapshots. Each item in the list contains detailed information about one snapshot.</p>
                */
            Snapshots?: Snapshot[];
    }
    export namespace DescribeSnapshotsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeSnapshotsResponse) => any;
    }
    export interface DescribeSubnetGroupsRequest {
            /**
                * <p>The name of the subnet group to return details for.</p>
                */
            SubnetGroupName?: string;
            /**
                * <p>The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.</p>
                */
            MaxResults?: number;
            /**
                * <p>An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. </p>
                */
            NextToken?: string;
    }
    export namespace DescribeSubnetGroupsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeSubnetGroupsRequest) => any;
    }
    export interface DescribeSubnetGroupsResponse {
            /**
                * <p>An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. </p>
                */
            NextToken?: string;
            /**
                * <p>A list of subnet groups. Each element in the list contains detailed information about one group.</p>
                */
            SubnetGroups?: SubnetGroup[];
    }
    export namespace DescribeSubnetGroupsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeSubnetGroupsResponse) => any;
    }
    /**
        * <p>Used to streamline results of a search based on the property being filtered.</p>
        */
    export interface Filter {
            /**
                * <p>The property being filtered. For example, UserName.</p>
                */
            Name: string | undefined;
            /**
                * <p>The property values to filter on. For example, "user-123".</p>
                */
            Values: string[] | undefined;
    }
    export namespace Filter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Filter) => any;
    }
    export interface DescribeUsersRequest {
            /**
                * <p>The name of the user</p>
                */
            UserName?: string;
            /**
                * <p>Filter to determine the list of users to return.</p>
                */
            Filters?: Filter[];
            /**
                * <p>The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.</p>
                */
            MaxResults?: number;
            /**
                * <p>An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. </p>
                */
            NextToken?: string;
    }
    export namespace DescribeUsersRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeUsersRequest) => any;
    }
    export interface DescribeUsersResponse {
            /**
                * <p>A list of users.</p>
                */
            Users?: User[];
            /**
                * <p>An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. </p>
                */
            NextToken?: string;
    }
    export namespace DescribeUsersResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeUsersResponse) => any;
    }
    /**
        * <p></p>
        */
    export class APICallRateForCustomerExceededFault extends __BaseException {
            readonly name: "APICallRateForCustomerExceededFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<APICallRateForCustomerExceededFault, __BaseException>);
    }
    export interface FailoverShardRequest {
            /**
                * <p>The cluster being failed over</p>
                */
            ClusterName: string | undefined;
            /**
                * <p>The name of the shard</p>
                */
            ShardName: string | undefined;
    }
    export namespace FailoverShardRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FailoverShardRequest) => any;
    }
    export interface FailoverShardResponse {
            /**
                * <p>The cluster being failed over</p>
                */
            Cluster?: Cluster;
    }
    export namespace FailoverShardResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FailoverShardResponse) => any;
    }
    /**
        * <p></p>
        */
    export class InvalidKMSKeyFault extends __BaseException {
            readonly name: "InvalidKMSKeyFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidKMSKeyFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class ShardNotFoundFault extends __BaseException {
            readonly name: "ShardNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ShardNotFoundFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class TestFailoverNotAvailableFault extends __BaseException {
            readonly name: "TestFailoverNotAvailableFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TestFailoverNotAvailableFault, __BaseException>);
    }
    export interface ListAllowedNodeTypeUpdatesRequest {
            /**
                * <p>The name of the cluster you want to scale. MemoryDB uses the cluster name to identify the current node type being used by this cluster, and from that to create a list of node types
                *          you can scale up to.</p>
                */
            ClusterName: string | undefined;
    }
    export namespace ListAllowedNodeTypeUpdatesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListAllowedNodeTypeUpdatesRequest) => any;
    }
    export interface ListAllowedNodeTypeUpdatesResponse {
            /**
                * <p>A list node types which you can use to scale up your cluster.</p>
                */
            ScaleUpNodeTypes?: string[];
            /**
                * <p>A list node types which you can use to scale down your cluster.</p>
                */
            ScaleDownNodeTypes?: string[];
    }
    export namespace ListAllowedNodeTypeUpdatesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListAllowedNodeTypeUpdatesResponse) => any;
    }
    /**
        * <p></p>
        */
    export class InvalidARNFault extends __BaseException {
            readonly name: "InvalidARNFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidARNFault, __BaseException>);
    }
    export interface ListTagsRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the resource for which you want the list of tags</p>
                */
            ResourceArn: string | undefined;
    }
    export namespace ListTagsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsRequest) => any;
    }
    export interface ListTagsResponse {
            /**
                * <p>A list of tags as key-value pairs.</p>
                */
            TagList?: Tag[];
    }
    export namespace ListTagsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsResponse) => any;
    }
    export interface ResetParameterGroupRequest {
            /**
                * <p>The name of the parameter group to reset.</p>
                */
            ParameterGroupName: string | undefined;
            /**
                * <p>If true, all parameters in the parameter group are reset to their default values. If false, only the parameters listed by ParameterNames are reset to their default values.</p>
                */
            AllParameters?: boolean;
            /**
                * <p>An array of parameter names to reset to their default values. If AllParameters is true, do not use ParameterNames. If AllParameters is false, you must specify the name of at least one parameter to reset.</p>
                */
            ParameterNames?: string[];
    }
    export namespace ResetParameterGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResetParameterGroupRequest) => any;
    }
    export interface ResetParameterGroupResponse {
            /**
                * <p>The parameter group being reset.</p>
                */
            ParameterGroup?: ParameterGroup;
    }
    export namespace ResetParameterGroupResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResetParameterGroupResponse) => any;
    }
    export interface TagResourceRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the resource to which the tags are to be added</p>
                */
            ResourceArn: string | undefined;
            /**
                * <p>A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.</p>
                */
            Tags: Tag[] | undefined;
    }
    export namespace TagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceRequest) => any;
    }
    export interface TagResourceResponse {
            /**
                * <p>A list of tags as key-value pairs.</p>
                */
            TagList?: Tag[];
    }
    export namespace TagResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceResponse) => any;
    }
    /**
        * <p></p>
        */
    export class TagNotFoundFault extends __BaseException {
            readonly name: "TagNotFoundFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TagNotFoundFault, __BaseException>);
    }
    export interface UntagResourceRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the resource to which the tags are to be removed</p>
                */
            ResourceArn: string | undefined;
            /**
                * <p>The list of keys of the tags that are to be removed</p>
                */
            TagKeys: string[] | undefined;
    }
    export namespace UntagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceRequest) => any;
    }
    export interface UntagResourceResponse {
            /**
                * <p>The list of tags removed</p>
                */
            TagList?: Tag[];
    }
    export namespace UntagResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceResponse) => any;
    }
    export interface UpdateACLRequest {
            /**
                * <p>The name of the Access Control List</p>
                */
            ACLName: string | undefined;
            /**
                * <p>The list of users to add to the Access Control List</p>
                */
            UserNamesToAdd?: string[];
            /**
                * <p>The list of users to remove from the Access Control List</p>
                */
            UserNamesToRemove?: string[];
    }
    export namespace UpdateACLRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateACLRequest) => any;
    }
    export interface UpdateACLResponse {
            /**
                * <p>The updated Access Control List</p>
                */
            ACL?: ACL;
    }
    export namespace UpdateACLResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateACLResponse) => any;
    }
    /**
        * <p></p>
        */
    export class InvalidNodeStateFault extends __BaseException {
            readonly name: "InvalidNodeStateFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidNodeStateFault, __BaseException>);
    }
    /**
        * <p></p>
        */
    export class NoOperationFault extends __BaseException {
            readonly name: "NoOperationFault";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NoOperationFault, __BaseException>);
    }
    /**
        * <p>A request to configure the number of replicas in a shard</p>
        */
    export interface ReplicaConfigurationRequest {
            /**
                * <p>The number of replicas to scale up or down to</p>
                */
            ReplicaCount?: number;
    }
    export namespace ReplicaConfigurationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReplicaConfigurationRequest) => any;
    }
    /**
        * <p>A request to configure the sharding properties of a cluster</p>
        */
    export interface ShardConfigurationRequest {
            /**
                * <p>The number of shards in the cluster</p>
                */
            ShardCount?: number;
    }
    export namespace ShardConfigurationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ShardConfigurationRequest) => any;
    }
    export interface UpdateClusterRequest {
            /**
                * <p>The name of the cluster to update</p>
                */
            ClusterName: string | undefined;
            /**
                * <p>The description of the cluster to update</p>
                */
            Description?: string;
            /**
                * <p>The SecurityGroupIds to update</p>
                */
            SecurityGroupIds?: string[];
            /**
                * <p>The maintenance window to update</p>
                */
            MaintenanceWindow?: string;
            /**
                * <p>The SNS topic ARN to update</p>
                */
            SnsTopicArn?: string;
            /**
                * <p>The status of the Amazon SNS notification topic. Notifications are sent only if the status is active.</p>
                */
            SnsTopicStatus?: string;
            /**
                * <p>The name of the parameter group to update</p>
                */
            ParameterGroupName?: string;
            /**
                * <p>The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of your cluster.</p>
                */
            SnapshotWindow?: string;
            /**
                * <p>The number of days for which MemoryDB retains automatic cluster snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot that was taken today is retained for 5 days before being deleted.</p>
                */
            SnapshotRetentionLimit?: number;
            /**
                * <p>A valid node type that you want to scale this cluster up or down to.</p>
                */
            NodeType?: string;
            /**
                * <p>The upgraded version of the engine to be run on the nodes. You can upgrade to a newer engine version, but you cannot downgrade to an earlier engine version. If you want to use an earlier engine version, you must delete the existing cluster and create it anew with the earlier engine version.</p>
                */
            EngineVersion?: string;
            /**
                * <p>The number of replicas that will reside in each shard</p>
                */
            ReplicaConfiguration?: ReplicaConfigurationRequest;
            /**
                * <p>The number of shards in the cluster</p>
                */
            ShardConfiguration?: ShardConfigurationRequest;
            /**
                * <p>The Access Control List that is associated with the cluster</p>
                */
            ACLName?: string;
    }
    export namespace UpdateClusterRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateClusterRequest) => any;
    }
    export interface UpdateClusterResponse {
            /**
                * <p>The updated cluster</p>
                */
            Cluster?: Cluster;
    }
    export namespace UpdateClusterResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateClusterResponse) => any;
    }
    /**
        * <p>Describes a name-value pair that is used to update the value of a parameter.</p>
        */
    export interface ParameterNameValue {
            /**
                * <p>The name of the parameter</p>
                */
            ParameterName?: string;
            /**
                * <p>The value of the parameter</p>
                */
            ParameterValue?: string;
    }
    export namespace ParameterNameValue {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ParameterNameValue) => any;
    }
    export interface UpdateParameterGroupRequest {
            /**
                * <p>The name of the parameter group to update.</p>
                */
            ParameterGroupName: string | undefined;
            /**
                * <p>An array of parameter names and values for the parameter update. You must supply at least one parameter name and value; subsequent arguments are optional. A maximum of 20 parameters may be updated per request.</p>
                */
            ParameterNameValues: ParameterNameValue[] | undefined;
    }
    export namespace UpdateParameterGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateParameterGroupRequest) => any;
    }
    export interface UpdateParameterGroupResponse {
            /**
                * <p>The updated parameter group</p>
                */
            ParameterGroup?: ParameterGroup;
    }
    export namespace UpdateParameterGroupResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateParameterGroupResponse) => any;
    }
    /**
        * <p></p>
        */
    export class SubnetInUse extends __BaseException {
            readonly name: "SubnetInUse";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<SubnetInUse, __BaseException>);
    }
    export interface UpdateSubnetGroupRequest {
            /**
                * <p>The name of the subnet group</p>
                */
            SubnetGroupName: string | undefined;
            /**
                * <p>A description of the subnet group</p>
                */
            Description?: string;
            /**
                * <p>The EC2 subnet IDs for the subnet group.</p>
                */
            SubnetIds?: string[];
    }
    export namespace UpdateSubnetGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateSubnetGroupRequest) => any;
    }
    export interface UpdateSubnetGroupResponse {
            /**
                * <p>The updated subnet group</p>
                */
            SubnetGroup?: SubnetGroup;
    }
    export namespace UpdateSubnetGroupResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateSubnetGroupResponse) => any;
    }
    export interface UpdateUserRequest {
            /**
                * <p>The name of the user</p>
                */
            UserName: string | undefined;
            /**
                * <p>Denotes the user's authentication properties, such as whether it requires a password to authenticate.</p>
                */
            AuthenticationMode?: AuthenticationMode;
            /**
                * <p>Access permissions string used for this user.</p>
                */
            AccessString?: string;
    }
    export namespace UpdateUserRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateUserRequest) => any;
    }
    export interface UpdateUserResponse {
            /**
                * <p>The updated user</p>
                */
            User?: User;
    }
    export namespace UpdateUserResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateUserResponse) => any;
    }
}

declare module '@aws-sdk/client-memorydb/node_modules/@aws-sdk/client-memorydb/dist-types/models/MemoryDBServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from MemoryDB service.
        */
    export class MemoryDBServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

