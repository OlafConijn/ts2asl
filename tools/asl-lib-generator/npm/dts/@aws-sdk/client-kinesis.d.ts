// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/smithy-client
//   @aws-sdk/config-resolver
//   @aws-sdk/eventstream-serde-config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http

declare module '@aws-sdk/client-kinesis' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { AddTagsToStreamCommandInput, AddTagsToStreamCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/AddTagsToStreamCommand";
    import { CreateStreamCommandInput, CreateStreamCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/CreateStreamCommand";
    import { DecreaseStreamRetentionPeriodCommandInput, DecreaseStreamRetentionPeriodCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DecreaseStreamRetentionPeriodCommand";
    import { DeleteStreamCommandInput, DeleteStreamCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DeleteStreamCommand";
    import { DeregisterStreamConsumerCommandInput, DeregisterStreamConsumerCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DeregisterStreamConsumerCommand";
    import { DescribeLimitsCommandInput, DescribeLimitsCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DescribeLimitsCommand";
    import { DescribeStreamCommandInput, DescribeStreamCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DescribeStreamCommand";
    import { DescribeStreamConsumerCommandInput, DescribeStreamConsumerCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DescribeStreamConsumerCommand";
    import { DescribeStreamSummaryCommandInput, DescribeStreamSummaryCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DescribeStreamSummaryCommand";
    import { DisableEnhancedMonitoringCommandInput, DisableEnhancedMonitoringCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DisableEnhancedMonitoringCommand";
    import { EnableEnhancedMonitoringCommandInput, EnableEnhancedMonitoringCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/EnableEnhancedMonitoringCommand";
    import { GetRecordsCommandInput, GetRecordsCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/GetRecordsCommand";
    import { GetShardIteratorCommandInput, GetShardIteratorCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/GetShardIteratorCommand";
    import { IncreaseStreamRetentionPeriodCommandInput, IncreaseStreamRetentionPeriodCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/IncreaseStreamRetentionPeriodCommand";
    import { ListShardsCommandInput, ListShardsCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/ListShardsCommand";
    import { ListStreamConsumersCommandInput, ListStreamConsumersCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/ListStreamConsumersCommand";
    import { ListStreamsCommandInput, ListStreamsCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/ListStreamsCommand";
    import { ListTagsForStreamCommandInput, ListTagsForStreamCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/ListTagsForStreamCommand";
    import { MergeShardsCommandInput, MergeShardsCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/MergeShardsCommand";
    import { PutRecordCommandInput, PutRecordCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/PutRecordCommand";
    import { PutRecordsCommandInput, PutRecordsCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/PutRecordsCommand";
    import { RegisterStreamConsumerCommandInput, RegisterStreamConsumerCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/RegisterStreamConsumerCommand";
    import { RemoveTagsFromStreamCommandInput, RemoveTagsFromStreamCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/RemoveTagsFromStreamCommand";
    import { SplitShardCommandInput, SplitShardCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/SplitShardCommand";
    import { StartStreamEncryptionCommandInput, StartStreamEncryptionCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/StartStreamEncryptionCommand";
    import { StopStreamEncryptionCommandInput, StopStreamEncryptionCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/StopStreamEncryptionCommand";
    import { SubscribeToShardCommandInput, SubscribeToShardCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/SubscribeToShardCommand";
    import { UpdateShardCountCommandInput, UpdateShardCountCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/UpdateShardCountCommand";
    import { UpdateStreamModeCommandInput, UpdateStreamModeCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/UpdateStreamModeCommand";
    import { KinesisClient } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    /**
        * <fullname>Amazon Kinesis Data Streams Service API Reference</fullname>
        *         <p>Amazon Kinesis Data Streams is a managed service that scales elastically for real-time
        *             processing of streaming big data.</p>
        */
    export class Kinesis extends KinesisClient {
            /**
                * <p>Adds or updates tags for the specified Kinesis data stream. You can assign up to 50
                *             tags to a data stream.</p>
                *         <p>If tags have already been assigned to the stream, <code>AddTagsToStream</code>
                *             overwrites any existing tags that correspond to the specified tag keys.</p>
                *         <p>
                *             <a>AddTagsToStream</a> has a limit of five transactions per second per
                *             account.</p>
                */
            addTagsToStream(args: AddTagsToStreamCommandInput, options?: __HttpHandlerOptions): Promise<AddTagsToStreamCommandOutput>;
            addTagsToStream(args: AddTagsToStreamCommandInput, cb: (err: any, data?: AddTagsToStreamCommandOutput) => void): void;
            addTagsToStream(args: AddTagsToStreamCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AddTagsToStreamCommandOutput) => void): void;
            /**
                * <p>Creates a Kinesis data stream. A stream captures and transports data records that are
                *             continuously emitted from different data sources or <i>producers</i>.
                *             Scale-out within a stream is explicitly supported by means of shards, which are uniquely
                *             identified groups of data records in a stream.</p>
                *         <p>You specify and control the number of shards that a stream is composed of. Each shard
                *             can support reads up to five transactions per second, up to a maximum data read total of
                *             2 MiB per second. Each shard can support writes up to 1,000 records per second, up to a
                *             maximum data write total of 1 MiB per second. If the amount of data input increases or
                *             decreases, you can add or remove shards.</p>
                *         <p>The stream name identifies the stream. The name is scoped to the Amazon Web Services
                *             account used by the application. It is also scoped by Amazon Web Services Region. That
                *             is, two streams in two different accounts can have the same name, and two streams in the
                *             same account, but in two different Regions, can have the same name.</p>
                *         <p>
                *             <code>CreateStream</code> is an asynchronous operation. Upon receiving a
                *                 <code>CreateStream</code> request, Kinesis Data Streams immediately returns and sets
                *             the stream status to <code>CREATING</code>. After the stream is created, Kinesis Data
                *             Streams sets the stream status to <code>ACTIVE</code>. You should perform read and write
                *             operations only on an <code>ACTIVE</code> stream. </p>
                *         <p>You receive a <code>LimitExceededException</code> when making a
                *                 <code>CreateStream</code> request when you try to do one of the following:</p>
                *         <ul>
                *             <li>
                *
                *                 <p>Have more than five streams in the <code>CREATING</code> state at any point in
                *                     time.</p>
                *             </li>
                *             <li>
                *
                *                 <p>Create more shards than are authorized for your account.</p>
                *             </li>
                *          </ul>
                *         <p>For the default shard limit for an Amazon Web Services account, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/service-sizes-and-limits.html">Amazon
                *                 Kinesis Data Streams Limits</a> in the <i>Amazon Kinesis Data Streams
                *                 Developer Guide</i>. To increase this limit, <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html">contact Amazon Web Services
                *                 Support</a>.</p>
                *         <p>You can use <a>DescribeStreamSummary</a> to check the stream status, which
                *             is returned in <code>StreamStatus</code>.</p>
                *         <p>
                *             <a>CreateStream</a> has a limit of five transactions per second per
                *             account.</p>
                */
            createStream(args: CreateStreamCommandInput, options?: __HttpHandlerOptions): Promise<CreateStreamCommandOutput>;
            createStream(args: CreateStreamCommandInput, cb: (err: any, data?: CreateStreamCommandOutput) => void): void;
            createStream(args: CreateStreamCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateStreamCommandOutput) => void): void;
            /**
                * <p>Decreases the Kinesis data stream's retention period, which is the length of time data
                *             records are accessible after they are added to the stream. The minimum value of a
                *             stream's retention period is 24 hours.</p>
                *         <p>This operation may result in lost data. For example, if the stream's retention period
                *             is 48 hours and is decreased to 24 hours, any data already in the stream that is older
                *             than 24 hours is inaccessible.</p>
                */
            decreaseStreamRetentionPeriod(args: DecreaseStreamRetentionPeriodCommandInput, options?: __HttpHandlerOptions): Promise<DecreaseStreamRetentionPeriodCommandOutput>;
            decreaseStreamRetentionPeriod(args: DecreaseStreamRetentionPeriodCommandInput, cb: (err: any, data?: DecreaseStreamRetentionPeriodCommandOutput) => void): void;
            decreaseStreamRetentionPeriod(args: DecreaseStreamRetentionPeriodCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DecreaseStreamRetentionPeriodCommandOutput) => void): void;
            /**
                * <p>Deletes a Kinesis data stream and all its shards and data. You must shut down any
                *             applications that are operating on the stream before you delete the stream. If an
                *             application attempts to operate on a deleted stream, it receives the exception
                *                 <code>ResourceNotFoundException</code>.</p>
                *         <p>If the stream is in the <code>ACTIVE</code> state, you can delete it. After a
                *                 <code>DeleteStream</code> request, the specified stream is in the
                *                 <code>DELETING</code> state until Kinesis Data Streams completes the
                *             deletion.</p>
                *         <p>
                *             <b>Note:</b> Kinesis Data Streams might continue to accept
                *             data read and write operations, such as <a>PutRecord</a>, <a>PutRecords</a>, and <a>GetRecords</a>, on a stream in the
                *                 <code>DELETING</code> state until the stream deletion is complete.</p>
                *         <p>When you delete a stream, any shards in that stream are also deleted, and any tags are
                *             dissociated from the stream.</p>
                *         <p>You can use the <a>DescribeStreamSummary</a> operation to check the state
                *             of the stream, which is returned in <code>StreamStatus</code>.</p>
                *
                *         <p>
                *             <a>DeleteStream</a> has a limit of five transactions per second per
                *             account.</p>
                */
            deleteStream(args: DeleteStreamCommandInput, options?: __HttpHandlerOptions): Promise<DeleteStreamCommandOutput>;
            deleteStream(args: DeleteStreamCommandInput, cb: (err: any, data?: DeleteStreamCommandOutput) => void): void;
            deleteStream(args: DeleteStreamCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteStreamCommandOutput) => void): void;
            /**
                * <p>To deregister a consumer, provide its ARN. Alternatively, you can provide the ARN of
                *             the data stream and the name you gave the consumer when you registered it. You may also
                *             provide all three parameters, as long as they don't conflict with each other. If you
                *             don't know the name or ARN of the consumer that you want to deregister, you can use the
                *                 <a>ListStreamConsumers</a> operation to get a list of the descriptions of
                *             all the consumers that are currently registered with a given data stream. The
                *             description of a consumer contains its name and ARN.</p>
                *         <p>This operation has a limit of five transactions per second per stream.</p>
                */
            deregisterStreamConsumer(args: DeregisterStreamConsumerCommandInput, options?: __HttpHandlerOptions): Promise<DeregisterStreamConsumerCommandOutput>;
            deregisterStreamConsumer(args: DeregisterStreamConsumerCommandInput, cb: (err: any, data?: DeregisterStreamConsumerCommandOutput) => void): void;
            deregisterStreamConsumer(args: DeregisterStreamConsumerCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeregisterStreamConsumerCommandOutput) => void): void;
            /**
                * <p>Describes the shard limits and usage for the account.</p>
                *         <p>If you update your account limits, the old limits might be returned for a few
                *             minutes.</p>
                *         <p>This operation has a limit of one transaction per second per account.</p>
                */
            describeLimits(args: DescribeLimitsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeLimitsCommandOutput>;
            describeLimits(args: DescribeLimitsCommandInput, cb: (err: any, data?: DescribeLimitsCommandOutput) => void): void;
            describeLimits(args: DescribeLimitsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeLimitsCommandOutput) => void): void;
            /**
                * <p>Describes the specified Kinesis data stream.</p>
                *         <note>
                *             <p>This API has been revised. It's highly recommended that you use the <a>DescribeStreamSummary</a> API to get a summarized description of the
                *                 specified Kinesis data stream and the <a>ListShards</a> API to list the
                *                 shards in a specified data stream and obtain information about each shard. </p>
                *         </note>
                *         <p>The information returned includes the stream name, Amazon Resource Name (ARN),
                *             creation time, enhanced metric configuration, and shard map. The shard map is an array
                *             of shard objects. For each shard object, there is the hash key and sequence number
                *             ranges that the shard spans, and the IDs of any earlier shards that played in a role in
                *             creating the shard. Every record ingested in the stream is identified by a sequence
                *             number, which is assigned when the record is put into the stream.</p>
                *
                *         <p>You can limit the number of shards returned by each call. For more information, see
                *                 <a href="https://docs.aws.amazon.com/kinesis/latest/dev/kinesis-using-sdk-java-retrieve-shards.html">Retrieving
                *                 Shards from a Stream</a> in the <i>Amazon Kinesis Data Streams Developer
                *                 Guide</i>.</p>
                *         <p>There are no guarantees about the chronological order shards returned. To process
                *             shards in chronological order, use the ID of the parent shard to track the lineage to
                *             the oldest shard.</p>
                *         <p>This operation has a limit of 10 transactions per second per account.</p>
                */
            describeStream(args: DescribeStreamCommandInput, options?: __HttpHandlerOptions): Promise<DescribeStreamCommandOutput>;
            describeStream(args: DescribeStreamCommandInput, cb: (err: any, data?: DescribeStreamCommandOutput) => void): void;
            describeStream(args: DescribeStreamCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeStreamCommandOutput) => void): void;
            /**
                * <p>To get the description of a registered consumer, provide the ARN of the consumer.
                *             Alternatively, you can provide the ARN of the data stream and the name you gave the
                *             consumer when you registered it. You may also provide all three parameters, as long as
                *             they don't conflict with each other. If you don't know the name or ARN of the consumer
                *             that you want to describe, you can use the <a>ListStreamConsumers</a>
                *             operation to get a list of the descriptions of all the consumers that are currently
                *             registered with a given data stream.</p>
                *         <p>This operation has a limit of 20 transactions per second per stream.</p>
                */
            describeStreamConsumer(args: DescribeStreamConsumerCommandInput, options?: __HttpHandlerOptions): Promise<DescribeStreamConsumerCommandOutput>;
            describeStreamConsumer(args: DescribeStreamConsumerCommandInput, cb: (err: any, data?: DescribeStreamConsumerCommandOutput) => void): void;
            describeStreamConsumer(args: DescribeStreamConsumerCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeStreamConsumerCommandOutput) => void): void;
            /**
                * <p>Provides a summarized description of the specified Kinesis data stream without the
                *             shard list.</p>
                *         <p>The information returned includes the stream name, Amazon Resource Name (ARN), status,
                *             record retention period, approximate creation time, monitoring, encryption details, and
                *             open shard count. </p>
                *         <p>
                *             <a>DescribeStreamSummary</a> has a limit of 20 transactions per second per
                *             account.</p>
                */
            describeStreamSummary(args: DescribeStreamSummaryCommandInput, options?: __HttpHandlerOptions): Promise<DescribeStreamSummaryCommandOutput>;
            describeStreamSummary(args: DescribeStreamSummaryCommandInput, cb: (err: any, data?: DescribeStreamSummaryCommandOutput) => void): void;
            describeStreamSummary(args: DescribeStreamSummaryCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeStreamSummaryCommandOutput) => void): void;
            /**
                * <p>Disables enhanced monitoring.</p>
                */
            disableEnhancedMonitoring(args: DisableEnhancedMonitoringCommandInput, options?: __HttpHandlerOptions): Promise<DisableEnhancedMonitoringCommandOutput>;
            disableEnhancedMonitoring(args: DisableEnhancedMonitoringCommandInput, cb: (err: any, data?: DisableEnhancedMonitoringCommandOutput) => void): void;
            disableEnhancedMonitoring(args: DisableEnhancedMonitoringCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DisableEnhancedMonitoringCommandOutput) => void): void;
            /**
                * <p>Enables enhanced Kinesis data stream monitoring for shard-level metrics.</p>
                */
            enableEnhancedMonitoring(args: EnableEnhancedMonitoringCommandInput, options?: __HttpHandlerOptions): Promise<EnableEnhancedMonitoringCommandOutput>;
            enableEnhancedMonitoring(args: EnableEnhancedMonitoringCommandInput, cb: (err: any, data?: EnableEnhancedMonitoringCommandOutput) => void): void;
            enableEnhancedMonitoring(args: EnableEnhancedMonitoringCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: EnableEnhancedMonitoringCommandOutput) => void): void;
            /**
                * <p>Gets data records from a Kinesis data stream's shard.</p>
                *         <p>Specify a shard iterator using the <code>ShardIterator</code> parameter. The shard
                *             iterator specifies the position in the shard from which you want to start reading data
                *             records sequentially. If there are no records available in the portion of the shard that
                *             the iterator points to, <a>GetRecords</a> returns an empty list. It might
                *             take multiple calls to get to a portion of the shard that contains records.</p>
                *         <p>You can scale by provisioning multiple shards per stream while considering service
                *             limits (for more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/service-sizes-and-limits.html">Amazon Kinesis Data Streams
                *                 Limits</a> in the <i>Amazon Kinesis Data Streams Developer
                *                 Guide</i>). Your application should have one thread per shard, each reading
                *             continuously from its stream. To read from a stream continually, call <a>GetRecords</a> in a loop. Use <a>GetShardIterator</a> to get the
                *             shard iterator to specify in the first <a>GetRecords</a> call. <a>GetRecords</a> returns a new shard iterator in
                *                 <code>NextShardIterator</code>. Specify the shard iterator returned in
                *                 <code>NextShardIterator</code> in subsequent calls to <a>GetRecords</a>.
                *             If the shard has been closed, the shard iterator can't return more data and <a>GetRecords</a> returns <code>null</code> in <code>NextShardIterator</code>.
                *             You can terminate the loop when the shard is closed, or when the shard iterator reaches
                *             the record with the sequence number or other attribute that marks it as the last record
                *             to process.</p>
                *         <p>Each data record can be up to 1 MiB in size, and each shard can read up to 2 MiB per
                *             second. You can ensure that your calls don't exceed the maximum supported size or
                *             throughput by using the <code>Limit</code> parameter to specify the maximum number of
                *             records that <a>GetRecords</a> can return. Consider your average record size
                *             when determining this limit. The maximum number of records that can be returned per call
                *             is 10,000.</p>
                *
                *         <p>The size of the data returned by <a>GetRecords</a> varies depending on the
                *             utilization of the shard. It is recommended that consumer applications retrieve records
                *             via the <code>GetRecords</code> command using the 5 TPS limit to remain caught up.
                *             Retrieving records less frequently can lead to consumer applications falling behind. The
                *             maximum size of data that <a>GetRecords</a> can return is 10 MiB. If a call
                *             returns this amount of data, subsequent calls made within the next 5 seconds throw
                *                 <code>ProvisionedThroughputExceededException</code>. If there is insufficient
                *             provisioned throughput on the stream, subsequent calls made within the next 1 second
                *             throw <code>ProvisionedThroughputExceededException</code>. <a>GetRecords</a>
                *             doesn't return any data when it throws an exception. For this reason, we recommend that
                *             you wait 1 second between calls to <a>GetRecords</a>. However, it's possible
                *             that the application will get exceptions for longer than 1 second.</p>
                *
                *
                *
                *
                *
                *
                *
                *
                *         <p>To detect whether the application is falling behind in processing, you can use the
                *                 <code>MillisBehindLatest</code> response attribute. You can also monitor the stream
                *             using CloudWatch metrics and other mechanisms (see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/monitoring.html">Monitoring</a> in the <i>Amazon
                *                 Kinesis Data Streams Developer Guide</i>).</p>
                *         <p>Each Amazon Kinesis record includes a value, <code>ApproximateArrivalTimestamp</code>,
                *             that is set when a stream successfully receives and stores a record. This is commonly
                *             referred to as a server-side time stamp, whereas a client-side time stamp is set when a
                *             data producer creates or sends the record to a stream (a data producer is any data
                *             source putting data records into a stream, for example with <a>PutRecords</a>). The time stamp has millisecond precision. There are no guarantees about the time
                *             stamp accuracy, or that the time stamp is always increasing. For example, records in a
                *             shard or across a stream might have time stamps that are out of order.</p>
                *         <p>This operation has a limit of five transactions per second per shard.</p>
                */
            getRecords(args: GetRecordsCommandInput, options?: __HttpHandlerOptions): Promise<GetRecordsCommandOutput>;
            getRecords(args: GetRecordsCommandInput, cb: (err: any, data?: GetRecordsCommandOutput) => void): void;
            getRecords(args: GetRecordsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetRecordsCommandOutput) => void): void;
            /**
                * <p>Gets an Amazon Kinesis shard iterator. A shard iterator expires 5 minutes after it is
                *             returned to the requester.</p>
                *         <p>A shard iterator specifies the shard position from which to start reading data records
                *             sequentially. The position is specified using the sequence number of a data record in a
                *             shard. A sequence number is the identifier associated with every record ingested in the
                *             stream, and is assigned when a record is put into the stream. Each stream has one or
                *             more shards.</p>
                *         <p>You must specify the shard iterator type. For example, you can set the
                *                 <code>ShardIteratorType</code> parameter to read exactly from the position denoted
                *             by a specific sequence number by using the <code>AT_SEQUENCE_NUMBER</code> shard
                *             iterator type. Alternatively, the parameter can read right after the sequence number by
                *             using the <code>AFTER_SEQUENCE_NUMBER</code> shard iterator type, using sequence numbers
                *             returned by earlier calls to <a>PutRecord</a>, <a>PutRecords</a>,
                *                 <a>GetRecords</a>, or <a>DescribeStream</a>. In the request,
                *             you can specify the shard iterator type <code>AT_TIMESTAMP</code> to read records from
                *             an arbitrary point in time, <code>TRIM_HORIZON</code> to cause
                *                 <code>ShardIterator</code> to point to the last untrimmed record in the shard in the
                *             system (the oldest data record in the shard), or <code>LATEST</code> so that you always
                *             read the most recent data in the shard. </p>
                *         <p>When you read repeatedly from a stream, use a <a>GetShardIterator</a>
                *             request to get the first shard iterator for use in your first <a>GetRecords</a> request and for subsequent reads use the shard iterator returned by the <a>GetRecords</a> request in <code>NextShardIterator</code>. A new shard
                *             iterator is returned by every <a>GetRecords</a> request in
                *                 <code>NextShardIterator</code>, which you use in the <code>ShardIterator</code>
                *             parameter of the next <a>GetRecords</a> request. </p>
                *         <p>If a <a>GetShardIterator</a> request is made too often, you receive a
                *                 <code>ProvisionedThroughputExceededException</code>. For more information about
                *             throughput limits, see <a>GetRecords</a>, and <a href="https://docs.aws.amazon.com/kinesis/latest/dev/service-sizes-and-limits.html">Streams Limits</a> in the
                *                 <i>Amazon Kinesis Data Streams Developer Guide</i>.</p>
                *         <p>If the shard is closed, <a>GetShardIterator</a> returns a valid iterator
                *             for the last sequence number of the shard. A shard can be closed as a result of using
                *                 <a>SplitShard</a> or <a>MergeShards</a>.</p>
                *         <p>
                *             <a>GetShardIterator</a> has a limit of five transactions per second per
                *             account per open shard.</p>
                */
            getShardIterator(args: GetShardIteratorCommandInput, options?: __HttpHandlerOptions): Promise<GetShardIteratorCommandOutput>;
            getShardIterator(args: GetShardIteratorCommandInput, cb: (err: any, data?: GetShardIteratorCommandOutput) => void): void;
            getShardIterator(args: GetShardIteratorCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetShardIteratorCommandOutput) => void): void;
            /**
                * <p>Increases the Kinesis data stream's retention period, which is the length of time data
                *             records are accessible after they are added to the stream. The maximum value of a
                *             stream's retention period is 8760 hours (365 days).</p>
                *         <p>If you choose a longer stream retention period, this operation increases the time
                *             period during which records that have not yet expired are accessible. However, it does
                *             not make previous, expired data (older than the stream's previous retention period)
                *             accessible after the operation has been called. For example, if a stream's retention
                *             period is set to 24 hours and is increased to 168 hours, any data that is older than 24
                *             hours remains inaccessible to consumer applications.</p>
                */
            increaseStreamRetentionPeriod(args: IncreaseStreamRetentionPeriodCommandInput, options?: __HttpHandlerOptions): Promise<IncreaseStreamRetentionPeriodCommandOutput>;
            increaseStreamRetentionPeriod(args: IncreaseStreamRetentionPeriodCommandInput, cb: (err: any, data?: IncreaseStreamRetentionPeriodCommandOutput) => void): void;
            increaseStreamRetentionPeriod(args: IncreaseStreamRetentionPeriodCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: IncreaseStreamRetentionPeriodCommandOutput) => void): void;
            /**
                * <p>Lists the shards in a stream and provides information about each shard. This operation
                *             has a limit of 1000 transactions per second per data stream.</p>
                *         <p>This action does not list expired shards. For information about expired shards, see
                *                 <a href="https://docs.aws.amazon.com/streams/latest/dev/kinesis-using-sdk-java-after-resharding.html#kinesis-using-sdk-java-resharding-data-routing">Data Routing, Data Persistence, and Shard State after a Reshard</a>. </p>
                *         <important>
                *             <p>This API is a new operation that is used by the Amazon Kinesis Client Library
                *                 (KCL). If you have a fine-grained IAM policy that only allows specific operations,
                *                 you must update your policy to allow calls to this API. For more information, see
                *                     <a href="https://docs.aws.amazon.com/streams/latest/dev/controlling-access.html">Controlling Access to Amazon Kinesis Data Streams Resources Using
                *                 IAM</a>.</p>
                *         </important>
                */
            listShards(args: ListShardsCommandInput, options?: __HttpHandlerOptions): Promise<ListShardsCommandOutput>;
            listShards(args: ListShardsCommandInput, cb: (err: any, data?: ListShardsCommandOutput) => void): void;
            listShards(args: ListShardsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListShardsCommandOutput) => void): void;
            /**
                * <p>Lists the consumers registered to receive data from a stream using enhanced fan-out,
                *             and provides information about each consumer.</p>
                *         <p>This operation has a limit of 5 transactions per second per stream.</p>
                */
            listStreamConsumers(args: ListStreamConsumersCommandInput, options?: __HttpHandlerOptions): Promise<ListStreamConsumersCommandOutput>;
            listStreamConsumers(args: ListStreamConsumersCommandInput, cb: (err: any, data?: ListStreamConsumersCommandOutput) => void): void;
            listStreamConsumers(args: ListStreamConsumersCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListStreamConsumersCommandOutput) => void): void;
            /**
                * <p>Lists your Kinesis data streams.</p>
                *         <p>The number of streams may be too large to return from a single call to
                *                 <code>ListStreams</code>. You can limit the number of returned streams using the
                *                 <code>Limit</code> parameter. If you do not specify a value for the
                *                 <code>Limit</code> parameter, Kinesis Data Streams uses the default limit, which is
                *             currently 100.</p>
                *         <p>You can detect if there are more streams available to list by using the
                *                 <code>HasMoreStreams</code> flag from the returned output. If there are more streams
                *             available, you can request more streams by using the name of the last stream returned by
                *             the <code>ListStreams</code> request in the <code>ExclusiveStartStreamName</code>
                *             parameter in a subsequent request to <code>ListStreams</code>. The group of stream names
                *             returned by the subsequent request is then added to the list. You can continue this
                *             process until all the stream names have been collected in the list. </p>
                *         <p>
                *             <a>ListStreams</a> has a limit of five transactions per second per
                *             account.</p>
                */
            listStreams(args: ListStreamsCommandInput, options?: __HttpHandlerOptions): Promise<ListStreamsCommandOutput>;
            listStreams(args: ListStreamsCommandInput, cb: (err: any, data?: ListStreamsCommandOutput) => void): void;
            listStreams(args: ListStreamsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListStreamsCommandOutput) => void): void;
            /**
                * <p>Lists the tags for the specified Kinesis data stream. This operation has a limit of
                *             five transactions per second per account.</p>
                */
            listTagsForStream(args: ListTagsForStreamCommandInput, options?: __HttpHandlerOptions): Promise<ListTagsForStreamCommandOutput>;
            listTagsForStream(args: ListTagsForStreamCommandInput, cb: (err: any, data?: ListTagsForStreamCommandOutput) => void): void;
            listTagsForStream(args: ListTagsForStreamCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTagsForStreamCommandOutput) => void): void;
            /**
                * <p>Merges two adjacent shards in a Kinesis data stream and combines them into a single
                *             shard to reduce the stream's capacity to ingest and transport data. Two shards are
                *             considered adjacent if the union of the hash key ranges for the two shards form a
                *             contiguous set with no gaps. For example, if you have two shards, one with a hash key
                *             range of 276...381 and the other with a hash key range of 382...454, then you could
                *             merge these two shards into a single shard that would have a hash key range of
                *             276...454. After the merge, the single child shard receives data for all hash key values
                *             covered by the two parent shards.</p>
                *         <p>
                *             <code>MergeShards</code> is called when there is a need to reduce the overall capacity
                *             of a stream because of excess capacity that is not being used. You must specify the
                *             shard to be merged and the adjacent shard for a stream. For more information about
                *             merging shards, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/kinesis-using-sdk-java-resharding-merge.html">Merge Two
                *                 Shards</a> in the <i>Amazon Kinesis Data Streams Developer
                *                 Guide</i>.</p>
                *         <p>If the stream is in the <code>ACTIVE</code> state, you can call
                *                 <code>MergeShards</code>. If a stream is in the <code>CREATING</code>,
                *                 <code>UPDATING</code>, or <code>DELETING</code> state, <code>MergeShards</code>
                *             returns a <code>ResourceInUseException</code>. If the specified stream does not exist,
                *                 <code>MergeShards</code> returns a <code>ResourceNotFoundException</code>. </p>
                *         <p>You can use <a>DescribeStreamSummary</a> to check the state of the stream,
                *             which is returned in <code>StreamStatus</code>.</p>
                *         <p>
                *             <code>MergeShards</code> is an asynchronous operation. Upon receiving a
                *                 <code>MergeShards</code> request, Amazon Kinesis Data Streams immediately returns a
                *             response and sets the <code>StreamStatus</code> to <code>UPDATING</code>. After the
                *             operation is completed, Kinesis Data Streams sets the <code>StreamStatus</code> to
                *                 <code>ACTIVE</code>. Read and write operations continue to work while the stream is
                *             in the <code>UPDATING</code> state. </p>
                *         <p>You use <a>DescribeStreamSummary</a> and the <a>ListShards</a>
                *             APIs to determine the shard IDs that are specified in the <code>MergeShards</code>
                *             request. </p>
                *         <p>If you try to operate on too many streams in parallel using <a>CreateStream</a>, <a>DeleteStream</a>, <code>MergeShards</code>,
                *             or <a>SplitShard</a>, you receive a <code>LimitExceededException</code>. </p>
                *         <p>
                *             <code>MergeShards</code> has a limit of five transactions per second per account.</p>
                */
            mergeShards(args: MergeShardsCommandInput, options?: __HttpHandlerOptions): Promise<MergeShardsCommandOutput>;
            mergeShards(args: MergeShardsCommandInput, cb: (err: any, data?: MergeShardsCommandOutput) => void): void;
            mergeShards(args: MergeShardsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: MergeShardsCommandOutput) => void): void;
            /**
                * <p>Writes a single data record into an Amazon Kinesis data stream. Call
                *                 <code>PutRecord</code> to send data into the stream for real-time ingestion and
                *             subsequent processing, one record at a time. Each shard can support writes up to 1,000
                *             records per second, up to a maximum data write total of 1 MiB per second.</p>
                *         <p>You must specify the name of the stream that captures, stores, and transports the
                *             data; a partition key; and the data blob itself.</p>
                *         <p>The data blob can be any type of data; for example, a segment from a log file,
                *             geographic/location data, website clickstream data, and so on.</p>
                *         <p>The partition key is used by Kinesis Data Streams to distribute data across shards.
                *             Kinesis Data Streams segregates the data records that belong to a stream into multiple
                *             shards, using the partition key associated with each data record to determine the shard
                *             to which a given data record belongs.</p>
                *         <p>Partition keys are Unicode strings, with a maximum length limit of 256 characters for
                *             each key. An MD5 hash function is used to map partition keys to 128-bit integer values
                *             and to map associated data records to shards using the hash key ranges of the shards.
                *             You can override hashing the partition key to determine the shard by explicitly
                *             specifying a hash value using the <code>ExplicitHashKey</code> parameter. For more
                *             information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/developing-producers-with-sdk.html#kinesis-using-sdk-java-add-data-to-stream">Adding Data to a Stream</a> in the <i>Amazon Kinesis Data Streams
                *                 Developer Guide</i>.</p>
                *         <p>
                *             <code>PutRecord</code> returns the shard ID of where the data record was placed and the
                *             sequence number that was assigned to the data record.</p>
                *         <p>Sequence numbers increase over time and are specific to a shard within a stream, not
                *             across all shards within a stream. To guarantee strictly increasing ordering, write
                *             serially to a shard and use the <code>SequenceNumberForOrdering</code> parameter. For
                *             more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/developing-producers-with-sdk.html#kinesis-using-sdk-java-add-data-to-stream">Adding Data to a Stream</a> in the <i>Amazon Kinesis Data Streams
                *                 Developer Guide</i>.</p>
                *         <important>
                *             <p>After you write a record to a stream, you cannot modify that record or its order
                *                 within the stream.</p>
                *         </important>
                *         <p>If a <code>PutRecord</code> request cannot be processed because of insufficient
                *             provisioned throughput on the shard involved in the request, <code>PutRecord</code>
                *             throws <code>ProvisionedThroughputExceededException</code>. </p>
                *         <p>By default, data records are accessible for 24 hours from the time that they are added
                *             to a stream. You can use <a>IncreaseStreamRetentionPeriod</a> or <a>DecreaseStreamRetentionPeriod</a> to modify this retention period.</p>
                */
            putRecord(args: PutRecordCommandInput, options?: __HttpHandlerOptions): Promise<PutRecordCommandOutput>;
            putRecord(args: PutRecordCommandInput, cb: (err: any, data?: PutRecordCommandOutput) => void): void;
            putRecord(args: PutRecordCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutRecordCommandOutput) => void): void;
            /**
                * <p>Writes multiple data records into a Kinesis data stream in a single call (also
                *             referred to as a <code>PutRecords</code> request). Use this operation to send data into
                *             the stream for data ingestion and processing. </p>
                *         <p>Each <code>PutRecords</code> request can support up to 500 records. Each record in the
                *             request can be as large as 1 MiB, up to a limit of 5 MiB for the entire request,
                *             including partition keys. Each shard can support writes up to 1,000 records per second,
                *             up to a maximum data write total of 1 MiB per second.</p>
                *         <p>You must specify the name of the stream that captures, stores, and transports the
                *             data; and an array of request <code>Records</code>, with each record in the array
                *             requiring a partition key and data blob. The record size limit applies to the total size
                *             of the partition key and data blob.</p>
                *         <p>The data blob can be any type of data; for example, a segment from a log file,
                *             geographic/location data, website clickstream data, and so on.</p>
                *         <p>The partition key is used by Kinesis Data Streams as input to a hash function that
                *             maps the partition key and associated data to a specific shard. An MD5 hash function is
                *             used to map partition keys to 128-bit integer values and to map associated data records
                *             to shards. As a result of this hashing mechanism, all data records with the same
                *             partition key map to the same shard within the stream. For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/developing-producers-with-sdk.html#kinesis-using-sdk-java-add-data-to-stream">Adding Data to a Stream</a> in the <i>Amazon Kinesis Data Streams
                *                 Developer Guide</i>.</p>
                *         <p>Each record in the <code>Records</code> array may include an optional parameter,
                *                 <code>ExplicitHashKey</code>, which overrides the partition key to shard mapping.
                *             This parameter allows a data producer to determine explicitly the shard where the record
                *             is stored. For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/developing-producers-with-sdk.html#kinesis-using-sdk-java-putrecords">Adding Multiple Records with PutRecords</a> in the <i>Amazon Kinesis
                *                 Data Streams Developer Guide</i>.</p>
                *         <p>The <code>PutRecords</code> response includes an array of response
                *                 <code>Records</code>. Each record in the response array directly correlates with a
                *             record in the request array using natural ordering, from the top to the bottom of the
                *             request and response. The response <code>Records</code> array always includes the same
                *             number of records as the request array.</p>
                *         <p>The response <code>Records</code> array includes both successfully and unsuccessfully
                *             processed records. Kinesis Data Streams attempts to process all records in each
                *                 <code>PutRecords</code> request. A single record failure does not stop the
                *             processing of subsequent records. As a result, PutRecords doesn't guarantee the ordering
                *             of records. If you need to read records in the same order they are written to the
                *             stream, use <a>PutRecord</a> instead of <code>PutRecords</code>, and write to
                *             the same shard.</p>
                *         <p>A successfully processed record includes <code>ShardId</code> and
                *                 <code>SequenceNumber</code> values. The <code>ShardId</code> parameter identifies
                *             the shard in the stream where the record is stored. The <code>SequenceNumber</code>
                *             parameter is an identifier assigned to the put record, unique to all records in the
                *             stream.</p>
                *         <p>An unsuccessfully processed record includes <code>ErrorCode</code> and
                *                 <code>ErrorMessage</code> values. <code>ErrorCode</code> reflects the type of error
                *             and can be one of the following values:
                *                 <code>ProvisionedThroughputExceededException</code> or <code>InternalFailure</code>.
                *                 <code>ErrorMessage</code> provides more detailed information about the
                *                 <code>ProvisionedThroughputExceededException</code> exception including the account
                *             ID, stream name, and shard ID of the record that was throttled. For more information
                *             about partially successful responses, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/kinesis-using-sdk-java-add-data-to-stream.html#kinesis-using-sdk-java-putrecords">Adding Multiple Records with PutRecords</a> in the <i>Amazon Kinesis
                *                 Data Streams Developer Guide</i>.</p>
                *         <important>
                *             <p>After you write a record to a stream, you cannot modify that record or its order
                *                 within the stream.</p>
                *         </important>
                *         <p>By default, data records are accessible for 24 hours from the time that they are added
                *             to a stream. You can use <a>IncreaseStreamRetentionPeriod</a> or <a>DecreaseStreamRetentionPeriod</a> to modify this retention period.</p>
                */
            putRecords(args: PutRecordsCommandInput, options?: __HttpHandlerOptions): Promise<PutRecordsCommandOutput>;
            putRecords(args: PutRecordsCommandInput, cb: (err: any, data?: PutRecordsCommandOutput) => void): void;
            putRecords(args: PutRecordsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutRecordsCommandOutput) => void): void;
            /**
                * <p>Registers a consumer with a Kinesis data stream. When you use this operation, the
                *             consumer you register can then call <a>SubscribeToShard</a> to receive data
                *             from the stream using enhanced fan-out, at a rate of up to 2 MiB per second for every
                *             shard you subscribe to. This rate is unaffected by the total number of consumers that
                *             read from the same stream.</p>
                *         <p>You can register up to 20 consumers per stream. A given consumer can only be
                *             registered with one stream at a time.</p>
                *         <p>For an example of how to use this operations, see <a href="/streams/latest/dev/building-enhanced-consumers-api.html">Enhanced Fan-Out
                *                 Using the Kinesis Data Streams API</a>.</p>
                *         <p>The use of this operation has a limit of five transactions per second per account.
                *             Also, only 5 consumers can be created simultaneously. In other words, you cannot have
                *             more than 5 consumers in a <code>CREATING</code> status at the same time. Registering a
                *             6th consumer while there are 5 in a <code>CREATING</code> status results in a
                *                 <code>LimitExceededException</code>.</p>
                */
            registerStreamConsumer(args: RegisterStreamConsumerCommandInput, options?: __HttpHandlerOptions): Promise<RegisterStreamConsumerCommandOutput>;
            registerStreamConsumer(args: RegisterStreamConsumerCommandInput, cb: (err: any, data?: RegisterStreamConsumerCommandOutput) => void): void;
            registerStreamConsumer(args: RegisterStreamConsumerCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RegisterStreamConsumerCommandOutput) => void): void;
            /**
                * <p>Removes tags from the specified Kinesis data stream. Removed tags are deleted and
                *             cannot be recovered after this operation successfully completes.</p>
                *         <p>If you specify a tag that does not exist, it is ignored.</p>
                *         <p>
                *             <a>RemoveTagsFromStream</a> has a limit of five transactions per second per
                *             account.</p>
                */
            removeTagsFromStream(args: RemoveTagsFromStreamCommandInput, options?: __HttpHandlerOptions): Promise<RemoveTagsFromStreamCommandOutput>;
            removeTagsFromStream(args: RemoveTagsFromStreamCommandInput, cb: (err: any, data?: RemoveTagsFromStreamCommandOutput) => void): void;
            removeTagsFromStream(args: RemoveTagsFromStreamCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RemoveTagsFromStreamCommandOutput) => void): void;
            /**
                * <p>Splits a shard into two new shards in the Kinesis data stream, to increase the
                *             stream's capacity to ingest and transport data. <code>SplitShard</code> is called when
                *             there is a need to increase the overall capacity of a stream because of an expected
                *             increase in the volume of data records being ingested. </p>
                *         <p>You can also use <code>SplitShard</code> when a shard appears to be approaching its
                *             maximum utilization; for example, the producers sending data into the specific shard are
                *             suddenly sending more than previously anticipated. You can also call
                *                 <code>SplitShard</code> to increase stream capacity, so that more Kinesis Data
                *             Streams applications can simultaneously read data from the stream for real-time
                *             processing. </p>
                *         <p>You must specify the shard to be split and the new hash key, which is the position in
                *             the shard where the shard gets split in two. In many cases, the new hash key might be
                *             the average of the beginning and ending hash key, but it can be any hash key value in
                *             the range being mapped into the shard. For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/kinesis-using-sdk-java-resharding-split.html">Split a
                *                 Shard</a> in the <i>Amazon Kinesis Data Streams Developer
                *                 Guide</i>.</p>
                *         <p>You can use <a>DescribeStreamSummary</a> and the <a>ListShards</a> APIs to determine the shard ID and hash key values for the <code>ShardToSplit</code>
                *             and <code>NewStartingHashKey</code> parameters that are specified in the
                *                 <code>SplitShard</code> request.</p>
                *         <p>
                *             <code>SplitShard</code> is an asynchronous operation. Upon receiving a
                *                 <code>SplitShard</code> request, Kinesis Data Streams immediately returns a response
                *             and sets the stream status to <code>UPDATING</code>. After the operation is completed,
                *             Kinesis Data Streams sets the stream status to <code>ACTIVE</code>. Read and write
                *             operations continue to work while the stream is in the <code>UPDATING</code> state. </p>
                *         <p>You can use <a>DescribeStreamSummary</a> to check the status of the stream,
                *             which is returned in <code>StreamStatus</code>. If the stream is in the
                *                 <code>ACTIVE</code> state, you can call <code>SplitShard</code>.
                *             </p>
                *         <p>If the specified stream does not exist, <a>DescribeStreamSummary</a>
                *             returns a <code>ResourceNotFoundException</code>. If you try to create more shards than
                *             are authorized for your account, you receive a <code>LimitExceededException</code>. </p>
                *         <p>For the default shard limit for an Amazon Web Services account, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/service-sizes-and-limits.html">Kinesis
                *                 Data Streams Limits</a> in the <i>Amazon Kinesis Data Streams Developer
                *                 Guide</i>. To increase this limit, <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html">contact Amazon Web Services
                *                 Support</a>.</p>
                *         <p>If you try to operate on too many streams simultaneously using <a>CreateStream</a>, <a>DeleteStream</a>, <a>MergeShards</a>, and/or <a>SplitShard</a>, you receive a
                *                 <code>LimitExceededException</code>. </p>
                *         <p>
                *             <code>SplitShard</code> has a limit of five transactions per second per account.</p>
                */
            splitShard(args: SplitShardCommandInput, options?: __HttpHandlerOptions): Promise<SplitShardCommandOutput>;
            splitShard(args: SplitShardCommandInput, cb: (err: any, data?: SplitShardCommandOutput) => void): void;
            splitShard(args: SplitShardCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: SplitShardCommandOutput) => void): void;
            /**
                * <p>Enables or updates server-side encryption using an Amazon Web Services KMS key for a
                *             specified stream. </p>
                *         <p>Starting encryption is an asynchronous operation. Upon receiving the request, Kinesis
                *             Data Streams returns immediately and sets the status of the stream to
                *                 <code>UPDATING</code>. After the update is complete, Kinesis Data Streams sets the
                *             status of the stream back to <code>ACTIVE</code>. Updating or applying encryption
                *             normally takes a few seconds to complete, but it can take minutes. You can continue to
                *             read and write data to your stream while its status is <code>UPDATING</code>. Once the
                *             status of the stream is <code>ACTIVE</code>, encryption begins for records written to
                *             the stream. </p>
                *         <p>API Limits: You can successfully apply a new Amazon Web Services KMS key for
                *             server-side encryption 25 times in a rolling 24-hour period.</p>
                *         <p>Note: It can take up to 5 seconds after the stream is in an <code>ACTIVE</code> status
                *             before all records written to the stream are encrypted. After you enable encryption, you
                *             can verify that encryption is applied by inspecting the API response from
                *                 <code>PutRecord</code> or <code>PutRecords</code>.</p>
                */
            startStreamEncryption(args: StartStreamEncryptionCommandInput, options?: __HttpHandlerOptions): Promise<StartStreamEncryptionCommandOutput>;
            startStreamEncryption(args: StartStreamEncryptionCommandInput, cb: (err: any, data?: StartStreamEncryptionCommandOutput) => void): void;
            startStreamEncryption(args: StartStreamEncryptionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: StartStreamEncryptionCommandOutput) => void): void;
            /**
                * <p>Disables server-side encryption for a specified stream. </p>
                *         <p>Stopping encryption is an asynchronous operation. Upon receiving the request, Kinesis
                *             Data Streams returns immediately and sets the status of the stream to
                *                 <code>UPDATING</code>. After the update is complete, Kinesis Data Streams sets the
                *             status of the stream back to <code>ACTIVE</code>. Stopping encryption normally takes a
                *             few seconds to complete, but it can take minutes. You can continue to read and write
                *             data to your stream while its status is <code>UPDATING</code>. Once the status of the
                *             stream is <code>ACTIVE</code>, records written to the stream are no longer encrypted by
                *             Kinesis Data Streams. </p>
                *         <p>API Limits: You can successfully disable server-side encryption 25 times in a rolling
                *             24-hour period. </p>
                *         <p>Note: It can take up to 5 seconds after the stream is in an <code>ACTIVE</code> status
                *             before all records written to the stream are no longer subject to encryption. After you
                *             disabled encryption, you can verify that encryption is not applied by inspecting the API
                *             response from <code>PutRecord</code> or <code>PutRecords</code>.</p>
                */
            stopStreamEncryption(args: StopStreamEncryptionCommandInput, options?: __HttpHandlerOptions): Promise<StopStreamEncryptionCommandOutput>;
            stopStreamEncryption(args: StopStreamEncryptionCommandInput, cb: (err: any, data?: StopStreamEncryptionCommandOutput) => void): void;
            stopStreamEncryption(args: StopStreamEncryptionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: StopStreamEncryptionCommandOutput) => void): void;
            /**
                * <p>This operation establishes an HTTP/2 connection between the consumer you specify in
                *             the <code>ConsumerARN</code> parameter and the shard you specify in the
                *                 <code>ShardId</code> parameter. After the connection is successfully established,
                *             Kinesis Data Streams pushes records from the shard to the consumer over this connection.
                *             Before you call this operation, call <a>RegisterStreamConsumer</a> to
                *             register the consumer with Kinesis Data Streams.</p>
                *         <p>When the <code>SubscribeToShard</code> call succeeds, your consumer starts receiving
                *             events of type <a>SubscribeToShardEvent</a> over the HTTP/2 connection for up
                *             to 5 minutes, after which time you need to call <code>SubscribeToShard</code> again to
                *             renew the subscription if you want to continue to receive records.</p>
                *         <p>You can make one call to <code>SubscribeToShard</code> per second per registered
                *             consumer per shard. For example, if you have a 4000 shard stream and two registered
                *             stream consumers, you can make one <code>SubscribeToShard</code> request per second for
                *             each combination of shard and registered consumer, allowing you to subscribe both
                *             consumers to all 4000 shards in one second. </p>
                *         <p>If you call <code>SubscribeToShard</code> again with the same <code>ConsumerARN</code>
                *             and <code>ShardId</code> within 5 seconds of a successful call, you'll get a
                *                 <code>ResourceInUseException</code>. If you call <code>SubscribeToShard</code> 5
                *             seconds or more after a successful call, the second call takes over the subscription and
                *             the previous connection expires or fails with a
                *             <code>ResourceInUseException</code>.</p>
                *         <p>For an example of how to use this operations, see <a href="/streams/latest/dev/building-enhanced-consumers-api.html">Enhanced Fan-Out
                *                 Using the Kinesis Data Streams API</a>.</p>
                */
            subscribeToShard(args: SubscribeToShardCommandInput, options?: __HttpHandlerOptions): Promise<SubscribeToShardCommandOutput>;
            subscribeToShard(args: SubscribeToShardCommandInput, cb: (err: any, data?: SubscribeToShardCommandOutput) => void): void;
            subscribeToShard(args: SubscribeToShardCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: SubscribeToShardCommandOutput) => void): void;
            /**
                * <p>Updates the shard count of the specified stream to the specified number of
                *             shards.</p>
                *         <p>Updating the shard count is an asynchronous operation. Upon receiving the request,
                *             Kinesis Data Streams returns immediately and sets the status of the stream to
                *                 <code>UPDATING</code>. After the update is complete, Kinesis Data Streams sets the
                *             status of the stream back to <code>ACTIVE</code>. Depending on the size of the stream,
                *             the scaling action could take a few minutes to complete. You can continue to read and
                *             write data to your stream while its status is <code>UPDATING</code>.</p>
                *         <p>To update the shard count, Kinesis Data Streams performs splits or merges on
                *             individual shards. This can cause short-lived shards to be created, in addition to the
                *             final shards. These short-lived shards count towards your total shard limit for your
                *             account in the Region.</p>
                *         <p>When using this operation, we recommend that you specify a target shard count that is
                *             a multiple of 25% (25%, 50%, 75%, 100%). You can specify any target value within your
                *             shard limit. However, if you specify a target that isn't a multiple of 25%, the scaling
                *             action might take longer to complete. </p>
                *         <p>This operation has the following default limits. By default, you cannot do the
                *             following:</p>
                *         <ul>
                *             <li>
                *                 <p>Scale more than ten times per rolling 24-hour period per stream</p>
                *             </li>
                *             <li>
                *                 <p>Scale up to more than double your current shard count for a stream</p>
                *             </li>
                *             <li>
                *                 <p>Scale down below half your current shard count for a stream</p>
                *             </li>
                *             <li>
                *                 <p>Scale up to more than 10000 shards in a stream</p>
                *             </li>
                *             <li>
                *                 <p>Scale a stream with more than 10000 shards down unless the result is less than
                *                     10000 shards</p>
                *             </li>
                *             <li>
                *                 <p>Scale up to more than the shard limit for your account</p>
                *             </li>
                *          </ul>
                *         <p>For the default limits for an Amazon Web Services account, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/service-sizes-and-limits.html">Streams
                *                 Limits</a> in the <i>Amazon Kinesis Data Streams Developer
                *                 Guide</i>. To request an increase in the call rate limit, the shard limit for
                *             this API, or your overall shard limit, use the <a href="https://console.aws.amazon.com/support/v1#/case/create?issueType=service-limit-increase&limitType=service-code-kinesis">limits form</a>.</p>
                */
            updateShardCount(args: UpdateShardCountCommandInput, options?: __HttpHandlerOptions): Promise<UpdateShardCountCommandOutput>;
            updateShardCount(args: UpdateShardCountCommandInput, cb: (err: any, data?: UpdateShardCountCommandOutput) => void): void;
            updateShardCount(args: UpdateShardCountCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateShardCountCommandOutput) => void): void;
            /**
                * <p> Updates the capacity mode of the data stream. Currently, in Kinesis Data Streams, you
                *             can choose between an <b>on-demand</b> capacity mode and a
                *                 <b>provisioned</b> capacity mode for your data stream.
                *         </p>
                */
            updateStreamMode(args: UpdateStreamModeCommandInput, options?: __HttpHandlerOptions): Promise<UpdateStreamModeCommandOutput>;
            updateStreamMode(args: UpdateStreamModeCommandInput, cb: (err: any, data?: UpdateStreamModeCommandOutput) => void): void;
            updateStreamMode(args: UpdateStreamModeCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateStreamModeCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/AddTagsToStreamCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { AddTagsToStreamInput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface AddTagsToStreamCommandInput extends AddTagsToStreamInput {
    }
    export interface AddTagsToStreamCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Adds or updates tags for the specified Kinesis data stream. You can assign up to 50
        *             tags to a data stream.</p>
        *         <p>If tags have already been assigned to the stream, <code>AddTagsToStream</code>
        *             overwrites any existing tags that correspond to the specified tag keys.</p>
        *         <p>
        *             <a>AddTagsToStream</a> has a limit of five transactions per second per
        *             account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, AddTagsToStreamCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, AddTagsToStreamCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new AddTagsToStreamCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link AddTagsToStreamCommandInput} for command's `input` shape.
        * @see {@link AddTagsToStreamCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class AddTagsToStreamCommand extends $Command<AddTagsToStreamCommandInput, AddTagsToStreamCommandOutput, KinesisClientResolvedConfig> {
            readonly input: AddTagsToStreamCommandInput;
            constructor(input: AddTagsToStreamCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<AddTagsToStreamCommandInput, AddTagsToStreamCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/CreateStreamCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { CreateStreamInput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface CreateStreamCommandInput extends CreateStreamInput {
    }
    export interface CreateStreamCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Creates a Kinesis data stream. A stream captures and transports data records that are
        *             continuously emitted from different data sources or <i>producers</i>.
        *             Scale-out within a stream is explicitly supported by means of shards, which are uniquely
        *             identified groups of data records in a stream.</p>
        *         <p>You specify and control the number of shards that a stream is composed of. Each shard
        *             can support reads up to five transactions per second, up to a maximum data read total of
        *             2 MiB per second. Each shard can support writes up to 1,000 records per second, up to a
        *             maximum data write total of 1 MiB per second. If the amount of data input increases or
        *             decreases, you can add or remove shards.</p>
        *         <p>The stream name identifies the stream. The name is scoped to the Amazon Web Services
        *             account used by the application. It is also scoped by Amazon Web Services Region. That
        *             is, two streams in two different accounts can have the same name, and two streams in the
        *             same account, but in two different Regions, can have the same name.</p>
        *         <p>
        *             <code>CreateStream</code> is an asynchronous operation. Upon receiving a
        *                 <code>CreateStream</code> request, Kinesis Data Streams immediately returns and sets
        *             the stream status to <code>CREATING</code>. After the stream is created, Kinesis Data
        *             Streams sets the stream status to <code>ACTIVE</code>. You should perform read and write
        *             operations only on an <code>ACTIVE</code> stream. </p>
        *         <p>You receive a <code>LimitExceededException</code> when making a
        *                 <code>CreateStream</code> request when you try to do one of the following:</p>
        *         <ul>
        *             <li>
        *
        *                 <p>Have more than five streams in the <code>CREATING</code> state at any point in
        *                     time.</p>
        *             </li>
        *             <li>
        *
        *                 <p>Create more shards than are authorized for your account.</p>
        *             </li>
        *          </ul>
        *         <p>For the default shard limit for an Amazon Web Services account, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/service-sizes-and-limits.html">Amazon
        *                 Kinesis Data Streams Limits</a> in the <i>Amazon Kinesis Data Streams
        *                 Developer Guide</i>. To increase this limit, <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html">contact Amazon Web Services
        *                 Support</a>.</p>
        *         <p>You can use <a>DescribeStreamSummary</a> to check the stream status, which
        *             is returned in <code>StreamStatus</code>.</p>
        *         <p>
        *             <a>CreateStream</a> has a limit of five transactions per second per
        *             account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, CreateStreamCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, CreateStreamCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new CreateStreamCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateStreamCommandInput} for command's `input` shape.
        * @see {@link CreateStreamCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class CreateStreamCommand extends $Command<CreateStreamCommandInput, CreateStreamCommandOutput, KinesisClientResolvedConfig> {
            readonly input: CreateStreamCommandInput;
            constructor(input: CreateStreamCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateStreamCommandInput, CreateStreamCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DecreaseStreamRetentionPeriodCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { DecreaseStreamRetentionPeriodInput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface DecreaseStreamRetentionPeriodCommandInput extends DecreaseStreamRetentionPeriodInput {
    }
    export interface DecreaseStreamRetentionPeriodCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Decreases the Kinesis data stream's retention period, which is the length of time data
        *             records are accessible after they are added to the stream. The minimum value of a
        *             stream's retention period is 24 hours.</p>
        *         <p>This operation may result in lost data. For example, if the stream's retention period
        *             is 48 hours and is decreased to 24 hours, any data already in the stream that is older
        *             than 24 hours is inaccessible.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, DecreaseStreamRetentionPeriodCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, DecreaseStreamRetentionPeriodCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new DecreaseStreamRetentionPeriodCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DecreaseStreamRetentionPeriodCommandInput} for command's `input` shape.
        * @see {@link DecreaseStreamRetentionPeriodCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class DecreaseStreamRetentionPeriodCommand extends $Command<DecreaseStreamRetentionPeriodCommandInput, DecreaseStreamRetentionPeriodCommandOutput, KinesisClientResolvedConfig> {
            readonly input: DecreaseStreamRetentionPeriodCommandInput;
            constructor(input: DecreaseStreamRetentionPeriodCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DecreaseStreamRetentionPeriodCommandInput, DecreaseStreamRetentionPeriodCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DeleteStreamCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { DeleteStreamInput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface DeleteStreamCommandInput extends DeleteStreamInput {
    }
    export interface DeleteStreamCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes a Kinesis data stream and all its shards and data. You must shut down any
        *             applications that are operating on the stream before you delete the stream. If an
        *             application attempts to operate on a deleted stream, it receives the exception
        *                 <code>ResourceNotFoundException</code>.</p>
        *         <p>If the stream is in the <code>ACTIVE</code> state, you can delete it. After a
        *                 <code>DeleteStream</code> request, the specified stream is in the
        *                 <code>DELETING</code> state until Kinesis Data Streams completes the
        *             deletion.</p>
        *         <p>
        *             <b>Note:</b> Kinesis Data Streams might continue to accept
        *             data read and write operations, such as <a>PutRecord</a>, <a>PutRecords</a>, and <a>GetRecords</a>, on a stream in the
        *                 <code>DELETING</code> state until the stream deletion is complete.</p>
        *         <p>When you delete a stream, any shards in that stream are also deleted, and any tags are
        *             dissociated from the stream.</p>
        *         <p>You can use the <a>DescribeStreamSummary</a> operation to check the state
        *             of the stream, which is returned in <code>StreamStatus</code>.</p>
        *
        *         <p>
        *             <a>DeleteStream</a> has a limit of five transactions per second per
        *             account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, DeleteStreamCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, DeleteStreamCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new DeleteStreamCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteStreamCommandInput} for command's `input` shape.
        * @see {@link DeleteStreamCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class DeleteStreamCommand extends $Command<DeleteStreamCommandInput, DeleteStreamCommandOutput, KinesisClientResolvedConfig> {
            readonly input: DeleteStreamCommandInput;
            constructor(input: DeleteStreamCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteStreamCommandInput, DeleteStreamCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DeregisterStreamConsumerCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { DeregisterStreamConsumerInput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface DeregisterStreamConsumerCommandInput extends DeregisterStreamConsumerInput {
    }
    export interface DeregisterStreamConsumerCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>To deregister a consumer, provide its ARN. Alternatively, you can provide the ARN of
        *             the data stream and the name you gave the consumer when you registered it. You may also
        *             provide all three parameters, as long as they don't conflict with each other. If you
        *             don't know the name or ARN of the consumer that you want to deregister, you can use the
        *                 <a>ListStreamConsumers</a> operation to get a list of the descriptions of
        *             all the consumers that are currently registered with a given data stream. The
        *             description of a consumer contains its name and ARN.</p>
        *         <p>This operation has a limit of five transactions per second per stream.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, DeregisterStreamConsumerCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, DeregisterStreamConsumerCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new DeregisterStreamConsumerCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeregisterStreamConsumerCommandInput} for command's `input` shape.
        * @see {@link DeregisterStreamConsumerCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class DeregisterStreamConsumerCommand extends $Command<DeregisterStreamConsumerCommandInput, DeregisterStreamConsumerCommandOutput, KinesisClientResolvedConfig> {
            readonly input: DeregisterStreamConsumerCommandInput;
            constructor(input: DeregisterStreamConsumerCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeregisterStreamConsumerCommandInput, DeregisterStreamConsumerCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DescribeLimitsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { DescribeLimitsInput, DescribeLimitsOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface DescribeLimitsCommandInput extends DescribeLimitsInput {
    }
    export interface DescribeLimitsCommandOutput extends DescribeLimitsOutput, __MetadataBearer {
    }
    /**
        * <p>Describes the shard limits and usage for the account.</p>
        *         <p>If you update your account limits, the old limits might be returned for a few
        *             minutes.</p>
        *         <p>This operation has a limit of one transaction per second per account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, DescribeLimitsCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, DescribeLimitsCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new DescribeLimitsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeLimitsCommandInput} for command's `input` shape.
        * @see {@link DescribeLimitsCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class DescribeLimitsCommand extends $Command<DescribeLimitsCommandInput, DescribeLimitsCommandOutput, KinesisClientResolvedConfig> {
            readonly input: DescribeLimitsCommandInput;
            constructor(input: DescribeLimitsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeLimitsCommandInput, DescribeLimitsCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DescribeStreamCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { DescribeStreamInput, DescribeStreamOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface DescribeStreamCommandInput extends DescribeStreamInput {
    }
    export interface DescribeStreamCommandOutput extends DescribeStreamOutput, __MetadataBearer {
    }
    /**
        * <p>Describes the specified Kinesis data stream.</p>
        *         <note>
        *             <p>This API has been revised. It's highly recommended that you use the <a>DescribeStreamSummary</a> API to get a summarized description of the
        *                 specified Kinesis data stream and the <a>ListShards</a> API to list the
        *                 shards in a specified data stream and obtain information about each shard. </p>
        *         </note>
        *         <p>The information returned includes the stream name, Amazon Resource Name (ARN),
        *             creation time, enhanced metric configuration, and shard map. The shard map is an array
        *             of shard objects. For each shard object, there is the hash key and sequence number
        *             ranges that the shard spans, and the IDs of any earlier shards that played in a role in
        *             creating the shard. Every record ingested in the stream is identified by a sequence
        *             number, which is assigned when the record is put into the stream.</p>
        *
        *         <p>You can limit the number of shards returned by each call. For more information, see
        *                 <a href="https://docs.aws.amazon.com/kinesis/latest/dev/kinesis-using-sdk-java-retrieve-shards.html">Retrieving
        *                 Shards from a Stream</a> in the <i>Amazon Kinesis Data Streams Developer
        *                 Guide</i>.</p>
        *         <p>There are no guarantees about the chronological order shards returned. To process
        *             shards in chronological order, use the ID of the parent shard to track the lineage to
        *             the oldest shard.</p>
        *         <p>This operation has a limit of 10 transactions per second per account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, DescribeStreamCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, DescribeStreamCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new DescribeStreamCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeStreamCommandInput} for command's `input` shape.
        * @see {@link DescribeStreamCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class DescribeStreamCommand extends $Command<DescribeStreamCommandInput, DescribeStreamCommandOutput, KinesisClientResolvedConfig> {
            readonly input: DescribeStreamCommandInput;
            constructor(input: DescribeStreamCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeStreamCommandInput, DescribeStreamCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DescribeStreamConsumerCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { DescribeStreamConsumerInput, DescribeStreamConsumerOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface DescribeStreamConsumerCommandInput extends DescribeStreamConsumerInput {
    }
    export interface DescribeStreamConsumerCommandOutput extends DescribeStreamConsumerOutput, __MetadataBearer {
    }
    /**
        * <p>To get the description of a registered consumer, provide the ARN of the consumer.
        *             Alternatively, you can provide the ARN of the data stream and the name you gave the
        *             consumer when you registered it. You may also provide all three parameters, as long as
        *             they don't conflict with each other. If you don't know the name or ARN of the consumer
        *             that you want to describe, you can use the <a>ListStreamConsumers</a>
        *             operation to get a list of the descriptions of all the consumers that are currently
        *             registered with a given data stream.</p>
        *         <p>This operation has a limit of 20 transactions per second per stream.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, DescribeStreamConsumerCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, DescribeStreamConsumerCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new DescribeStreamConsumerCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeStreamConsumerCommandInput} for command's `input` shape.
        * @see {@link DescribeStreamConsumerCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class DescribeStreamConsumerCommand extends $Command<DescribeStreamConsumerCommandInput, DescribeStreamConsumerCommandOutput, KinesisClientResolvedConfig> {
            readonly input: DescribeStreamConsumerCommandInput;
            constructor(input: DescribeStreamConsumerCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeStreamConsumerCommandInput, DescribeStreamConsumerCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DescribeStreamSummaryCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { DescribeStreamSummaryInput, DescribeStreamSummaryOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface DescribeStreamSummaryCommandInput extends DescribeStreamSummaryInput {
    }
    export interface DescribeStreamSummaryCommandOutput extends DescribeStreamSummaryOutput, __MetadataBearer {
    }
    /**
        * <p>Provides a summarized description of the specified Kinesis data stream without the
        *             shard list.</p>
        *         <p>The information returned includes the stream name, Amazon Resource Name (ARN), status,
        *             record retention period, approximate creation time, monitoring, encryption details, and
        *             open shard count. </p>
        *         <p>
        *             <a>DescribeStreamSummary</a> has a limit of 20 transactions per second per
        *             account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, DescribeStreamSummaryCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, DescribeStreamSummaryCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new DescribeStreamSummaryCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeStreamSummaryCommandInput} for command's `input` shape.
        * @see {@link DescribeStreamSummaryCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class DescribeStreamSummaryCommand extends $Command<DescribeStreamSummaryCommandInput, DescribeStreamSummaryCommandOutput, KinesisClientResolvedConfig> {
            readonly input: DescribeStreamSummaryCommandInput;
            constructor(input: DescribeStreamSummaryCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeStreamSummaryCommandInput, DescribeStreamSummaryCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DisableEnhancedMonitoringCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { DisableEnhancedMonitoringInput, EnhancedMonitoringOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface DisableEnhancedMonitoringCommandInput extends DisableEnhancedMonitoringInput {
    }
    export interface DisableEnhancedMonitoringCommandOutput extends EnhancedMonitoringOutput, __MetadataBearer {
    }
    /**
        * <p>Disables enhanced monitoring.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, DisableEnhancedMonitoringCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, DisableEnhancedMonitoringCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new DisableEnhancedMonitoringCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DisableEnhancedMonitoringCommandInput} for command's `input` shape.
        * @see {@link DisableEnhancedMonitoringCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class DisableEnhancedMonitoringCommand extends $Command<DisableEnhancedMonitoringCommandInput, DisableEnhancedMonitoringCommandOutput, KinesisClientResolvedConfig> {
            readonly input: DisableEnhancedMonitoringCommandInput;
            constructor(input: DisableEnhancedMonitoringCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DisableEnhancedMonitoringCommandInput, DisableEnhancedMonitoringCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/EnableEnhancedMonitoringCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { EnableEnhancedMonitoringInput, EnhancedMonitoringOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface EnableEnhancedMonitoringCommandInput extends EnableEnhancedMonitoringInput {
    }
    export interface EnableEnhancedMonitoringCommandOutput extends EnhancedMonitoringOutput, __MetadataBearer {
    }
    /**
        * <p>Enables enhanced Kinesis data stream monitoring for shard-level metrics.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, EnableEnhancedMonitoringCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, EnableEnhancedMonitoringCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new EnableEnhancedMonitoringCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link EnableEnhancedMonitoringCommandInput} for command's `input` shape.
        * @see {@link EnableEnhancedMonitoringCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class EnableEnhancedMonitoringCommand extends $Command<EnableEnhancedMonitoringCommandInput, EnableEnhancedMonitoringCommandOutput, KinesisClientResolvedConfig> {
            readonly input: EnableEnhancedMonitoringCommandInput;
            constructor(input: EnableEnhancedMonitoringCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<EnableEnhancedMonitoringCommandInput, EnableEnhancedMonitoringCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/GetRecordsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { GetRecordsInput, GetRecordsOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface GetRecordsCommandInput extends GetRecordsInput {
    }
    export interface GetRecordsCommandOutput extends GetRecordsOutput, __MetadataBearer {
    }
    /**
        * <p>Gets data records from a Kinesis data stream's shard.</p>
        *         <p>Specify a shard iterator using the <code>ShardIterator</code> parameter. The shard
        *             iterator specifies the position in the shard from which you want to start reading data
        *             records sequentially. If there are no records available in the portion of the shard that
        *             the iterator points to, <a>GetRecords</a> returns an empty list. It might
        *             take multiple calls to get to a portion of the shard that contains records.</p>
        *         <p>You can scale by provisioning multiple shards per stream while considering service
        *             limits (for more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/service-sizes-and-limits.html">Amazon Kinesis Data Streams
        *                 Limits</a> in the <i>Amazon Kinesis Data Streams Developer
        *                 Guide</i>). Your application should have one thread per shard, each reading
        *             continuously from its stream. To read from a stream continually, call <a>GetRecords</a> in a loop. Use <a>GetShardIterator</a> to get the
        *             shard iterator to specify in the first <a>GetRecords</a> call. <a>GetRecords</a> returns a new shard iterator in
        *                 <code>NextShardIterator</code>. Specify the shard iterator returned in
        *                 <code>NextShardIterator</code> in subsequent calls to <a>GetRecords</a>.
        *             If the shard has been closed, the shard iterator can't return more data and <a>GetRecords</a> returns <code>null</code> in <code>NextShardIterator</code>.
        *             You can terminate the loop when the shard is closed, or when the shard iterator reaches
        *             the record with the sequence number or other attribute that marks it as the last record
        *             to process.</p>
        *         <p>Each data record can be up to 1 MiB in size, and each shard can read up to 2 MiB per
        *             second. You can ensure that your calls don't exceed the maximum supported size or
        *             throughput by using the <code>Limit</code> parameter to specify the maximum number of
        *             records that <a>GetRecords</a> can return. Consider your average record size
        *             when determining this limit. The maximum number of records that can be returned per call
        *             is 10,000.</p>
        *
        *         <p>The size of the data returned by <a>GetRecords</a> varies depending on the
        *             utilization of the shard. It is recommended that consumer applications retrieve records
        *             via the <code>GetRecords</code> command using the 5 TPS limit to remain caught up.
        *             Retrieving records less frequently can lead to consumer applications falling behind. The
        *             maximum size of data that <a>GetRecords</a> can return is 10 MiB. If a call
        *             returns this amount of data, subsequent calls made within the next 5 seconds throw
        *                 <code>ProvisionedThroughputExceededException</code>. If there is insufficient
        *             provisioned throughput on the stream, subsequent calls made within the next 1 second
        *             throw <code>ProvisionedThroughputExceededException</code>. <a>GetRecords</a>
        *             doesn't return any data when it throws an exception. For this reason, we recommend that
        *             you wait 1 second between calls to <a>GetRecords</a>. However, it's possible
        *             that the application will get exceptions for longer than 1 second.</p>
        *
        *
        *
        *
        *
        *
        *
        *
        *         <p>To detect whether the application is falling behind in processing, you can use the
        *                 <code>MillisBehindLatest</code> response attribute. You can also monitor the stream
        *             using CloudWatch metrics and other mechanisms (see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/monitoring.html">Monitoring</a> in the <i>Amazon
        *                 Kinesis Data Streams Developer Guide</i>).</p>
        *         <p>Each Amazon Kinesis record includes a value, <code>ApproximateArrivalTimestamp</code>,
        *             that is set when a stream successfully receives and stores a record. This is commonly
        *             referred to as a server-side time stamp, whereas a client-side time stamp is set when a
        *             data producer creates or sends the record to a stream (a data producer is any data
        *             source putting data records into a stream, for example with <a>PutRecords</a>). The time stamp has millisecond precision. There are no guarantees about the time
        *             stamp accuracy, or that the time stamp is always increasing. For example, records in a
        *             shard or across a stream might have time stamps that are out of order.</p>
        *         <p>This operation has a limit of five transactions per second per shard.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, GetRecordsCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, GetRecordsCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new GetRecordsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetRecordsCommandInput} for command's `input` shape.
        * @see {@link GetRecordsCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class GetRecordsCommand extends $Command<GetRecordsCommandInput, GetRecordsCommandOutput, KinesisClientResolvedConfig> {
            readonly input: GetRecordsCommandInput;
            constructor(input: GetRecordsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetRecordsCommandInput, GetRecordsCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/GetShardIteratorCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { GetShardIteratorInput, GetShardIteratorOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface GetShardIteratorCommandInput extends GetShardIteratorInput {
    }
    export interface GetShardIteratorCommandOutput extends GetShardIteratorOutput, __MetadataBearer {
    }
    /**
        * <p>Gets an Amazon Kinesis shard iterator. A shard iterator expires 5 minutes after it is
        *             returned to the requester.</p>
        *         <p>A shard iterator specifies the shard position from which to start reading data records
        *             sequentially. The position is specified using the sequence number of a data record in a
        *             shard. A sequence number is the identifier associated with every record ingested in the
        *             stream, and is assigned when a record is put into the stream. Each stream has one or
        *             more shards.</p>
        *         <p>You must specify the shard iterator type. For example, you can set the
        *                 <code>ShardIteratorType</code> parameter to read exactly from the position denoted
        *             by a specific sequence number by using the <code>AT_SEQUENCE_NUMBER</code> shard
        *             iterator type. Alternatively, the parameter can read right after the sequence number by
        *             using the <code>AFTER_SEQUENCE_NUMBER</code> shard iterator type, using sequence numbers
        *             returned by earlier calls to <a>PutRecord</a>, <a>PutRecords</a>,
        *                 <a>GetRecords</a>, or <a>DescribeStream</a>. In the request,
        *             you can specify the shard iterator type <code>AT_TIMESTAMP</code> to read records from
        *             an arbitrary point in time, <code>TRIM_HORIZON</code> to cause
        *                 <code>ShardIterator</code> to point to the last untrimmed record in the shard in the
        *             system (the oldest data record in the shard), or <code>LATEST</code> so that you always
        *             read the most recent data in the shard. </p>
        *         <p>When you read repeatedly from a stream, use a <a>GetShardIterator</a>
        *             request to get the first shard iterator for use in your first <a>GetRecords</a> request and for subsequent reads use the shard iterator returned by the <a>GetRecords</a> request in <code>NextShardIterator</code>. A new shard
        *             iterator is returned by every <a>GetRecords</a> request in
        *                 <code>NextShardIterator</code>, which you use in the <code>ShardIterator</code>
        *             parameter of the next <a>GetRecords</a> request. </p>
        *         <p>If a <a>GetShardIterator</a> request is made too often, you receive a
        *                 <code>ProvisionedThroughputExceededException</code>. For more information about
        *             throughput limits, see <a>GetRecords</a>, and <a href="https://docs.aws.amazon.com/kinesis/latest/dev/service-sizes-and-limits.html">Streams Limits</a> in the
        *                 <i>Amazon Kinesis Data Streams Developer Guide</i>.</p>
        *         <p>If the shard is closed, <a>GetShardIterator</a> returns a valid iterator
        *             for the last sequence number of the shard. A shard can be closed as a result of using
        *                 <a>SplitShard</a> or <a>MergeShards</a>.</p>
        *         <p>
        *             <a>GetShardIterator</a> has a limit of five transactions per second per
        *             account per open shard.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, GetShardIteratorCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, GetShardIteratorCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new GetShardIteratorCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetShardIteratorCommandInput} for command's `input` shape.
        * @see {@link GetShardIteratorCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class GetShardIteratorCommand extends $Command<GetShardIteratorCommandInput, GetShardIteratorCommandOutput, KinesisClientResolvedConfig> {
            readonly input: GetShardIteratorCommandInput;
            constructor(input: GetShardIteratorCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetShardIteratorCommandInput, GetShardIteratorCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/IncreaseStreamRetentionPeriodCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { IncreaseStreamRetentionPeriodInput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface IncreaseStreamRetentionPeriodCommandInput extends IncreaseStreamRetentionPeriodInput {
    }
    export interface IncreaseStreamRetentionPeriodCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Increases the Kinesis data stream's retention period, which is the length of time data
        *             records are accessible after they are added to the stream. The maximum value of a
        *             stream's retention period is 8760 hours (365 days).</p>
        *         <p>If you choose a longer stream retention period, this operation increases the time
        *             period during which records that have not yet expired are accessible. However, it does
        *             not make previous, expired data (older than the stream's previous retention period)
        *             accessible after the operation has been called. For example, if a stream's retention
        *             period is set to 24 hours and is increased to 168 hours, any data that is older than 24
        *             hours remains inaccessible to consumer applications.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, IncreaseStreamRetentionPeriodCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, IncreaseStreamRetentionPeriodCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new IncreaseStreamRetentionPeriodCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link IncreaseStreamRetentionPeriodCommandInput} for command's `input` shape.
        * @see {@link IncreaseStreamRetentionPeriodCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class IncreaseStreamRetentionPeriodCommand extends $Command<IncreaseStreamRetentionPeriodCommandInput, IncreaseStreamRetentionPeriodCommandOutput, KinesisClientResolvedConfig> {
            readonly input: IncreaseStreamRetentionPeriodCommandInput;
            constructor(input: IncreaseStreamRetentionPeriodCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<IncreaseStreamRetentionPeriodCommandInput, IncreaseStreamRetentionPeriodCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/ListShardsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { ListShardsInput, ListShardsOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface ListShardsCommandInput extends ListShardsInput {
    }
    export interface ListShardsCommandOutput extends ListShardsOutput, __MetadataBearer {
    }
    /**
        * <p>Lists the shards in a stream and provides information about each shard. This operation
        *             has a limit of 1000 transactions per second per data stream.</p>
        *         <p>This action does not list expired shards. For information about expired shards, see
        *                 <a href="https://docs.aws.amazon.com/streams/latest/dev/kinesis-using-sdk-java-after-resharding.html#kinesis-using-sdk-java-resharding-data-routing">Data Routing, Data Persistence, and Shard State after a Reshard</a>. </p>
        *         <important>
        *             <p>This API is a new operation that is used by the Amazon Kinesis Client Library
        *                 (KCL). If you have a fine-grained IAM policy that only allows specific operations,
        *                 you must update your policy to allow calls to this API. For more information, see
        *                     <a href="https://docs.aws.amazon.com/streams/latest/dev/controlling-access.html">Controlling Access to Amazon Kinesis Data Streams Resources Using
        *                 IAM</a>.</p>
        *         </important>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, ListShardsCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, ListShardsCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new ListShardsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListShardsCommandInput} for command's `input` shape.
        * @see {@link ListShardsCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class ListShardsCommand extends $Command<ListShardsCommandInput, ListShardsCommandOutput, KinesisClientResolvedConfig> {
            readonly input: ListShardsCommandInput;
            constructor(input: ListShardsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListShardsCommandInput, ListShardsCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/ListStreamConsumersCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { ListStreamConsumersInput, ListStreamConsumersOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface ListStreamConsumersCommandInput extends ListStreamConsumersInput {
    }
    export interface ListStreamConsumersCommandOutput extends ListStreamConsumersOutput, __MetadataBearer {
    }
    /**
        * <p>Lists the consumers registered to receive data from a stream using enhanced fan-out,
        *             and provides information about each consumer.</p>
        *         <p>This operation has a limit of 5 transactions per second per stream.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, ListStreamConsumersCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, ListStreamConsumersCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new ListStreamConsumersCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListStreamConsumersCommandInput} for command's `input` shape.
        * @see {@link ListStreamConsumersCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class ListStreamConsumersCommand extends $Command<ListStreamConsumersCommandInput, ListStreamConsumersCommandOutput, KinesisClientResolvedConfig> {
            readonly input: ListStreamConsumersCommandInput;
            constructor(input: ListStreamConsumersCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListStreamConsumersCommandInput, ListStreamConsumersCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/ListStreamsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { ListStreamsInput, ListStreamsOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface ListStreamsCommandInput extends ListStreamsInput {
    }
    export interface ListStreamsCommandOutput extends ListStreamsOutput, __MetadataBearer {
    }
    /**
        * <p>Lists your Kinesis data streams.</p>
        *         <p>The number of streams may be too large to return from a single call to
        *                 <code>ListStreams</code>. You can limit the number of returned streams using the
        *                 <code>Limit</code> parameter. If you do not specify a value for the
        *                 <code>Limit</code> parameter, Kinesis Data Streams uses the default limit, which is
        *             currently 100.</p>
        *         <p>You can detect if there are more streams available to list by using the
        *                 <code>HasMoreStreams</code> flag from the returned output. If there are more streams
        *             available, you can request more streams by using the name of the last stream returned by
        *             the <code>ListStreams</code> request in the <code>ExclusiveStartStreamName</code>
        *             parameter in a subsequent request to <code>ListStreams</code>. The group of stream names
        *             returned by the subsequent request is then added to the list. You can continue this
        *             process until all the stream names have been collected in the list. </p>
        *         <p>
        *             <a>ListStreams</a> has a limit of five transactions per second per
        *             account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, ListStreamsCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, ListStreamsCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new ListStreamsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListStreamsCommandInput} for command's `input` shape.
        * @see {@link ListStreamsCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class ListStreamsCommand extends $Command<ListStreamsCommandInput, ListStreamsCommandOutput, KinesisClientResolvedConfig> {
            readonly input: ListStreamsCommandInput;
            constructor(input: ListStreamsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListStreamsCommandInput, ListStreamsCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/ListTagsForStreamCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { ListTagsForStreamInput, ListTagsForStreamOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface ListTagsForStreamCommandInput extends ListTagsForStreamInput {
    }
    export interface ListTagsForStreamCommandOutput extends ListTagsForStreamOutput, __MetadataBearer {
    }
    /**
        * <p>Lists the tags for the specified Kinesis data stream. This operation has a limit of
        *             five transactions per second per account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, ListTagsForStreamCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, ListTagsForStreamCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new ListTagsForStreamCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTagsForStreamCommandInput} for command's `input` shape.
        * @see {@link ListTagsForStreamCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class ListTagsForStreamCommand extends $Command<ListTagsForStreamCommandInput, ListTagsForStreamCommandOutput, KinesisClientResolvedConfig> {
            readonly input: ListTagsForStreamCommandInput;
            constructor(input: ListTagsForStreamCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTagsForStreamCommandInput, ListTagsForStreamCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/MergeShardsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { MergeShardsInput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface MergeShardsCommandInput extends MergeShardsInput {
    }
    export interface MergeShardsCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Merges two adjacent shards in a Kinesis data stream and combines them into a single
        *             shard to reduce the stream's capacity to ingest and transport data. Two shards are
        *             considered adjacent if the union of the hash key ranges for the two shards form a
        *             contiguous set with no gaps. For example, if you have two shards, one with a hash key
        *             range of 276...381 and the other with a hash key range of 382...454, then you could
        *             merge these two shards into a single shard that would have a hash key range of
        *             276...454. After the merge, the single child shard receives data for all hash key values
        *             covered by the two parent shards.</p>
        *         <p>
        *             <code>MergeShards</code> is called when there is a need to reduce the overall capacity
        *             of a stream because of excess capacity that is not being used. You must specify the
        *             shard to be merged and the adjacent shard for a stream. For more information about
        *             merging shards, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/kinesis-using-sdk-java-resharding-merge.html">Merge Two
        *                 Shards</a> in the <i>Amazon Kinesis Data Streams Developer
        *                 Guide</i>.</p>
        *         <p>If the stream is in the <code>ACTIVE</code> state, you can call
        *                 <code>MergeShards</code>. If a stream is in the <code>CREATING</code>,
        *                 <code>UPDATING</code>, or <code>DELETING</code> state, <code>MergeShards</code>
        *             returns a <code>ResourceInUseException</code>. If the specified stream does not exist,
        *                 <code>MergeShards</code> returns a <code>ResourceNotFoundException</code>. </p>
        *         <p>You can use <a>DescribeStreamSummary</a> to check the state of the stream,
        *             which is returned in <code>StreamStatus</code>.</p>
        *         <p>
        *             <code>MergeShards</code> is an asynchronous operation. Upon receiving a
        *                 <code>MergeShards</code> request, Amazon Kinesis Data Streams immediately returns a
        *             response and sets the <code>StreamStatus</code> to <code>UPDATING</code>. After the
        *             operation is completed, Kinesis Data Streams sets the <code>StreamStatus</code> to
        *                 <code>ACTIVE</code>. Read and write operations continue to work while the stream is
        *             in the <code>UPDATING</code> state. </p>
        *         <p>You use <a>DescribeStreamSummary</a> and the <a>ListShards</a>
        *             APIs to determine the shard IDs that are specified in the <code>MergeShards</code>
        *             request. </p>
        *         <p>If you try to operate on too many streams in parallel using <a>CreateStream</a>, <a>DeleteStream</a>, <code>MergeShards</code>,
        *             or <a>SplitShard</a>, you receive a <code>LimitExceededException</code>. </p>
        *         <p>
        *             <code>MergeShards</code> has a limit of five transactions per second per account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, MergeShardsCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, MergeShardsCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new MergeShardsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link MergeShardsCommandInput} for command's `input` shape.
        * @see {@link MergeShardsCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class MergeShardsCommand extends $Command<MergeShardsCommandInput, MergeShardsCommandOutput, KinesisClientResolvedConfig> {
            readonly input: MergeShardsCommandInput;
            constructor(input: MergeShardsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<MergeShardsCommandInput, MergeShardsCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/PutRecordCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { PutRecordInput, PutRecordOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface PutRecordCommandInput extends PutRecordInput {
    }
    export interface PutRecordCommandOutput extends PutRecordOutput, __MetadataBearer {
    }
    /**
        * <p>Writes a single data record into an Amazon Kinesis data stream. Call
        *                 <code>PutRecord</code> to send data into the stream for real-time ingestion and
        *             subsequent processing, one record at a time. Each shard can support writes up to 1,000
        *             records per second, up to a maximum data write total of 1 MiB per second.</p>
        *         <p>You must specify the name of the stream that captures, stores, and transports the
        *             data; a partition key; and the data blob itself.</p>
        *         <p>The data blob can be any type of data; for example, a segment from a log file,
        *             geographic/location data, website clickstream data, and so on.</p>
        *         <p>The partition key is used by Kinesis Data Streams to distribute data across shards.
        *             Kinesis Data Streams segregates the data records that belong to a stream into multiple
        *             shards, using the partition key associated with each data record to determine the shard
        *             to which a given data record belongs.</p>
        *         <p>Partition keys are Unicode strings, with a maximum length limit of 256 characters for
        *             each key. An MD5 hash function is used to map partition keys to 128-bit integer values
        *             and to map associated data records to shards using the hash key ranges of the shards.
        *             You can override hashing the partition key to determine the shard by explicitly
        *             specifying a hash value using the <code>ExplicitHashKey</code> parameter. For more
        *             information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/developing-producers-with-sdk.html#kinesis-using-sdk-java-add-data-to-stream">Adding Data to a Stream</a> in the <i>Amazon Kinesis Data Streams
        *                 Developer Guide</i>.</p>
        *         <p>
        *             <code>PutRecord</code> returns the shard ID of where the data record was placed and the
        *             sequence number that was assigned to the data record.</p>
        *         <p>Sequence numbers increase over time and are specific to a shard within a stream, not
        *             across all shards within a stream. To guarantee strictly increasing ordering, write
        *             serially to a shard and use the <code>SequenceNumberForOrdering</code> parameter. For
        *             more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/developing-producers-with-sdk.html#kinesis-using-sdk-java-add-data-to-stream">Adding Data to a Stream</a> in the <i>Amazon Kinesis Data Streams
        *                 Developer Guide</i>.</p>
        *         <important>
        *             <p>After you write a record to a stream, you cannot modify that record or its order
        *                 within the stream.</p>
        *         </important>
        *         <p>If a <code>PutRecord</code> request cannot be processed because of insufficient
        *             provisioned throughput on the shard involved in the request, <code>PutRecord</code>
        *             throws <code>ProvisionedThroughputExceededException</code>. </p>
        *         <p>By default, data records are accessible for 24 hours from the time that they are added
        *             to a stream. You can use <a>IncreaseStreamRetentionPeriod</a> or <a>DecreaseStreamRetentionPeriod</a> to modify this retention period.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, PutRecordCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, PutRecordCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new PutRecordCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutRecordCommandInput} for command's `input` shape.
        * @see {@link PutRecordCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class PutRecordCommand extends $Command<PutRecordCommandInput, PutRecordCommandOutput, KinesisClientResolvedConfig> {
            readonly input: PutRecordCommandInput;
            constructor(input: PutRecordCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutRecordCommandInput, PutRecordCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/PutRecordsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { PutRecordsInput, PutRecordsOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface PutRecordsCommandInput extends PutRecordsInput {
    }
    export interface PutRecordsCommandOutput extends PutRecordsOutput, __MetadataBearer {
    }
    /**
        * <p>Writes multiple data records into a Kinesis data stream in a single call (also
        *             referred to as a <code>PutRecords</code> request). Use this operation to send data into
        *             the stream for data ingestion and processing. </p>
        *         <p>Each <code>PutRecords</code> request can support up to 500 records. Each record in the
        *             request can be as large as 1 MiB, up to a limit of 5 MiB for the entire request,
        *             including partition keys. Each shard can support writes up to 1,000 records per second,
        *             up to a maximum data write total of 1 MiB per second.</p>
        *         <p>You must specify the name of the stream that captures, stores, and transports the
        *             data; and an array of request <code>Records</code>, with each record in the array
        *             requiring a partition key and data blob. The record size limit applies to the total size
        *             of the partition key and data blob.</p>
        *         <p>The data blob can be any type of data; for example, a segment from a log file,
        *             geographic/location data, website clickstream data, and so on.</p>
        *         <p>The partition key is used by Kinesis Data Streams as input to a hash function that
        *             maps the partition key and associated data to a specific shard. An MD5 hash function is
        *             used to map partition keys to 128-bit integer values and to map associated data records
        *             to shards. As a result of this hashing mechanism, all data records with the same
        *             partition key map to the same shard within the stream. For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/developing-producers-with-sdk.html#kinesis-using-sdk-java-add-data-to-stream">Adding Data to a Stream</a> in the <i>Amazon Kinesis Data Streams
        *                 Developer Guide</i>.</p>
        *         <p>Each record in the <code>Records</code> array may include an optional parameter,
        *                 <code>ExplicitHashKey</code>, which overrides the partition key to shard mapping.
        *             This parameter allows a data producer to determine explicitly the shard where the record
        *             is stored. For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/developing-producers-with-sdk.html#kinesis-using-sdk-java-putrecords">Adding Multiple Records with PutRecords</a> in the <i>Amazon Kinesis
        *                 Data Streams Developer Guide</i>.</p>
        *         <p>The <code>PutRecords</code> response includes an array of response
        *                 <code>Records</code>. Each record in the response array directly correlates with a
        *             record in the request array using natural ordering, from the top to the bottom of the
        *             request and response. The response <code>Records</code> array always includes the same
        *             number of records as the request array.</p>
        *         <p>The response <code>Records</code> array includes both successfully and unsuccessfully
        *             processed records. Kinesis Data Streams attempts to process all records in each
        *                 <code>PutRecords</code> request. A single record failure does not stop the
        *             processing of subsequent records. As a result, PutRecords doesn't guarantee the ordering
        *             of records. If you need to read records in the same order they are written to the
        *             stream, use <a>PutRecord</a> instead of <code>PutRecords</code>, and write to
        *             the same shard.</p>
        *         <p>A successfully processed record includes <code>ShardId</code> and
        *                 <code>SequenceNumber</code> values. The <code>ShardId</code> parameter identifies
        *             the shard in the stream where the record is stored. The <code>SequenceNumber</code>
        *             parameter is an identifier assigned to the put record, unique to all records in the
        *             stream.</p>
        *         <p>An unsuccessfully processed record includes <code>ErrorCode</code> and
        *                 <code>ErrorMessage</code> values. <code>ErrorCode</code> reflects the type of error
        *             and can be one of the following values:
        *                 <code>ProvisionedThroughputExceededException</code> or <code>InternalFailure</code>.
        *                 <code>ErrorMessage</code> provides more detailed information about the
        *                 <code>ProvisionedThroughputExceededException</code> exception including the account
        *             ID, stream name, and shard ID of the record that was throttled. For more information
        *             about partially successful responses, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/kinesis-using-sdk-java-add-data-to-stream.html#kinesis-using-sdk-java-putrecords">Adding Multiple Records with PutRecords</a> in the <i>Amazon Kinesis
        *                 Data Streams Developer Guide</i>.</p>
        *         <important>
        *             <p>After you write a record to a stream, you cannot modify that record or its order
        *                 within the stream.</p>
        *         </important>
        *         <p>By default, data records are accessible for 24 hours from the time that they are added
        *             to a stream. You can use <a>IncreaseStreamRetentionPeriod</a> or <a>DecreaseStreamRetentionPeriod</a> to modify this retention period.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, PutRecordsCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, PutRecordsCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new PutRecordsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutRecordsCommandInput} for command's `input` shape.
        * @see {@link PutRecordsCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class PutRecordsCommand extends $Command<PutRecordsCommandInput, PutRecordsCommandOutput, KinesisClientResolvedConfig> {
            readonly input: PutRecordsCommandInput;
            constructor(input: PutRecordsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutRecordsCommandInput, PutRecordsCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/RegisterStreamConsumerCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { RegisterStreamConsumerInput, RegisterStreamConsumerOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface RegisterStreamConsumerCommandInput extends RegisterStreamConsumerInput {
    }
    export interface RegisterStreamConsumerCommandOutput extends RegisterStreamConsumerOutput, __MetadataBearer {
    }
    /**
        * <p>Registers a consumer with a Kinesis data stream. When you use this operation, the
        *             consumer you register can then call <a>SubscribeToShard</a> to receive data
        *             from the stream using enhanced fan-out, at a rate of up to 2 MiB per second for every
        *             shard you subscribe to. This rate is unaffected by the total number of consumers that
        *             read from the same stream.</p>
        *         <p>You can register up to 20 consumers per stream. A given consumer can only be
        *             registered with one stream at a time.</p>
        *         <p>For an example of how to use this operations, see <a href="/streams/latest/dev/building-enhanced-consumers-api.html">Enhanced Fan-Out
        *                 Using the Kinesis Data Streams API</a>.</p>
        *         <p>The use of this operation has a limit of five transactions per second per account.
        *             Also, only 5 consumers can be created simultaneously. In other words, you cannot have
        *             more than 5 consumers in a <code>CREATING</code> status at the same time. Registering a
        *             6th consumer while there are 5 in a <code>CREATING</code> status results in a
        *                 <code>LimitExceededException</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, RegisterStreamConsumerCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, RegisterStreamConsumerCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new RegisterStreamConsumerCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RegisterStreamConsumerCommandInput} for command's `input` shape.
        * @see {@link RegisterStreamConsumerCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class RegisterStreamConsumerCommand extends $Command<RegisterStreamConsumerCommandInput, RegisterStreamConsumerCommandOutput, KinesisClientResolvedConfig> {
            readonly input: RegisterStreamConsumerCommandInput;
            constructor(input: RegisterStreamConsumerCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RegisterStreamConsumerCommandInput, RegisterStreamConsumerCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/RemoveTagsFromStreamCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { RemoveTagsFromStreamInput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface RemoveTagsFromStreamCommandInput extends RemoveTagsFromStreamInput {
    }
    export interface RemoveTagsFromStreamCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Removes tags from the specified Kinesis data stream. Removed tags are deleted and
        *             cannot be recovered after this operation successfully completes.</p>
        *         <p>If you specify a tag that does not exist, it is ignored.</p>
        *         <p>
        *             <a>RemoveTagsFromStream</a> has a limit of five transactions per second per
        *             account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, RemoveTagsFromStreamCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, RemoveTagsFromStreamCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new RemoveTagsFromStreamCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RemoveTagsFromStreamCommandInput} for command's `input` shape.
        * @see {@link RemoveTagsFromStreamCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class RemoveTagsFromStreamCommand extends $Command<RemoveTagsFromStreamCommandInput, RemoveTagsFromStreamCommandOutput, KinesisClientResolvedConfig> {
            readonly input: RemoveTagsFromStreamCommandInput;
            constructor(input: RemoveTagsFromStreamCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RemoveTagsFromStreamCommandInput, RemoveTagsFromStreamCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/SplitShardCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { SplitShardInput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface SplitShardCommandInput extends SplitShardInput {
    }
    export interface SplitShardCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Splits a shard into two new shards in the Kinesis data stream, to increase the
        *             stream's capacity to ingest and transport data. <code>SplitShard</code> is called when
        *             there is a need to increase the overall capacity of a stream because of an expected
        *             increase in the volume of data records being ingested. </p>
        *         <p>You can also use <code>SplitShard</code> when a shard appears to be approaching its
        *             maximum utilization; for example, the producers sending data into the specific shard are
        *             suddenly sending more than previously anticipated. You can also call
        *                 <code>SplitShard</code> to increase stream capacity, so that more Kinesis Data
        *             Streams applications can simultaneously read data from the stream for real-time
        *             processing. </p>
        *         <p>You must specify the shard to be split and the new hash key, which is the position in
        *             the shard where the shard gets split in two. In many cases, the new hash key might be
        *             the average of the beginning and ending hash key, but it can be any hash key value in
        *             the range being mapped into the shard. For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/kinesis-using-sdk-java-resharding-split.html">Split a
        *                 Shard</a> in the <i>Amazon Kinesis Data Streams Developer
        *                 Guide</i>.</p>
        *         <p>You can use <a>DescribeStreamSummary</a> and the <a>ListShards</a> APIs to determine the shard ID and hash key values for the <code>ShardToSplit</code>
        *             and <code>NewStartingHashKey</code> parameters that are specified in the
        *                 <code>SplitShard</code> request.</p>
        *         <p>
        *             <code>SplitShard</code> is an asynchronous operation. Upon receiving a
        *                 <code>SplitShard</code> request, Kinesis Data Streams immediately returns a response
        *             and sets the stream status to <code>UPDATING</code>. After the operation is completed,
        *             Kinesis Data Streams sets the stream status to <code>ACTIVE</code>. Read and write
        *             operations continue to work while the stream is in the <code>UPDATING</code> state. </p>
        *         <p>You can use <a>DescribeStreamSummary</a> to check the status of the stream,
        *             which is returned in <code>StreamStatus</code>. If the stream is in the
        *                 <code>ACTIVE</code> state, you can call <code>SplitShard</code>.
        *             </p>
        *         <p>If the specified stream does not exist, <a>DescribeStreamSummary</a>
        *             returns a <code>ResourceNotFoundException</code>. If you try to create more shards than
        *             are authorized for your account, you receive a <code>LimitExceededException</code>. </p>
        *         <p>For the default shard limit for an Amazon Web Services account, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/service-sizes-and-limits.html">Kinesis
        *                 Data Streams Limits</a> in the <i>Amazon Kinesis Data Streams Developer
        *                 Guide</i>. To increase this limit, <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html">contact Amazon Web Services
        *                 Support</a>.</p>
        *         <p>If you try to operate on too many streams simultaneously using <a>CreateStream</a>, <a>DeleteStream</a>, <a>MergeShards</a>, and/or <a>SplitShard</a>, you receive a
        *                 <code>LimitExceededException</code>. </p>
        *         <p>
        *             <code>SplitShard</code> has a limit of five transactions per second per account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, SplitShardCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, SplitShardCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new SplitShardCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link SplitShardCommandInput} for command's `input` shape.
        * @see {@link SplitShardCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class SplitShardCommand extends $Command<SplitShardCommandInput, SplitShardCommandOutput, KinesisClientResolvedConfig> {
            readonly input: SplitShardCommandInput;
            constructor(input: SplitShardCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<SplitShardCommandInput, SplitShardCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/StartStreamEncryptionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { StartStreamEncryptionInput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface StartStreamEncryptionCommandInput extends StartStreamEncryptionInput {
    }
    export interface StartStreamEncryptionCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Enables or updates server-side encryption using an Amazon Web Services KMS key for a
        *             specified stream. </p>
        *         <p>Starting encryption is an asynchronous operation. Upon receiving the request, Kinesis
        *             Data Streams returns immediately and sets the status of the stream to
        *                 <code>UPDATING</code>. After the update is complete, Kinesis Data Streams sets the
        *             status of the stream back to <code>ACTIVE</code>. Updating or applying encryption
        *             normally takes a few seconds to complete, but it can take minutes. You can continue to
        *             read and write data to your stream while its status is <code>UPDATING</code>. Once the
        *             status of the stream is <code>ACTIVE</code>, encryption begins for records written to
        *             the stream. </p>
        *         <p>API Limits: You can successfully apply a new Amazon Web Services KMS key for
        *             server-side encryption 25 times in a rolling 24-hour period.</p>
        *         <p>Note: It can take up to 5 seconds after the stream is in an <code>ACTIVE</code> status
        *             before all records written to the stream are encrypted. After you enable encryption, you
        *             can verify that encryption is applied by inspecting the API response from
        *                 <code>PutRecord</code> or <code>PutRecords</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, StartStreamEncryptionCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, StartStreamEncryptionCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new StartStreamEncryptionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link StartStreamEncryptionCommandInput} for command's `input` shape.
        * @see {@link StartStreamEncryptionCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class StartStreamEncryptionCommand extends $Command<StartStreamEncryptionCommandInput, StartStreamEncryptionCommandOutput, KinesisClientResolvedConfig> {
            readonly input: StartStreamEncryptionCommandInput;
            constructor(input: StartStreamEncryptionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<StartStreamEncryptionCommandInput, StartStreamEncryptionCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/StopStreamEncryptionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { StopStreamEncryptionInput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface StopStreamEncryptionCommandInput extends StopStreamEncryptionInput {
    }
    export interface StopStreamEncryptionCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Disables server-side encryption for a specified stream. </p>
        *         <p>Stopping encryption is an asynchronous operation. Upon receiving the request, Kinesis
        *             Data Streams returns immediately and sets the status of the stream to
        *                 <code>UPDATING</code>. After the update is complete, Kinesis Data Streams sets the
        *             status of the stream back to <code>ACTIVE</code>. Stopping encryption normally takes a
        *             few seconds to complete, but it can take minutes. You can continue to read and write
        *             data to your stream while its status is <code>UPDATING</code>. Once the status of the
        *             stream is <code>ACTIVE</code>, records written to the stream are no longer encrypted by
        *             Kinesis Data Streams. </p>
        *         <p>API Limits: You can successfully disable server-side encryption 25 times in a rolling
        *             24-hour period. </p>
        *         <p>Note: It can take up to 5 seconds after the stream is in an <code>ACTIVE</code> status
        *             before all records written to the stream are no longer subject to encryption. After you
        *             disabled encryption, you can verify that encryption is not applied by inspecting the API
        *             response from <code>PutRecord</code> or <code>PutRecords</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, StopStreamEncryptionCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, StopStreamEncryptionCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new StopStreamEncryptionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link StopStreamEncryptionCommandInput} for command's `input` shape.
        * @see {@link StopStreamEncryptionCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class StopStreamEncryptionCommand extends $Command<StopStreamEncryptionCommandInput, StopStreamEncryptionCommandOutput, KinesisClientResolvedConfig> {
            readonly input: StopStreamEncryptionCommandInput;
            constructor(input: StopStreamEncryptionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<StopStreamEncryptionCommandInput, StopStreamEncryptionCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/SubscribeToShardCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { SubscribeToShardInput, SubscribeToShardOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface SubscribeToShardCommandInput extends SubscribeToShardInput {
    }
    export interface SubscribeToShardCommandOutput extends SubscribeToShardOutput, __MetadataBearer {
    }
    /**
        * <p>This operation establishes an HTTP/2 connection between the consumer you specify in
        *             the <code>ConsumerARN</code> parameter and the shard you specify in the
        *                 <code>ShardId</code> parameter. After the connection is successfully established,
        *             Kinesis Data Streams pushes records from the shard to the consumer over this connection.
        *             Before you call this operation, call <a>RegisterStreamConsumer</a> to
        *             register the consumer with Kinesis Data Streams.</p>
        *         <p>When the <code>SubscribeToShard</code> call succeeds, your consumer starts receiving
        *             events of type <a>SubscribeToShardEvent</a> over the HTTP/2 connection for up
        *             to 5 minutes, after which time you need to call <code>SubscribeToShard</code> again to
        *             renew the subscription if you want to continue to receive records.</p>
        *         <p>You can make one call to <code>SubscribeToShard</code> per second per registered
        *             consumer per shard. For example, if you have a 4000 shard stream and two registered
        *             stream consumers, you can make one <code>SubscribeToShard</code> request per second for
        *             each combination of shard and registered consumer, allowing you to subscribe both
        *             consumers to all 4000 shards in one second. </p>
        *         <p>If you call <code>SubscribeToShard</code> again with the same <code>ConsumerARN</code>
        *             and <code>ShardId</code> within 5 seconds of a successful call, you'll get a
        *                 <code>ResourceInUseException</code>. If you call <code>SubscribeToShard</code> 5
        *             seconds or more after a successful call, the second call takes over the subscription and
        *             the previous connection expires or fails with a
        *             <code>ResourceInUseException</code>.</p>
        *         <p>For an example of how to use this operations, see <a href="/streams/latest/dev/building-enhanced-consumers-api.html">Enhanced Fan-Out
        *                 Using the Kinesis Data Streams API</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, SubscribeToShardCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, SubscribeToShardCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new SubscribeToShardCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link SubscribeToShardCommandInput} for command's `input` shape.
        * @see {@link SubscribeToShardCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class SubscribeToShardCommand extends $Command<SubscribeToShardCommandInput, SubscribeToShardCommandOutput, KinesisClientResolvedConfig> {
            readonly input: SubscribeToShardCommandInput;
            constructor(input: SubscribeToShardCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<SubscribeToShardCommandInput, SubscribeToShardCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/UpdateShardCountCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { UpdateShardCountInput, UpdateShardCountOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface UpdateShardCountCommandInput extends UpdateShardCountInput {
    }
    export interface UpdateShardCountCommandOutput extends UpdateShardCountOutput, __MetadataBearer {
    }
    /**
        * <p>Updates the shard count of the specified stream to the specified number of
        *             shards.</p>
        *         <p>Updating the shard count is an asynchronous operation. Upon receiving the request,
        *             Kinesis Data Streams returns immediately and sets the status of the stream to
        *                 <code>UPDATING</code>. After the update is complete, Kinesis Data Streams sets the
        *             status of the stream back to <code>ACTIVE</code>. Depending on the size of the stream,
        *             the scaling action could take a few minutes to complete. You can continue to read and
        *             write data to your stream while its status is <code>UPDATING</code>.</p>
        *         <p>To update the shard count, Kinesis Data Streams performs splits or merges on
        *             individual shards. This can cause short-lived shards to be created, in addition to the
        *             final shards. These short-lived shards count towards your total shard limit for your
        *             account in the Region.</p>
        *         <p>When using this operation, we recommend that you specify a target shard count that is
        *             a multiple of 25% (25%, 50%, 75%, 100%). You can specify any target value within your
        *             shard limit. However, if you specify a target that isn't a multiple of 25%, the scaling
        *             action might take longer to complete. </p>
        *         <p>This operation has the following default limits. By default, you cannot do the
        *             following:</p>
        *         <ul>
        *             <li>
        *                 <p>Scale more than ten times per rolling 24-hour period per stream</p>
        *             </li>
        *             <li>
        *                 <p>Scale up to more than double your current shard count for a stream</p>
        *             </li>
        *             <li>
        *                 <p>Scale down below half your current shard count for a stream</p>
        *             </li>
        *             <li>
        *                 <p>Scale up to more than 10000 shards in a stream</p>
        *             </li>
        *             <li>
        *                 <p>Scale a stream with more than 10000 shards down unless the result is less than
        *                     10000 shards</p>
        *             </li>
        *             <li>
        *                 <p>Scale up to more than the shard limit for your account</p>
        *             </li>
        *          </ul>
        *         <p>For the default limits for an Amazon Web Services account, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/service-sizes-and-limits.html">Streams
        *                 Limits</a> in the <i>Amazon Kinesis Data Streams Developer
        *                 Guide</i>. To request an increase in the call rate limit, the shard limit for
        *             this API, or your overall shard limit, use the <a href="https://console.aws.amazon.com/support/v1#/case/create?issueType=service-limit-increase&limitType=service-code-kinesis">limits form</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, UpdateShardCountCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, UpdateShardCountCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new UpdateShardCountCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateShardCountCommandInput} for command's `input` shape.
        * @see {@link UpdateShardCountCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class UpdateShardCountCommand extends $Command<UpdateShardCountCommandInput, UpdateShardCountCommandOutput, KinesisClientResolvedConfig> {
            readonly input: UpdateShardCountCommandInput;
            constructor(input: UpdateShardCountCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateShardCountCommandInput, UpdateShardCountCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/UpdateStreamModeCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { KinesisClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient";
    import { UpdateStreamModeInput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0";
    export interface UpdateStreamModeCommandInput extends UpdateStreamModeInput {
    }
    export interface UpdateStreamModeCommandOutput extends __MetadataBearer {
    }
    /**
        * <p> Updates the capacity mode of the data stream. Currently, in Kinesis Data Streams, you
        *             can choose between an <b>on-demand</b> capacity mode and a
        *                 <b>provisioned</b> capacity mode for your data stream.
        *         </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { KinesisClient, UpdateStreamModeCommand } from "@aws-sdk/client-kinesis"; // ES Modules import
        * // const { KinesisClient, UpdateStreamModeCommand } = require("@aws-sdk/client-kinesis"); // CommonJS import
        * const client = new KinesisClient(config);
        * const command = new UpdateStreamModeCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateStreamModeCommandInput} for command's `input` shape.
        * @see {@link UpdateStreamModeCommandOutput} for command's `response` shape.
        * @see {@link KinesisClientResolvedConfig | config} for KinesisClient's `config` shape.
        *
        */
    export class UpdateStreamModeCommand extends $Command<UpdateStreamModeCommandInput, UpdateStreamModeCommandOutput, KinesisClientResolvedConfig> {
            readonly input: UpdateStreamModeCommandInput;
            constructor(input: UpdateStreamModeCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: KinesisClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateStreamModeCommandInput, UpdateStreamModeCommandOutput>;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/KinesisClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { EventStreamSerdeInputConfig, EventStreamSerdeResolvedConfig } from "@aws-sdk/eventstream-serde-config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, EventStreamSerdeProvider as __EventStreamSerdeProvider, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { AddTagsToStreamCommandInput, AddTagsToStreamCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/AddTagsToStreamCommand";
    import { CreateStreamCommandInput, CreateStreamCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/CreateStreamCommand";
    import { DecreaseStreamRetentionPeriodCommandInput, DecreaseStreamRetentionPeriodCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DecreaseStreamRetentionPeriodCommand";
    import { DeleteStreamCommandInput, DeleteStreamCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DeleteStreamCommand";
    import { DeregisterStreamConsumerCommandInput, DeregisterStreamConsumerCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DeregisterStreamConsumerCommand";
    import { DescribeLimitsCommandInput, DescribeLimitsCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DescribeLimitsCommand";
    import { DescribeStreamCommandInput, DescribeStreamCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DescribeStreamCommand";
    import { DescribeStreamConsumerCommandInput, DescribeStreamConsumerCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DescribeStreamConsumerCommand";
    import { DescribeStreamSummaryCommandInput, DescribeStreamSummaryCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DescribeStreamSummaryCommand";
    import { DisableEnhancedMonitoringCommandInput, DisableEnhancedMonitoringCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/DisableEnhancedMonitoringCommand";
    import { EnableEnhancedMonitoringCommandInput, EnableEnhancedMonitoringCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/EnableEnhancedMonitoringCommand";
    import { GetRecordsCommandInput, GetRecordsCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/GetRecordsCommand";
    import { GetShardIteratorCommandInput, GetShardIteratorCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/GetShardIteratorCommand";
    import { IncreaseStreamRetentionPeriodCommandInput, IncreaseStreamRetentionPeriodCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/IncreaseStreamRetentionPeriodCommand";
    import { ListShardsCommandInput, ListShardsCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/ListShardsCommand";
    import { ListStreamConsumersCommandInput, ListStreamConsumersCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/ListStreamConsumersCommand";
    import { ListStreamsCommandInput, ListStreamsCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/ListStreamsCommand";
    import { ListTagsForStreamCommandInput, ListTagsForStreamCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/ListTagsForStreamCommand";
    import { MergeShardsCommandInput, MergeShardsCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/MergeShardsCommand";
    import { PutRecordCommandInput, PutRecordCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/PutRecordCommand";
    import { PutRecordsCommandInput, PutRecordsCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/PutRecordsCommand";
    import { RegisterStreamConsumerCommandInput, RegisterStreamConsumerCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/RegisterStreamConsumerCommand";
    import { RemoveTagsFromStreamCommandInput, RemoveTagsFromStreamCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/RemoveTagsFromStreamCommand";
    import { SplitShardCommandInput, SplitShardCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/SplitShardCommand";
    import { StartStreamEncryptionCommandInput, StartStreamEncryptionCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/StartStreamEncryptionCommand";
    import { StopStreamEncryptionCommandInput, StopStreamEncryptionCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/StopStreamEncryptionCommand";
    import { SubscribeToShardCommandInput, SubscribeToShardCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/SubscribeToShardCommand";
    import { UpdateShardCountCommandInput, UpdateShardCountCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/UpdateShardCountCommand";
    import { UpdateStreamModeCommandInput, UpdateStreamModeCommandOutput } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/commands/UpdateStreamModeCommand";
    export type ServiceInputTypes = AddTagsToStreamCommandInput | CreateStreamCommandInput | DecreaseStreamRetentionPeriodCommandInput | DeleteStreamCommandInput | DeregisterStreamConsumerCommandInput | DescribeLimitsCommandInput | DescribeStreamCommandInput | DescribeStreamConsumerCommandInput | DescribeStreamSummaryCommandInput | DisableEnhancedMonitoringCommandInput | EnableEnhancedMonitoringCommandInput | GetRecordsCommandInput | GetShardIteratorCommandInput | IncreaseStreamRetentionPeriodCommandInput | ListShardsCommandInput | ListStreamConsumersCommandInput | ListStreamsCommandInput | ListTagsForStreamCommandInput | MergeShardsCommandInput | PutRecordCommandInput | PutRecordsCommandInput | RegisterStreamConsumerCommandInput | RemoveTagsFromStreamCommandInput | SplitShardCommandInput | StartStreamEncryptionCommandInput | StopStreamEncryptionCommandInput | SubscribeToShardCommandInput | UpdateShardCountCommandInput | UpdateStreamModeCommandInput;
    export type ServiceOutputTypes = AddTagsToStreamCommandOutput | CreateStreamCommandOutput | DecreaseStreamRetentionPeriodCommandOutput | DeleteStreamCommandOutput | DeregisterStreamConsumerCommandOutput | DescribeLimitsCommandOutput | DescribeStreamCommandOutput | DescribeStreamConsumerCommandOutput | DescribeStreamSummaryCommandOutput | DisableEnhancedMonitoringCommandOutput | EnableEnhancedMonitoringCommandOutput | GetRecordsCommandOutput | GetShardIteratorCommandOutput | IncreaseStreamRetentionPeriodCommandOutput | ListShardsCommandOutput | ListStreamConsumersCommandOutput | ListStreamsCommandOutput | ListTagsForStreamCommandOutput | MergeShardsCommandOutput | PutRecordCommandOutput | PutRecordsCommandOutput | RegisterStreamConsumerCommandOutput | RemoveTagsFromStreamCommandOutput | SplitShardCommandOutput | StartStreamEncryptionCommandOutput | StopStreamEncryptionCommandOutput | SubscribeToShardCommandOutput | UpdateShardCountCommandOutput | UpdateStreamModeCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The function that provides necessary utilities for generating and parsing event stream
                */
            eventStreamSerdeProvider?: __EventStreamSerdeProvider;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type KinesisClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig & EventStreamSerdeInputConfig;
    /**
        * The configuration interface of KinesisClient class constructor that set the region, credentials and other options.
        */
    export interface KinesisClientConfig extends KinesisClientConfigType {
    }
    type KinesisClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig & EventStreamSerdeResolvedConfig;
    /**
        * The resolved configuration interface of KinesisClient class. This is resolved and normalized from the {@link KinesisClientConfig | constructor configuration interface}.
        */
    export interface KinesisClientResolvedConfig extends KinesisClientResolvedConfigType {
    }
    /**
        * <fullname>Amazon Kinesis Data Streams Service API Reference</fullname>
        *         <p>Amazon Kinesis Data Streams is a managed service that scales elastically for real-time
        *             processing of streaming big data.</p>
        */
    export class KinesisClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, KinesisClientResolvedConfig> {
            /**
                * The resolved configuration of KinesisClient class. This is resolved and normalized from the {@link KinesisClientConfig | constructor configuration interface}.
                */
            readonly config: KinesisClientResolvedConfig;
            constructor(configuration: KinesisClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { KinesisServiceException as __BaseException } from "@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/KinesisServiceException";
    /**
        * <p>Represents the input for <code>AddTagsToStream</code>.</p>
        */
    export interface AddTagsToStreamInput {
            /**
                * <p>The name of the stream.</p>
                */
            StreamName: string | undefined;
            /**
                * <p>A set of up to 10 key-value pairs to use to create the tags.</p>
                */
            Tags: Record<string, string> | undefined;
    }
    export namespace AddTagsToStreamInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AddTagsToStreamInput) => any;
    }
    /**
        * <p>A specified parameter exceeds its restrictions, is not supported, or can't be used.
        *             For more information, see the returned message.</p>
        */
    export class InvalidArgumentException extends __BaseException {
            readonly name: "InvalidArgumentException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidArgumentException, __BaseException>);
    }
    /**
        * <p>The requested resource exceeds the maximum number allowed, or the number of concurrent
        *             stream requests exceeds the maximum number allowed. </p>
        */
    export class LimitExceededException extends __BaseException {
            readonly name: "LimitExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<LimitExceededException, __BaseException>);
    }
    /**
        * <p>The resource is not available for this operation. For successful operation, the
        *             resource must be in the <code>ACTIVE</code> state.</p>
        */
    export class ResourceInUseException extends __BaseException {
            readonly name: "ResourceInUseException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceInUseException, __BaseException>);
    }
    /**
        * <p>The requested resource could not be found. The stream might not be specified
        *             correctly.</p>
        */
    export class ResourceNotFoundException extends __BaseException {
            readonly name: "ResourceNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>);
    }
    /**
        * <p>The range of possible hash key values for the shard, which is a set of ordered
        *             contiguous positive integers.</p>
        */
    export interface HashKeyRange {
            /**
                * <p>The starting hash key of the hash key range.</p>
                */
            StartingHashKey: string | undefined;
            /**
                * <p>The ending hash key of the hash key range.</p>
                */
            EndingHashKey: string | undefined;
    }
    export namespace HashKeyRange {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: HashKeyRange) => any;
    }
    /**
        * <p>Output parameter of the GetRecords API. The existing child shard of the current
        *             shard.</p>
        */
    export interface ChildShard {
            /**
                * <p>The shard ID of the existing child shard of the current shard.</p>
                */
            ShardId: string | undefined;
            /**
                * <p>The current shard that is the parent of the existing child shard.</p>
                */
            ParentShards: string[] | undefined;
            /**
                * <p>The range of possible hash key values for the shard, which is a set of ordered
                *             contiguous positive integers.</p>
                */
            HashKeyRange: HashKeyRange | undefined;
    }
    export namespace ChildShard {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ChildShard) => any;
    }
    export enum ConsumerStatus {
            ACTIVE = "ACTIVE",
            CREATING = "CREATING",
            DELETING = "DELETING"
    }
    /**
        * <p>An object that represents the details of the consumer you registered. This type of
        *             object is returned by <a>RegisterStreamConsumer</a>.</p>
        */
    export interface Consumer {
            /**
                * <p>The name of the consumer is something you choose when you register the
                *             consumer.</p>
                */
            ConsumerName: string | undefined;
            /**
                * <p>When you register a consumer, Kinesis Data Streams generates an ARN for it. You need
                *             this ARN to be able to call <a>SubscribeToShard</a>.</p>
                *         <p>If you delete a consumer and then create a new one with the same name, it won't have
                *             the same ARN. That's because consumer ARNs contain the creation timestamp. This is
                *             important to keep in mind if you have IAM policies that reference consumer ARNs.</p>
                */
            ConsumerARN: string | undefined;
            /**
                * <p>A consumer can't read data while in the <code>CREATING</code> or <code>DELETING</code>
                *             states.</p>
                */
            ConsumerStatus: ConsumerStatus | string | undefined;
            /**
                * <p></p>
                */
            ConsumerCreationTimestamp: Date | undefined;
    }
    export namespace Consumer {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Consumer) => any;
    }
    /**
        * <p>An object that represents the details of a registered consumer. This type of object is
        *             returned by <a>DescribeStreamConsumer</a>.</p>
        */
    export interface ConsumerDescription {
            /**
                * <p>The name of the consumer is something you choose when you register the
                *             consumer.</p>
                */
            ConsumerName: string | undefined;
            /**
                * <p>When you register a consumer, Kinesis Data Streams generates an ARN for it. You need
                *             this ARN to be able to call <a>SubscribeToShard</a>.</p>
                *         <p>If you delete a consumer and then create a new one with the same name, it won't have
                *             the same ARN. That's because consumer ARNs contain the creation timestamp. This is
                *             important to keep in mind if you have IAM policies that reference consumer ARNs.</p>
                */
            ConsumerARN: string | undefined;
            /**
                * <p>A consumer can't read data while in the <code>CREATING</code> or <code>DELETING</code>
                *             states.</p>
                */
            ConsumerStatus: ConsumerStatus | string | undefined;
            /**
                * <p></p>
                */
            ConsumerCreationTimestamp: Date | undefined;
            /**
                * <p>The ARN of the stream with which you registered the consumer.</p>
                */
            StreamARN: string | undefined;
    }
    export namespace ConsumerDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ConsumerDescription) => any;
    }
    export enum StreamMode {
            ON_DEMAND = "ON_DEMAND",
            PROVISIONED = "PROVISIONED"
    }
    /**
        * <p> Specifies the capacity mode to which you want to set your data stream. Currently, in
        *             Kinesis Data Streams, you can choose between an <b>on-demand</b> capacity mode and a <b>provisioned</b> capacity mode for your data streams. </p>
        */
    export interface StreamModeDetails {
            /**
                * <p> Specifies the capacity mode to which you want to set your data stream. Currently, in
                *             Kinesis Data Streams, you can choose between an <b>on-demand</b> capacity mode and a <b>provisioned</b> capacity mode for your data streams. </p>
                */
            StreamMode: StreamMode | string | undefined;
    }
    export namespace StreamModeDetails {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StreamModeDetails) => any;
    }
    /**
        * <p>Represents the input for <code>CreateStream</code>.</p>
        */
    export interface CreateStreamInput {
            /**
                * <p>A name to identify the stream. The stream name is scoped to the Amazon Web Services
                *             account used by the application that creates the stream. It is also scoped by Amazon Web Services Region. That is, two streams in two different Amazon Web Services accounts
                *             can have the same name. Two streams in the same Amazon Web Services account but in two
                *             different Regions can also have the same name.</p>
                */
            StreamName: string | undefined;
            /**
                * <p>The number of shards that the stream will use. The throughput of the stream is a
                *             function of the number of shards; more shards are required for greater provisioned
                *             throughput.</p>
                */
            ShardCount?: number;
            /**
                * <p> Indicates the capacity mode of the data stream. Currently, in Kinesis Data Streams,
                *             you can choose between an <b>on-demand</b> capacity mode and a
                *                 <b>provisioned</b> capacity mode for your data
                *             streams.</p>
                */
            StreamModeDetails?: StreamModeDetails;
    }
    export namespace CreateStreamInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateStreamInput) => any;
    }
    /**
        * <p>Represents the input for <a>DecreaseStreamRetentionPeriod</a>.</p>
        */
    export interface DecreaseStreamRetentionPeriodInput {
            /**
                * <p>The name of the stream to modify.</p>
                */
            StreamName: string | undefined;
            /**
                * <p>The new retention period of the stream, in hours. Must be less than the current
                *             retention period.</p>
                */
            RetentionPeriodHours: number | undefined;
    }
    export namespace DecreaseStreamRetentionPeriodInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DecreaseStreamRetentionPeriodInput) => any;
    }
    /**
        * <p>Represents the input for <a>DeleteStream</a>.</p>
        */
    export interface DeleteStreamInput {
            /**
                * <p>The name of the stream to delete.</p>
                */
            StreamName: string | undefined;
            /**
                * <p>If this parameter is unset (<code>null</code>) or if you set it to <code>false</code>,
                *             and the stream has registered consumers, the call to <code>DeleteStream</code> fails
                *             with a <code>ResourceInUseException</code>. </p>
                */
            EnforceConsumerDeletion?: boolean;
    }
    export namespace DeleteStreamInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteStreamInput) => any;
    }
    export interface DeregisterStreamConsumerInput {
            /**
                * <p>The ARN of the Kinesis data stream that the consumer is registered with. For more
                *             information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and Amazon Web Services Service
                *             Namespaces</a>.</p>
                */
            StreamARN?: string;
            /**
                * <p>The name that you gave to the consumer.</p>
                */
            ConsumerName?: string;
            /**
                * <p>The ARN returned by Kinesis Data Streams when you registered the consumer. If you
                *             don't know the ARN of the consumer that you want to deregister, you can use the
                *             ListStreamConsumers operation to get a list of the descriptions of all the consumers
                *             that are currently registered with a given data stream. The description of a consumer
                *             contains its ARN.</p>
                */
            ConsumerARN?: string;
    }
    export namespace DeregisterStreamConsumerInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeregisterStreamConsumerInput) => any;
    }
    export interface DescribeLimitsInput {
    }
    export namespace DescribeLimitsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeLimitsInput) => any;
    }
    export interface DescribeLimitsOutput {
            /**
                * <p>The maximum number of shards.</p>
                */
            ShardLimit: number | undefined;
            /**
                * <p>The number of open shards.</p>
                */
            OpenShardCount: number | undefined;
            /**
                * <p> Indicates the number of data streams with the on-demand capacity mode.</p>
                */
            OnDemandStreamCount: number | undefined;
            /**
                * <p> The maximum number of data streams with the on-demand capacity mode. </p>
                */
            OnDemandStreamCountLimit: number | undefined;
    }
    export namespace DescribeLimitsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeLimitsOutput) => any;
    }
    /**
        * <p>Represents the input for <code>DescribeStream</code>.</p>
        */
    export interface DescribeStreamInput {
            /**
                * <p>The name of the stream to describe.</p>
                */
            StreamName: string | undefined;
            /**
                * <p>The maximum number of shards to return in a single call. The default value is 100. If
                *             you specify a value greater than 100, at most 100 results are returned.</p>
                */
            Limit?: number;
            /**
                * <p>The shard ID of the shard to start with.</p>
                *         <p>Specify this parameter to indicate that you want to describe the stream starting with
                *             the shard whose ID immediately follows <code>ExclusiveStartShardId</code>.</p>
                *         <p>If you don't specify this parameter, the default behavior for
                *                 <code>DescribeStream</code> is to describe the stream starting with the first shard
                *             in the stream.</p>
                */
            ExclusiveStartShardId?: string;
    }
    export namespace DescribeStreamInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeStreamInput) => any;
    }
    export enum EncryptionType {
            KMS = "KMS",
            NONE = "NONE"
    }
    export enum MetricsName {
            ALL = "ALL",
            INCOMING_BYTES = "IncomingBytes",
            INCOMING_RECORDS = "IncomingRecords",
            ITERATOR_AGE_MILLISECONDS = "IteratorAgeMilliseconds",
            OUTGOING_BYTES = "OutgoingBytes",
            OUTGOING_RECORDS = "OutgoingRecords",
            READ_PROVISIONED_THROUGHPUT_EXCEEDED = "ReadProvisionedThroughputExceeded",
            WRITE_PROVISIONED_THROUGHPUT_EXCEEDED = "WriteProvisionedThroughputExceeded"
    }
    /**
        * <p>Represents enhanced metrics types.</p>
        */
    export interface EnhancedMetrics {
            /**
                * <p>List of shard-level metrics.</p>
                *         <p>The following are the valid shard-level metrics. The value "<code>ALL</code>" enhances
                *             every metric.</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>IncomingBytes</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>IncomingRecords</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>OutgoingBytes</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>OutgoingRecords</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>WriteProvisionedThroughputExceeded</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ReadProvisionedThroughputExceeded</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>IteratorAgeMilliseconds</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ALL</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/monitoring-with-cloudwatch.html">Monitoring the Amazon
                *                 Kinesis Data Streams Service with Amazon CloudWatch</a> in the <i>Amazon
                *                 Kinesis Data Streams Developer Guide</i>.</p>
                */
            ShardLevelMetrics?: (MetricsName | string)[];
    }
    export namespace EnhancedMetrics {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EnhancedMetrics) => any;
    }
    /**
        * <p>The range of possible sequence numbers for the shard.</p>
        */
    export interface SequenceNumberRange {
            /**
                * <p>The starting sequence number for the range.</p>
                */
            StartingSequenceNumber: string | undefined;
            /**
                * <p>The ending sequence number for the range. Shards that are in the OPEN state have an
                *             ending sequence number of <code>null</code>.</p>
                */
            EndingSequenceNumber?: string;
    }
    export namespace SequenceNumberRange {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SequenceNumberRange) => any;
    }
    /**
        * <p>A uniquely identified group of data records in a Kinesis data stream.</p>
        */
    export interface Shard {
            /**
                * <p>The unique identifier of the shard within the stream.</p>
                */
            ShardId: string | undefined;
            /**
                * <p>The shard ID of the shard's parent.</p>
                */
            ParentShardId?: string;
            /**
                * <p>The shard ID of the shard adjacent to the shard's parent.</p>
                */
            AdjacentParentShardId?: string;
            /**
                * <p>The range of possible hash key values for the shard, which is a set of ordered
                *             contiguous positive integers.</p>
                */
            HashKeyRange: HashKeyRange | undefined;
            /**
                * <p>The range of possible sequence numbers for the shard.</p>
                */
            SequenceNumberRange: SequenceNumberRange | undefined;
    }
    export namespace Shard {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Shard) => any;
    }
    export enum StreamStatus {
            ACTIVE = "ACTIVE",
            CREATING = "CREATING",
            DELETING = "DELETING",
            UPDATING = "UPDATING"
    }
    /**
        * <p>Represents the output for <a>DescribeStream</a>.</p>
        */
    export interface StreamDescription {
            /**
                * <p>The name of the stream being described.</p>
                */
            StreamName: string | undefined;
            /**
                * <p>The Amazon Resource Name (ARN) for the stream being described.</p>
                */
            StreamARN: string | undefined;
            /**
                * <p>The current status of the stream being described. The stream status is one of the
                *             following states:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>CREATING</code> - The stream is being created. Kinesis Data Streams
                *                     immediately returns and sets <code>StreamStatus</code> to
                *                     <code>CREATING</code>.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>DELETING</code> - The stream is being deleted. The specified stream is in
                *                     the <code>DELETING</code> state until Kinesis Data Streams completes the
                *                     deletion.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ACTIVE</code> - The stream exists and is ready for read and write
                *                     operations or deletion. You should perform read and write operations only on an
                *                         <code>ACTIVE</code> stream.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>UPDATING</code> - Shards in the stream are being merged or split. Read and
                *                     write operations continue to work while the stream is in the
                *                         <code>UPDATING</code> state.</p>
                *             </li>
                *          </ul>
                */
            StreamStatus: StreamStatus | string | undefined;
            /**
                * <p> Specifies the capacity mode to which you want to set your data stream. Currently, in
                *             Kinesis Data Streams, you can choose between an <b>on-demand</b> capacity mode and a <b>provisioned</b> capacity mode for your data streams. </p>
                */
            StreamModeDetails?: StreamModeDetails;
            /**
                * <p>The shards that comprise the stream.</p>
                */
            Shards: Shard[] | undefined;
            /**
                * <p>If set to <code>true</code>, more shards in the stream are available to
                *             describe.</p>
                */
            HasMoreShards: boolean | undefined;
            /**
                * <p>The current retention period, in hours. Minimum value of 24. Maximum value of
                *             168.</p>
                */
            RetentionPeriodHours: number | undefined;
            /**
                * <p>The approximate time that the stream was created.</p>
                */
            StreamCreationTimestamp: Date | undefined;
            /**
                * <p>Represents the current enhanced monitoring settings of the stream.</p>
                */
            EnhancedMonitoring: EnhancedMetrics[] | undefined;
            /**
                * <p>The server-side encryption type used on the stream. This parameter can be one of the
                *             following values:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>NONE</code>: Do not encrypt the records in the stream.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>KMS</code>: Use server-side encryption on the records in the stream
                *                     using a customer-managed Amazon Web Services KMS key.</p>
                *             </li>
                *          </ul>
                */
            EncryptionType?: EncryptionType | string;
            /**
                * <p>The GUID for the customer-managed Amazon Web Services KMS key to use for encryption.
                *             This value can be a globally unique identifier, a fully specified ARN to either an alias
                *             or a key, or an alias name prefixed by "alias/".You can also use a master key owned by
                *             Kinesis Data Streams by specifying the alias <code>aws/kinesis</code>.</p>
                *         <ul>
                *             <li>
                *                 <p>Key ARN example:
                *                         <code>arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012</code>
                *                </p>
                *             </li>
                *             <li>
                *                 <p>Alias ARN example:
                *                         <code>arn:aws:kms:us-east-1:123456789012:alias/MyAliasName</code>
                *                </p>
                *             </li>
                *             <li>
                *                 <p>Globally unique key ID example:
                *                         <code>12345678-1234-1234-1234-123456789012</code>
                *                </p>
                *             </li>
                *             <li>
                *                 <p>Alias name example: <code>alias/MyAliasName</code>
                *                </p>
                *             </li>
                *             <li>
                *                 <p>Master key owned by Kinesis Data Streams:
                *                     <code>alias/aws/kinesis</code>
                *                </p>
                *             </li>
                *          </ul>
                */
            KeyId?: string;
    }
    export namespace StreamDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StreamDescription) => any;
    }
    /**
        * <p>Represents the output for <code>DescribeStream</code>.</p>
        */
    export interface DescribeStreamOutput {
            /**
                * <p>The current status of the stream, the stream Amazon Resource Name (ARN), an array of
                *             shard objects that comprise the stream, and whether there are more shards
                *             available.</p>
                */
            StreamDescription: StreamDescription | undefined;
    }
    export namespace DescribeStreamOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeStreamOutput) => any;
    }
    export interface DescribeStreamConsumerInput {
            /**
                * <p>The ARN of the Kinesis data stream that the consumer is registered with. For more
                *             information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and Amazon Web Services Service
                *             Namespaces</a>.</p>
                */
            StreamARN?: string;
            /**
                * <p>The name that you gave to the consumer.</p>
                */
            ConsumerName?: string;
            /**
                * <p>The ARN returned by Kinesis Data Streams when you registered the consumer.</p>
                */
            ConsumerARN?: string;
    }
    export namespace DescribeStreamConsumerInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeStreamConsumerInput) => any;
    }
    export interface DescribeStreamConsumerOutput {
            /**
                * <p>An object that represents the details of the consumer.</p>
                */
            ConsumerDescription: ConsumerDescription | undefined;
    }
    export namespace DescribeStreamConsumerOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeStreamConsumerOutput) => any;
    }
    export interface DescribeStreamSummaryInput {
            /**
                * <p>The name of the stream to describe.</p>
                */
            StreamName: string | undefined;
    }
    export namespace DescribeStreamSummaryInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeStreamSummaryInput) => any;
    }
    /**
        * <p>Represents the output for <a>DescribeStreamSummary</a>
        *          </p>
        */
    export interface StreamDescriptionSummary {
            /**
                * <p>The name of the stream being described.</p>
                */
            StreamName: string | undefined;
            /**
                * <p>The Amazon Resource Name (ARN) for the stream being described.</p>
                */
            StreamARN: string | undefined;
            /**
                * <p>The current status of the stream being described. The stream status is one of the
                *             following states:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>CREATING</code> - The stream is being created. Kinesis Data Streams
                *                     immediately returns and sets <code>StreamStatus</code> to
                *                     <code>CREATING</code>.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>DELETING</code> - The stream is being deleted. The specified stream is in
                *                     the <code>DELETING</code> state until Kinesis Data Streams completes the
                *                     deletion.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ACTIVE</code> - The stream exists and is ready for read and write
                *                     operations or deletion. You should perform read and write operations only on an
                *                         <code>ACTIVE</code> stream.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>UPDATING</code> - Shards in the stream are being merged or split. Read and
                *                     write operations continue to work while the stream is in the
                *                         <code>UPDATING</code> state.</p>
                *             </li>
                *          </ul>
                */
            StreamStatus: StreamStatus | string | undefined;
            /**
                * <p> Specifies the capacity mode to which you want to set your data stream. Currently, in
                *             Kinesis Data Streams, you can choose between an <b>on-demand</b> ycapacity mode and a <b>provisioned</b> capacity mode for your data streams. </p>
                */
            StreamModeDetails?: StreamModeDetails;
            /**
                * <p>The current retention period, in hours.</p>
                */
            RetentionPeriodHours: number | undefined;
            /**
                * <p>The approximate time that the stream was created.</p>
                */
            StreamCreationTimestamp: Date | undefined;
            /**
                * <p>Represents the current enhanced monitoring settings of the stream.</p>
                */
            EnhancedMonitoring: EnhancedMetrics[] | undefined;
            /**
                * <p>The encryption type used. This value is one of the following:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>KMS</code>
                *                </p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>NONE</code>
                *                </p>
                *             </li>
                *          </ul>
                */
            EncryptionType?: EncryptionType | string;
            /**
                * <p>The GUID for the customer-managed Amazon Web Services KMS key to use for encryption.
                *             This value can be a globally unique identifier, a fully specified ARN to either an alias
                *             or a key, or an alias name prefixed by "alias/".You can also use a master key owned by
                *             Kinesis Data Streams by specifying the alias <code>aws/kinesis</code>.</p>
                *         <ul>
                *             <li>
                *                 <p>Key ARN example:
                *                         <code>arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012</code>
                *                </p>
                *             </li>
                *             <li>
                *                 <p>Alias ARN example: <code>
                *                         arn:aws:kms:us-east-1:123456789012:alias/MyAliasName</code>
                *                </p>
                *             </li>
                *             <li>
                *                 <p>Globally unique key ID example:
                *                         <code>12345678-1234-1234-1234-123456789012</code>
                *                </p>
                *             </li>
                *             <li>
                *                 <p>Alias name example: <code>alias/MyAliasName</code>
                *                </p>
                *             </li>
                *             <li>
                *                 <p>Master key owned by Kinesis Data Streams:
                *                     <code>alias/aws/kinesis</code>
                *                </p>
                *             </li>
                *          </ul>
                */
            KeyId?: string;
            /**
                * <p>The number of open shards in the stream.</p>
                */
            OpenShardCount: number | undefined;
            /**
                * <p>The number of enhanced fan-out consumers registered with the stream.</p>
                */
            ConsumerCount?: number;
    }
    export namespace StreamDescriptionSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StreamDescriptionSummary) => any;
    }
    export interface DescribeStreamSummaryOutput {
            /**
                * <p>A <a>StreamDescriptionSummary</a> containing information about the
                *             stream.</p>
                */
            StreamDescriptionSummary: StreamDescriptionSummary | undefined;
    }
    export namespace DescribeStreamSummaryOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeStreamSummaryOutput) => any;
    }
    /**
        * <p>Represents the input for <a>DisableEnhancedMonitoring</a>.</p>
        */
    export interface DisableEnhancedMonitoringInput {
            /**
                * <p>The name of the Kinesis data stream for which to disable enhanced monitoring.</p>
                */
            StreamName: string | undefined;
            /**
                * <p>List of shard-level metrics to disable.</p>
                *         <p>The following are the valid shard-level metrics. The value "<code>ALL</code>" disables
                *             every metric.</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>IncomingBytes</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>IncomingRecords</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>OutgoingBytes</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>OutgoingRecords</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>WriteProvisionedThroughputExceeded</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ReadProvisionedThroughputExceeded</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>IteratorAgeMilliseconds</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ALL</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/monitoring-with-cloudwatch.html">Monitoring the Amazon
                *                 Kinesis Data Streams Service with Amazon CloudWatch</a> in the <i>Amazon
                *                 Kinesis Data Streams Developer Guide</i>.</p>
                */
            ShardLevelMetrics: (MetricsName | string)[] | undefined;
    }
    export namespace DisableEnhancedMonitoringInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DisableEnhancedMonitoringInput) => any;
    }
    /**
        * <p>Represents the output for <a>EnableEnhancedMonitoring</a> and <a>DisableEnhancedMonitoring</a>.</p>
        */
    export interface EnhancedMonitoringOutput {
            /**
                * <p>The name of the Kinesis data stream.</p>
                */
            StreamName?: string;
            /**
                * <p>Represents the current state of the metrics that are in the enhanced state before the
                *             operation.</p>
                */
            CurrentShardLevelMetrics?: (MetricsName | string)[];
            /**
                * <p>Represents the list of all the metrics that would be in the enhanced state after the
                *             operation.</p>
                */
            DesiredShardLevelMetrics?: (MetricsName | string)[];
    }
    export namespace EnhancedMonitoringOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EnhancedMonitoringOutput) => any;
    }
    /**
        * <p>Represents the input for <a>EnableEnhancedMonitoring</a>.</p>
        */
    export interface EnableEnhancedMonitoringInput {
            /**
                * <p>The name of the stream for which to enable enhanced monitoring.</p>
                */
            StreamName: string | undefined;
            /**
                * <p>List of shard-level metrics to enable.</p>
                *         <p>The following are the valid shard-level metrics. The value "<code>ALL</code>" enables
                *             every metric.</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>IncomingBytes</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>IncomingRecords</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>OutgoingBytes</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>OutgoingRecords</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>WriteProvisionedThroughputExceeded</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ReadProvisionedThroughputExceeded</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>IteratorAgeMilliseconds</code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ALL</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/monitoring-with-cloudwatch.html">Monitoring the Amazon
                *                 Kinesis Data Streams Service with Amazon CloudWatch</a> in the <i>Amazon
                *                 Kinesis Data Streams Developer Guide</i>.</p>
                */
            ShardLevelMetrics: (MetricsName | string)[] | undefined;
    }
    export namespace EnableEnhancedMonitoringInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EnableEnhancedMonitoringInput) => any;
    }
    /**
        * <p>The provided iterator exceeds the maximum age allowed.</p>
        */
    export class ExpiredIteratorException extends __BaseException {
            readonly name: "ExpiredIteratorException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ExpiredIteratorException, __BaseException>);
    }
    /**
        * <p>The pagination token passed to the operation is expired.</p>
        */
    export class ExpiredNextTokenException extends __BaseException {
            readonly name: "ExpiredNextTokenException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ExpiredNextTokenException, __BaseException>);
    }
    /**
        * <p>Represents the input for <a>GetRecords</a>.</p>
        */
    export interface GetRecordsInput {
            /**
                * <p>The position in the shard from which you want to start sequentially reading data
                *             records. A shard iterator specifies this position using the sequence number of a data
                *             record in the shard.</p>
                */
            ShardIterator: string | undefined;
            /**
                * <p>The maximum number of records to return. Specify a value of up to 10,000. If you
                *             specify a value that is greater than 10,000, <a>GetRecords</a> throws
                *                 <code>InvalidArgumentException</code>. The default value is 10,000.</p>
                */
            Limit?: number;
    }
    export namespace GetRecordsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetRecordsInput) => any;
    }
    /**
        * <p>The unit of data of the Kinesis data stream, which is composed of a sequence number, a
        *             partition key, and a data blob.</p>
        */
    export interface _Record {
            /**
                * <p>The unique identifier of the record within its shard.</p>
                */
            SequenceNumber: string | undefined;
            /**
                * <p>The approximate time that the record was inserted into the stream.</p>
                */
            ApproximateArrivalTimestamp?: Date;
            /**
                * <p>The data blob. The data in the blob is both opaque and immutable to Kinesis Data
                *             Streams, which does not inspect, interpret, or change the data in the blob in any way.
                *             When the data blob (the payload before base64-encoding) is added to the partition key
                *             size, the total size must not exceed the maximum record size (1 MiB).</p>
                */
            Data: Uint8Array | undefined;
            /**
                * <p>Identifies which shard in the stream the data record is assigned to.</p>
                */
            PartitionKey: string | undefined;
            /**
                * <p>The encryption type used on the record. This parameter can be one of the following
                *             values:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>NONE</code>: Do not encrypt the records in the stream.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>KMS</code>: Use server-side encryption on the records in the stream
                *                     using a customer-managed Amazon Web Services KMS key.</p>
                *             </li>
                *          </ul>
                */
            EncryptionType?: EncryptionType | string;
    }
    export namespace _Record {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: _Record) => any;
    }
    /**
        * <p>Represents the output for <a>GetRecords</a>.</p>
        */
    export interface GetRecordsOutput {
            /**
                * <p>The data records retrieved from the shard.</p>
                */
            Records: _Record[] | undefined;
            /**
                * <p>The next position in the shard from which to start sequentially reading data records.
                *             If set to <code>null</code>, the shard has been closed and the requested iterator does
                *             not return any more data. </p>
                */
            NextShardIterator?: string;
            /**
                * <p>The number of milliseconds the <a>GetRecords</a> response is from the tip
                *             of the stream, indicating how far behind current time the consumer is. A value of zero
                *             indicates that record processing is caught up, and there are no new records to process
                *             at this moment.</p>
                */
            MillisBehindLatest?: number;
            /**
                * <p>The list of the current shard's child shards, returned in the <code>GetRecords</code>
                *             API's response only when the end of the current shard is reached.</p>
                */
            ChildShards?: ChildShard[];
    }
    export namespace GetRecordsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetRecordsOutput) => any;
    }
    /**
        * <p>The ciphertext references a key that doesn't exist or that you don't have access
        *             to.</p>
        */
    export class KMSAccessDeniedException extends __BaseException {
            readonly name: "KMSAccessDeniedException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<KMSAccessDeniedException, __BaseException>);
    }
    /**
        * <p>The request was rejected because the specified customer master key (CMK) isn't
        *             enabled.</p>
        */
    export class KMSDisabledException extends __BaseException {
            readonly name: "KMSDisabledException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<KMSDisabledException, __BaseException>);
    }
    /**
        * <p>The request was rejected because the state of the specified resource isn't valid for
        *             this request. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">How Key State Affects Use of a
        *                 Customer Master Key</a> in the <i>Amazon Web Services Key Management
        *                 Service Developer Guide</i>.</p>
        */
    export class KMSInvalidStateException extends __BaseException {
            readonly name: "KMSInvalidStateException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<KMSInvalidStateException, __BaseException>);
    }
    /**
        * <p>The request was rejected because the specified entity or resource can't be
        *             found.</p>
        */
    export class KMSNotFoundException extends __BaseException {
            readonly name: "KMSNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<KMSNotFoundException, __BaseException>);
    }
    /**
        * <p>The Amazon Web Services access key ID needs a subscription for the service.</p>
        */
    export class KMSOptInRequired extends __BaseException {
            readonly name: "KMSOptInRequired";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<KMSOptInRequired, __BaseException>);
    }
    /**
        * <p>The request was denied due to request throttling. For more information about
        *             throttling, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/limits.html#requests-per-second">Limits</a> in
        *             the <i>Amazon Web Services Key Management Service Developer
        *             Guide</i>.</p>
        */
    export class KMSThrottlingException extends __BaseException {
            readonly name: "KMSThrottlingException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<KMSThrottlingException, __BaseException>);
    }
    /**
        * <p>The request rate for the stream is too high, or the requested data is too large for
        *             the available throughput. Reduce the frequency or size of your requests. For more
        *             information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/service-sizes-and-limits.html">Streams Limits</a> in the
        *                 <i>Amazon Kinesis Data Streams Developer Guide</i>, and <a href="https://docs.aws.amazon.com/general/latest/gr/api-retries.html">Error Retries and
        *                 Exponential Backoff in Amazon Web Services</a> in the <i>Amazon Web Services General Reference</i>.</p>
        */
    export class ProvisionedThroughputExceededException extends __BaseException {
            readonly name: "ProvisionedThroughputExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ProvisionedThroughputExceededException, __BaseException>);
    }
    export enum ShardIteratorType {
            AFTER_SEQUENCE_NUMBER = "AFTER_SEQUENCE_NUMBER",
            AT_SEQUENCE_NUMBER = "AT_SEQUENCE_NUMBER",
            AT_TIMESTAMP = "AT_TIMESTAMP",
            LATEST = "LATEST",
            TRIM_HORIZON = "TRIM_HORIZON"
    }
    /**
        * <p>Represents the input for <code>GetShardIterator</code>.</p>
        */
    export interface GetShardIteratorInput {
            /**
                * <p>The name of the Amazon Kinesis data stream.</p>
                */
            StreamName: string | undefined;
            /**
                * <p>The shard ID of the Kinesis Data Streams shard to get the iterator for.</p>
                */
            ShardId: string | undefined;
            /**
                * <p>Determines how the shard iterator is used to start reading data records from the
                *             shard.</p>
                *         <p>The following are the valid Amazon Kinesis shard iterator types:</p>
                *         <ul>
                *             <li>
                *
                *                 <p>AT_SEQUENCE_NUMBER - Start reading from the position denoted by a specific
                *                     sequence number, provided in the value
                *                     <code>StartingSequenceNumber</code>.</p>
                *             </li>
                *             <li>
                *
                *                 <p>AFTER_SEQUENCE_NUMBER - Start reading right after the position denoted by a
                *                     specific sequence number, provided in the value
                *                         <code>StartingSequenceNumber</code>.</p>
                *             </li>
                *             <li>
                *
                *                 <p>AT_TIMESTAMP - Start reading from the position denoted by a specific time
                *                     stamp, provided in the value <code>Timestamp</code>.</p>
                *             </li>
                *             <li>
                *
                *                 <p>TRIM_HORIZON - Start reading at the last untrimmed record in the shard in the
                *                     system, which is the oldest data record in the shard.</p>
                *             </li>
                *             <li>
                *
                *                 <p>LATEST - Start reading just after the most recent record in the shard, so that
                *                     you always read the most recent data in the shard.</p>
                *             </li>
                *          </ul>
                */
            ShardIteratorType: ShardIteratorType | string | undefined;
            /**
                * <p>The sequence number of the data record in the shard from which to start reading. Used
                *             with shard iterator type AT_SEQUENCE_NUMBER and AFTER_SEQUENCE_NUMBER.</p>
                */
            StartingSequenceNumber?: string;
            /**
                * <p>The time stamp of the data record from which to start reading. Used with shard
                *             iterator type AT_TIMESTAMP. A time stamp is the Unix epoch date with precision in
                *             milliseconds. For example, <code>2016-04-04T19:58:46.480-00:00</code> or
                *                 <code>1459799926.480</code>. If a record with this exact time stamp does not exist,
                *             the iterator returned is for the next (later) record. If the time stamp is older than
                *             the current trim horizon, the iterator returned is for the oldest untrimmed data record
                *             (TRIM_HORIZON).</p>
                */
            Timestamp?: Date;
    }
    export namespace GetShardIteratorInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetShardIteratorInput) => any;
    }
    /**
        * <p>Represents the output for <code>GetShardIterator</code>.</p>
        */
    export interface GetShardIteratorOutput {
            /**
                * <p>The position in the shard from which to start reading data records sequentially. A
                *             shard iterator specifies this position using the sequence number of a data record in a
                *             shard.</p>
                */
            ShardIterator?: string;
    }
    export namespace GetShardIteratorOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetShardIteratorOutput) => any;
    }
    /**
        * <p>Represents the input for <a>IncreaseStreamRetentionPeriod</a>.</p>
        */
    export interface IncreaseStreamRetentionPeriodInput {
            /**
                * <p>The name of the stream to modify.</p>
                */
            StreamName: string | undefined;
            /**
                * <p>The new retention period of the stream, in hours. Must be more than the current
                *             retention period.</p>
                */
            RetentionPeriodHours: number | undefined;
    }
    export namespace IncreaseStreamRetentionPeriodInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: IncreaseStreamRetentionPeriodInput) => any;
    }
    /**
        * <p>The processing of the request failed because of an unknown error, exception, or
        *             failure.</p>
        */
    export class InternalFailureException extends __BaseException {
            readonly name: "InternalFailureException";
            readonly $fault: "server";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InternalFailureException, __BaseException>);
    }
    export enum ShardFilterType {
            AFTER_SHARD_ID = "AFTER_SHARD_ID",
            AT_LATEST = "AT_LATEST",
            AT_TIMESTAMP = "AT_TIMESTAMP",
            AT_TRIM_HORIZON = "AT_TRIM_HORIZON",
            FROM_TIMESTAMP = "FROM_TIMESTAMP",
            FROM_TRIM_HORIZON = "FROM_TRIM_HORIZON"
    }
    /**
        * <p>The request parameter used to filter out the response of the <code>ListShards</code>
        *             API.</p>
        */
    export interface ShardFilter {
            /**
                * <p>The shard type specified in the <code>ShardFilter</code> parameter. This is a required
                *             property of the <code>ShardFilter</code> parameter.</p>
                *         <p>You can specify the following valid values: </p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>AFTER_SHARD_ID</code> - the response includes all the shards, starting
                *                     with the shard whose ID immediately follows the <code>ShardId</code> that you
                *                     provided. </p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>AT_TRIM_HORIZON</code> - the response includes all the shards that were
                *                     open at <code>TRIM_HORIZON</code>.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>FROM_TRIM_HORIZON</code> - (default), the response includes all the
                *                     shards within the retention period of the data stream (trim to tip).</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>AT_LATEST</code> - the response includes only the currently open shards
                *                     of the data stream.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>AT_TIMESTAMP</code> - the response includes all shards whose start
                *                     timestamp is less than or equal to the given timestamp and end timestamp is
                *                     greater than or equal to the given timestamp or still open. </p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>FROM_TIMESTAMP</code> - the response incldues all closed shards whose
                *                     end timestamp is greater than or equal to the given timestamp and also all open
                *                     shards. Corrected to <code>TRIM_HORIZON</code> of the data stream if
                *                         <code>FROM_TIMESTAMP</code> is less than the <code>TRIM_HORIZON</code>
                *                     value.</p>
                *             </li>
                *          </ul>
                */
            Type: ShardFilterType | string | undefined;
            /**
                * <p>The exclusive start <code>shardID</code> speified in the <code>ShardFilter</code>
                *             parameter. This property can only be used if the <code>AFTER_SHARD_ID</code> shard type
                *             is specified.</p>
                */
            ShardId?: string;
            /**
                * <p>The timestamps specified in the <code>ShardFilter</code> parameter. A timestamp is a
                *             Unix epoch date with precision in milliseconds. For example,
                *             2016-04-04T19:58:46.480-00:00 or 1459799926.480. This property can only be used if
                *                 <code>FROM_TIMESTAMP</code> or <code>AT_TIMESTAMP</code> shard types are
                *             specified.</p>
                */
            Timestamp?: Date;
    }
    export namespace ShardFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ShardFilter) => any;
    }
    export interface ListShardsInput {
            /**
                * <p>The name of the data stream whose shards you want to list. </p>
                *         <p>You cannot specify this parameter if you specify the <code>NextToken</code>
                *             parameter.</p>
                */
            StreamName?: string;
            /**
                * <p>When the number of shards in the data stream is greater than the default value for the
                *                 <code>MaxResults</code> parameter, or if you explicitly specify a value for
                *                 <code>MaxResults</code> that is less than the number of shards in the data stream,
                *             the response includes a pagination token named <code>NextToken</code>. You can specify
                *             this <code>NextToken</code> value in a subsequent call to <code>ListShards</code> to
                *             list the next set of shards.</p>
                *         <p>Don't specify <code>StreamName</code> or <code>StreamCreationTimestamp</code> if you
                *             specify <code>NextToken</code> because the latter unambiguously identifies the
                *             stream.</p>
                *         <p>You can optionally specify a value for the <code>MaxResults</code> parameter when you
                *             specify <code>NextToken</code>. If you specify a <code>MaxResults</code> value that is
                *             less than the number of shards that the operation returns if you don't specify
                *                 <code>MaxResults</code>, the response will contain a new <code>NextToken</code>
                *             value. You can use the new <code>NextToken</code> value in a subsequent call to the
                *                 <code>ListShards</code> operation.</p>
                *         <important>
                *             <p>Tokens expire after 300 seconds. When you obtain a value for
                *                     <code>NextToken</code> in the response to a call to <code>ListShards</code>, you
                *                 have 300 seconds to use that value. If you specify an expired token in a call to
                *                     <code>ListShards</code>, you get <code>ExpiredNextTokenException</code>.</p>
                *         </important>
                */
            NextToken?: string;
            /**
                * <p>Specify this parameter to indicate that you want to list the shards starting with the
                *             shard whose ID immediately follows <code>ExclusiveStartShardId</code>.</p>
                *         <p>If you don't specify this parameter, the default behavior is for
                *                 <code>ListShards</code> to list the shards starting with the first one in the
                *             stream.</p>
                *         <p>You cannot specify this parameter if you specify <code>NextToken</code>.</p>
                */
            ExclusiveStartShardId?: string;
            /**
                * <p>The maximum number of shards to return in a single call to <code>ListShards</code>.
                *             The maximum number of shards to return in a single call. The default value is 1000. If
                *             you specify a value greater than 1000, at most 1000 results are returned. </p>
                *         <p>When the number of shards to be listed is greater than the value of
                *                 <code>MaxResults</code>, the response contains a <code>NextToken</code> value that
                *             you can use in a subsequent call to <code>ListShards</code> to list the next set of
                *             shards.</p>
                */
            MaxResults?: number;
            /**
                * <p>Specify this input parameter to distinguish data streams that have the same name. For
                *             example, if you create a data stream and then delete it, and you later create another
                *             data stream with the same name, you can use this input parameter to specify which of the
                *             two streams you want to list the shards for.</p>
                *         <p>You cannot specify this parameter if you specify the <code>NextToken</code>
                *             parameter.</p>
                */
            StreamCreationTimestamp?: Date;
            /**
                * <p>Enables you to filter out the response of the <code>ListShards</code> API. You can
                *             only specify one filter at a time. </p>
                *         <p>If you use the <code>ShardFilter</code> parameter when invoking the ListShards API,
                *             the <code>Type</code> is the required property and must be specified. If you specify the
                *                 <code>AT_TRIM_HORIZON</code>, <code>FROM_TRIM_HORIZON</code>, or
                *                 <code>AT_LATEST</code> types, you do not need to specify either the
                *                 <code>ShardId</code> or the <code>Timestamp</code> optional properties. </p>
                *         <p>If you specify the <code>AFTER_SHARD_ID</code> type, you must also provide the value
                *             for the optional <code>ShardId</code> property. The <code>ShardId</code> property is
                *             identical in fuctionality to the <code>ExclusiveStartShardId</code> parameter of the
                *                 <code>ListShards</code> API. When <code>ShardId</code> property is specified, the
                *             response includes the shards starting with the shard whose ID immediately follows the
                *                 <code>ShardId</code> that you provided. </p>
                *         <p>If you specify the <code>AT_TIMESTAMP</code> or <code>FROM_TIMESTAMP_ID</code> type,
                *             you must also provide the value for the optional <code>Timestamp</code> property. If you
                *             specify the AT_TIMESTAMP type, then all shards that were open at the provided timestamp
                *             are returned. If you specify the FROM_TIMESTAMP type, then all shards starting from the
                *             provided timestamp to TIP are returned. </p>
                */
            ShardFilter?: ShardFilter;
    }
    export namespace ListShardsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListShardsInput) => any;
    }
    export interface ListShardsOutput {
            /**
                * <p>An array of JSON objects. Each object represents one shard and specifies the IDs of
                *             the shard, the shard's parent, and the shard that's adjacent to the shard's parent. Each
                *             object also contains the starting and ending hash keys and the starting and ending
                *             sequence numbers for the shard.</p>
                */
            Shards?: Shard[];
            /**
                * <p>When the number of shards in the data stream is greater than the default value for the
                *                 <code>MaxResults</code> parameter, or if you explicitly specify a value for
                *                 <code>MaxResults</code> that is less than the number of shards in the data stream,
                *             the response includes a pagination token named <code>NextToken</code>. You can specify
                *             this <code>NextToken</code> value in a subsequent call to <code>ListShards</code> to
                *             list the next set of shards. For more information about the use of this pagination token
                *             when calling the <code>ListShards</code> operation, see <a>ListShardsInput$NextToken</a>.</p>
                *         <important>
                *             <p>Tokens expire after 300 seconds. When you obtain a value for
                *                     <code>NextToken</code> in the response to a call to <code>ListShards</code>, you
                *                 have 300 seconds to use that value. If you specify an expired token in a call to
                *                     <code>ListShards</code>, you get <code>ExpiredNextTokenException</code>.</p>
                *         </important>
                */
            NextToken?: string;
    }
    export namespace ListShardsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListShardsOutput) => any;
    }
    export interface ListStreamConsumersInput {
            /**
                * <p>The ARN of the Kinesis data stream for which you want to list the registered
                *             consumers. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and Amazon Web Services Service
                *             Namespaces</a>.</p>
                */
            StreamARN: string | undefined;
            /**
                * <p>When the number of consumers that are registered with the data stream is greater than
                *             the default value for the <code>MaxResults</code> parameter, or if you explicitly
                *             specify a value for <code>MaxResults</code> that is less than the number of consumers
                *             that are registered with the data stream, the response includes a pagination token named
                *                 <code>NextToken</code>. You can specify this <code>NextToken</code> value in a
                *             subsequent call to <code>ListStreamConsumers</code> to list the next set of registered
                *             consumers.</p>
                *         <p>Don't specify <code>StreamName</code> or <code>StreamCreationTimestamp</code> if you
                *             specify <code>NextToken</code> because the latter unambiguously identifies the
                *             stream.</p>
                *         <p>You can optionally specify a value for the <code>MaxResults</code> parameter when you
                *             specify <code>NextToken</code>. If you specify a <code>MaxResults</code> value that is
                *             less than the number of consumers that the operation returns if you don't specify
                *                 <code>MaxResults</code>, the response will contain a new <code>NextToken</code>
                *             value. You can use the new <code>NextToken</code> value in a subsequent call to the
                *                 <code>ListStreamConsumers</code> operation to list the next set of consumers.</p>
                *         <important>
                *             <p>Tokens expire after 300 seconds. When you obtain a value for
                *                     <code>NextToken</code> in the response to a call to
                *                     <code>ListStreamConsumers</code>, you have 300 seconds to use that value. If you
                *                 specify an expired token in a call to <code>ListStreamConsumers</code>, you get
                *                     <code>ExpiredNextTokenException</code>.</p>
                *         </important>
                */
            NextToken?: string;
            /**
                * <p>The maximum number of consumers that you want a single call of
                *                 <code>ListStreamConsumers</code> to return. The default value is 100. If you specify
                *             a value greater than 100, at most 100 results are returned. </p>
                */
            MaxResults?: number;
            /**
                * <p>Specify this input parameter to distinguish data streams that have the same name. For
                *             example, if you create a data stream and then delete it, and you later create another
                *             data stream with the same name, you can use this input parameter to specify which of the
                *             two streams you want to list the consumers for. </p>
                *         <p>You can't specify this parameter if you specify the NextToken parameter. </p>
                */
            StreamCreationTimestamp?: Date;
    }
    export namespace ListStreamConsumersInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListStreamConsumersInput) => any;
    }
    export interface ListStreamConsumersOutput {
            /**
                * <p>An array of JSON objects. Each object represents one registered consumer.</p>
                */
            Consumers?: Consumer[];
            /**
                * <p>When the number of consumers that are registered with the data stream is greater than
                *             the default value for the <code>MaxResults</code> parameter, or if you explicitly
                *             specify a value for <code>MaxResults</code> that is less than the number of registered
                *             consumers, the response includes a pagination token named <code>NextToken</code>. You
                *             can specify this <code>NextToken</code> value in a subsequent call to
                *                 <code>ListStreamConsumers</code> to list the next set of registered consumers. For
                *             more information about the use of this pagination token when calling the
                *                 <code>ListStreamConsumers</code> operation, see <a>ListStreamConsumersInput$NextToken</a>.</p>
                *         <important>
                *             <p>Tokens expire after 300 seconds. When you obtain a value for
                *                     <code>NextToken</code> in the response to a call to
                *                     <code>ListStreamConsumers</code>, you have 300 seconds to use that value. If you
                *                 specify an expired token in a call to <code>ListStreamConsumers</code>, you get
                *                     <code>ExpiredNextTokenException</code>.</p>
                *         </important>
                */
            NextToken?: string;
    }
    export namespace ListStreamConsumersOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListStreamConsumersOutput) => any;
    }
    /**
        * <p>Represents the input for <code>ListStreams</code>.</p>
        */
    export interface ListStreamsInput {
            /**
                * <p>The maximum number of streams to list. The default value is 100. If you specify a
                *             value greater than 100, at most 100 results are returned.</p>
                */
            Limit?: number;
            /**
                * <p>The name of the stream to start the list with.</p>
                */
            ExclusiveStartStreamName?: string;
    }
    export namespace ListStreamsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListStreamsInput) => any;
    }
    /**
        * <p>Represents the output for <code>ListStreams</code>.</p>
        */
    export interface ListStreamsOutput {
            /**
                * <p>The names of the streams that are associated with the Amazon Web Services account
                *             making the <code>ListStreams</code> request.</p>
                */
            StreamNames: string[] | undefined;
            /**
                * <p>If set to <code>true</code>, there are more streams available to list.</p>
                */
            HasMoreStreams: boolean | undefined;
    }
    export namespace ListStreamsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListStreamsOutput) => any;
    }
    /**
        * <p>Represents the input for <code>ListTagsForStream</code>.</p>
        */
    export interface ListTagsForStreamInput {
            /**
                * <p>The name of the stream.</p>
                */
            StreamName: string | undefined;
            /**
                * <p>The key to use as the starting point for the list of tags. If this parameter is set,
                *                 <code>ListTagsForStream</code> gets all tags that occur after
                *                 <code>ExclusiveStartTagKey</code>. </p>
                */
            ExclusiveStartTagKey?: string;
            /**
                * <p>The number of tags to return. If this number is less than the total number of tags
                *             associated with the stream, <code>HasMoreTags</code> is set to <code>true</code>. To
                *             list additional tags, set <code>ExclusiveStartTagKey</code> to the last key in the
                *             response.</p>
                */
            Limit?: number;
    }
    export namespace ListTagsForStreamInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForStreamInput) => any;
    }
    /**
        * <p>Metadata assigned to the stream, consisting of a key-value pair.</p>
        */
    export interface Tag {
            /**
                * <p>A unique identifier for the tag. Maximum length: 128 characters. Valid characters:
                *             Unicode letters, digits, white space, _ . / = + - % @</p>
                */
            Key: string | undefined;
            /**
                * <p>An optional string, typically used to describe or define the tag. Maximum length: 256
                *             characters. Valid characters: Unicode letters, digits, white space, _ . / = + - %
                *             @</p>
                */
            Value?: string;
    }
    export namespace Tag {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Tag) => any;
    }
    /**
        * <p>Represents the output for <code>ListTagsForStream</code>.</p>
        */
    export interface ListTagsForStreamOutput {
            /**
                * <p>A list of tags associated with <code>StreamName</code>, starting with the first tag
                *             after <code>ExclusiveStartTagKey</code> and up to the specified <code>Limit</code>.
                *         </p>
                */
            Tags: Tag[] | undefined;
            /**
                * <p>If set to <code>true</code>, more tags are available. To request additional tags, set
                *                 <code>ExclusiveStartTagKey</code> to the key of the last tag returned.</p>
                */
            HasMoreTags: boolean | undefined;
    }
    export namespace ListTagsForStreamOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForStreamOutput) => any;
    }
    /**
        * <p>Represents the input for <code>MergeShards</code>.</p>
        */
    export interface MergeShardsInput {
            /**
                * <p>The name of the stream for the merge.</p>
                */
            StreamName: string | undefined;
            /**
                * <p>The shard ID of the shard to combine with the adjacent shard for the merge.</p>
                */
            ShardToMerge: string | undefined;
            /**
                * <p>The shard ID of the adjacent shard for the merge.</p>
                */
            AdjacentShardToMerge: string | undefined;
    }
    export namespace MergeShardsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: MergeShardsInput) => any;
    }
    /**
        * <p>
        *
        *         </p>
        */
    export class ValidationException extends __BaseException {
            readonly name: "ValidationException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ValidationException, __BaseException>);
    }
    /**
        * <p>Represents the input for <code>PutRecord</code>.</p>
        */
    export interface PutRecordInput {
            /**
                * <p>The name of the stream to put the data record into.</p>
                */
            StreamName: string | undefined;
            /**
                * <p>The data blob to put into the record, which is base64-encoded when the blob is
                *             serialized. When the data blob (the payload before base64-encoding) is added to the
                *             partition key size, the total size must not exceed the maximum record size (1
                *             MiB).</p>
                */
            Data: Uint8Array | undefined;
            /**
                * <p>Determines which shard in the stream the data record is assigned to. Partition keys
                *             are Unicode strings with a maximum length limit of 256 characters for each key. Amazon
                *             Kinesis Data Streams uses the partition key as input to a hash function that maps the
                *             partition key and associated data to a specific shard. Specifically, an MD5 hash
                *             function is used to map partition keys to 128-bit integer values and to map associated
                *             data records to shards. As a result of this hashing mechanism, all data records with the
                *             same partition key map to the same shard within the stream.</p>
                */
            PartitionKey: string | undefined;
            /**
                * <p>The hash value used to explicitly determine the shard the data record is assigned to
                *             by overriding the partition key hash.</p>
                */
            ExplicitHashKey?: string;
            /**
                * <p>Guarantees strictly increasing sequence numbers, for puts from the same client and to
                *             the same partition key. Usage: set the <code>SequenceNumberForOrdering</code> of record
                *                 <i>n</i> to the sequence number of record <i>n-1</i> (as
                *             returned in the result when putting record <i>n-1</i>). If this parameter
                *             is not set, records are coarsely ordered based on arrival time.</p>
                */
            SequenceNumberForOrdering?: string;
    }
    export namespace PutRecordInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutRecordInput) => any;
    }
    /**
        * <p>Represents the output for <code>PutRecord</code>.</p>
        */
    export interface PutRecordOutput {
            /**
                * <p>The shard ID of the shard where the data record was placed.</p>
                */
            ShardId: string | undefined;
            /**
                * <p>The sequence number identifier that was assigned to the put data record. The sequence
                *             number for the record is unique across all records in the stream. A sequence number is
                *             the identifier associated with every record put into the stream.</p>
                */
            SequenceNumber: string | undefined;
            /**
                * <p>The encryption type to use on the record. This parameter can be one of the following
                *             values:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>NONE</code>: Do not encrypt the records in the stream.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>KMS</code>: Use server-side encryption on the records in the stream
                *                     using a customer-managed Amazon Web Services KMS key.</p>
                *             </li>
                *          </ul>
                */
            EncryptionType?: EncryptionType | string;
    }
    export namespace PutRecordOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutRecordOutput) => any;
    }
    /**
        * <p>Represents the output for <code>PutRecords</code>.</p>
        */
    export interface PutRecordsRequestEntry {
            /**
                * <p>The data blob to put into the record, which is base64-encoded when the blob is
                *             serialized. When the data blob (the payload before base64-encoding) is added to the
                *             partition key size, the total size must not exceed the maximum record size (1
                *             MiB).</p>
                */
            Data: Uint8Array | undefined;
            /**
                * <p>The hash value used to determine explicitly the shard that the data record is assigned
                *             to by overriding the partition key hash.</p>
                */
            ExplicitHashKey?: string;
            /**
                * <p>Determines which shard in the stream the data record is assigned to. Partition keys
                *             are Unicode strings with a maximum length limit of 256 characters for each key. Amazon
                *             Kinesis Data Streams uses the partition key as input to a hash function that maps the
                *             partition key and associated data to a specific shard. Specifically, an MD5 hash
                *             function is used to map partition keys to 128-bit integer values and to map associated
                *             data records to shards. As a result of this hashing mechanism, all data records with the
                *             same partition key map to the same shard within the stream.</p>
                */
            PartitionKey: string | undefined;
    }
    export namespace PutRecordsRequestEntry {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutRecordsRequestEntry) => any;
    }
    /**
        * <p>A <code>PutRecords</code> request.</p>
        */
    export interface PutRecordsInput {
            /**
                * <p>The records associated with the request.</p>
                */
            Records: PutRecordsRequestEntry[] | undefined;
            /**
                * <p>The stream name associated with the request.</p>
                */
            StreamName: string | undefined;
    }
    export namespace PutRecordsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutRecordsInput) => any;
    }
    /**
        * <p>Represents the result of an individual record from a <code>PutRecords</code> request.
        *             A record that is successfully added to a stream includes <code>SequenceNumber</code> and
        *                 <code>ShardId</code> in the result. A record that fails to be added to the stream
        *             includes <code>ErrorCode</code> and <code>ErrorMessage</code> in the result.</p>
        */
    export interface PutRecordsResultEntry {
            /**
                * <p>The sequence number for an individual record result.</p>
                */
            SequenceNumber?: string;
            /**
                * <p>The shard ID for an individual record result.</p>
                */
            ShardId?: string;
            /**
                * <p>The error code for an individual record result. <code>ErrorCodes</code> can be either
                *                 <code>ProvisionedThroughputExceededException</code> or
                *             <code>InternalFailure</code>.</p>
                */
            ErrorCode?: string;
            /**
                * <p>The error message for an individual record result. An <code>ErrorCode</code> value of
                *                 <code>ProvisionedThroughputExceededException</code> has an error message that
                *             includes the account ID, stream name, and shard ID. An <code>ErrorCode</code> value of
                *                 <code>InternalFailure</code> has the error message <code>"Internal Service
                *                 Failure"</code>.</p>
                */
            ErrorMessage?: string;
    }
    export namespace PutRecordsResultEntry {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutRecordsResultEntry) => any;
    }
    /**
        * <p>
        *             <code>PutRecords</code> results.</p>
        */
    export interface PutRecordsOutput {
            /**
                * <p>The number of unsuccessfully processed records in a <code>PutRecords</code>
                *             request.</p>
                */
            FailedRecordCount?: number;
            /**
                * <p>An array of successfully and unsuccessfully processed record results. A record that is
                *             successfully added to a stream includes <code>SequenceNumber</code> and
                *                 <code>ShardId</code> in the result. A record that fails to be added to a stream
                *             includes <code>ErrorCode</code> and <code>ErrorMessage</code> in the result.</p>
                */
            Records: PutRecordsResultEntry[] | undefined;
            /**
                * <p>The encryption type used on the records. This parameter can be one of the following
                *             values:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>NONE</code>: Do not encrypt the records.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>KMS</code>: Use server-side encryption on the records using a
                *                     customer-managed Amazon Web Services KMS key.</p>
                *             </li>
                *          </ul>
                */
            EncryptionType?: EncryptionType | string;
    }
    export namespace PutRecordsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutRecordsOutput) => any;
    }
    export interface RegisterStreamConsumerInput {
            /**
                * <p>The ARN of the Kinesis data stream that you want to register the consumer with. For
                *             more info, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and Amazon Web Services Service
                *             Namespaces</a>.</p>
                */
            StreamARN: string | undefined;
            /**
                * <p>For a given Kinesis data stream, each consumer must have a unique name. However,
                *             consumer names don't have to be unique across data streams.</p>
                */
            ConsumerName: string | undefined;
    }
    export namespace RegisterStreamConsumerInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RegisterStreamConsumerInput) => any;
    }
    export interface RegisterStreamConsumerOutput {
            /**
                * <p>An object that represents the details of the consumer you registered. When you
                *             register a consumer, it gets an ARN that is generated by Kinesis Data Streams.</p>
                */
            Consumer: Consumer | undefined;
    }
    export namespace RegisterStreamConsumerOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RegisterStreamConsumerOutput) => any;
    }
    /**
        * <p>Represents the input for <code>RemoveTagsFromStream</code>.</p>
        */
    export interface RemoveTagsFromStreamInput {
            /**
                * <p>The name of the stream.</p>
                */
            StreamName: string | undefined;
            /**
                * <p>A list of tag keys. Each corresponding tag is removed from the stream.</p>
                */
            TagKeys: string[] | undefined;
    }
    export namespace RemoveTagsFromStreamInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RemoveTagsFromStreamInput) => any;
    }
    /**
        * <p>Represents the input for <code>SplitShard</code>.</p>
        */
    export interface SplitShardInput {
            /**
                * <p>The name of the stream for the shard split.</p>
                */
            StreamName: string | undefined;
            /**
                * <p>The shard ID of the shard to split.</p>
                */
            ShardToSplit: string | undefined;
            /**
                * <p>A hash key value for the starting hash key of one of the child shards created by the
                *             split. The hash key range for a given shard constitutes a set of ordered contiguous
                *             positive integers. The value for <code>NewStartingHashKey</code> must be in the range of
                *             hash keys being mapped into the shard. The <code>NewStartingHashKey</code> hash key
                *             value and all higher hash key values in hash key range are distributed to one of the
                *             child shards. All the lower hash key values in the range are distributed to the other
                *             child shard.</p>
                */
            NewStartingHashKey: string | undefined;
    }
    export namespace SplitShardInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SplitShardInput) => any;
    }
    export interface StartStreamEncryptionInput {
            /**
                * <p>The name of the stream for which to start encrypting records.</p>
                */
            StreamName: string | undefined;
            /**
                * <p>The encryption type to use. The only valid value is <code>KMS</code>.</p>
                */
            EncryptionType: EncryptionType | string | undefined;
            /**
                * <p>The GUID for the customer-managed Amazon Web Services KMS key to use for encryption.
                *             This value can be a globally unique identifier, a fully specified Amazon Resource Name
                *             (ARN) to either an alias or a key, or an alias name prefixed by "alias/".You can also
                *             use a master key owned by Kinesis Data Streams by specifying the alias
                *                 <code>aws/kinesis</code>.</p>
                *         <ul>
                *             <li>
                *                 <p>Key ARN example:
                *                         <code>arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012</code>
                *                </p>
                *             </li>
                *             <li>
                *                 <p>Alias ARN example:
                *                         <code>arn:aws:kms:us-east-1:123456789012:alias/MyAliasName</code>
                *                </p>
                *             </li>
                *             <li>
                *                 <p>Globally unique key ID example:
                *                         <code>12345678-1234-1234-1234-123456789012</code>
                *                </p>
                *             </li>
                *             <li>
                *                 <p>Alias name example: <code>alias/MyAliasName</code>
                *                </p>
                *             </li>
                *             <li>
                *                 <p>Master key owned by Kinesis Data Streams:
                *                     <code>alias/aws/kinesis</code>
                *                </p>
                *             </li>
                *          </ul>
                */
            KeyId: string | undefined;
    }
    export namespace StartStreamEncryptionInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartStreamEncryptionInput) => any;
    }
    export interface StopStreamEncryptionInput {
            /**
                * <p>The name of the stream on which to stop encrypting records.</p>
                */
            StreamName: string | undefined;
            /**
                * <p>The encryption type. The only valid value is <code>KMS</code>.</p>
                */
            EncryptionType: EncryptionType | string | undefined;
            /**
                * <p>The GUID for the customer-managed Amazon Web Services KMS key to use for encryption.
                *             This value can be a globally unique identifier, a fully specified Amazon Resource Name
                *             (ARN) to either an alias or a key, or an alias name prefixed by "alias/".You can also
                *             use a master key owned by Kinesis Data Streams by specifying the alias
                *                 <code>aws/kinesis</code>.</p>
                *         <ul>
                *             <li>
                *                 <p>Key ARN example:
                *                         <code>arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012</code>
                *                </p>
                *             </li>
                *             <li>
                *                 <p>Alias ARN example:
                *                         <code>arn:aws:kms:us-east-1:123456789012:alias/MyAliasName</code>
                *                </p>
                *             </li>
                *             <li>
                *                 <p>Globally unique key ID example:
                *                         <code>12345678-1234-1234-1234-123456789012</code>
                *                </p>
                *             </li>
                *             <li>
                *                 <p>Alias name example: <code>alias/MyAliasName</code>
                *                </p>
                *             </li>
                *             <li>
                *                 <p>Master key owned by Kinesis Data Streams:
                *                     <code>alias/aws/kinesis</code>
                *                </p>
                *             </li>
                *          </ul>
                */
            KeyId: string | undefined;
    }
    export namespace StopStreamEncryptionInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StopStreamEncryptionInput) => any;
    }
    /**
        * <p>The starting position in the data stream from which to start streaming.</p>
        */
    export interface StartingPosition {
            /**
                * <p>You can set the starting position to one of the following values:</p>
                *         <p>
                *             <code>AT_SEQUENCE_NUMBER</code>: Start streaming from the position denoted by the
                *             sequence number specified in the <code>SequenceNumber</code> field.</p>
                *         <p>
                *             <code>AFTER_SEQUENCE_NUMBER</code>: Start streaming right after the position denoted
                *             by the sequence number specified in the <code>SequenceNumber</code> field.</p>
                *         <p>
                *             <code>AT_TIMESTAMP</code>: Start streaming from the position denoted by the time stamp
                *             specified in the <code>Timestamp</code> field.</p>
                *         <p>
                *             <code>TRIM_HORIZON</code>: Start streaming at the last untrimmed record in the shard,
                *             which is the oldest data record in the shard.</p>
                *         <p>
                *             <code>LATEST</code>: Start streaming just after the most recent record in the shard,
                *             so that you always read the most recent data in the shard.</p>
                */
            Type: ShardIteratorType | string | undefined;
            /**
                * <p>The sequence number of the data record in the shard from which to start streaming. To
                *             specify a sequence number, set <code>StartingPosition</code> to
                *                 <code>AT_SEQUENCE_NUMBER</code> or <code>AFTER_SEQUENCE_NUMBER</code>.</p>
                */
            SequenceNumber?: string;
            /**
                * <p>The time stamp of the data record from which to start reading. To specify a time
                *             stamp, set <code>StartingPosition</code> to <code>Type AT_TIMESTAMP</code>. A time stamp
                *             is the Unix epoch date with precision in milliseconds. For example,
                *                 <code>2016-04-04T19:58:46.480-00:00</code> or <code>1459799926.480</code>. If a
                *             record with this exact time stamp does not exist, records will be streamed from the next
                *             (later) record. If the time stamp is older than the current trim horizon, records will
                *             be streamed from the oldest untrimmed data record (<code>TRIM_HORIZON</code>).</p>
                */
            Timestamp?: Date;
    }
    export namespace StartingPosition {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartingPosition) => any;
    }
    export interface SubscribeToShardInput {
            /**
                * <p>For this parameter, use the value you obtained when you called <a>RegisterStreamConsumer</a>.</p>
                */
            ConsumerARN: string | undefined;
            /**
                * <p>The ID of the shard you want to subscribe to. To see a list of all the shards for a
                *             given stream, use <a>ListShards</a>.</p>
                */
            ShardId: string | undefined;
            /**
                * <p>The starting position in the data stream from which to start streaming.</p>
                */
            StartingPosition: StartingPosition | undefined;
    }
    export namespace SubscribeToShardInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SubscribeToShardInput) => any;
    }
    /**
        * <p>After you call <a>SubscribeToShard</a>, Kinesis Data Streams sends events
        *             of this type over an HTTP/2 connection to your consumer.</p>
        */
    export interface SubscribeToShardEvent {
            /**
                * <p></p>
                */
            Records: _Record[] | undefined;
            /**
                * <p>Use this as <code>SequenceNumber</code> in the next call to <a>SubscribeToShard</a>, with <code>StartingPosition</code> set to
                *                 <code>AT_SEQUENCE_NUMBER</code> or <code>AFTER_SEQUENCE_NUMBER</code>. Use
                *                 <code>ContinuationSequenceNumber</code> for checkpointing because it captures your
                *             shard progress even when no data is written to the shard.</p>
                */
            ContinuationSequenceNumber: string | undefined;
            /**
                * <p>The number of milliseconds the read records are from the tip of the stream, indicating
                *             how far behind current time the consumer is. A value of zero indicates that record
                *             processing is caught up, and there are no new records to process at this moment.</p>
                */
            MillisBehindLatest: number | undefined;
            /**
                * <p>The list of the child shards of the current shard, returned only at the end of the
                *             current shard.</p>
                */
            ChildShards?: ChildShard[];
    }
    export namespace SubscribeToShardEvent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SubscribeToShardEvent) => any;
    }
    /**
        * <p>This is a tagged union for all of the types of events an enhanced fan-out consumer can
        *             receive over HTTP/2 after a call to <a>SubscribeToShard</a>.</p>
        */
    export type SubscribeToShardEventStream = SubscribeToShardEventStream.InternalFailureExceptionMember | SubscribeToShardEventStream.KMSAccessDeniedExceptionMember | SubscribeToShardEventStream.KMSDisabledExceptionMember | SubscribeToShardEventStream.KMSInvalidStateExceptionMember | SubscribeToShardEventStream.KMSNotFoundExceptionMember | SubscribeToShardEventStream.KMSOptInRequiredMember | SubscribeToShardEventStream.KMSThrottlingExceptionMember | SubscribeToShardEventStream.ResourceInUseExceptionMember | SubscribeToShardEventStream.ResourceNotFoundExceptionMember | SubscribeToShardEventStream.SubscribeToShardEventMember | SubscribeToShardEventStream.$UnknownMember;
    export namespace SubscribeToShardEventStream {
            /**
                * <p>After you call <a>SubscribeToShard</a>, Kinesis Data Streams sends events
                *             of this type to your consumer. For an example of how to handle these events, see <a href="/streams/latest/dev/building-enhanced-consumers-api.html">Enhanced Fan-Out
                *                 Using the Kinesis Data Streams API</a>.</p>
                */
            interface SubscribeToShardEventMember {
                    SubscribeToShardEvent: SubscribeToShardEvent;
                    ResourceNotFoundException?: never;
                    ResourceInUseException?: never;
                    KMSDisabledException?: never;
                    KMSInvalidStateException?: never;
                    KMSAccessDeniedException?: never;
                    KMSNotFoundException?: never;
                    KMSOptInRequired?: never;
                    KMSThrottlingException?: never;
                    InternalFailureException?: never;
                    $unknown?: never;
            }
            /**
                * <p>The requested resource could not be found. The stream might not be specified
                *             correctly.</p>
                */
            interface ResourceNotFoundExceptionMember {
                    SubscribeToShardEvent?: never;
                    ResourceNotFoundException: ResourceNotFoundException;
                    ResourceInUseException?: never;
                    KMSDisabledException?: never;
                    KMSInvalidStateException?: never;
                    KMSAccessDeniedException?: never;
                    KMSNotFoundException?: never;
                    KMSOptInRequired?: never;
                    KMSThrottlingException?: never;
                    InternalFailureException?: never;
                    $unknown?: never;
            }
            /**
                * <p>The resource is not available for this operation. For successful operation, the
                *             resource must be in the <code>ACTIVE</code> state.</p>
                */
            interface ResourceInUseExceptionMember {
                    SubscribeToShardEvent?: never;
                    ResourceNotFoundException?: never;
                    ResourceInUseException: ResourceInUseException;
                    KMSDisabledException?: never;
                    KMSInvalidStateException?: never;
                    KMSAccessDeniedException?: never;
                    KMSNotFoundException?: never;
                    KMSOptInRequired?: never;
                    KMSThrottlingException?: never;
                    InternalFailureException?: never;
                    $unknown?: never;
            }
            /**
                * <p>The request was rejected because the specified customer master key (CMK) isn't
                *             enabled.</p>
                */
            interface KMSDisabledExceptionMember {
                    SubscribeToShardEvent?: never;
                    ResourceNotFoundException?: never;
                    ResourceInUseException?: never;
                    KMSDisabledException: KMSDisabledException;
                    KMSInvalidStateException?: never;
                    KMSAccessDeniedException?: never;
                    KMSNotFoundException?: never;
                    KMSOptInRequired?: never;
                    KMSThrottlingException?: never;
                    InternalFailureException?: never;
                    $unknown?: never;
            }
            /**
                * <p>The request was rejected because the state of the specified resource isn't valid for
                *             this request. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">How Key State Affects Use of a
                *                 Customer Master Key</a> in the <i>Amazon Web Services Key Management
                *                 Service Developer Guide</i>.</p>
                */
            interface KMSInvalidStateExceptionMember {
                    SubscribeToShardEvent?: never;
                    ResourceNotFoundException?: never;
                    ResourceInUseException?: never;
                    KMSDisabledException?: never;
                    KMSInvalidStateException: KMSInvalidStateException;
                    KMSAccessDeniedException?: never;
                    KMSNotFoundException?: never;
                    KMSOptInRequired?: never;
                    KMSThrottlingException?: never;
                    InternalFailureException?: never;
                    $unknown?: never;
            }
            /**
                * <p>The ciphertext references a key that doesn't exist or that you don't have access
                *             to.</p>
                */
            interface KMSAccessDeniedExceptionMember {
                    SubscribeToShardEvent?: never;
                    ResourceNotFoundException?: never;
                    ResourceInUseException?: never;
                    KMSDisabledException?: never;
                    KMSInvalidStateException?: never;
                    KMSAccessDeniedException: KMSAccessDeniedException;
                    KMSNotFoundException?: never;
                    KMSOptInRequired?: never;
                    KMSThrottlingException?: never;
                    InternalFailureException?: never;
                    $unknown?: never;
            }
            /**
                * <p>The request was rejected because the specified entity or resource can't be
                *             found.</p>
                */
            interface KMSNotFoundExceptionMember {
                    SubscribeToShardEvent?: never;
                    ResourceNotFoundException?: never;
                    ResourceInUseException?: never;
                    KMSDisabledException?: never;
                    KMSInvalidStateException?: never;
                    KMSAccessDeniedException?: never;
                    KMSNotFoundException: KMSNotFoundException;
                    KMSOptInRequired?: never;
                    KMSThrottlingException?: never;
                    InternalFailureException?: never;
                    $unknown?: never;
            }
            /**
                * <p>The Amazon Web Services access key ID needs a subscription for the service.</p>
                */
            interface KMSOptInRequiredMember {
                    SubscribeToShardEvent?: never;
                    ResourceNotFoundException?: never;
                    ResourceInUseException?: never;
                    KMSDisabledException?: never;
                    KMSInvalidStateException?: never;
                    KMSAccessDeniedException?: never;
                    KMSNotFoundException?: never;
                    KMSOptInRequired: KMSOptInRequired;
                    KMSThrottlingException?: never;
                    InternalFailureException?: never;
                    $unknown?: never;
            }
            /**
                * <p>The request was denied due to request throttling. For more information about
                *             throttling, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/limits.html#requests-per-second">Limits</a> in
                *             the <i>Amazon Web Services Key Management Service Developer
                *             Guide</i>.</p>
                */
            interface KMSThrottlingExceptionMember {
                    SubscribeToShardEvent?: never;
                    ResourceNotFoundException?: never;
                    ResourceInUseException?: never;
                    KMSDisabledException?: never;
                    KMSInvalidStateException?: never;
                    KMSAccessDeniedException?: never;
                    KMSNotFoundException?: never;
                    KMSOptInRequired?: never;
                    KMSThrottlingException: KMSThrottlingException;
                    InternalFailureException?: never;
                    $unknown?: never;
            }
            /**
                * <p>The processing of the request failed because of an unknown error, exception, or
                *             failure.</p>
                */
            interface InternalFailureExceptionMember {
                    SubscribeToShardEvent?: never;
                    ResourceNotFoundException?: never;
                    ResourceInUseException?: never;
                    KMSDisabledException?: never;
                    KMSInvalidStateException?: never;
                    KMSAccessDeniedException?: never;
                    KMSNotFoundException?: never;
                    KMSOptInRequired?: never;
                    KMSThrottlingException?: never;
                    InternalFailureException: InternalFailureException;
                    $unknown?: never;
            }
            interface $UnknownMember {
                    SubscribeToShardEvent?: never;
                    ResourceNotFoundException?: never;
                    ResourceInUseException?: never;
                    KMSDisabledException?: never;
                    KMSInvalidStateException?: never;
                    KMSAccessDeniedException?: never;
                    KMSNotFoundException?: never;
                    KMSOptInRequired?: never;
                    KMSThrottlingException?: never;
                    InternalFailureException?: never;
                    $unknown: [string, any];
            }
            interface Visitor<T> {
                    SubscribeToShardEvent: (value: SubscribeToShardEvent) => T;
                    ResourceNotFoundException: (value: ResourceNotFoundException) => T;
                    ResourceInUseException: (value: ResourceInUseException) => T;
                    KMSDisabledException: (value: KMSDisabledException) => T;
                    KMSInvalidStateException: (value: KMSInvalidStateException) => T;
                    KMSAccessDeniedException: (value: KMSAccessDeniedException) => T;
                    KMSNotFoundException: (value: KMSNotFoundException) => T;
                    KMSOptInRequired: (value: KMSOptInRequired) => T;
                    KMSThrottlingException: (value: KMSThrottlingException) => T;
                    InternalFailureException: (value: InternalFailureException) => T;
                    _: (name: string, value: any) => T;
            }
            const visit: <T>(value: SubscribeToShardEventStream, visitor: Visitor<T>) => T;
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SubscribeToShardEventStream) => any;
    }
    export interface SubscribeToShardOutput {
            /**
                * <p>The event stream that your consumer can use to read records from the shard.</p>
                */
            EventStream: AsyncIterable<SubscribeToShardEventStream> | undefined;
    }
    export namespace SubscribeToShardOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SubscribeToShardOutput) => any;
    }
    export enum ScalingType {
            UNIFORM_SCALING = "UNIFORM_SCALING"
    }
    export interface UpdateShardCountInput {
            /**
                * <p>The name of the stream.</p>
                */
            StreamName: string | undefined;
            /**
                * <p>The new number of shards. This value has the following default limits. By default, you
                *             cannot do the following: </p>
                *         <ul>
                *             <li>
                *                 <p>Set this value to more than double your current shard count for a
                *                     stream.</p>
                *             </li>
                *             <li>
                *                 <p>Set this value below half your current shard count for a stream.</p>
                *             </li>
                *             <li>
                *                 <p>Set this value to more than 10000 shards in a stream (the default limit for
                *                     shard count per stream is 10000 per account per region), unless you request a
                *                     limit increase.</p>
                *             </li>
                *             <li>
                *                 <p>Scale a stream with more than 10000 shards down unless you set this value to
                *                     less than 10000 shards.</p>
                *             </li>
                *          </ul>
                */
            TargetShardCount: number | undefined;
            /**
                * <p>The scaling type. Uniform scaling creates shards of equal size.</p>
                */
            ScalingType: ScalingType | string | undefined;
    }
    export namespace UpdateShardCountInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateShardCountInput) => any;
    }
    export interface UpdateShardCountOutput {
            /**
                * <p>The name of the stream.</p>
                */
            StreamName?: string;
            /**
                * <p>The current number of shards.</p>
                */
            CurrentShardCount?: number;
            /**
                * <p>The updated number of shards.</p>
                */
            TargetShardCount?: number;
    }
    export namespace UpdateShardCountOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateShardCountOutput) => any;
    }
    export interface UpdateStreamModeInput {
            /**
                * <p> Specifies the ARN of the data stream whose capacity mode you want to update. </p>
                */
            StreamARN: string | undefined;
            /**
                * <p> Specifies the capacity mode to which you want to set your data stream. Currently, in
                *             Kinesis Data Streams, you can choose between an <b>on-demand</b> capacity mode and a <b>provisioned</b> capacity mode for your data streams. </p>
                */
            StreamModeDetails: StreamModeDetails | undefined;
    }
    export namespace UpdateStreamModeInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateStreamModeInput) => any;
    }
}

declare module '@aws-sdk/client-kinesis/node_modules/@aws-sdk/client-kinesis/dist-types/models/KinesisServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from Kinesis service.
        */
    export class KinesisServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

