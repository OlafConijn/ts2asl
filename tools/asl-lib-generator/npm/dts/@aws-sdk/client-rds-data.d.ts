// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/smithy-client
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http

declare module '@aws-sdk/client-rds-data' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { BatchExecuteStatementCommandInput, BatchExecuteStatementCommandOutput } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/commands/BatchExecuteStatementCommand";
    import { BeginTransactionCommandInput, BeginTransactionCommandOutput } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/commands/BeginTransactionCommand";
    import { CommitTransactionCommandInput, CommitTransactionCommandOutput } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/commands/CommitTransactionCommand";
    import { ExecuteSqlCommandInput, ExecuteSqlCommandOutput } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/commands/ExecuteSqlCommand";
    import { ExecuteStatementCommandInput, ExecuteStatementCommandOutput } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/commands/ExecuteStatementCommand";
    import { RollbackTransactionCommandInput, RollbackTransactionCommandOutput } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/commands/RollbackTransactionCommand";
    import { RDSDataClient } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/RDSDataClient";
    /**
        * <fullname>Amazon RDS Data Service</fullname>
        *         <p>Amazon RDS provides an HTTP endpoint to run SQL statements on an Amazon Aurora
        *             Serverless DB cluster. To run these statements, you work with the Data Service
        *             API.</p>
        *         <p>For more information about the Data Service API, see
        *           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html">Using the Data API</a>
        *           in the <i>Amazon Aurora User Guide</i>.</p>
        */
    export class RDSData extends RDSDataClient {
            /**
                * <p>Runs a batch SQL statement over an array of data.</p>
                *         <p>You can run bulk update and insert operations for multiple records using a DML
                *             statement with different parameter sets. Bulk operations can provide a significant
                *             performance improvement over individual insert and update operations.</p>
                *         <important>
                *             <p>If a call isn't part of a transaction because it doesn't include the
                *                     <code>transactionID</code> parameter, changes that result from the call are
                *                 committed automatically.</p>
                *             <p>There isn't a fixed upper limit on the number of parameter sets. However, the maximum size of the HTTP request
                *                 submitted through the Data API is 4 MiB. If the request exceeds this limit, the Data API returns an error and doesn't
                *                 process the request. This 4-MiB limit includes the size of the HTTP headers and the JSON notation in the request. Thus, the
                *                 number of parameter sets that you can include depends on a combination of factors, such as the size of the SQL statement and
                *                 the size of each parameter set.</p>
                *             <p>The response size limit is 1 MiB. If the call returns more than 1 MiB of response data, the call is terminated.</p>
                *         </important>
                */
            batchExecuteStatement(args: BatchExecuteStatementCommandInput, options?: __HttpHandlerOptions): Promise<BatchExecuteStatementCommandOutput>;
            batchExecuteStatement(args: BatchExecuteStatementCommandInput, cb: (err: any, data?: BatchExecuteStatementCommandOutput) => void): void;
            batchExecuteStatement(args: BatchExecuteStatementCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchExecuteStatementCommandOutput) => void): void;
            /**
                * <p>Starts a SQL transaction.</p>
                *
                *         <important>
                *             <p>A transaction can run for a maximum of 24 hours. A transaction is terminated and
                *                 rolled back automatically after 24 hours.</p>
                *             <p>A transaction times out if no calls use its transaction ID in three minutes.
                *                 If a transaction times out before it's committed, it's rolled back
                *                 automatically.</p>
                *             <p>DDL statements inside a transaction cause an implicit commit. We recommend
                *                 that you run each DDL statement in a separate <code>ExecuteStatement</code> call with
                *                 <code>continueAfterTimeout</code> enabled.</p>
                *         </important>
                */
            beginTransaction(args: BeginTransactionCommandInput, options?: __HttpHandlerOptions): Promise<BeginTransactionCommandOutput>;
            beginTransaction(args: BeginTransactionCommandInput, cb: (err: any, data?: BeginTransactionCommandOutput) => void): void;
            beginTransaction(args: BeginTransactionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BeginTransactionCommandOutput) => void): void;
            /**
                * <p>Ends a SQL transaction started with the <code>BeginTransaction</code> operation and
                *             commits the changes.</p>
                */
            commitTransaction(args: CommitTransactionCommandInput, options?: __HttpHandlerOptions): Promise<CommitTransactionCommandOutput>;
            commitTransaction(args: CommitTransactionCommandInput, cb: (err: any, data?: CommitTransactionCommandOutput) => void): void;
            commitTransaction(args: CommitTransactionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CommitTransactionCommandOutput) => void): void;
            /**
                * @deprecated
                *
                * <p>Runs one or more SQL statements.</p>
                *         <important>
                *             <p>This operation is deprecated. Use the <code>BatchExecuteStatement</code> or
                *                     <code>ExecuteStatement</code> operation.</p>
                *         </important>
                */
            executeSql(args: ExecuteSqlCommandInput, options?: __HttpHandlerOptions): Promise<ExecuteSqlCommandOutput>;
            executeSql(args: ExecuteSqlCommandInput, cb: (err: any, data?: ExecuteSqlCommandOutput) => void): void;
            executeSql(args: ExecuteSqlCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ExecuteSqlCommandOutput) => void): void;
            /**
                * <p>Runs a SQL statement against a database.</p>
                *         <important>
                *             <p>If a call isn't part of a transaction because it doesn't include the
                *                     <code>transactionID</code> parameter, changes that result from the call are
                *                 committed automatically.</p>
                *             <p>If the binary response data from the database is more than 1 MB, the call is terminated.</p>
                *         </important>
                */
            executeStatement(args: ExecuteStatementCommandInput, options?: __HttpHandlerOptions): Promise<ExecuteStatementCommandOutput>;
            executeStatement(args: ExecuteStatementCommandInput, cb: (err: any, data?: ExecuteStatementCommandOutput) => void): void;
            executeStatement(args: ExecuteStatementCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ExecuteStatementCommandOutput) => void): void;
            /**
                * <p>Performs a rollback of a transaction. Rolling back a transaction cancels its changes.</p>
                */
            rollbackTransaction(args: RollbackTransactionCommandInput, options?: __HttpHandlerOptions): Promise<RollbackTransactionCommandOutput>;
            rollbackTransaction(args: RollbackTransactionCommandInput, cb: (err: any, data?: RollbackTransactionCommandOutput) => void): void;
            rollbackTransaction(args: RollbackTransactionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RollbackTransactionCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/commands/BatchExecuteStatementCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { BatchExecuteStatementRequest, BatchExecuteStatementResponse } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/models/models_0";
    import { RDSDataClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/RDSDataClient";
    export interface BatchExecuteStatementCommandInput extends BatchExecuteStatementRequest {
    }
    export interface BatchExecuteStatementCommandOutput extends BatchExecuteStatementResponse, __MetadataBearer {
    }
    /**
        * <p>Runs a batch SQL statement over an array of data.</p>
        *         <p>You can run bulk update and insert operations for multiple records using a DML
        *             statement with different parameter sets. Bulk operations can provide a significant
        *             performance improvement over individual insert and update operations.</p>
        *         <important>
        *             <p>If a call isn't part of a transaction because it doesn't include the
        *                     <code>transactionID</code> parameter, changes that result from the call are
        *                 committed automatically.</p>
        *             <p>There isn't a fixed upper limit on the number of parameter sets. However, the maximum size of the HTTP request
        *                 submitted through the Data API is 4 MiB. If the request exceeds this limit, the Data API returns an error and doesn't
        *                 process the request. This 4-MiB limit includes the size of the HTTP headers and the JSON notation in the request. Thus, the
        *                 number of parameter sets that you can include depends on a combination of factors, such as the size of the SQL statement and
        *                 the size of each parameter set.</p>
        *             <p>The response size limit is 1 MiB. If the call returns more than 1 MiB of response data, the call is terminated.</p>
        *         </important>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RDSDataClient, BatchExecuteStatementCommand } from "@aws-sdk/client-rds-data"; // ES Modules import
        * // const { RDSDataClient, BatchExecuteStatementCommand } = require("@aws-sdk/client-rds-data"); // CommonJS import
        * const client = new RDSDataClient(config);
        * const command = new BatchExecuteStatementCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchExecuteStatementCommandInput} for command's `input` shape.
        * @see {@link BatchExecuteStatementCommandOutput} for command's `response` shape.
        * @see {@link RDSDataClientResolvedConfig | config} for RDSDataClient's `config` shape.
        *
        */
    export class BatchExecuteStatementCommand extends $Command<BatchExecuteStatementCommandInput, BatchExecuteStatementCommandOutput, RDSDataClientResolvedConfig> {
            readonly input: BatchExecuteStatementCommandInput;
            constructor(input: BatchExecuteStatementCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RDSDataClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchExecuteStatementCommandInput, BatchExecuteStatementCommandOutput>;
    }
}

declare module '@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/commands/BeginTransactionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { BeginTransactionRequest, BeginTransactionResponse } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/models/models_0";
    import { RDSDataClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/RDSDataClient";
    export interface BeginTransactionCommandInput extends BeginTransactionRequest {
    }
    export interface BeginTransactionCommandOutput extends BeginTransactionResponse, __MetadataBearer {
    }
    /**
        * <p>Starts a SQL transaction.</p>
        *
        *         <important>
        *             <p>A transaction can run for a maximum of 24 hours. A transaction is terminated and
        *                 rolled back automatically after 24 hours.</p>
        *             <p>A transaction times out if no calls use its transaction ID in three minutes.
        *                 If a transaction times out before it's committed, it's rolled back
        *                 automatically.</p>
        *             <p>DDL statements inside a transaction cause an implicit commit. We recommend
        *                 that you run each DDL statement in a separate <code>ExecuteStatement</code> call with
        *                 <code>continueAfterTimeout</code> enabled.</p>
        *         </important>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RDSDataClient, BeginTransactionCommand } from "@aws-sdk/client-rds-data"; // ES Modules import
        * // const { RDSDataClient, BeginTransactionCommand } = require("@aws-sdk/client-rds-data"); // CommonJS import
        * const client = new RDSDataClient(config);
        * const command = new BeginTransactionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BeginTransactionCommandInput} for command's `input` shape.
        * @see {@link BeginTransactionCommandOutput} for command's `response` shape.
        * @see {@link RDSDataClientResolvedConfig | config} for RDSDataClient's `config` shape.
        *
        */
    export class BeginTransactionCommand extends $Command<BeginTransactionCommandInput, BeginTransactionCommandOutput, RDSDataClientResolvedConfig> {
            readonly input: BeginTransactionCommandInput;
            constructor(input: BeginTransactionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RDSDataClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BeginTransactionCommandInput, BeginTransactionCommandOutput>;
    }
}

declare module '@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/commands/CommitTransactionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CommitTransactionRequest, CommitTransactionResponse } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/models/models_0";
    import { RDSDataClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/RDSDataClient";
    export interface CommitTransactionCommandInput extends CommitTransactionRequest {
    }
    export interface CommitTransactionCommandOutput extends CommitTransactionResponse, __MetadataBearer {
    }
    /**
        * <p>Ends a SQL transaction started with the <code>BeginTransaction</code> operation and
        *             commits the changes.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RDSDataClient, CommitTransactionCommand } from "@aws-sdk/client-rds-data"; // ES Modules import
        * // const { RDSDataClient, CommitTransactionCommand } = require("@aws-sdk/client-rds-data"); // CommonJS import
        * const client = new RDSDataClient(config);
        * const command = new CommitTransactionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CommitTransactionCommandInput} for command's `input` shape.
        * @see {@link CommitTransactionCommandOutput} for command's `response` shape.
        * @see {@link RDSDataClientResolvedConfig | config} for RDSDataClient's `config` shape.
        *
        */
    export class CommitTransactionCommand extends $Command<CommitTransactionCommandInput, CommitTransactionCommandOutput, RDSDataClientResolvedConfig> {
            readonly input: CommitTransactionCommandInput;
            constructor(input: CommitTransactionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RDSDataClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CommitTransactionCommandInput, CommitTransactionCommandOutput>;
    }
}

declare module '@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/commands/ExecuteSqlCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ExecuteSqlRequest, ExecuteSqlResponse } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/models/models_0";
    import { RDSDataClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/RDSDataClient";
    export interface ExecuteSqlCommandInput extends ExecuteSqlRequest {
    }
    export interface ExecuteSqlCommandOutput extends ExecuteSqlResponse, __MetadataBearer {
    }
    /**
        * @deprecated
        *
        * <p>Runs one or more SQL statements.</p>
        *         <important>
        *             <p>This operation is deprecated. Use the <code>BatchExecuteStatement</code> or
        *                     <code>ExecuteStatement</code> operation.</p>
        *         </important>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RDSDataClient, ExecuteSqlCommand } from "@aws-sdk/client-rds-data"; // ES Modules import
        * // const { RDSDataClient, ExecuteSqlCommand } = require("@aws-sdk/client-rds-data"); // CommonJS import
        * const client = new RDSDataClient(config);
        * const command = new ExecuteSqlCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ExecuteSqlCommandInput} for command's `input` shape.
        * @see {@link ExecuteSqlCommandOutput} for command's `response` shape.
        * @see {@link RDSDataClientResolvedConfig | config} for RDSDataClient's `config` shape.
        *
        */
    export class ExecuteSqlCommand extends $Command<ExecuteSqlCommandInput, ExecuteSqlCommandOutput, RDSDataClientResolvedConfig> {
            readonly input: ExecuteSqlCommandInput;
            constructor(input: ExecuteSqlCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RDSDataClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ExecuteSqlCommandInput, ExecuteSqlCommandOutput>;
    }
}

declare module '@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/commands/ExecuteStatementCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ExecuteStatementRequest, ExecuteStatementResponse } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/models/models_0";
    import { RDSDataClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/RDSDataClient";
    export interface ExecuteStatementCommandInput extends ExecuteStatementRequest {
    }
    export interface ExecuteStatementCommandOutput extends ExecuteStatementResponse, __MetadataBearer {
    }
    /**
        * <p>Runs a SQL statement against a database.</p>
        *         <important>
        *             <p>If a call isn't part of a transaction because it doesn't include the
        *                     <code>transactionID</code> parameter, changes that result from the call are
        *                 committed automatically.</p>
        *             <p>If the binary response data from the database is more than 1 MB, the call is terminated.</p>
        *         </important>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RDSDataClient, ExecuteStatementCommand } from "@aws-sdk/client-rds-data"; // ES Modules import
        * // const { RDSDataClient, ExecuteStatementCommand } = require("@aws-sdk/client-rds-data"); // CommonJS import
        * const client = new RDSDataClient(config);
        * const command = new ExecuteStatementCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ExecuteStatementCommandInput} for command's `input` shape.
        * @see {@link ExecuteStatementCommandOutput} for command's `response` shape.
        * @see {@link RDSDataClientResolvedConfig | config} for RDSDataClient's `config` shape.
        *
        */
    export class ExecuteStatementCommand extends $Command<ExecuteStatementCommandInput, ExecuteStatementCommandOutput, RDSDataClientResolvedConfig> {
            readonly input: ExecuteStatementCommandInput;
            constructor(input: ExecuteStatementCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RDSDataClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ExecuteStatementCommandInput, ExecuteStatementCommandOutput>;
    }
}

declare module '@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/commands/RollbackTransactionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { RollbackTransactionRequest, RollbackTransactionResponse } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/models/models_0";
    import { RDSDataClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/RDSDataClient";
    export interface RollbackTransactionCommandInput extends RollbackTransactionRequest {
    }
    export interface RollbackTransactionCommandOutput extends RollbackTransactionResponse, __MetadataBearer {
    }
    /**
        * <p>Performs a rollback of a transaction. Rolling back a transaction cancels its changes.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { RDSDataClient, RollbackTransactionCommand } from "@aws-sdk/client-rds-data"; // ES Modules import
        * // const { RDSDataClient, RollbackTransactionCommand } = require("@aws-sdk/client-rds-data"); // CommonJS import
        * const client = new RDSDataClient(config);
        * const command = new RollbackTransactionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RollbackTransactionCommandInput} for command's `input` shape.
        * @see {@link RollbackTransactionCommandOutput} for command's `response` shape.
        * @see {@link RDSDataClientResolvedConfig | config} for RDSDataClient's `config` shape.
        *
        */
    export class RollbackTransactionCommand extends $Command<RollbackTransactionCommandInput, RollbackTransactionCommandOutput, RDSDataClientResolvedConfig> {
            readonly input: RollbackTransactionCommandInput;
            constructor(input: RollbackTransactionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: RDSDataClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RollbackTransactionCommandInput, RollbackTransactionCommandOutput>;
    }
}

declare module '@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/RDSDataClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { BatchExecuteStatementCommandInput, BatchExecuteStatementCommandOutput } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/commands/BatchExecuteStatementCommand";
    import { BeginTransactionCommandInput, BeginTransactionCommandOutput } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/commands/BeginTransactionCommand";
    import { CommitTransactionCommandInput, CommitTransactionCommandOutput } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/commands/CommitTransactionCommand";
    import { ExecuteSqlCommandInput, ExecuteSqlCommandOutput } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/commands/ExecuteSqlCommand";
    import { ExecuteStatementCommandInput, ExecuteStatementCommandOutput } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/commands/ExecuteStatementCommand";
    import { RollbackTransactionCommandInput, RollbackTransactionCommandOutput } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/commands/RollbackTransactionCommand";
    export type ServiceInputTypes = BatchExecuteStatementCommandInput | BeginTransactionCommandInput | CommitTransactionCommandInput | ExecuteSqlCommandInput | ExecuteStatementCommandInput | RollbackTransactionCommandInput;
    export type ServiceOutputTypes = BatchExecuteStatementCommandOutput | BeginTransactionCommandOutput | CommitTransactionCommandOutput | ExecuteSqlCommandOutput | ExecuteStatementCommandOutput | RollbackTransactionCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type RDSDataClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of RDSDataClient class constructor that set the region, credentials and other options.
        */
    export interface RDSDataClientConfig extends RDSDataClientConfigType {
    }
    type RDSDataClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of RDSDataClient class. This is resolved and normalized from the {@link RDSDataClientConfig | constructor configuration interface}.
        */
    export interface RDSDataClientResolvedConfig extends RDSDataClientResolvedConfigType {
    }
    /**
        * <fullname>Amazon RDS Data Service</fullname>
        *         <p>Amazon RDS provides an HTTP endpoint to run SQL statements on an Amazon Aurora
        *             Serverless DB cluster. To run these statements, you work with the Data Service
        *             API.</p>
        *         <p>For more information about the Data Service API, see
        *           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html">Using the Data API</a>
        *           in the <i>Amazon Aurora User Guide</i>.</p>
        */
    export class RDSDataClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, RDSDataClientResolvedConfig> {
            /**
                * The resolved configuration of RDSDataClient class. This is resolved and normalized from the {@link RDSDataClientConfig | constructor configuration interface}.
                */
            readonly config: RDSDataClientResolvedConfig;
            constructor(configuration: RDSDataClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { RDSDataServiceException as __BaseException } from "@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/models/RDSDataServiceException";
    /**
        * <p>You do not have sufficient access to perform this action.</p>
        */
    export class AccessDeniedException extends __BaseException {
            readonly name: "AccessDeniedException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AccessDeniedException, __BaseException>);
    }
    /**
        * <p>There is an error in the call or in a SQL statement.</p>
        */
    export class BadRequestException extends __BaseException {
            readonly name: "BadRequestException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<BadRequestException, __BaseException>);
    }
    export enum TypeHint {
            DATE = "DATE",
            DECIMAL = "DECIMAL",
            JSON = "JSON",
            TIME = "TIME",
            TIMESTAMP = "TIMESTAMP",
            UUID = "UUID"
    }
    /**
        * <p>There are insufficient privileges to make the call.</p>
        */
    export class ForbiddenException extends __BaseException {
            readonly name: "ForbiddenException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ForbiddenException, __BaseException>);
    }
    /**
        * <p>An internal error occurred.</p>
        */
    export class InternalServerErrorException extends __BaseException {
            readonly name: "InternalServerErrorException";
            readonly $fault: "server";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InternalServerErrorException, __BaseException>);
    }
    /**
        * <p>The service specified by the <code>resourceArn</code> parameter is not
        *             available.</p>
        */
    export class ServiceUnavailableError extends __BaseException {
            readonly name: "ServiceUnavailableError";
            readonly $fault: "server";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ServiceUnavailableError, __BaseException>);
    }
    /**
        * <p>The execution of the SQL statement timed out.</p>
        */
    export class StatementTimeoutException extends __BaseException {
            readonly name: "StatementTimeoutException";
            readonly $fault: "client";
            /**
                * <p>The database connection ID that executed the SQL statement.</p>
                */
            dbConnectionId?: number;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<StatementTimeoutException, __BaseException>);
    }
    /**
        * <p>The request parameters represent the input of a request to start a SQL
        *             transaction.</p>
        */
    export interface BeginTransactionRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
                */
            resourceArn: string | undefined;
            /**
                * <p>The name or ARN of the secret that enables access to the DB cluster.</p>
                */
            secretArn: string | undefined;
            /**
                * <p>The name of the database.</p>
                */
            database?: string;
            /**
                * <p>The name of the database schema.</p>
                */
            schema?: string;
    }
    export namespace BeginTransactionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BeginTransactionRequest) => any;
    }
    /**
        * <p>The response elements represent the output of a request to start a SQL
        *             transaction.</p>
        */
    export interface BeginTransactionResponse {
            /**
                * <p>The transaction ID of the transaction started by the call.</p>
                */
            transactionId?: string;
    }
    export namespace BeginTransactionResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BeginTransactionResponse) => any;
    }
    /**
        * <p>Contains the metadata for a column.</p>
        */
    export interface ColumnMetadata {
            /**
                * <p>The name of the column.</p>
                */
            name?: string;
            /**
                * <p>The type of the column.</p>
                */
            type?: number;
            /**
                * <p>The database-specific data type of the column.</p>
                */
            typeName?: string;
            /**
                * <p>The label for the column.</p>
                */
            label?: string;
            /**
                * <p>The name of the schema that owns the table that includes the column.</p>
                */
            schemaName?: string;
            /**
                * <p>The name of the table that includes the column.</p>
                */
            tableName?: string;
            /**
                * <p>A value that indicates whether the column increments automatically.</p>
                */
            isAutoIncrement?: boolean;
            /**
                * <p>A value that indicates whether an integer column is signed.</p>
                */
            isSigned?: boolean;
            /**
                * <p>A value that indicates whether the column contains currency values.</p>
                */
            isCurrency?: boolean;
            /**
                * <p>A value that indicates whether the column is case-sensitive.</p>
                */
            isCaseSensitive?: boolean;
            /**
                * <p>A value that indicates whether the column is nullable.</p>
                */
            nullable?: number;
            /**
                * <p>The precision value of a decimal number column.</p>
                */
            precision?: number;
            /**
                * <p>The scale value of a decimal number column.</p>
                */
            scale?: number;
            /**
                * <p>The type of the column.</p>
                */
            arrayBaseColumnType?: number;
    }
    export namespace ColumnMetadata {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ColumnMetadata) => any;
    }
    /**
        * <p>The request parameters represent the input of a commit transaction request.</p>
        */
    export interface CommitTransactionRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
                */
            resourceArn: string | undefined;
            /**
                * <p>The name or ARN of the secret that enables access to the DB cluster.</p>
                */
            secretArn: string | undefined;
            /**
                * <p>The identifier of the transaction to end and commit.</p>
                */
            transactionId: string | undefined;
    }
    export namespace CommitTransactionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CommitTransactionRequest) => any;
    }
    /**
        * <p>The response elements represent the output of a commit transaction request.</p>
        */
    export interface CommitTransactionResponse {
            /**
                * <p>The status of the commit operation.</p>
                */
            transactionStatus?: string;
    }
    export namespace CommitTransactionResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CommitTransactionResponse) => any;
    }
    /**
        * <p>The <code>resourceArn</code>, <code>secretArn</code>, or <code>transactionId</code> value can't be found.</p>
        */
    export class NotFoundException extends __BaseException {
            readonly name: "NotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<NotFoundException, __BaseException>);
    }
    export enum DecimalReturnType {
            DOUBLE_OR_LONG = "DOUBLE_OR_LONG",
            STRING = "STRING"
    }
    /**
        * <p>The request parameters represent the input of a request to run one or more SQL
        *             statements.</p>
        */
    export interface ExecuteSqlRequest {
            /**
                * <p>The ARN of the Aurora Serverless DB cluster.</p>
                */
            dbClusterOrInstanceArn: string | undefined;
            /**
                * <p>The Amazon Resource Name (ARN) of the secret that enables access to the DB cluster. Enter the database user name and password
                *             for the credentials in the secret.</p>
                *         <p>For information about creating the secret, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/create_database_secret.html">Create a database secret</a>.</p>
                */
            awsSecretStoreArn: string | undefined;
            /**
                * <p>One or more SQL statements to run on the DB cluster.</p>
                *         <p>You can separate SQL statements from each other with a semicolon (;). Any valid SQL
                *             statement is permitted, including data definition, data manipulation, and commit
                *             statements. </p>
                */
            sqlStatements: string | undefined;
            /**
                * <p>The name of the database.</p>
                */
            database?: string;
            /**
                * <p>The name of the database schema.</p>
                */
            schema?: string;
    }
    export namespace ExecuteSqlRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExecuteSqlRequest) => any;
    }
    /**
        * <p>The metadata of the result set returned by a SQL statement.</p>
        */
    export interface ResultSetMetadata {
            /**
                * <p>The number of columns in the result set.</p>
                */
            columnCount?: number;
            /**
                * <p>The metadata of the columns in the result set.</p>
                */
            columnMetadata?: ColumnMetadata[];
    }
    export namespace ResultSetMetadata {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResultSetMetadata) => any;
    }
    export enum RecordsFormatType {
            JSON = "JSON",
            NONE = "NONE"
    }
    export enum LongReturnType {
            LONG = "LONG",
            STRING = "STRING"
    }
    /**
        * <p>Options that control how the result set is returned.</p>
        */
    export interface ResultSetOptions {
            /**
                * <p>A value that indicates how a field of <code>DECIMAL</code> type is represented
                *             in the response. The value of <code>STRING</code>, the default, specifies that
                *             it is converted to a String value. The value of <code>DOUBLE_OR_LONG</code>
                *             specifies that it is converted to a Long value if its scale is 0, or to a Double
                *             value otherwise.</p>
                *         <important>
                *             <p>Conversion to Double or Long can result in roundoff errors due to precision loss.
                *                 We recommend converting to String, especially when working with currency values.</p>
                *         </important>
                */
            decimalReturnType?: DecimalReturnType | string;
            /**
                * <p>A value that indicates how a field of <code>LONG</code> type is represented.
                *         Allowed values are <code>LONG</code> and <code>STRING</code>. The default
                *         is <code>LONG</code>. Specify <code>STRING</code> if the length or
                *         precision of numeric values might cause truncation or rounding errors.
                *         </p>
                */
            longReturnType?: LongReturnType | string;
    }
    export namespace ResultSetOptions {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResultSetOptions) => any;
    }
    /**
        * <p>The request parameters represent the input of a request to perform a rollback of a
        *             transaction.</p>
        */
    export interface RollbackTransactionRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
                */
            resourceArn: string | undefined;
            /**
                * <p>The name or ARN of the secret that enables access to the DB cluster.</p>
                */
            secretArn: string | undefined;
            /**
                * <p>The identifier of the transaction to roll back.</p>
                */
            transactionId: string | undefined;
    }
    export namespace RollbackTransactionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RollbackTransactionRequest) => any;
    }
    /**
        * <p>The response elements represent the output of a request to perform a rollback of a
        *             transaction.</p>
        */
    export interface RollbackTransactionResponse {
            /**
                * <p>The status of the rollback operation.</p>
                */
            transactionStatus?: string;
    }
    export namespace RollbackTransactionResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RollbackTransactionResponse) => any;
    }
    /**
        * <p>Contains an array.</p>
        */
    export type ArrayValue = ArrayValue.ArrayValuesMember | ArrayValue.BooleanValuesMember | ArrayValue.DoubleValuesMember | ArrayValue.LongValuesMember | ArrayValue.StringValuesMember | ArrayValue.$UnknownMember;
    export namespace ArrayValue {
            /**
                * <p>An array of Boolean values.</p>
                */
            interface BooleanValuesMember {
                    booleanValues: boolean[];
                    longValues?: never;
                    doubleValues?: never;
                    stringValues?: never;
                    arrayValues?: never;
                    $unknown?: never;
            }
            /**
                * <p>An array of integers.</p>
                */
            interface LongValuesMember {
                    booleanValues?: never;
                    longValues: number[];
                    doubleValues?: never;
                    stringValues?: never;
                    arrayValues?: never;
                    $unknown?: never;
            }
            /**
                * <p>An array of floating-point numbers.</p>
                */
            interface DoubleValuesMember {
                    booleanValues?: never;
                    longValues?: never;
                    doubleValues: number[];
                    stringValues?: never;
                    arrayValues?: never;
                    $unknown?: never;
            }
            /**
                * <p>An array of strings.</p>
                */
            interface StringValuesMember {
                    booleanValues?: never;
                    longValues?: never;
                    doubleValues?: never;
                    stringValues: string[];
                    arrayValues?: never;
                    $unknown?: never;
            }
            /**
                * <p>An array of arrays.</p>
                */
            interface ArrayValuesMember {
                    booleanValues?: never;
                    longValues?: never;
                    doubleValues?: never;
                    stringValues?: never;
                    arrayValues: ArrayValue[];
                    $unknown?: never;
            }
            interface $UnknownMember {
                    booleanValues?: never;
                    longValues?: never;
                    doubleValues?: never;
                    stringValues?: never;
                    arrayValues?: never;
                    $unknown: [string, any];
            }
            interface Visitor<T> {
                    booleanValues: (value: boolean[]) => T;
                    longValues: (value: number[]) => T;
                    doubleValues: (value: number[]) => T;
                    stringValues: (value: string[]) => T;
                    arrayValues: (value: ArrayValue[]) => T;
                    _: (name: string, value: any) => T;
            }
            const visit: <T>(value: ArrayValue, visitor: Visitor<T>) => T;
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ArrayValue) => any;
    }
    /**
        * <p>Contains a value.</p>
        */
    export type Field = Field.ArrayValueMember | Field.BlobValueMember | Field.BooleanValueMember | Field.DoubleValueMember | Field.IsNullMember | Field.LongValueMember | Field.StringValueMember | Field.$UnknownMember;
    export namespace Field {
            /**
                * <p>A NULL value.</p>
                */
            interface IsNullMember {
                    isNull: boolean;
                    booleanValue?: never;
                    longValue?: never;
                    doubleValue?: never;
                    stringValue?: never;
                    blobValue?: never;
                    arrayValue?: never;
                    $unknown?: never;
            }
            /**
                * <p>A value of Boolean data type.</p>
                */
            interface BooleanValueMember {
                    isNull?: never;
                    booleanValue: boolean;
                    longValue?: never;
                    doubleValue?: never;
                    stringValue?: never;
                    blobValue?: never;
                    arrayValue?: never;
                    $unknown?: never;
            }
            /**
                * <p>A value of long data type.</p>
                */
            interface LongValueMember {
                    isNull?: never;
                    booleanValue?: never;
                    longValue: number;
                    doubleValue?: never;
                    stringValue?: never;
                    blobValue?: never;
                    arrayValue?: never;
                    $unknown?: never;
            }
            /**
                * <p>A value of double data type.</p>
                */
            interface DoubleValueMember {
                    isNull?: never;
                    booleanValue?: never;
                    longValue?: never;
                    doubleValue: number;
                    stringValue?: never;
                    blobValue?: never;
                    arrayValue?: never;
                    $unknown?: never;
            }
            /**
                * <p>A value of string data type.</p>
                */
            interface StringValueMember {
                    isNull?: never;
                    booleanValue?: never;
                    longValue?: never;
                    doubleValue?: never;
                    stringValue: string;
                    blobValue?: never;
                    arrayValue?: never;
                    $unknown?: never;
            }
            /**
                * <p>A value of BLOB data type.</p>
                */
            interface BlobValueMember {
                    isNull?: never;
                    booleanValue?: never;
                    longValue?: never;
                    doubleValue?: never;
                    stringValue?: never;
                    blobValue: Uint8Array;
                    arrayValue?: never;
                    $unknown?: never;
            }
            /**
                * <p>An array of values.</p>
                */
            interface ArrayValueMember {
                    isNull?: never;
                    booleanValue?: never;
                    longValue?: never;
                    doubleValue?: never;
                    stringValue?: never;
                    blobValue?: never;
                    arrayValue: ArrayValue;
                    $unknown?: never;
            }
            interface $UnknownMember {
                    isNull?: never;
                    booleanValue?: never;
                    longValue?: never;
                    doubleValue?: never;
                    stringValue?: never;
                    blobValue?: never;
                    arrayValue?: never;
                    $unknown: [string, any];
            }
            interface Visitor<T> {
                    isNull: (value: boolean) => T;
                    booleanValue: (value: boolean) => T;
                    longValue: (value: number) => T;
                    doubleValue: (value: number) => T;
                    stringValue: (value: string) => T;
                    blobValue: (value: Uint8Array) => T;
                    arrayValue: (value: ArrayValue) => T;
                    _: (name: string, value: any) => T;
            }
            const visit: <T>(value: Field, visitor: Visitor<T>) => T;
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Field) => any;
    }
    /**
        * <p>A parameter used in a SQL statement.</p>
        */
    export interface SqlParameter {
            /**
                * <p>The name of the parameter.</p>
                */
            name?: string;
            /**
                * <p>The value of the parameter.</p>
                */
            value?: Field;
            /**
                * <p>A hint that specifies the correct object type for data type mapping. Possible values
                *             are as follows:</p>
                *         <ul>
                *             <li>
                *                <p>
                *                   <code>DATE</code> - The corresponding <code>String</code> parameter value is sent as an object
                *               of <code>DATE</code> type to the database. The accepted format is <code>YYYY-MM-DD</code>.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>DECIMAL</code> - The corresponding <code>String</code> parameter value is sent as an object
                *                     of <code>DECIMAL</code> type to the database.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>JSON</code> - The corresponding <code>String</code> parameter value is sent as an
                *            object of <code>JSON</code> type to the database.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>TIME</code> - The corresponding <code>String</code> parameter value is sent as an object
                *                     of <code>TIME</code> type to the database. The accepted format is <code>HH:MM:SS[.FFF]</code>.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>TIMESTAMP</code> - The corresponding <code>String</code> parameter value is sent as an object
                *               of <code>TIMESTAMP</code> type to the database. The accepted format is <code>YYYY-MM-DD HH:MM:SS[.FFF]</code>.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>UUID</code> - The corresponding <code>String</code> parameter value is sent as an object of
                *              <code>UUID</code> type to the database.
                *           </p>
                *             </li>
                *          </ul>
                */
            typeHint?: TypeHint | string;
    }
    export namespace SqlParameter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SqlParameter) => any;
    }
    /**
        * <p>The response elements represent the results of an update.</p>
        */
    export interface UpdateResult {
            /**
                * <p>Values for fields generated during the request.</p>
                */
            generatedFields?: Field[];
    }
    export namespace UpdateResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateResult) => any;
    }
    /**
        * <p>Contains the value of a column.</p>
        *
        *         <important>
        *             <p>This data structure is only used with the deprecated <code>ExecuteSql</code> operation.
        *               Use the <code>BatchExecuteStatement</code> or <code>ExecuteStatement</code> operation instead.</p>
        *         </important>
        */
    export type Value = Value.ArrayValuesMember | Value.BigIntValueMember | Value.BitValueMember | Value.BlobValueMember | Value.DoubleValueMember | Value.IntValueMember | Value.IsNullMember | Value.RealValueMember | Value.StringValueMember | Value.StructValueMember | Value.$UnknownMember;
    export namespace Value {
            /**
                * <p>A NULL value.</p>
                */
            interface IsNullMember {
                    isNull: boolean;
                    bitValue?: never;
                    bigIntValue?: never;
                    intValue?: never;
                    doubleValue?: never;
                    realValue?: never;
                    stringValue?: never;
                    blobValue?: never;
                    arrayValues?: never;
                    structValue?: never;
                    $unknown?: never;
            }
            /**
                * <p>A value for a column of BIT data type.</p>
                */
            interface BitValueMember {
                    isNull?: never;
                    bitValue: boolean;
                    bigIntValue?: never;
                    intValue?: never;
                    doubleValue?: never;
                    realValue?: never;
                    stringValue?: never;
                    blobValue?: never;
                    arrayValues?: never;
                    structValue?: never;
                    $unknown?: never;
            }
            /**
                * <p>A value for a column of big integer data type.</p>
                */
            interface BigIntValueMember {
                    isNull?: never;
                    bitValue?: never;
                    bigIntValue: number;
                    intValue?: never;
                    doubleValue?: never;
                    realValue?: never;
                    stringValue?: never;
                    blobValue?: never;
                    arrayValues?: never;
                    structValue?: never;
                    $unknown?: never;
            }
            /**
                * <p>A value for a column of integer data type.</p>
                */
            interface IntValueMember {
                    isNull?: never;
                    bitValue?: never;
                    bigIntValue?: never;
                    intValue: number;
                    doubleValue?: never;
                    realValue?: never;
                    stringValue?: never;
                    blobValue?: never;
                    arrayValues?: never;
                    structValue?: never;
                    $unknown?: never;
            }
            /**
                * <p>A value for a column of double data type.</p>
                */
            interface DoubleValueMember {
                    isNull?: never;
                    bitValue?: never;
                    bigIntValue?: never;
                    intValue?: never;
                    doubleValue: number;
                    realValue?: never;
                    stringValue?: never;
                    blobValue?: never;
                    arrayValues?: never;
                    structValue?: never;
                    $unknown?: never;
            }
            /**
                * <p>A value for a column of real data type.</p>
                */
            interface RealValueMember {
                    isNull?: never;
                    bitValue?: never;
                    bigIntValue?: never;
                    intValue?: never;
                    doubleValue?: never;
                    realValue: number;
                    stringValue?: never;
                    blobValue?: never;
                    arrayValues?: never;
                    structValue?: never;
                    $unknown?: never;
            }
            /**
                * <p>A value for a column of string data type.</p>
                */
            interface StringValueMember {
                    isNull?: never;
                    bitValue?: never;
                    bigIntValue?: never;
                    intValue?: never;
                    doubleValue?: never;
                    realValue?: never;
                    stringValue: string;
                    blobValue?: never;
                    arrayValues?: never;
                    structValue?: never;
                    $unknown?: never;
            }
            /**
                * <p>A value for a column of BLOB data type.</p>
                */
            interface BlobValueMember {
                    isNull?: never;
                    bitValue?: never;
                    bigIntValue?: never;
                    intValue?: never;
                    doubleValue?: never;
                    realValue?: never;
                    stringValue?: never;
                    blobValue: Uint8Array;
                    arrayValues?: never;
                    structValue?: never;
                    $unknown?: never;
            }
            /**
                * <p>An array of column values.</p>
                */
            interface ArrayValuesMember {
                    isNull?: never;
                    bitValue?: never;
                    bigIntValue?: never;
                    intValue?: never;
                    doubleValue?: never;
                    realValue?: never;
                    stringValue?: never;
                    blobValue?: never;
                    arrayValues: Value[];
                    structValue?: never;
                    $unknown?: never;
            }
            /**
                * <p>A value for a column of STRUCT data type.</p>
                */
            interface StructValueMember {
                    isNull?: never;
                    bitValue?: never;
                    bigIntValue?: never;
                    intValue?: never;
                    doubleValue?: never;
                    realValue?: never;
                    stringValue?: never;
                    blobValue?: never;
                    arrayValues?: never;
                    structValue: StructValue;
                    $unknown?: never;
            }
            interface $UnknownMember {
                    isNull?: never;
                    bitValue?: never;
                    bigIntValue?: never;
                    intValue?: never;
                    doubleValue?: never;
                    realValue?: never;
                    stringValue?: never;
                    blobValue?: never;
                    arrayValues?: never;
                    structValue?: never;
                    $unknown: [string, any];
            }
            interface Visitor<T> {
                    isNull: (value: boolean) => T;
                    bitValue: (value: boolean) => T;
                    bigIntValue: (value: number) => T;
                    intValue: (value: number) => T;
                    doubleValue: (value: number) => T;
                    realValue: (value: number) => T;
                    stringValue: (value: string) => T;
                    blobValue: (value: Uint8Array) => T;
                    arrayValues: (value: Value[]) => T;
                    structValue: (value: StructValue) => T;
                    _: (name: string, value: any) => T;
            }
            const visit: <T>(value: Value, visitor: Visitor<T>) => T;
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Value) => any;
    }
    /**
        * <p>The request parameters represent the input of a request to run a SQL statement against
        *             a database.</p>
        */
    export interface ExecuteStatementRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
                */
            resourceArn: string | undefined;
            /**
                * <p>The ARN of the secret that enables access to the DB cluster. Enter the database user name and password for the credentials in
                *             the secret.</p>
                *         <p>For information about creating the secret, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/create_database_secret.html">Create a database secret</a>.</p>
                */
            secretArn: string | undefined;
            /**
                * <p>The SQL statement to run.</p>
                */
            sql: string | undefined;
            /**
                * <p>The name of the database.</p>
                */
            database?: string;
            /**
                * <p>The name of the database schema.</p>
                *         <note>
                *             <p>Currently, the <code>schema</code> parameter isn't supported.</p>
                *         </note>
                */
            schema?: string;
            /**
                * <p>The parameters for the SQL statement.</p>
                *         <note>
                *             <p>Array parameters are not supported.</p>
                *         </note>
                */
            parameters?: SqlParameter[];
            /**
                * <p>The identifier of a transaction that was started by using the
                *                 <code>BeginTransaction</code> operation. Specify the transaction ID of the
                *             transaction that you want to include the SQL statement in.</p>
                *         <p>If the SQL statement is not part of a transaction, don't set this parameter.</p>
                */
            transactionId?: string;
            /**
                * <p>A value that indicates whether to include metadata in the results.</p>
                */
            includeResultMetadata?: boolean;
            /**
                * <p>A value that indicates whether to continue running the statement after
                *             the call times out. By default, the statement stops running when the call
                *             times out.</p>
                *         <important>
                *             <p>For DDL statements, we recommend continuing to run the statement after
                *                the call times out. When a DDL statement terminates before it is finished
                *                running, it can result in errors and possibly corrupted data structures.</p>
                *         </important>
                */
            continueAfterTimeout?: boolean;
            /**
                * <p>Options that control how the result set is returned.</p>
                */
            resultSetOptions?: ResultSetOptions;
            /**
                * <p>A value that indicates whether to format the result set as a single JSON string.
                *         This parameter only applies to <code>SELECT</code> statements and is ignored for
                *         other types of statements. Allowed values are <code>NONE</code> and <code>JSON</code>.
                *         The default value is <code>NONE</code>. The result is returned in the <code>formattedRecords</code> field.</p>
                *         <p>For usage information about the JSON format for result sets, see
                *           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html">Using the Data API</a>
                *           in the <i>Amazon Aurora User Guide</i>.</p>
                */
            formatRecordsAs?: RecordsFormatType | string;
    }
    export namespace ExecuteStatementRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExecuteStatementRequest) => any;
    }
    /**
        * <p>A structure value returned by a call.</p>
        *         <important>
        *             <p>This data structure is only used with the deprecated <code>ExecuteSql</code> operation.
        *               Use the <code>BatchExecuteStatement</code> or <code>ExecuteStatement</code> operation instead.</p>
        *         </important>
        */
    export interface StructValue {
            /**
                * <p>The attributes returned in the record.</p>
                */
            attributes?: Value[];
    }
    export namespace StructValue {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StructValue) => any;
    }
    /**
        * <p>The request parameters represent the input of a SQL statement over an array of
        *             data.</p>
        */
    export interface BatchExecuteStatementRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
                */
            resourceArn: string | undefined;
            /**
                * <p>The ARN of the secret that enables access to the DB cluster. Enter the database user name and password for the credentials in
                *             the secret.</p>
                *         <p>For information about creating the secret, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/create_database_secret.html">Create a database secret</a>.</p>
                */
            secretArn: string | undefined;
            /**
                * <p>The SQL statement to run. Don't include a semicolon (;) at the end of the SQL statement.</p>
                */
            sql: string | undefined;
            /**
                * <p>The name of the database.</p>
                */
            database?: string;
            /**
                * <p>The name of the database schema.</p>
                */
            schema?: string;
            /**
                * <p>The parameter set for the batch operation.</p>
                *         <p>The SQL statement is executed as many times as the number of parameter sets provided.
                *           To execute a SQL statement with no parameters, use one of the following options:</p>
                *         <ul>
                *             <li>
                *                 <p>Specify one or more empty parameter sets.</p>
                *             </li>
                *             <li>
                *                 <p>Use the <code>ExecuteStatement</code> operation instead of the <code>BatchExecuteStatement</code> operation.</p>
                *             </li>
                *          </ul>
                *         <note>
                *             <p>Array parameters are not supported.</p>
                *         </note>
                */
            parameterSets?: SqlParameter[][];
            /**
                * <p>The identifier of a transaction that was started by using the
                *                 <code>BeginTransaction</code> operation. Specify the transaction ID of the
                *             transaction that you want to include the SQL statement in.</p>
                *         <p>If the SQL statement is not part of a transaction, don't set this
                *             parameter.</p>
                */
            transactionId?: string;
    }
    export namespace BatchExecuteStatementRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchExecuteStatementRequest) => any;
    }
    /**
        * <p>The response elements represent the output of a SQL statement over an array of
        *             data.</p>
        */
    export interface BatchExecuteStatementResponse {
            /**
                * <p>The execution results of each batch entry.</p>
                */
            updateResults?: UpdateResult[];
    }
    export namespace BatchExecuteStatementResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchExecuteStatementResponse) => any;
    }
    /**
        * <p>A record returned by a call.</p>
        *         <important>
        *             <p>This data structure is only used with the deprecated <code>ExecuteSql</code> operation.
        *               Use the <code>BatchExecuteStatement</code> or <code>ExecuteStatement</code> operation instead.</p>
        *         </important>
        */
    export interface _Record {
            /**
                * <p>The values returned in the record.</p>
                */
            values?: Value[];
    }
    export namespace _Record {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: _Record) => any;
    }
    /**
        * <p>The response elements represent the output of a request to run a SQL statement against
        *             a database.</p>
        */
    export interface ExecuteStatementResponse {
            /**
                * <p>The records returned by the SQL statement. This field is blank if the
                *         <code>formatRecordsAs</code> parameter is set to <code>JSON</code>.</p>
                */
            records?: Field[][];
            /**
                * <p>Metadata for the columns included in the results. This field is blank if the
                *         <code>formatRecordsAs</code> parameter is set to <code>JSON</code>.</p>
                */
            columnMetadata?: ColumnMetadata[];
            /**
                * <p>The number of records updated by the request.</p>
                */
            numberOfRecordsUpdated?: number;
            /**
                * <p>Values for fields generated during a DML request.</p>
                *
                *         <note>
                *             <p>The <code>generatedFields</code> data isn't supported by Aurora PostgreSQL.
                *                 To get the values of generated fields, use the <code>RETURNING</code> clause. For
                *                 more information, see <a href="https://www.postgresql.org/docs/10/dml-returning.html">Returning Data From
                *                     Modified Rows</a> in the PostgreSQL documentation.</p>
                *         </note>
                */
            generatedFields?: Field[];
            /**
                * <p>A string value that represents the result set of a <code>SELECT</code> statement
                *         in JSON format. This value is only present when the <code>formatRecordsAs</code>
                *         parameter is set to <code>JSON</code>.</p>
                *         <p>The size limit for this field is currently 10 MB. If the JSON-formatted string representing the
                *           result set requires more than 10 MB, the call returns an error.</p>
                */
            formattedRecords?: string;
    }
    export namespace ExecuteStatementResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExecuteStatementResponse) => any;
    }
    /**
        * <p>The result set returned by a SQL statement.</p>
        *         <important>
        *             <p>This data structure is only used with the deprecated <code>ExecuteSql</code> operation.
        *               Use the <code>BatchExecuteStatement</code> or <code>ExecuteStatement</code> operation instead.</p>
        *         </important>
        */
    export interface ResultFrame {
            /**
                * <p>The result-set metadata in the result set.</p>
                */
            resultSetMetadata?: ResultSetMetadata;
            /**
                * <p>The records in the result set.</p>
                */
            records?: _Record[];
    }
    export namespace ResultFrame {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResultFrame) => any;
    }
    /**
        * <p>The result of a SQL statement.</p>
        *
        *         <important>
        *             <p>This data structure is only used with the deprecated <code>ExecuteSql</code> operation.
        *               Use the <code>BatchExecuteStatement</code> or <code>ExecuteStatement</code> operation instead.</p>
        *         </important>
        */
    export interface SqlStatementResult {
            /**
                * <p>The result set of the SQL statement.</p>
                */
            resultFrame?: ResultFrame;
            /**
                * <p>The number of records updated by a SQL statement.</p>
                */
            numberOfRecordsUpdated?: number;
    }
    export namespace SqlStatementResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SqlStatementResult) => any;
    }
    /**
        * <p>The response elements represent the output of a request to run one or more SQL
        *             statements.</p>
        */
    export interface ExecuteSqlResponse {
            /**
                * <p>The results of the SQL statement or statements.</p>
                */
            sqlStatementResults?: SqlStatementResult[];
    }
    export namespace ExecuteSqlResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExecuteSqlResponse) => any;
    }
}

declare module '@aws-sdk/client-rds-data/node_modules/@aws-sdk/client-rds-data/dist-types/models/RDSDataServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from RDSData service.
        */
    export class RDSDataServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

