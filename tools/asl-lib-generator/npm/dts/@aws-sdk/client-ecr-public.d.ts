// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/smithy-client
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http

declare module '@aws-sdk/client-ecr-public' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { BatchCheckLayerAvailabilityCommandInput, BatchCheckLayerAvailabilityCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/BatchCheckLayerAvailabilityCommand";
    import { BatchDeleteImageCommandInput, BatchDeleteImageCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/BatchDeleteImageCommand";
    import { CompleteLayerUploadCommandInput, CompleteLayerUploadCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/CompleteLayerUploadCommand";
    import { CreateRepositoryCommandInput, CreateRepositoryCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/CreateRepositoryCommand";
    import { DeleteRepositoryCommandInput, DeleteRepositoryCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/DeleteRepositoryCommand";
    import { DeleteRepositoryPolicyCommandInput, DeleteRepositoryPolicyCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/DeleteRepositoryPolicyCommand";
    import { DescribeImagesCommandInput, DescribeImagesCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/DescribeImagesCommand";
    import { DescribeImageTagsCommandInput, DescribeImageTagsCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/DescribeImageTagsCommand";
    import { DescribeRegistriesCommandInput, DescribeRegistriesCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/DescribeRegistriesCommand";
    import { DescribeRepositoriesCommandInput, DescribeRepositoriesCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/DescribeRepositoriesCommand";
    import { GetAuthorizationTokenCommandInput, GetAuthorizationTokenCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/GetAuthorizationTokenCommand";
    import { GetRegistryCatalogDataCommandInput, GetRegistryCatalogDataCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/GetRegistryCatalogDataCommand";
    import { GetRepositoryCatalogDataCommandInput, GetRepositoryCatalogDataCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/GetRepositoryCatalogDataCommand";
    import { GetRepositoryPolicyCommandInput, GetRepositoryPolicyCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/GetRepositoryPolicyCommand";
    import { InitiateLayerUploadCommandInput, InitiateLayerUploadCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/InitiateLayerUploadCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/ListTagsForResourceCommand";
    import { PutImageCommandInput, PutImageCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/PutImageCommand";
    import { PutRegistryCatalogDataCommandInput, PutRegistryCatalogDataCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/PutRegistryCatalogDataCommand";
    import { PutRepositoryCatalogDataCommandInput, PutRepositoryCatalogDataCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/PutRepositoryCatalogDataCommand";
    import { SetRepositoryPolicyCommandInput, SetRepositoryPolicyCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/SetRepositoryPolicyCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/UntagResourceCommand";
    import { UploadLayerPartCommandInput, UploadLayerPartCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/UploadLayerPartCommand";
    import { ECRPUBLICClient } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    /**
        * <fullname>Amazon Elastic Container Registry Public</fullname>
        *          <p>Amazon Elastic Container Registry (Amazon ECR) is a managed container image registry service. Amazon ECR provides both
        *          public and private registries to host your container images. You can use the familiar
        *          Docker CLI, or their preferred client, to push, pull, and manage images. Amazon ECR provides a
        *          secure, scalable, and reliable registry for your Docker or Open Container Initiative (OCI)
        *          images. Amazon ECR supports public repositories with this API. For information about the Amazon ECR
        *          API for private repositories, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/APIReference/Welcome.html">Amazon Elastic Container Registry API Reference</a>.</p>
        */
    export class ECRPUBLIC extends ECRPUBLICClient {
            /**
                * <p>Checks the availability of one or more image layers within a repository in a public
                *          registry. When an image is pushed to a repository, each image layer is checked to verify if
                *          it has been uploaded before. If it has been uploaded, then the image layer is
                *          skipped.</p>
                *          <note>
                *             <p>This operation is used by the Amazon ECR proxy and is not generally used by customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
                *          </note>
                */
            batchCheckLayerAvailability(args: BatchCheckLayerAvailabilityCommandInput, options?: __HttpHandlerOptions): Promise<BatchCheckLayerAvailabilityCommandOutput>;
            batchCheckLayerAvailability(args: BatchCheckLayerAvailabilityCommandInput, cb: (err: any, data?: BatchCheckLayerAvailabilityCommandOutput) => void): void;
            batchCheckLayerAvailability(args: BatchCheckLayerAvailabilityCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchCheckLayerAvailabilityCommandOutput) => void): void;
            /**
                * <p>Deletes a list of specified images within a repository in a public registry. Images are
                *          specified with either an <code>imageTag</code> or <code>imageDigest</code>.</p>
                *          <p>You can remove a tag from an image by specifying the image's tag in your request. When
                *          you remove the last tag from an image, the image is deleted from your repository.</p>
                *          <p>You can completely delete an image (and all of its tags) by specifying the image's
                *          digest in your request.</p>
                */
            batchDeleteImage(args: BatchDeleteImageCommandInput, options?: __HttpHandlerOptions): Promise<BatchDeleteImageCommandOutput>;
            batchDeleteImage(args: BatchDeleteImageCommandInput, cb: (err: any, data?: BatchDeleteImageCommandOutput) => void): void;
            batchDeleteImage(args: BatchDeleteImageCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchDeleteImageCommandOutput) => void): void;
            /**
                * <p>Informs Amazon ECR that the image layer upload has completed for a specified public registry,
                *          repository name, and upload ID. You can optionally provide a <code>sha256</code> digest of
                *          the image layer for data validation purposes.</p>
                *          <p>When an image is pushed, the CompleteLayerUpload API is called once per each new image
                *          layer to verify that the upload has completed.</p>
                *          <note>
                *             <p>This operation is used by the Amazon ECR proxy and is not generally used by customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
                *          </note>
                */
            completeLayerUpload(args: CompleteLayerUploadCommandInput, options?: __HttpHandlerOptions): Promise<CompleteLayerUploadCommandOutput>;
            completeLayerUpload(args: CompleteLayerUploadCommandInput, cb: (err: any, data?: CompleteLayerUploadCommandOutput) => void): void;
            completeLayerUpload(args: CompleteLayerUploadCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CompleteLayerUploadCommandOutput) => void): void;
            /**
                * <p>Creates a repository in a public registry. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/Repositories.html">Amazon ECR
                *             repositories</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
                */
            createRepository(args: CreateRepositoryCommandInput, options?: __HttpHandlerOptions): Promise<CreateRepositoryCommandOutput>;
            createRepository(args: CreateRepositoryCommandInput, cb: (err: any, data?: CreateRepositoryCommandOutput) => void): void;
            createRepository(args: CreateRepositoryCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateRepositoryCommandOutput) => void): void;
            /**
                * <p>Deletes a repository in a public registry. If the repository contains images, you must
                *          either delete all images in the repository or use the <code>force</code> option which
                *          deletes all images on your behalf before deleting the repository.</p>
                */
            deleteRepository(args: DeleteRepositoryCommandInput, options?: __HttpHandlerOptions): Promise<DeleteRepositoryCommandOutput>;
            deleteRepository(args: DeleteRepositoryCommandInput, cb: (err: any, data?: DeleteRepositoryCommandOutput) => void): void;
            deleteRepository(args: DeleteRepositoryCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteRepositoryCommandOutput) => void): void;
            /**
                * <p>Deletes the repository policy associated with the specified repository.</p>
                */
            deleteRepositoryPolicy(args: DeleteRepositoryPolicyCommandInput, options?: __HttpHandlerOptions): Promise<DeleteRepositoryPolicyCommandOutput>;
            deleteRepositoryPolicy(args: DeleteRepositoryPolicyCommandInput, cb: (err: any, data?: DeleteRepositoryPolicyCommandOutput) => void): void;
            deleteRepositoryPolicy(args: DeleteRepositoryPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteRepositoryPolicyCommandOutput) => void): void;
            /**
                * <p>Returns metadata about the images in a repository in a public registry.</p>
                *          <note>
                *             <p>Beginning with Docker version 1.9, the Docker client compresses image layers before
                *             pushing them to a V2 Docker registry. The output of the <code>docker images</code>
                *             command shows the uncompressed image size, so it may return a larger image size than the
                *             image sizes returned by <a>DescribeImages</a>.</p>
                *          </note>
                */
            describeImages(args: DescribeImagesCommandInput, options?: __HttpHandlerOptions): Promise<DescribeImagesCommandOutput>;
            describeImages(args: DescribeImagesCommandInput, cb: (err: any, data?: DescribeImagesCommandOutput) => void): void;
            describeImages(args: DescribeImagesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeImagesCommandOutput) => void): void;
            /**
                * <p>Returns the image tag details for a repository in a public registry.</p>
                */
            describeImageTags(args: DescribeImageTagsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeImageTagsCommandOutput>;
            describeImageTags(args: DescribeImageTagsCommandInput, cb: (err: any, data?: DescribeImageTagsCommandOutput) => void): void;
            describeImageTags(args: DescribeImageTagsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeImageTagsCommandOutput) => void): void;
            /**
                * <p>Returns details for a public registry.</p>
                */
            describeRegistries(args: DescribeRegistriesCommandInput, options?: __HttpHandlerOptions): Promise<DescribeRegistriesCommandOutput>;
            describeRegistries(args: DescribeRegistriesCommandInput, cb: (err: any, data?: DescribeRegistriesCommandOutput) => void): void;
            describeRegistries(args: DescribeRegistriesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeRegistriesCommandOutput) => void): void;
            /**
                * <p>Describes repositories in a public registry.</p>
                */
            describeRepositories(args: DescribeRepositoriesCommandInput, options?: __HttpHandlerOptions): Promise<DescribeRepositoriesCommandOutput>;
            describeRepositories(args: DescribeRepositoriesCommandInput, cb: (err: any, data?: DescribeRepositoriesCommandOutput) => void): void;
            describeRepositories(args: DescribeRepositoriesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeRepositoriesCommandOutput) => void): void;
            /**
                * <p>Retrieves an authorization token. An authorization token represents your IAM
                *          authentication credentials and can be used to access any Amazon ECR registry that your IAM
                *          principal has access to. The authorization token is valid for 12 hours. This API requires
                *          the <code>ecr-public:GetAuthorizationToken</code> and
                *             <code>sts:GetServiceBearerToken</code> permissions.</p>
                */
            getAuthorizationToken(args: GetAuthorizationTokenCommandInput, options?: __HttpHandlerOptions): Promise<GetAuthorizationTokenCommandOutput>;
            getAuthorizationToken(args: GetAuthorizationTokenCommandInput, cb: (err: any, data?: GetAuthorizationTokenCommandOutput) => void): void;
            getAuthorizationToken(args: GetAuthorizationTokenCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetAuthorizationTokenCommandOutput) => void): void;
            /**
                * <p>Retrieves catalog metadata for a public registry.</p>
                */
            getRegistryCatalogData(args: GetRegistryCatalogDataCommandInput, options?: __HttpHandlerOptions): Promise<GetRegistryCatalogDataCommandOutput>;
            getRegistryCatalogData(args: GetRegistryCatalogDataCommandInput, cb: (err: any, data?: GetRegistryCatalogDataCommandOutput) => void): void;
            getRegistryCatalogData(args: GetRegistryCatalogDataCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetRegistryCatalogDataCommandOutput) => void): void;
            /**
                * <p>Retrieve catalog metadata for a repository in a public registry. This metadata is
                *          displayed publicly in the Amazon ECR Public Gallery.</p>
                */
            getRepositoryCatalogData(args: GetRepositoryCatalogDataCommandInput, options?: __HttpHandlerOptions): Promise<GetRepositoryCatalogDataCommandOutput>;
            getRepositoryCatalogData(args: GetRepositoryCatalogDataCommandInput, cb: (err: any, data?: GetRepositoryCatalogDataCommandOutput) => void): void;
            getRepositoryCatalogData(args: GetRepositoryCatalogDataCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetRepositoryCatalogDataCommandOutput) => void): void;
            /**
                * <p>Retrieves the repository policy for the specified repository.</p>
                */
            getRepositoryPolicy(args: GetRepositoryPolicyCommandInput, options?: __HttpHandlerOptions): Promise<GetRepositoryPolicyCommandOutput>;
            getRepositoryPolicy(args: GetRepositoryPolicyCommandInput, cb: (err: any, data?: GetRepositoryPolicyCommandOutput) => void): void;
            getRepositoryPolicy(args: GetRepositoryPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetRepositoryPolicyCommandOutput) => void): void;
            /**
                * <p>Notifies Amazon ECR that you intend to upload an image layer.</p>
                *          <p>When an image is pushed, the InitiateLayerUpload API is called once per image layer that
                *          has not already been uploaded. Whether or not an image layer has been uploaded is
                *          determined by the BatchCheckLayerAvailability API action.</p>
                *          <note>
                *             <p>This operation is used by the Amazon ECR proxy and is not generally used by customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
                *          </note>
                */
            initiateLayerUpload(args: InitiateLayerUploadCommandInput, options?: __HttpHandlerOptions): Promise<InitiateLayerUploadCommandOutput>;
            initiateLayerUpload(args: InitiateLayerUploadCommandInput, cb: (err: any, data?: InitiateLayerUploadCommandOutput) => void): void;
            initiateLayerUpload(args: InitiateLayerUploadCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: InitiateLayerUploadCommandOutput) => void): void;
            /**
                * <p>List the tags for an Amazon ECR Public resource.</p>
                */
            listTagsForResource(args: ListTagsForResourceCommandInput, options?: __HttpHandlerOptions): Promise<ListTagsForResourceCommandOutput>;
            listTagsForResource(args: ListTagsForResourceCommandInput, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            listTagsForResource(args: ListTagsForResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            /**
                * <p>Creates or updates the image manifest and tags associated with an image.</p>
                *          <p>When an image is pushed and all new image layers have been uploaded, the PutImage API is
                *          called once to create or update the image manifest and the tags associated with the
                *          image.</p>
                *
                *          <note>
                *             <p>This operation is used by the Amazon ECR proxy and is not generally used by customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
                *          </note>
                */
            putImage(args: PutImageCommandInput, options?: __HttpHandlerOptions): Promise<PutImageCommandOutput>;
            putImage(args: PutImageCommandInput, cb: (err: any, data?: PutImageCommandOutput) => void): void;
            putImage(args: PutImageCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutImageCommandOutput) => void): void;
            /**
                * <p>Create or updates the catalog data for a public registry.</p>
                */
            putRegistryCatalogData(args: PutRegistryCatalogDataCommandInput, options?: __HttpHandlerOptions): Promise<PutRegistryCatalogDataCommandOutput>;
            putRegistryCatalogData(args: PutRegistryCatalogDataCommandInput, cb: (err: any, data?: PutRegistryCatalogDataCommandOutput) => void): void;
            putRegistryCatalogData(args: PutRegistryCatalogDataCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutRegistryCatalogDataCommandOutput) => void): void;
            /**
                * <p>Creates or updates the catalog data for a repository in a public registry.</p>
                */
            putRepositoryCatalogData(args: PutRepositoryCatalogDataCommandInput, options?: __HttpHandlerOptions): Promise<PutRepositoryCatalogDataCommandOutput>;
            putRepositoryCatalogData(args: PutRepositoryCatalogDataCommandInput, cb: (err: any, data?: PutRepositoryCatalogDataCommandOutput) => void): void;
            putRepositoryCatalogData(args: PutRepositoryCatalogDataCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutRepositoryCatalogDataCommandOutput) => void): void;
            /**
                * <p>Applies a repository policy to the specified public repository to control access
                *          permissions. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-policies.html">Amazon ECR Repository
                *             Policies</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
                */
            setRepositoryPolicy(args: SetRepositoryPolicyCommandInput, options?: __HttpHandlerOptions): Promise<SetRepositoryPolicyCommandOutput>;
            setRepositoryPolicy(args: SetRepositoryPolicyCommandInput, cb: (err: any, data?: SetRepositoryPolicyCommandOutput) => void): void;
            setRepositoryPolicy(args: SetRepositoryPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: SetRepositoryPolicyCommandOutput) => void): void;
            /**
                * <p>Associates the specified tags to a resource with the specified <code>resourceArn</code>.
                *          If existing tags on a resource are not specified in the request parameters, they are not
                *          changed. When a resource is deleted, the tags associated with that resource are deleted as
                *          well.</p>
                */
            tagResource(args: TagResourceCommandInput, options?: __HttpHandlerOptions): Promise<TagResourceCommandOutput>;
            tagResource(args: TagResourceCommandInput, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            tagResource(args: TagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            /**
                * <p>Deletes specified tags from a resource.</p>
                */
            untagResource(args: UntagResourceCommandInput, options?: __HttpHandlerOptions): Promise<UntagResourceCommandOutput>;
            untagResource(args: UntagResourceCommandInput, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            untagResource(args: UntagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            /**
                * <p>Uploads an image layer part to Amazon ECR.</p>
                *          <p>When an image is pushed, each new image layer is uploaded in parts. The maximum size of
                *          each image layer part can be 20971520 bytes (or about 20MB). The UploadLayerPart API is
                *          called once per each new image layer part.</p>
                *          <note>
                *             <p>This operation is used by the Amazon ECR proxy and is not generally used by customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
                *          </note>
                */
            uploadLayerPart(args: UploadLayerPartCommandInput, options?: __HttpHandlerOptions): Promise<UploadLayerPartCommandOutput>;
            uploadLayerPart(args: UploadLayerPartCommandInput, cb: (err: any, data?: UploadLayerPartCommandOutput) => void): void;
            uploadLayerPart(args: UploadLayerPartCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UploadLayerPartCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/BatchCheckLayerAvailabilityCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { BatchCheckLayerAvailabilityRequest, BatchCheckLayerAvailabilityResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface BatchCheckLayerAvailabilityCommandInput extends BatchCheckLayerAvailabilityRequest {
    }
    export interface BatchCheckLayerAvailabilityCommandOutput extends BatchCheckLayerAvailabilityResponse, __MetadataBearer {
    }
    /**
        * <p>Checks the availability of one or more image layers within a repository in a public
        *          registry. When an image is pushed to a repository, each image layer is checked to verify if
        *          it has been uploaded before. If it has been uploaded, then the image layer is
        *          skipped.</p>
        *          <note>
        *             <p>This operation is used by the Amazon ECR proxy and is not generally used by customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
        *          </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, BatchCheckLayerAvailabilityCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, BatchCheckLayerAvailabilityCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new BatchCheckLayerAvailabilityCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchCheckLayerAvailabilityCommandInput} for command's `input` shape.
        * @see {@link BatchCheckLayerAvailabilityCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class BatchCheckLayerAvailabilityCommand extends $Command<BatchCheckLayerAvailabilityCommandInput, BatchCheckLayerAvailabilityCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: BatchCheckLayerAvailabilityCommandInput;
            constructor(input: BatchCheckLayerAvailabilityCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchCheckLayerAvailabilityCommandInput, BatchCheckLayerAvailabilityCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/BatchDeleteImageCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { BatchDeleteImageRequest, BatchDeleteImageResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface BatchDeleteImageCommandInput extends BatchDeleteImageRequest {
    }
    export interface BatchDeleteImageCommandOutput extends BatchDeleteImageResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes a list of specified images within a repository in a public registry. Images are
        *          specified with either an <code>imageTag</code> or <code>imageDigest</code>.</p>
        *          <p>You can remove a tag from an image by specifying the image's tag in your request. When
        *          you remove the last tag from an image, the image is deleted from your repository.</p>
        *          <p>You can completely delete an image (and all of its tags) by specifying the image's
        *          digest in your request.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, BatchDeleteImageCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, BatchDeleteImageCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new BatchDeleteImageCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchDeleteImageCommandInput} for command's `input` shape.
        * @see {@link BatchDeleteImageCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class BatchDeleteImageCommand extends $Command<BatchDeleteImageCommandInput, BatchDeleteImageCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: BatchDeleteImageCommandInput;
            constructor(input: BatchDeleteImageCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchDeleteImageCommandInput, BatchDeleteImageCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/CompleteLayerUploadCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { CompleteLayerUploadRequest, CompleteLayerUploadResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface CompleteLayerUploadCommandInput extends CompleteLayerUploadRequest {
    }
    export interface CompleteLayerUploadCommandOutput extends CompleteLayerUploadResponse, __MetadataBearer {
    }
    /**
        * <p>Informs Amazon ECR that the image layer upload has completed for a specified public registry,
        *          repository name, and upload ID. You can optionally provide a <code>sha256</code> digest of
        *          the image layer for data validation purposes.</p>
        *          <p>When an image is pushed, the CompleteLayerUpload API is called once per each new image
        *          layer to verify that the upload has completed.</p>
        *          <note>
        *             <p>This operation is used by the Amazon ECR proxy and is not generally used by customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
        *          </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, CompleteLayerUploadCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, CompleteLayerUploadCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new CompleteLayerUploadCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CompleteLayerUploadCommandInput} for command's `input` shape.
        * @see {@link CompleteLayerUploadCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class CompleteLayerUploadCommand extends $Command<CompleteLayerUploadCommandInput, CompleteLayerUploadCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: CompleteLayerUploadCommandInput;
            constructor(input: CompleteLayerUploadCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CompleteLayerUploadCommandInput, CompleteLayerUploadCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/CreateRepositoryCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { CreateRepositoryRequest, CreateRepositoryResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface CreateRepositoryCommandInput extends CreateRepositoryRequest {
    }
    export interface CreateRepositoryCommandOutput extends CreateRepositoryResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a repository in a public registry. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/Repositories.html">Amazon ECR
        *             repositories</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, CreateRepositoryCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, CreateRepositoryCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new CreateRepositoryCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateRepositoryCommandInput} for command's `input` shape.
        * @see {@link CreateRepositoryCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class CreateRepositoryCommand extends $Command<CreateRepositoryCommandInput, CreateRepositoryCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: CreateRepositoryCommandInput;
            constructor(input: CreateRepositoryCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateRepositoryCommandInput, CreateRepositoryCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/DeleteRepositoryCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { DeleteRepositoryRequest, DeleteRepositoryResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface DeleteRepositoryCommandInput extends DeleteRepositoryRequest {
    }
    export interface DeleteRepositoryCommandOutput extends DeleteRepositoryResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes a repository in a public registry. If the repository contains images, you must
        *          either delete all images in the repository or use the <code>force</code> option which
        *          deletes all images on your behalf before deleting the repository.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, DeleteRepositoryCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, DeleteRepositoryCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new DeleteRepositoryCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteRepositoryCommandInput} for command's `input` shape.
        * @see {@link DeleteRepositoryCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class DeleteRepositoryCommand extends $Command<DeleteRepositoryCommandInput, DeleteRepositoryCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: DeleteRepositoryCommandInput;
            constructor(input: DeleteRepositoryCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteRepositoryCommandInput, DeleteRepositoryCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/DeleteRepositoryPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { DeleteRepositoryPolicyRequest, DeleteRepositoryPolicyResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface DeleteRepositoryPolicyCommandInput extends DeleteRepositoryPolicyRequest {
    }
    export interface DeleteRepositoryPolicyCommandOutput extends DeleteRepositoryPolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes the repository policy associated with the specified repository.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, DeleteRepositoryPolicyCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, DeleteRepositoryPolicyCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new DeleteRepositoryPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteRepositoryPolicyCommandInput} for command's `input` shape.
        * @see {@link DeleteRepositoryPolicyCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class DeleteRepositoryPolicyCommand extends $Command<DeleteRepositoryPolicyCommandInput, DeleteRepositoryPolicyCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: DeleteRepositoryPolicyCommandInput;
            constructor(input: DeleteRepositoryPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteRepositoryPolicyCommandInput, DeleteRepositoryPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/DescribeImagesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { DescribeImagesRequest, DescribeImagesResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface DescribeImagesCommandInput extends DescribeImagesRequest {
    }
    export interface DescribeImagesCommandOutput extends DescribeImagesResponse, __MetadataBearer {
    }
    /**
        * <p>Returns metadata about the images in a repository in a public registry.</p>
        *          <note>
        *             <p>Beginning with Docker version 1.9, the Docker client compresses image layers before
        *             pushing them to a V2 Docker registry. The output of the <code>docker images</code>
        *             command shows the uncompressed image size, so it may return a larger image size than the
        *             image sizes returned by <a>DescribeImages</a>.</p>
        *          </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, DescribeImagesCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, DescribeImagesCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new DescribeImagesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeImagesCommandInput} for command's `input` shape.
        * @see {@link DescribeImagesCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class DescribeImagesCommand extends $Command<DescribeImagesCommandInput, DescribeImagesCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: DescribeImagesCommandInput;
            constructor(input: DescribeImagesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeImagesCommandInput, DescribeImagesCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/DescribeImageTagsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { DescribeImageTagsRequest, DescribeImageTagsResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface DescribeImageTagsCommandInput extends DescribeImageTagsRequest {
    }
    export interface DescribeImageTagsCommandOutput extends DescribeImageTagsResponse, __MetadataBearer {
    }
    /**
        * <p>Returns the image tag details for a repository in a public registry.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, DescribeImageTagsCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, DescribeImageTagsCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new DescribeImageTagsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeImageTagsCommandInput} for command's `input` shape.
        * @see {@link DescribeImageTagsCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class DescribeImageTagsCommand extends $Command<DescribeImageTagsCommandInput, DescribeImageTagsCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: DescribeImageTagsCommandInput;
            constructor(input: DescribeImageTagsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeImageTagsCommandInput, DescribeImageTagsCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/DescribeRegistriesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { DescribeRegistriesRequest, DescribeRegistriesResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface DescribeRegistriesCommandInput extends DescribeRegistriesRequest {
    }
    export interface DescribeRegistriesCommandOutput extends DescribeRegistriesResponse, __MetadataBearer {
    }
    /**
        * <p>Returns details for a public registry.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, DescribeRegistriesCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, DescribeRegistriesCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new DescribeRegistriesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeRegistriesCommandInput} for command's `input` shape.
        * @see {@link DescribeRegistriesCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class DescribeRegistriesCommand extends $Command<DescribeRegistriesCommandInput, DescribeRegistriesCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: DescribeRegistriesCommandInput;
            constructor(input: DescribeRegistriesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeRegistriesCommandInput, DescribeRegistriesCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/DescribeRepositoriesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { DescribeRepositoriesRequest, DescribeRepositoriesResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface DescribeRepositoriesCommandInput extends DescribeRepositoriesRequest {
    }
    export interface DescribeRepositoriesCommandOutput extends DescribeRepositoriesResponse, __MetadataBearer {
    }
    /**
        * <p>Describes repositories in a public registry.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, DescribeRepositoriesCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, DescribeRepositoriesCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new DescribeRepositoriesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeRepositoriesCommandInput} for command's `input` shape.
        * @see {@link DescribeRepositoriesCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class DescribeRepositoriesCommand extends $Command<DescribeRepositoriesCommandInput, DescribeRepositoriesCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: DescribeRepositoriesCommandInput;
            constructor(input: DescribeRepositoriesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeRepositoriesCommandInput, DescribeRepositoriesCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/GetAuthorizationTokenCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { GetAuthorizationTokenRequest, GetAuthorizationTokenResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface GetAuthorizationTokenCommandInput extends GetAuthorizationTokenRequest {
    }
    export interface GetAuthorizationTokenCommandOutput extends GetAuthorizationTokenResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves an authorization token. An authorization token represents your IAM
        *          authentication credentials and can be used to access any Amazon ECR registry that your IAM
        *          principal has access to. The authorization token is valid for 12 hours. This API requires
        *          the <code>ecr-public:GetAuthorizationToken</code> and
        *             <code>sts:GetServiceBearerToken</code> permissions.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, GetAuthorizationTokenCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, GetAuthorizationTokenCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new GetAuthorizationTokenCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetAuthorizationTokenCommandInput} for command's `input` shape.
        * @see {@link GetAuthorizationTokenCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class GetAuthorizationTokenCommand extends $Command<GetAuthorizationTokenCommandInput, GetAuthorizationTokenCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: GetAuthorizationTokenCommandInput;
            constructor(input: GetAuthorizationTokenCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetAuthorizationTokenCommandInput, GetAuthorizationTokenCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/GetRegistryCatalogDataCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { GetRegistryCatalogDataRequest, GetRegistryCatalogDataResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface GetRegistryCatalogDataCommandInput extends GetRegistryCatalogDataRequest {
    }
    export interface GetRegistryCatalogDataCommandOutput extends GetRegistryCatalogDataResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves catalog metadata for a public registry.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, GetRegistryCatalogDataCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, GetRegistryCatalogDataCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new GetRegistryCatalogDataCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetRegistryCatalogDataCommandInput} for command's `input` shape.
        * @see {@link GetRegistryCatalogDataCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class GetRegistryCatalogDataCommand extends $Command<GetRegistryCatalogDataCommandInput, GetRegistryCatalogDataCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: GetRegistryCatalogDataCommandInput;
            constructor(input: GetRegistryCatalogDataCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetRegistryCatalogDataCommandInput, GetRegistryCatalogDataCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/GetRepositoryCatalogDataCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { GetRepositoryCatalogDataRequest, GetRepositoryCatalogDataResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface GetRepositoryCatalogDataCommandInput extends GetRepositoryCatalogDataRequest {
    }
    export interface GetRepositoryCatalogDataCommandOutput extends GetRepositoryCatalogDataResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieve catalog metadata for a repository in a public registry. This metadata is
        *          displayed publicly in the Amazon ECR Public Gallery.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, GetRepositoryCatalogDataCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, GetRepositoryCatalogDataCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new GetRepositoryCatalogDataCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetRepositoryCatalogDataCommandInput} for command's `input` shape.
        * @see {@link GetRepositoryCatalogDataCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class GetRepositoryCatalogDataCommand extends $Command<GetRepositoryCatalogDataCommandInput, GetRepositoryCatalogDataCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: GetRepositoryCatalogDataCommandInput;
            constructor(input: GetRepositoryCatalogDataCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetRepositoryCatalogDataCommandInput, GetRepositoryCatalogDataCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/GetRepositoryPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { GetRepositoryPolicyRequest, GetRepositoryPolicyResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface GetRepositoryPolicyCommandInput extends GetRepositoryPolicyRequest {
    }
    export interface GetRepositoryPolicyCommandOutput extends GetRepositoryPolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves the repository policy for the specified repository.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, GetRepositoryPolicyCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, GetRepositoryPolicyCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new GetRepositoryPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetRepositoryPolicyCommandInput} for command's `input` shape.
        * @see {@link GetRepositoryPolicyCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class GetRepositoryPolicyCommand extends $Command<GetRepositoryPolicyCommandInput, GetRepositoryPolicyCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: GetRepositoryPolicyCommandInput;
            constructor(input: GetRepositoryPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetRepositoryPolicyCommandInput, GetRepositoryPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/InitiateLayerUploadCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { InitiateLayerUploadRequest, InitiateLayerUploadResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface InitiateLayerUploadCommandInput extends InitiateLayerUploadRequest {
    }
    export interface InitiateLayerUploadCommandOutput extends InitiateLayerUploadResponse, __MetadataBearer {
    }
    /**
        * <p>Notifies Amazon ECR that you intend to upload an image layer.</p>
        *          <p>When an image is pushed, the InitiateLayerUpload API is called once per image layer that
        *          has not already been uploaded. Whether or not an image layer has been uploaded is
        *          determined by the BatchCheckLayerAvailability API action.</p>
        *          <note>
        *             <p>This operation is used by the Amazon ECR proxy and is not generally used by customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
        *          </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, InitiateLayerUploadCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, InitiateLayerUploadCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new InitiateLayerUploadCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link InitiateLayerUploadCommandInput} for command's `input` shape.
        * @see {@link InitiateLayerUploadCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class InitiateLayerUploadCommand extends $Command<InitiateLayerUploadCommandInput, InitiateLayerUploadCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: InitiateLayerUploadCommandInput;
            constructor(input: InitiateLayerUploadCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<InitiateLayerUploadCommandInput, InitiateLayerUploadCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/ListTagsForResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { ListTagsForResourceRequest, ListTagsForResourceResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface ListTagsForResourceCommandInput extends ListTagsForResourceRequest {
    }
    export interface ListTagsForResourceCommandOutput extends ListTagsForResourceResponse, __MetadataBearer {
    }
    /**
        * <p>List the tags for an Amazon ECR Public resource.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, ListTagsForResourceCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, ListTagsForResourceCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new ListTagsForResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTagsForResourceCommandInput} for command's `input` shape.
        * @see {@link ListTagsForResourceCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class ListTagsForResourceCommand extends $Command<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: ListTagsForResourceCommandInput;
            constructor(input: ListTagsForResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/PutImageCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { PutImageRequest, PutImageResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface PutImageCommandInput extends PutImageRequest {
    }
    export interface PutImageCommandOutput extends PutImageResponse, __MetadataBearer {
    }
    /**
        * <p>Creates or updates the image manifest and tags associated with an image.</p>
        *          <p>When an image is pushed and all new image layers have been uploaded, the PutImage API is
        *          called once to create or update the image manifest and the tags associated with the
        *          image.</p>
        *
        *          <note>
        *             <p>This operation is used by the Amazon ECR proxy and is not generally used by customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
        *          </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, PutImageCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, PutImageCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new PutImageCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutImageCommandInput} for command's `input` shape.
        * @see {@link PutImageCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class PutImageCommand extends $Command<PutImageCommandInput, PutImageCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: PutImageCommandInput;
            constructor(input: PutImageCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutImageCommandInput, PutImageCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/PutRegistryCatalogDataCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { PutRegistryCatalogDataRequest, PutRegistryCatalogDataResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface PutRegistryCatalogDataCommandInput extends PutRegistryCatalogDataRequest {
    }
    export interface PutRegistryCatalogDataCommandOutput extends PutRegistryCatalogDataResponse, __MetadataBearer {
    }
    /**
        * <p>Create or updates the catalog data for a public registry.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, PutRegistryCatalogDataCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, PutRegistryCatalogDataCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new PutRegistryCatalogDataCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutRegistryCatalogDataCommandInput} for command's `input` shape.
        * @see {@link PutRegistryCatalogDataCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class PutRegistryCatalogDataCommand extends $Command<PutRegistryCatalogDataCommandInput, PutRegistryCatalogDataCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: PutRegistryCatalogDataCommandInput;
            constructor(input: PutRegistryCatalogDataCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutRegistryCatalogDataCommandInput, PutRegistryCatalogDataCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/PutRepositoryCatalogDataCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { PutRepositoryCatalogDataRequest, PutRepositoryCatalogDataResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface PutRepositoryCatalogDataCommandInput extends PutRepositoryCatalogDataRequest {
    }
    export interface PutRepositoryCatalogDataCommandOutput extends PutRepositoryCatalogDataResponse, __MetadataBearer {
    }
    /**
        * <p>Creates or updates the catalog data for a repository in a public registry.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, PutRepositoryCatalogDataCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, PutRepositoryCatalogDataCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new PutRepositoryCatalogDataCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutRepositoryCatalogDataCommandInput} for command's `input` shape.
        * @see {@link PutRepositoryCatalogDataCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class PutRepositoryCatalogDataCommand extends $Command<PutRepositoryCatalogDataCommandInput, PutRepositoryCatalogDataCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: PutRepositoryCatalogDataCommandInput;
            constructor(input: PutRepositoryCatalogDataCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutRepositoryCatalogDataCommandInput, PutRepositoryCatalogDataCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/SetRepositoryPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { SetRepositoryPolicyRequest, SetRepositoryPolicyResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface SetRepositoryPolicyCommandInput extends SetRepositoryPolicyRequest {
    }
    export interface SetRepositoryPolicyCommandOutput extends SetRepositoryPolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Applies a repository policy to the specified public repository to control access
        *          permissions. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-policies.html">Amazon ECR Repository
        *             Policies</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, SetRepositoryPolicyCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, SetRepositoryPolicyCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new SetRepositoryPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link SetRepositoryPolicyCommandInput} for command's `input` shape.
        * @see {@link SetRepositoryPolicyCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class SetRepositoryPolicyCommand extends $Command<SetRepositoryPolicyCommandInput, SetRepositoryPolicyCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: SetRepositoryPolicyCommandInput;
            constructor(input: SetRepositoryPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<SetRepositoryPolicyCommandInput, SetRepositoryPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/TagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { TagResourceRequest, TagResourceResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface TagResourceCommandInput extends TagResourceRequest {
    }
    export interface TagResourceCommandOutput extends TagResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Associates the specified tags to a resource with the specified <code>resourceArn</code>.
        *          If existing tags on a resource are not specified in the request parameters, they are not
        *          changed. When a resource is deleted, the tags associated with that resource are deleted as
        *          well.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, TagResourceCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, TagResourceCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new TagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TagResourceCommandInput} for command's `input` shape.
        * @see {@link TagResourceCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class TagResourceCommand extends $Command<TagResourceCommandInput, TagResourceCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: TagResourceCommandInput;
            constructor(input: TagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TagResourceCommandInput, TagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/UntagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { UntagResourceRequest, UntagResourceResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface UntagResourceCommandInput extends UntagResourceRequest {
    }
    export interface UntagResourceCommandOutput extends UntagResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes specified tags from a resource.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, UntagResourceCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, UntagResourceCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new UntagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UntagResourceCommandInput} for command's `input` shape.
        * @see {@link UntagResourceCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class UntagResourceCommand extends $Command<UntagResourceCommandInput, UntagResourceCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: UntagResourceCommandInput;
            constructor(input: UntagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UntagResourceCommandInput, UntagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/UploadLayerPartCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRPUBLICClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient";
    import { UploadLayerPartRequest, UploadLayerPartResponse } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0";
    export interface UploadLayerPartCommandInput extends UploadLayerPartRequest {
    }
    export interface UploadLayerPartCommandOutput extends UploadLayerPartResponse, __MetadataBearer {
    }
    /**
        * <p>Uploads an image layer part to Amazon ECR.</p>
        *          <p>When an image is pushed, each new image layer is uploaded in parts. The maximum size of
        *          each image layer part can be 20971520 bytes (or about 20MB). The UploadLayerPart API is
        *          called once per each new image layer part.</p>
        *          <note>
        *             <p>This operation is used by the Amazon ECR proxy and is not generally used by customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
        *          </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRPUBLICClient, UploadLayerPartCommand } from "@aws-sdk/client-ecr-public"; // ES Modules import
        * // const { ECRPUBLICClient, UploadLayerPartCommand } = require("@aws-sdk/client-ecr-public"); // CommonJS import
        * const client = new ECRPUBLICClient(config);
        * const command = new UploadLayerPartCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UploadLayerPartCommandInput} for command's `input` shape.
        * @see {@link UploadLayerPartCommandOutput} for command's `response` shape.
        * @see {@link ECRPUBLICClientResolvedConfig | config} for ECRPUBLICClient's `config` shape.
        *
        */
    export class UploadLayerPartCommand extends $Command<UploadLayerPartCommandInput, UploadLayerPartCommandOutput, ECRPUBLICClientResolvedConfig> {
            readonly input: UploadLayerPartCommandInput;
            constructor(input: UploadLayerPartCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRPUBLICClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UploadLayerPartCommandInput, UploadLayerPartCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/ECRPUBLICClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { BatchCheckLayerAvailabilityCommandInput, BatchCheckLayerAvailabilityCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/BatchCheckLayerAvailabilityCommand";
    import { BatchDeleteImageCommandInput, BatchDeleteImageCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/BatchDeleteImageCommand";
    import { CompleteLayerUploadCommandInput, CompleteLayerUploadCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/CompleteLayerUploadCommand";
    import { CreateRepositoryCommandInput, CreateRepositoryCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/CreateRepositoryCommand";
    import { DeleteRepositoryCommandInput, DeleteRepositoryCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/DeleteRepositoryCommand";
    import { DeleteRepositoryPolicyCommandInput, DeleteRepositoryPolicyCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/DeleteRepositoryPolicyCommand";
    import { DescribeImagesCommandInput, DescribeImagesCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/DescribeImagesCommand";
    import { DescribeImageTagsCommandInput, DescribeImageTagsCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/DescribeImageTagsCommand";
    import { DescribeRegistriesCommandInput, DescribeRegistriesCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/DescribeRegistriesCommand";
    import { DescribeRepositoriesCommandInput, DescribeRepositoriesCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/DescribeRepositoriesCommand";
    import { GetAuthorizationTokenCommandInput, GetAuthorizationTokenCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/GetAuthorizationTokenCommand";
    import { GetRegistryCatalogDataCommandInput, GetRegistryCatalogDataCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/GetRegistryCatalogDataCommand";
    import { GetRepositoryCatalogDataCommandInput, GetRepositoryCatalogDataCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/GetRepositoryCatalogDataCommand";
    import { GetRepositoryPolicyCommandInput, GetRepositoryPolicyCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/GetRepositoryPolicyCommand";
    import { InitiateLayerUploadCommandInput, InitiateLayerUploadCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/InitiateLayerUploadCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/ListTagsForResourceCommand";
    import { PutImageCommandInput, PutImageCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/PutImageCommand";
    import { PutRegistryCatalogDataCommandInput, PutRegistryCatalogDataCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/PutRegistryCatalogDataCommand";
    import { PutRepositoryCatalogDataCommandInput, PutRepositoryCatalogDataCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/PutRepositoryCatalogDataCommand";
    import { SetRepositoryPolicyCommandInput, SetRepositoryPolicyCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/SetRepositoryPolicyCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/UntagResourceCommand";
    import { UploadLayerPartCommandInput, UploadLayerPartCommandOutput } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/commands/UploadLayerPartCommand";
    export type ServiceInputTypes = BatchCheckLayerAvailabilityCommandInput | BatchDeleteImageCommandInput | CompleteLayerUploadCommandInput | CreateRepositoryCommandInput | DeleteRepositoryCommandInput | DeleteRepositoryPolicyCommandInput | DescribeImageTagsCommandInput | DescribeImagesCommandInput | DescribeRegistriesCommandInput | DescribeRepositoriesCommandInput | GetAuthorizationTokenCommandInput | GetRegistryCatalogDataCommandInput | GetRepositoryCatalogDataCommandInput | GetRepositoryPolicyCommandInput | InitiateLayerUploadCommandInput | ListTagsForResourceCommandInput | PutImageCommandInput | PutRegistryCatalogDataCommandInput | PutRepositoryCatalogDataCommandInput | SetRepositoryPolicyCommandInput | TagResourceCommandInput | UntagResourceCommandInput | UploadLayerPartCommandInput;
    export type ServiceOutputTypes = BatchCheckLayerAvailabilityCommandOutput | BatchDeleteImageCommandOutput | CompleteLayerUploadCommandOutput | CreateRepositoryCommandOutput | DeleteRepositoryCommandOutput | DeleteRepositoryPolicyCommandOutput | DescribeImageTagsCommandOutput | DescribeImagesCommandOutput | DescribeRegistriesCommandOutput | DescribeRepositoriesCommandOutput | GetAuthorizationTokenCommandOutput | GetRegistryCatalogDataCommandOutput | GetRepositoryCatalogDataCommandOutput | GetRepositoryPolicyCommandOutput | InitiateLayerUploadCommandOutput | ListTagsForResourceCommandOutput | PutImageCommandOutput | PutRegistryCatalogDataCommandOutput | PutRepositoryCatalogDataCommandOutput | SetRepositoryPolicyCommandOutput | TagResourceCommandOutput | UntagResourceCommandOutput | UploadLayerPartCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type ECRPUBLICClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of ECRPUBLICClient class constructor that set the region, credentials and other options.
        */
    export interface ECRPUBLICClientConfig extends ECRPUBLICClientConfigType {
    }
    type ECRPUBLICClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of ECRPUBLICClient class. This is resolved and normalized from the {@link ECRPUBLICClientConfig | constructor configuration interface}.
        */
    export interface ECRPUBLICClientResolvedConfig extends ECRPUBLICClientResolvedConfigType {
    }
    /**
        * <fullname>Amazon Elastic Container Registry Public</fullname>
        *          <p>Amazon Elastic Container Registry (Amazon ECR) is a managed container image registry service. Amazon ECR provides both
        *          public and private registries to host your container images. You can use the familiar
        *          Docker CLI, or their preferred client, to push, pull, and manage images. Amazon ECR provides a
        *          secure, scalable, and reliable registry for your Docker or Open Container Initiative (OCI)
        *          images. Amazon ECR supports public repositories with this API. For information about the Amazon ECR
        *          API for private repositories, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/APIReference/Welcome.html">Amazon Elastic Container Registry API Reference</a>.</p>
        */
    export class ECRPUBLICClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, ECRPUBLICClientResolvedConfig> {
            /**
                * The resolved configuration of ECRPUBLICClient class. This is resolved and normalized from the {@link ECRPUBLICClientConfig | constructor configuration interface}.
                */
            readonly config: ECRPUBLICClientResolvedConfig;
            constructor(configuration: ECRPUBLICClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { ECRPUBLICServiceException as __BaseException } from "@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/ECRPUBLICServiceException";
    /**
        * <p>An authorization token data object that corresponds to a public registry.</p>
        */
    export interface AuthorizationData {
            /**
                * <p>A base64-encoded string that contains authorization data for a public Amazon ECR registry.
                *          When the string is decoded, it is presented in the format <code>user:password</code> for
                *          public registry authentication using <code>docker login</code>.</p>
                */
            authorizationToken?: string;
            /**
                * <p>The Unix time in seconds and milliseconds when the authorization token expires.
                *          Authorization tokens are valid for 12 hours.</p>
                */
            expiresAt?: Date;
    }
    export namespace AuthorizationData {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AuthorizationData) => any;
    }
    export interface BatchCheckLayerAvailabilityRequest {
            /**
                * <p>The AWS account ID associated with the public registry that contains the image layers to
                *          check. If you do not specify a registry, the default public registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository that is associated with the image layers to check.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>The digests of the image layers to check.</p>
                */
            layerDigests: string[] | undefined;
    }
    export namespace BatchCheckLayerAvailabilityRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchCheckLayerAvailabilityRequest) => any;
    }
    export enum LayerFailureCode {
            InvalidLayerDigest = "InvalidLayerDigest",
            MissingLayerDigest = "MissingLayerDigest"
    }
    /**
        * <p>An object representing an Amazon ECR image layer failure.</p>
        */
    export interface LayerFailure {
            /**
                * <p>The layer digest associated with the failure.</p>
                */
            layerDigest?: string;
            /**
                * <p>The failure code associated with the failure.</p>
                */
            failureCode?: LayerFailureCode | string;
            /**
                * <p>The reason for the failure.</p>
                */
            failureReason?: string;
    }
    export namespace LayerFailure {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LayerFailure) => any;
    }
    export enum LayerAvailability {
            AVAILABLE = "AVAILABLE",
            UNAVAILABLE = "UNAVAILABLE"
    }
    /**
        * <p>An object representing an Amazon ECR image layer.</p>
        */
    export interface Layer {
            /**
                * <p>The <code>sha256</code> digest of the image layer.</p>
                */
            layerDigest?: string;
            /**
                * <p>The availability status of the image layer.</p>
                */
            layerAvailability?: LayerAvailability | string;
            /**
                * <p>The size, in bytes, of the image layer.</p>
                */
            layerSize?: number;
            /**
                * <p>The media type of the layer, such as
                *             <code>application/vnd.docker.image.rootfs.diff.tar.gzip</code> or
                *             <code>application/vnd.oci.image.layer.v1.tar+gzip</code>.</p>
                */
            mediaType?: string;
    }
    export namespace Layer {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Layer) => any;
    }
    export interface BatchCheckLayerAvailabilityResponse {
            /**
                * <p>A list of image layer objects corresponding to the image layer references in the
                *          request.</p>
                */
            layers?: Layer[];
            /**
                * <p>Any failures associated with the call.</p>
                */
            failures?: LayerFailure[];
    }
    export namespace BatchCheckLayerAvailabilityResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchCheckLayerAvailabilityResponse) => any;
    }
    /**
        * <p>The specified parameter is invalid. Review the available parameters for the API
        *          request.</p>
        */
    export class InvalidParameterException extends __BaseException {
            readonly name: "InvalidParameterException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidParameterException, __BaseException>);
    }
    /**
        * <p>The registry does not exist.</p>
        */
    export class RegistryNotFoundException extends __BaseException {
            readonly name: "RegistryNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<RegistryNotFoundException, __BaseException>);
    }
    /**
        * <p>The specified repository could not be found. Check the spelling of the specified
        *          repository and ensure that you are performing operations on the correct registry.</p>
        */
    export class RepositoryNotFoundException extends __BaseException {
            readonly name: "RepositoryNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<RepositoryNotFoundException, __BaseException>);
    }
    /**
        * <p>These errors are usually caused by a server-side issue.</p>
        */
    export class ServerException extends __BaseException {
            readonly name: "ServerException";
            readonly $fault: "server";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ServerException, __BaseException>);
    }
    /**
        * <p>An object with identifying information for an Amazon ECR image.</p>
        */
    export interface ImageIdentifier {
            /**
                * <p>The <code>sha256</code> digest of the image manifest.</p>
                */
            imageDigest?: string;
            /**
                * <p>The tag used for the image.</p>
                */
            imageTag?: string;
    }
    export namespace ImageIdentifier {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImageIdentifier) => any;
    }
    export interface BatchDeleteImageRequest {
            /**
                * <p>The AWS account ID associated with the registry that contains the image to delete.
                *          If you do not specify a registry, the default public registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The repository in a public registry that contains the image to delete.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>A list of image ID references that correspond to images to delete. The format of the
                *             <code>imageIds</code> reference is <code>imageTag=tag</code> or
                *             <code>imageDigest=digest</code>.</p>
                */
            imageIds: ImageIdentifier[] | undefined;
    }
    export namespace BatchDeleteImageRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchDeleteImageRequest) => any;
    }
    export enum ImageFailureCode {
            ImageNotFound = "ImageNotFound",
            ImageReferencedByManifestList = "ImageReferencedByManifestList",
            ImageTagDoesNotMatchDigest = "ImageTagDoesNotMatchDigest",
            InvalidImageDigest = "InvalidImageDigest",
            InvalidImageTag = "InvalidImageTag",
            KmsError = "KmsError",
            MissingDigestAndTag = "MissingDigestAndTag"
    }
    /**
        * <p>An object representing an Amazon ECR image failure.</p>
        */
    export interface ImageFailure {
            /**
                * <p>The image ID associated with the failure.</p>
                */
            imageId?: ImageIdentifier;
            /**
                * <p>The code associated with the failure.</p>
                */
            failureCode?: ImageFailureCode | string;
            /**
                * <p>The reason for the failure.</p>
                */
            failureReason?: string;
    }
    export namespace ImageFailure {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImageFailure) => any;
    }
    export interface BatchDeleteImageResponse {
            /**
                * <p>The image IDs of the deleted images.</p>
                */
            imageIds?: ImageIdentifier[];
            /**
                * <p>Any failures associated with the call.</p>
                */
            failures?: ImageFailure[];
    }
    export namespace BatchDeleteImageResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchDeleteImageResponse) => any;
    }
    export interface CompleteLayerUploadRequest {
            /**
                * <p>The AWS account ID associated with the registry to which to upload layers.
                *          If you do not specify a registry, the default public registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository in a public registry to associate with the image
                *          layer.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>The upload ID from a previous <a>InitiateLayerUpload</a> operation to
                *          associate with the image layer.</p>
                */
            uploadId: string | undefined;
            /**
                * <p>The <code>sha256</code> digest of the image layer.</p>
                */
            layerDigests: string[] | undefined;
    }
    export namespace CompleteLayerUploadRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CompleteLayerUploadRequest) => any;
    }
    export interface CompleteLayerUploadResponse {
            /**
                * <p>The public registry ID associated with the request.</p>
                */
            registryId?: string;
            /**
                * <p>The repository name associated with the request.</p>
                */
            repositoryName?: string;
            /**
                * <p>The upload ID associated with the layer.</p>
                */
            uploadId?: string;
            /**
                * <p>The <code>sha256</code> digest of the image layer.</p>
                */
            layerDigest?: string;
    }
    export namespace CompleteLayerUploadResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CompleteLayerUploadResponse) => any;
    }
    /**
        * <p>The specified layer upload does not contain any layer parts.</p>
        */
    export class EmptyUploadException extends __BaseException {
            readonly name: "EmptyUploadException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<EmptyUploadException, __BaseException>);
    }
    /**
        * <p>The layer digest calculation performed by Amazon ECR upon receipt of the image layer does not
        *          match the digest specified.</p>
        */
    export class InvalidLayerException extends __BaseException {
            readonly name: "InvalidLayerException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidLayerException, __BaseException>);
    }
    /**
        * <p>The image layer already exists in the associated repository.</p>
        */
    export class LayerAlreadyExistsException extends __BaseException {
            readonly name: "LayerAlreadyExistsException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<LayerAlreadyExistsException, __BaseException>);
    }
    /**
        * <p>Layer parts must be at least 5 MiB in size.</p>
        */
    export class LayerPartTooSmallException extends __BaseException {
            readonly name: "LayerPartTooSmallException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<LayerPartTooSmallException, __BaseException>);
    }
    /**
        * <p>The action is not supported in this Region.</p>
        */
    export class UnsupportedCommandException extends __BaseException {
            readonly name: "UnsupportedCommandException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UnsupportedCommandException, __BaseException>);
    }
    /**
        * <p>The upload could not be found, or the specified upload ID is not valid for this
        *          repository.</p>
        */
    export class UploadNotFoundException extends __BaseException {
            readonly name: "UploadNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UploadNotFoundException, __BaseException>);
    }
    /**
        * <p>An object containing the catalog data for a repository. This data is publicly visible in
        *          the Amazon ECR Public Gallery.</p>
        */
    export interface RepositoryCatalogDataInput {
            /**
                * <p>A short description of the contents of the repository. This text appears in both the
                *          image details and also when searching for repositories on the Amazon ECR Public Gallery.</p>
                */
            description?: string;
            /**
                * <p>The system architecture that the images in the repository are compatible with. On the
                *          Amazon ECR Public Gallery, the following supported architectures will appear as badges on the
                *          repository and are used as search filters.</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>Linux</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>Windows</code>
                *                </p>
                *             </li>
                *          </ul>
                *          <note>
                *             <p>If an unsupported tag is added to your repository catalog data, it will be associated
                *             with the repository and can be retrieved using the API but will not be discoverable in
                *             the Amazon ECR Public Gallery.</p>
                *          </note>
                */
            architectures?: string[];
            /**
                * <p>The operating systems that the images in the repository are compatible with. On the
                *          Amazon ECR Public Gallery, the following supported operating systems will appear as badges on
                *          the repository and are used as search filters.</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>ARM</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>ARM 64</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>x86</code>
                *                </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>x86-64</code>
                *                </p>
                *             </li>
                *          </ul>
                *          <note>
                *             <p>If an unsupported tag is added to your repository catalog data, it will be associated
                *             with the repository and can be retrieved using the API but will not be discoverable in
                *             the Amazon ECR Public Gallery.</p>
                *          </note>
                */
            operatingSystems?: string[];
            /**
                * <p>The base64-encoded repository logo payload.</p>
                *          <note>
                *             <p>The repository logo is only publicly visible in the Amazon ECR Public Gallery for verified
                *             accounts.</p>
                *          </note>
                */
            logoImageBlob?: Uint8Array;
            /**
                * <p>A detailed description of the contents of the repository. It is publicly visible in the
                *          Amazon ECR Public Gallery. The text must be in markdown format.</p>
                */
            aboutText?: string;
            /**
                * <p>Detailed information on how to use the contents of the repository. It is publicly
                *          visible in the Amazon ECR Public Gallery. The usage text provides context, support information,
                *          and additional usage details for users of the repository. The text must be in markdown
                *          format.</p>
                */
            usageText?: string;
    }
    export namespace RepositoryCatalogDataInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RepositoryCatalogDataInput) => any;
    }
    /**
        * <p>The metadata that you apply to a resource to help you categorize and organize them. Each
        *          tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.</p>
        */
    export interface Tag {
            /**
                * <p>One part of a key-value pair that make up a tag. A <code>key</code> is a general label
                *          that acts like a category for more specific tag values.</p>
                */
            Key?: string;
            /**
                * <p>The optional part of a key-value pair that make up a tag. A <code>value</code> acts as a
                *          descriptor within a tag category (key).</p>
                */
            Value?: string;
    }
    export namespace Tag {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Tag) => any;
    }
    export interface CreateRepositoryRequest {
            /**
                * <p>The name to use for the repository. This appears publicly in the Amazon ECR Public Gallery.
                *          The repository name may be specified on its own (such as <code>nginx-web-app</code>) or it
                *          can be prepended with a namespace to group the repository into a category (such as
                *             <code>project-a/nginx-web-app</code>).</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>The details about the repository that are publicly visible in the
                *          Amazon ECR Public Gallery.</p>
                */
            catalogData?: RepositoryCatalogDataInput;
            /**
                * <p>The metadata that you apply to the repository to help you categorize and organize them.
                *          Each tag consists of a key and an optional value, both of which you define.
                *          Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.</p>
                */
            tags?: Tag[];
    }
    export namespace CreateRepositoryRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateRepositoryRequest) => any;
    }
    /**
        * <p>The catalog data for a repository. This data is publicly visible in the
        *          Amazon ECR Public Gallery.</p>
        */
    export interface RepositoryCatalogData {
            /**
                * <p>The short description of the repository.</p>
                */
            description?: string;
            /**
                * <p>The architecture tags that are associated with the repository.</p>
                *          <note>
                *             <p>Only supported operating system tags appear publicly in the Amazon ECR Public Gallery. For
                *             more information, see <a>RepositoryCatalogDataInput</a>.</p>
                *          </note>
                */
            architectures?: string[];
            /**
                * <p>The operating system tags that are associated with the repository.</p>
                *          <note>
                *             <p>Only supported operating system tags appear publicly in the Amazon ECR Public Gallery. For
                *             more information, see <a>RepositoryCatalogDataInput</a>.</p>
                *          </note>
                */
            operatingSystems?: string[];
            /**
                * <p>The URL containing the logo associated with the repository.</p>
                */
            logoUrl?: string;
            /**
                * <p>The longform description of the contents of the repository. This text appears in the
                *          repository details on the Amazon ECR Public Gallery.</p>
                */
            aboutText?: string;
            /**
                * <p>The longform usage details of the contents of the repository. The usage text provides
                *          context for users of the repository.</p>
                */
            usageText?: string;
            /**
                * <p>Whether or not the repository is certified by AWS Marketplace.</p>
                */
            marketplaceCertified?: boolean;
    }
    export namespace RepositoryCatalogData {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RepositoryCatalogData) => any;
    }
    /**
        * <p>An object representing a repository.</p>
        */
    export interface Repository {
            /**
                * <p>The Amazon Resource Name (ARN) that identifies the repository. The ARN contains the <code>arn:aws:ecr</code> namespace, followed by the region of the repository, AWS account ID of the repository owner, repository namespace, and repository name. For example, <code>arn:aws:ecr:region:012345678910:repository/test</code>.</p>
                */
            repositoryArn?: string;
            /**
                * <p>The AWS account ID associated with the public registry that contains the
                *          repository.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository.</p>
                */
            repositoryName?: string;
            /**
                * <p>The URI for the repository. You can use this URI for container image <code>push</code>
                *          and <code>pull</code> operations.</p>
                */
            repositoryUri?: string;
            /**
                * <p>The date and time, in JavaScript date format, when the repository was created.</p>
                */
            createdAt?: Date;
    }
    export namespace Repository {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Repository) => any;
    }
    export interface CreateRepositoryResponse {
            /**
                * <p>The repository that was created.</p>
                */
            repository?: Repository;
            /**
                * <p>The catalog data for a repository. This data is publicly visible in the
                *          Amazon ECR Public Gallery.</p>
                */
            catalogData?: RepositoryCatalogData;
    }
    export namespace CreateRepositoryResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateRepositoryResponse) => any;
    }
    /**
        * <p>An invalid parameter has been specified. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.</p>
        */
    export class InvalidTagParameterException extends __BaseException {
            readonly name: "InvalidTagParameterException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidTagParameterException, __BaseException>);
    }
    /**
        * <p>The operation did not succeed because it would have exceeded a service limit for your
        *          account. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/service-quotas.html">Amazon ECR Service Quotas</a> in the
        *          Amazon Elastic Container Registry User Guide.</p>
        */
    export class LimitExceededException extends __BaseException {
            readonly name: "LimitExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<LimitExceededException, __BaseException>);
    }
    /**
        * <p>The specified repository already exists in the specified registry.</p>
        */
    export class RepositoryAlreadyExistsException extends __BaseException {
            readonly name: "RepositoryAlreadyExistsException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<RepositoryAlreadyExistsException, __BaseException>);
    }
    /**
        * <p>The list of tags on the repository is over the limit. The maximum number of tags that
        *          can be applied to a repository is 50.</p>
        */
    export class TooManyTagsException extends __BaseException {
            readonly name: "TooManyTagsException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyTagsException, __BaseException>);
    }
    export interface DeleteRepositoryRequest {
            /**
                * <p>The AWS account ID associated with the public registry that contains the repository to
                *          delete. If you do not specify a registry, the default public registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository to delete.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p> If a repository contains images, forces the deletion.</p>
                */
            force?: boolean;
    }
    export namespace DeleteRepositoryRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteRepositoryRequest) => any;
    }
    export interface DeleteRepositoryResponse {
            /**
                * <p>The repository that was deleted.</p>
                */
            repository?: Repository;
    }
    export namespace DeleteRepositoryResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteRepositoryResponse) => any;
    }
    /**
        * <p>The specified repository contains images. To delete a repository that contains images,
        *          you must force the deletion with the <code>force</code> parameter.</p>
        */
    export class RepositoryNotEmptyException extends __BaseException {
            readonly name: "RepositoryNotEmptyException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<RepositoryNotEmptyException, __BaseException>);
    }
    export interface DeleteRepositoryPolicyRequest {
            /**
                * <p>The AWS account ID associated with the public registry that contains the repository
                *          policy to delete. If you do not specify a registry, the default public registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository that is associated with the repository policy to
                *          delete.</p>
                */
            repositoryName: string | undefined;
    }
    export namespace DeleteRepositoryPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteRepositoryPolicyRequest) => any;
    }
    export interface DeleteRepositoryPolicyResponse {
            /**
                * <p>The registry ID associated with the request.</p>
                */
            registryId?: string;
            /**
                * <p>The repository name associated with the request.</p>
                */
            repositoryName?: string;
            /**
                * <p>The JSON repository policy that was deleted from the repository.</p>
                */
            policyText?: string;
    }
    export namespace DeleteRepositoryPolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteRepositoryPolicyResponse) => any;
    }
    /**
        * <p>The specified repository and registry combination does not have an associated repository
        *          policy.</p>
        */
    export class RepositoryPolicyNotFoundException extends __BaseException {
            readonly name: "RepositoryPolicyNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<RepositoryPolicyNotFoundException, __BaseException>);
    }
    export interface DescribeImagesRequest {
            /**
                * <p>The AWS account ID associated with the public registry that contains the repository in
                *          which to describe images. If you do not specify a registry, the default public registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The repository that contains the images to describe.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>The list of image IDs for the requested repository.</p>
                */
            imageIds?: ImageIdentifier[];
            /**
                * <p>The <code>nextToken</code> value returned from a previous paginated
                *             <code>DescribeImages</code> request where <code>maxResults</code> was used and the
                *          results exceeded the value of that parameter. Pagination continues from the end of the
                *          previous results that returned the <code>nextToken</code> value. This value is
                *             <code>null</code> when there are no more results to return. This option cannot be used
                *          when you specify images with <code>imageIds</code>.</p>
                */
            nextToken?: string;
            /**
                * <p>The maximum number of repository results returned by <code>DescribeImages</code> in
                *          paginated output. When this parameter is used, <code>DescribeImages</code> only returns
                *             <code>maxResults</code> results in a single page along with a <code>nextToken</code>
                *          response element. The remaining results of the initial request can be seen by sending
                *          another <code>DescribeImages</code> request with the returned <code>nextToken</code> value.
                *          This value can be between 1 and 1000. If this parameter is not
                *          used, then <code>DescribeImages</code> returns up to 100 results and a
                *             <code>nextToken</code> value, if applicable. This option cannot be used when you specify
                *          images with <code>imageIds</code>.</p>
                */
            maxResults?: number;
    }
    export namespace DescribeImagesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeImagesRequest) => any;
    }
    /**
        * <p>An object that describes an image returned by a <a>DescribeImages</a>
        *          operation.</p>
        */
    export interface ImageDetail {
            /**
                * <p>The AWS account ID associated with the public registry to which this image
                *          belongs.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository to which this image belongs.</p>
                */
            repositoryName?: string;
            /**
                * <p>The <code>sha256</code> digest of the image manifest.</p>
                */
            imageDigest?: string;
            /**
                * <p>The list of tags associated with this image.</p>
                */
            imageTags?: string[];
            /**
                * <p>The size, in bytes, of the image in the repository.</p>
                *          <p>If the image is a manifest list, this will be the max size of all manifests in the
                *          list.</p>
                *          <note>
                *             <p>Beginning with Docker version 1.9, the Docker client compresses image layers before
                *             pushing them to a V2 Docker registry. The output of the <code>docker images</code>
                *             command shows the uncompressed image size, so it may return a larger image size than the
                *             image sizes returned by <a>DescribeImages</a>.</p>
                *          </note>
                */
            imageSizeInBytes?: number;
            /**
                * <p>The date and time, expressed in standard JavaScript date format, at which the current
                *          image was pushed to the repository. </p>
                */
            imagePushedAt?: Date;
            /**
                * <p>The media type of the image manifest.</p>
                */
            imageManifestMediaType?: string;
            /**
                * <p>The artifact media type of the image.</p>
                */
            artifactMediaType?: string;
    }
    export namespace ImageDetail {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImageDetail) => any;
    }
    export interface DescribeImagesResponse {
            /**
                * <p>A list of <a>ImageDetail</a> objects that contain data about the
                *          image.</p>
                */
            imageDetails?: ImageDetail[];
            /**
                * <p>The <code>nextToken</code> value to include in a future <code>DescribeImages</code>
                *          request. When the results of a <code>DescribeImages</code> request exceed
                *             <code>maxResults</code>, this value can be used to retrieve the next page of results.
                *          This value is <code>null</code> when there are no more results to return.</p>
                */
            nextToken?: string;
    }
    export namespace DescribeImagesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeImagesResponse) => any;
    }
    /**
        * <p>The image requested does not exist in the specified repository.</p>
        */
    export class ImageNotFoundException extends __BaseException {
            readonly name: "ImageNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ImageNotFoundException, __BaseException>);
    }
    export interface DescribeImageTagsRequest {
            /**
                * <p>The AWS account ID associated with the public registry that contains the repository in
                *          which to describe images. If you do not specify a registry, the default public registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository that contains the image tag details to describe.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>The <code>nextToken</code> value returned from a previous paginated
                *             <code>DescribeImageTags</code> request where <code>maxResults</code> was used and the
                *          results exceeded the value of that parameter. Pagination continues from the end of the
                *          previous results that returned the <code>nextToken</code> value. This value is
                *             <code>null</code> when there are no more results to return. This option cannot be used
                *          when you specify images with <code>imageIds</code>.</p>
                */
            nextToken?: string;
            /**
                * <p>The maximum number of repository results returned by <code>DescribeImageTags</code> in
                *          paginated output. When this parameter is used, <code>DescribeImageTags</code> only returns
                *             <code>maxResults</code> results in a single page along with a <code>nextToken</code>
                *          response element. The remaining results of the initial request can be seen by sending
                *          another <code>DescribeImageTags</code> request with the returned <code>nextToken</code>
                *          value. This value can be between 1 and 1000. If this parameter
                *          is not used, then <code>DescribeImageTags</code> returns up to 100
                *          results and a <code>nextToken</code> value, if applicable. This option cannot be used when
                *          you specify images with <code>imageIds</code>.</p>
                */
            maxResults?: number;
    }
    export namespace DescribeImageTagsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeImageTagsRequest) => any;
    }
    /**
        * <p>An object that describes the image tag details returned by a <a>DescribeImageTags</a> action.</p>
        */
    export interface ReferencedImageDetail {
            /**
                * <p>The <code>sha256</code> digest of the image manifest.</p>
                */
            imageDigest?: string;
            /**
                * <p>The size, in bytes, of the image in the repository.</p>
                *          <p>If the image is a manifest list, this will be the max size of all manifests in the
                *          list.</p>
                *          <note>
                *             <p>Beginning with Docker version 1.9, the Docker client compresses image layers before
                *             pushing them to a V2 Docker registry. The output of the <code>docker images</code>
                *             command shows the uncompressed image size, so it may return a larger image size than the
                *             image sizes returned by <a>DescribeImages</a>.</p>
                *          </note>
                */
            imageSizeInBytes?: number;
            /**
                * <p>The date and time, expressed in standard JavaScript date format, at which the current
                *          image tag was pushed to the repository.</p>
                */
            imagePushedAt?: Date;
            /**
                * <p>The media type of the image manifest.</p>
                */
            imageManifestMediaType?: string;
            /**
                * <p>The artifact media type of the image.</p>
                */
            artifactMediaType?: string;
    }
    export namespace ReferencedImageDetail {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReferencedImageDetail) => any;
    }
    /**
        * <p>An object representing the image tag details for an image.</p>
        */
    export interface ImageTagDetail {
            /**
                * <p>The tag associated with the image.</p>
                */
            imageTag?: string;
            /**
                * <p>The time stamp indicating when the image tag was created.</p>
                */
            createdAt?: Date;
            /**
                * <p>An object that describes the details of an image.</p>
                */
            imageDetail?: ReferencedImageDetail;
    }
    export namespace ImageTagDetail {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImageTagDetail) => any;
    }
    export interface DescribeImageTagsResponse {
            /**
                * <p>The image tag details for the images in the requested repository.</p>
                */
            imageTagDetails?: ImageTagDetail[];
            /**
                * <p>The <code>nextToken</code> value to include in a future <code>DescribeImageTags</code>
                *          request. When the results of a <code>DescribeImageTags</code> request exceed
                *             <code>maxResults</code>, this value can be used to retrieve the next page of results.
                *          This value is <code>null</code> when there are no more results to return.</p>
                */
            nextToken?: string;
    }
    export namespace DescribeImageTagsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeImageTagsResponse) => any;
    }
    export interface DescribeRegistriesRequest {
            /**
                * <p>The <code>nextToken</code> value returned from a previous paginated
                *             <code>DescribeRegistries</code> request where <code>maxResults</code> was used and the
                *          results exceeded the value of that parameter. Pagination continues from the end of the
                *          previous results that returned the <code>nextToken</code> value. This value is
                *             <code>null</code> when there are no more results to return.</p>
                *          <note>
                *             <p>This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.</p>
                *          </note>
                */
            nextToken?: string;
            /**
                * <p>The maximum number of repository results returned by <code>DescribeRegistries</code> in
                *          paginated output. When this parameter is used, <code>DescribeRegistries</code> only returns
                *             <code>maxResults</code> results in a single page along with a <code>nextToken</code>
                *          response element. The remaining results of the initial request can be seen by sending
                *          another <code>DescribeRegistries</code> request with the returned <code>nextToken</code>
                *          value. This value can be between 1 and 1000. If this parameter
                *          is not used, then <code>DescribeRegistries</code> returns up to 100
                *          results and a <code>nextToken</code> value, if applicable.</p>
                */
            maxResults?: number;
    }
    export namespace DescribeRegistriesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeRegistriesRequest) => any;
    }
    export enum RegistryAliasStatus {
            ACTIVE = "ACTIVE",
            PENDING = "PENDING",
            REJECTED = "REJECTED"
    }
    /**
        * <p>An object representing the aliases for a public registry. A public registry is given an
        *          alias upon creation but a custom alias can be set using the Amazon ECR console. For more
        *          information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html">Registries</a> in the
        *             <i>Amazon Elastic Container Registry User Guide</i>.</p>
        */
    export interface RegistryAlias {
            /**
                * <p>The name of the registry alias.</p>
                */
            name: string | undefined;
            /**
                * <p>The status of the registry alias.</p>
                */
            status: RegistryAliasStatus | string | undefined;
            /**
                * <p>Whether or not the registry alias is the primary alias for the registry. If true, the
                *          alias is the primary registry alias and is displayed in both the repository URL and the
                *          image URI used in the <code>docker pull</code> commands on the Amazon ECR Public Gallery.</p>
                *          <note>
                *             <p>A registry alias that is not the primary registry alias can be used in the repository
                *             URI in a <code>docker pull</code> command.</p>
                *          </note>
                */
            primaryRegistryAlias: boolean | undefined;
            /**
                * <p>Whether or not the registry alias is the default alias for the registry. When the first
                *          public repository is created, your public registry is assigned a default registry
                *          alias.</p>
                */
            defaultRegistryAlias: boolean | undefined;
    }
    export namespace RegistryAlias {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RegistryAlias) => any;
    }
    /**
        * <p>The details of a public registry.</p>
        */
    export interface Registry {
            /**
                * <p>The AWS account ID associated with the registry. If you do not specify a registry, the default public registry is assumed.</p>
                */
            registryId: string | undefined;
            /**
                * <p>The Amazon Resource Name (ARN) of the public registry.</p>
                */
            registryArn: string | undefined;
            /**
                * <p>The URI of a public registry. The URI contains a universal prefix and the registry
                *          alias.</p>
                */
            registryUri: string | undefined;
            /**
                * <p>Whether the account is verified. This indicates whether the account is an AWS
                *          Marketplace vendor. If an account is verified, each public repository will received a
                *          verified account badge on the Amazon ECR Public Gallery.</p>
                */
            verified: boolean | undefined;
            /**
                * <p>An array of objects representing the aliases for a public registry.</p>
                */
            aliases: RegistryAlias[] | undefined;
    }
    export namespace Registry {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Registry) => any;
    }
    export interface DescribeRegistriesResponse {
            /**
                * <p>An object containing the details for a public registry.</p>
                */
            registries: Registry[] | undefined;
            /**
                * <p>The <code>nextToken</code> value to include in a future
                *             <code>DescribeRepositories</code> request. When the results of a
                *             <code>DescribeRepositories</code> request exceed <code>maxResults</code>, this value can
                *          be used to retrieve the next page of results. This value is <code>null</code> when there
                *          are no more results to return.</p>
                */
            nextToken?: string;
    }
    export namespace DescribeRegistriesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeRegistriesResponse) => any;
    }
    export interface DescribeRepositoriesRequest {
            /**
                * <p>The AWS account ID associated with the registry that contains the repositories to be
                *          described. If you do not specify a registry, the default public registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>A list of repositories to describe. If this parameter is omitted, then all repositories
                *          in a registry are described.</p>
                */
            repositoryNames?: string[];
            /**
                * <p>The <code>nextToken</code> value returned from a previous paginated
                *             <code>DescribeRepositories</code> request where <code>maxResults</code> was used and the
                *          results exceeded the value of that parameter. Pagination continues from the end of the
                *          previous results that returned the <code>nextToken</code> value. This value is
                *             <code>null</code> when there are no more results to return. This option cannot be used
                *          when you specify repositories with <code>repositoryNames</code>.</p>
                *          <note>
                *             <p>This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.</p>
                *          </note>
                */
            nextToken?: string;
            /**
                * <p>The maximum number of repository results returned by <code>DescribeRepositories</code>
                *          in paginated output. When this parameter is used, <code>DescribeRepositories</code> only
                *          returns <code>maxResults</code> results in a single page along with a
                *             <code>nextToken</code> response element. The remaining results of the initial request
                *          can be seen by sending another <code>DescribeRepositories</code> request with the returned
                *             <code>nextToken</code> value. This value can be between 1 and
                *          1000. If this parameter is not used, then <code>DescribeRepositories</code>
                *          returns up to 100 results and a <code>nextToken</code> value, if
                *          applicable. This option cannot be used when you specify repositories with
                *             <code>repositoryNames</code>.</p>
                */
            maxResults?: number;
    }
    export namespace DescribeRepositoriesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeRepositoriesRequest) => any;
    }
    export interface DescribeRepositoriesResponse {
            /**
                * <p>A list of repository objects corresponding to valid repositories.</p>
                */
            repositories?: Repository[];
            /**
                * <p>The <code>nextToken</code> value to include in a future
                *             <code>DescribeRepositories</code> request. When the results of a
                *             <code>DescribeRepositories</code> request exceed <code>maxResults</code>, this value can
                *          be used to retrieve the next page of results. This value is <code>null</code> when there
                *          are no more results to return.</p>
                */
            nextToken?: string;
    }
    export namespace DescribeRepositoriesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeRepositoriesResponse) => any;
    }
    export interface GetAuthorizationTokenRequest {
    }
    export namespace GetAuthorizationTokenRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetAuthorizationTokenRequest) => any;
    }
    export interface GetAuthorizationTokenResponse {
            /**
                * <p>An authorization token data object that corresponds to a public registry.</p>
                */
            authorizationData?: AuthorizationData;
    }
    export namespace GetAuthorizationTokenResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetAuthorizationTokenResponse) => any;
    }
    export interface GetRegistryCatalogDataRequest {
    }
    export namespace GetRegistryCatalogDataRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetRegistryCatalogDataRequest) => any;
    }
    /**
        * <p>The metadata for a public registry.</p>
        */
    export interface RegistryCatalogData {
            /**
                * <p>The display name for a public registry. This appears on the Amazon ECR Public Gallery.</p>
                *          <important>
                *             <p>Only accounts that have the verified account badge can have a registry display
                *             name.</p>
                *          </important>
                */
            displayName?: string;
    }
    export namespace RegistryCatalogData {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RegistryCatalogData) => any;
    }
    export interface GetRegistryCatalogDataResponse {
            /**
                * <p>The catalog metadata for the public registry.</p>
                */
            registryCatalogData: RegistryCatalogData | undefined;
    }
    export namespace GetRegistryCatalogDataResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetRegistryCatalogDataResponse) => any;
    }
    export interface GetRepositoryCatalogDataRequest {
            /**
                * <p>The AWS account ID associated with the registry that contains the repositories to be
                *          described. If you do not specify a registry, the default public registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository to retrieve the catalog metadata for.</p>
                */
            repositoryName: string | undefined;
    }
    export namespace GetRepositoryCatalogDataRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetRepositoryCatalogDataRequest) => any;
    }
    export interface GetRepositoryCatalogDataResponse {
            /**
                * <p>The catalog metadata for the repository.</p>
                */
            catalogData?: RepositoryCatalogData;
    }
    export namespace GetRepositoryCatalogDataResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetRepositoryCatalogDataResponse) => any;
    }
    export interface GetRepositoryPolicyRequest {
            /**
                * <p>The AWS account ID associated with the public registry that contains the repository.
                *          If you do not specify a registry, the default public registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository with the policy to retrieve.</p>
                */
            repositoryName: string | undefined;
    }
    export namespace GetRepositoryPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetRepositoryPolicyRequest) => any;
    }
    export interface GetRepositoryPolicyResponse {
            /**
                * <p>The registry ID associated with the request.</p>
                */
            registryId?: string;
            /**
                * <p>The repository name associated with the request.</p>
                */
            repositoryName?: string;
            /**
                * <p>The repository policy text associated with the repository. The policy text will be in
                *          JSON format.</p>
                */
            policyText?: string;
    }
    export namespace GetRepositoryPolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetRepositoryPolicyResponse) => any;
    }
    /**
        * <p>An object representing an Amazon ECR image.</p>
        */
    export interface Image {
            /**
                * <p>The AWS account ID associated with the registry containing the image.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository associated with the image.</p>
                */
            repositoryName?: string;
            /**
                * <p>An object containing the image tag and image digest associated with an image.</p>
                */
            imageId?: ImageIdentifier;
            /**
                * <p>The image manifest associated with the image.</p>
                */
            imageManifest?: string;
            /**
                * <p>The manifest media type of the image.</p>
                */
            imageManifestMediaType?: string;
    }
    export namespace Image {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Image) => any;
    }
    /**
        * <p>The specified image has already been pushed, and there were no changes to the manifest
        *          or image tag after the last push.</p>
        */
    export class ImageAlreadyExistsException extends __BaseException {
            readonly name: "ImageAlreadyExistsException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ImageAlreadyExistsException, __BaseException>);
    }
    /**
        * <p>The specified image digest does not match the digest that Amazon ECR calculated for the
        *          image.</p>
        */
    export class ImageDigestDoesNotMatchException extends __BaseException {
            readonly name: "ImageDigestDoesNotMatchException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ImageDigestDoesNotMatchException, __BaseException>);
    }
    /**
        * <p>The specified image is tagged with a tag that already exists. The repository is
        *          configured for tag immutability.</p>
        */
    export class ImageTagAlreadyExistsException extends __BaseException {
            readonly name: "ImageTagAlreadyExistsException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ImageTagAlreadyExistsException, __BaseException>);
    }
    export interface InitiateLayerUploadRequest {
            /**
                * <p>The AWS account ID associated with the registry to which you intend to upload layers.
                *          If you do not specify a registry, the default public registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository to which you intend to upload layers.</p>
                */
            repositoryName: string | undefined;
    }
    export namespace InitiateLayerUploadRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InitiateLayerUploadRequest) => any;
    }
    export interface InitiateLayerUploadResponse {
            /**
                * <p>The upload ID for the layer upload. This parameter is passed to further <a>UploadLayerPart</a> and <a>CompleteLayerUpload</a> operations.</p>
                */
            uploadId?: string;
            /**
                * <p>The size, in bytes, that Amazon ECR expects future layer part uploads to be.</p>
                */
            partSize?: number;
    }
    export namespace InitiateLayerUploadResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InitiateLayerUploadResponse) => any;
    }
    /**
        * <p>The layer part size is not valid, or the first byte specified is not consecutive to the
        *          last byte of a previous layer part upload.</p>
        */
    export class InvalidLayerPartException extends __BaseException {
            readonly name: "InvalidLayerPartException";
            readonly $fault: "client";
            /**
                * <p>The AWS account ID associated with the layer part.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository.</p>
                */
            repositoryName?: string;
            /**
                * <p>The upload ID associated with the layer part.</p>
                */
            uploadId?: string;
            /**
                * <p>The position of the last byte of the layer part.</p>
                */
            lastValidByteReceived?: number;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidLayerPartException, __BaseException>);
    }
    /**
        * <p>The specified layers could not be found, or the specified layer is not valid for this
        *          repository.</p>
        */
    export class LayersNotFoundException extends __BaseException {
            readonly name: "LayersNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<LayersNotFoundException, __BaseException>);
    }
    export interface ListTagsForResourceRequest {
            /**
                * <p>The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the
                *          supported resource is an Amazon ECR Public repository.</p>
                */
            resourceArn: string | undefined;
    }
    export namespace ListTagsForResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceRequest) => any;
    }
    export interface ListTagsForResourceResponse {
            /**
                * <p>The tags for the resource.</p>
                */
            tags?: Tag[];
    }
    export namespace ListTagsForResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceResponse) => any;
    }
    export interface PutImageRequest {
            /**
                * <p>The AWS account ID associated with the public registry that contains the repository in
                *          which to put the image. If you do not specify a registry, the default public registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository in which to put the image.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>The image manifest corresponding to the image to be uploaded.</p>
                */
            imageManifest: string | undefined;
            /**
                * <p>The media type of the image manifest. If you push an image manifest that does not
                *          contain the <code>mediaType</code> field, you must specify the
                *             <code>imageManifestMediaType</code> in the request.</p>
                */
            imageManifestMediaType?: string;
            /**
                * <p>The tag to associate with the image. This parameter is required for images that use the
                *          Docker Image Manifest V2 Schema 2 or Open Container Initiative (OCI) formats.</p>
                */
            imageTag?: string;
            /**
                * <p>The image digest of the image manifest corresponding to the image.</p>
                */
            imageDigest?: string;
    }
    export namespace PutImageRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutImageRequest) => any;
    }
    export interface PutImageResponse {
            /**
                * <p>Details of the image uploaded.</p>
                */
            image?: Image;
    }
    export namespace PutImageResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutImageResponse) => any;
    }
    /**
        * <p>The manifest list is referencing an image that does not exist.</p>
        */
    export class ReferencedImagesNotFoundException extends __BaseException {
            readonly name: "ReferencedImagesNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ReferencedImagesNotFoundException, __BaseException>);
    }
    export interface PutRegistryCatalogDataRequest {
            /**
                * <p>The display name for a public registry. The display name is shown as the repository
                *          author in the Amazon ECR Public Gallery.</p>
                *          <note>
                *             <p>The registry display name is only publicly visible in the Amazon ECR Public Gallery for
                *             verified accounts.</p>
                *          </note>
                */
            displayName?: string;
    }
    export namespace PutRegistryCatalogDataRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutRegistryCatalogDataRequest) => any;
    }
    export interface PutRegistryCatalogDataResponse {
            /**
                * <p>The catalog data for the public registry.</p>
                */
            registryCatalogData: RegistryCatalogData | undefined;
    }
    export namespace PutRegistryCatalogDataResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutRegistryCatalogDataResponse) => any;
    }
    export interface PutRepositoryCatalogDataRequest {
            /**
                * <p>The AWS account ID associated with the public registry the repository is in.
                *          If you do not specify a registry, the default public registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository to create or update the catalog data for.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>An object containing the catalog data for a repository. This data is publicly visible in
                *          the Amazon ECR Public Gallery.</p>
                */
            catalogData: RepositoryCatalogDataInput | undefined;
    }
    export namespace PutRepositoryCatalogDataRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutRepositoryCatalogDataRequest) => any;
    }
    export interface PutRepositoryCatalogDataResponse {
            /**
                * <p>The catalog data for the repository.</p>
                */
            catalogData?: RepositoryCatalogData;
    }
    export namespace PutRepositoryCatalogDataResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutRepositoryCatalogDataResponse) => any;
    }
    export interface SetRepositoryPolicyRequest {
            /**
                * <p>The AWS account ID associated with the registry that contains the repository.
                *          If you do not specify a registry, the default public registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository to receive the policy.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>The JSON repository policy text to apply to the repository. For more information, see
                *             <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-policy-examples.html">Amazon ECR Repository
                *             Policies</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
                */
            policyText: string | undefined;
            /**
                * <p>If the policy you are attempting to set on a repository policy would prevent you from
                *          setting another policy in the future, you must force the <a>SetRepositoryPolicy</a> operation. This is intended to prevent accidental
                *          repository lock outs.</p>
                */
            force?: boolean;
    }
    export namespace SetRepositoryPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SetRepositoryPolicyRequest) => any;
    }
    export interface SetRepositoryPolicyResponse {
            /**
                * <p>The registry ID associated with the request.</p>
                */
            registryId?: string;
            /**
                * <p>The repository name associated with the request.</p>
                */
            repositoryName?: string;
            /**
                * <p>The JSON repository policy text applied to the repository.</p>
                */
            policyText?: string;
    }
    export namespace SetRepositoryPolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SetRepositoryPolicyResponse) => any;
    }
    export interface TagResourceRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the resource to which to add tags. Currently, the
                *          supported resource is an Amazon ECR Public repository.</p>
                */
            resourceArn: string | undefined;
            /**
                * <p>The tags to add to the resource. A tag is an array of key-value pairs.
                *          Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.</p>
                */
            tags: Tag[] | undefined;
    }
    export namespace TagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceRequest) => any;
    }
    export interface TagResourceResponse {
    }
    export namespace TagResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceResponse) => any;
    }
    export interface UntagResourceRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the resource from which to delete tags. Currently, the supported
                *          resource is an Amazon ECR Public repository.</p>
                */
            resourceArn: string | undefined;
            /**
                * <p>The keys of the tags to be removed.</p>
                */
            tagKeys: string[] | undefined;
    }
    export namespace UntagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceRequest) => any;
    }
    export interface UntagResourceResponse {
    }
    export namespace UntagResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceResponse) => any;
    }
    export interface UploadLayerPartRequest {
            /**
                * <p>The AWS account ID associated with the registry to which you are uploading layer parts.
                *          If you do not specify a registry, the default public registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository to which you are uploading layer parts.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>The upload ID from a previous <a>InitiateLayerUpload</a> operation to
                *          associate with the layer part upload.</p>
                */
            uploadId: string | undefined;
            /**
                * <p>The position of the first byte of the layer part witin the overall image layer.</p>
                */
            partFirstByte: number | undefined;
            /**
                * <p>The position of the last byte of the layer part within the overall image layer.</p>
                */
            partLastByte: number | undefined;
            /**
                * <p>The base64-encoded layer part payload.</p>
                */
            layerPartBlob: Uint8Array | undefined;
    }
    export namespace UploadLayerPartRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UploadLayerPartRequest) => any;
    }
    export interface UploadLayerPartResponse {
            /**
                * <p>The registry ID associated with the request.</p>
                */
            registryId?: string;
            /**
                * <p>The repository name associated with the request.</p>
                */
            repositoryName?: string;
            /**
                * <p>The upload ID associated with the request.</p>
                */
            uploadId?: string;
            /**
                * <p>The integer value of the last byte received in the request.</p>
                */
            lastByteReceived?: number;
    }
    export namespace UploadLayerPartResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UploadLayerPartResponse) => any;
    }
}

declare module '@aws-sdk/client-ecr-public/node_modules/@aws-sdk/client-ecr-public/dist-types/models/ECRPUBLICServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from ECRPUBLIC service.
        */
    export class ECRPUBLICServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

